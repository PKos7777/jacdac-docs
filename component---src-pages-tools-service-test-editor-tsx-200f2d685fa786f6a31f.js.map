{"version":3,"sources":["webpack:///./src/components/ServiceSpecificationSelect.tsx","webpack:///./jacdac-ts/jacdac-spec/spectool/jdtest.ts","webpack:///./src/components/tools/ServiceTestEditor.tsx","webpack:///./src/pages/tools/service-test-editor.tsx","webpack:///./node_modules/@material-ui/lab/esm/AlertTitle/AlertTitle.js","webpack:///./node_modules/@material-ui/icons/Info.js","webpack:///./src/components/SelectService.tsx","webpack:///./src/components/test/ServiceTest.tsx","webpack:///./node_modules/use-editable/dist/use-editable.es.js","webpack:///./src/components/ui/HighlightTextField.tsx","webpack:///./jacdac-ts/node_modules/jsep/build/jsep.js"],"names":["useStyles","makeStyles","createStyles","root","minWidth","ServiceSpecificationSelect","props","label","serviceClass","setServiceClass","variant","fullWidth","error","useState","Math","random","labelId","classes","specs","serviceSpecifications","filter","spec","test","shortId","handleChange","event","parseInt","target","value","map","classIdentifier","name","supportedExpressions","parseSpecificationTestMarkdownToJSON","filecontent","filename","undefined","replace","info","description","serviceClassIdentifier","tests","backticksType","errors","lineNo","currentTest","testHeading","testPrompt","split","line","processLine","e","message","finishTest","length","trim","m","exec","interpret","slice","hd","cont","expanded","processCommand","prompt","registers","events","testCommands","call","callee","testCommandFunctions","getTestCommandFunctions","cmdIndex","findIndex","r","id","jsep","type","arguments","exprVisitor","p","c","indexOf","expected","args","processArguments","processCalls","push","eventSymTable","forEach","arg","a","argType","pkt","lookupEvent","lookupRegister","elements","lookupReplace","member","object","property","computed","testExpressionFunctions","getTestExpressionFunctions","parent","callExpr","tef","find","context","rootFun","ce","packets","kind","fld","getRegister","child","Array","isArray","lookup","i","Object","keys","k","toName","val","parseIntFloat","lit","raw","toString","fields","f","msg","some","file","SERVICE_TEST_SERVICE_STORAGE_KEY","SERVICE_TEST_SOURCE_STORAGE_KEY","ServiceTestEditor","useContext","AppContext","setError","useLocalStorage","SRV_BUTTON","source","setSource","serviceSpec","useMemo","serviceSpecificationFromClassIdentifier","json","servicePath","camelName","toLowerCase","handleLoadFromGithub","fetchText","ghSource","Page","SelectService","JacdacContext","bus","onSelect","services","useChange","n","gridBreakpoints","useGridBreakpoints","handleSelect","service","device","Diagnostics","hostDefinition","hostDefinitionFromServiceClass","handleStartSimulator","addHost","ServiceTestRunnerSelect","ServiceTest","showStartSimulator","serviceTest","serviceTestFromServiceClass","setService","useEffect","subscribe","DISCONNECT","Flags","diagnostics","GithubPullRequestButton","lazy","AnnotationTooltip","withStyles","theme","arrow","color","palette","main","tooltip","backgroundColor","common","white","boxShadow","shadows","fontSize","typography","body2","Tooltip","HighlightTextField","code","onChange","language","annotations","pullRequestTitle","pullRequestPath","pullRequestDescription","DarkModeContext","darkMode","DARK_THEME","LIGHT_THEME","editorRef","useRef","useEditable","disabled","indentation","defaultProps","className","style","tokens","getTokenProps","minHeight","whiteSpace","annotation","title","el","borderBottom","token","empty","key"],"mappings":"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AC3C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4FAA4F,aAAa;AACzG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd,UAAU,yBAAQ;AAClB,UAAU,yBAAQ;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,UAAU,4BAAW;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,EAAE,gCAAe;AACjB;;AAEA;AACA;AACA;AACA,GAAG;AACH,EAAE,gCAAe;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;;AAEA,+CAA+C,QAAQ;AACvD;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,C;;;;;;;;;;;;;;;;;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X;AAEI,aAAK,MAFT;AAGI,WAAG,EAAE5G;AAHT,SAKK6G,EALL,CADQ,GASRA,EATJ;AAWH,KAtCA,CAZL,CADH;AAAA,GANL,CADJ,CADJ,EAgEK,CAAC,EAACtB,WAAD,aAACA,WAAD,eAACA,WAAW,CAAExJ,MAAd,CAAD,iBACG,8BAAC,uBAAD;AAAM,QAAI,MAAV;AAAW,MAAE,EAAE;AAAf,kBACI,8BAAC,wBAAD;AAAO,YAAQ,EAAC;AAAhB,kBACI,0CACKwJ,WAAW,CAACjL,GAAZ,CAAgB,UAAC8D,CAAD,EAAI4B,CAAJ;AAAA,wBACb;AAAI,SAAG,EAAEA;AAAT,gBACU5B,CAAC,CAAC1C,IADZ,QACoB0C,CAAC,CAACvC,OADtB,CADa;AAAA,GAAhB,CADL,CADJ,CADJ,CAjER,EA6EK2J,gBAAgB,IAAIC,eAApB,iBACG,8BAAC,uBAAD;AAAM,QAAI;AAAV,kBACI,8BAAC,2BAAD,qBACI,8BAAC,uBAAD;AACI,SAAK,EAAED,gBADX;AAEI,QAAI,EAAEC,eAFV;AAGI,eAAW,EAAEC,sBAHjB;AAII,SAAK,qBACAD,eAAe,GAAG,KADlB,IAC0BL,IAD1B;AAJT,IADJ,CADJ,CA9ER,CADJ;AA8FH,C;;;;;;;ACvJD;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gCAAgC;AAChC,GAAG;AACH;AACA;AACA;AACA;AACA,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,6EAA6E;AAC7E;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;;;AAGJ,MAAM,KAA8B,EAAE,iBAYnC;AACH;AACA,QAAQ,KAA6B;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,Q","file":"component---src-pages-tools-service-test-editor-tsx-200f2d685fa786f6a31f.js","sourcesContent":["import { createStyles, makeStyles, MenuItem, TextField, Theme } from \"@material-ui/core\";\nimport React, { ChangeEvent, useState } from \"react\";\nimport { serviceSpecifications } from \"../../jacdac-ts/src/jdom/spec\"\n\nconst useStyles = makeStyles(() =>\n    createStyles({\n        root: {\n            minWidth: \"18rem\",\n        }\n    }),\n);\n\nexport default function ServiceSpecificationSelect(props: {\n    label: string,\n    serviceClass: number;\n    setServiceClass: (serviceClass: number) => void;\n    variant?: \"outlined\" | \"filled\" | \"standard\";\n    fullWidth?: boolean;\n    error?: string;\n}) {\n    const { label, serviceClass, setServiceClass, variant, fullWidth, error } = props;\n    const [labelId] = useState('select-' + Math.random());\n    const classes = useStyles();\n    const specs = serviceSpecifications().filter(spec => !/^_/.test(spec.shortId))\n\n    const handleChange = (event: ChangeEvent<HTMLInputElement>) =>\n        setServiceClass(parseInt(event.target.value));\n\n    return <TextField\n        id={labelId}\n        className={classes.root}\n        label={label}\n        error={!!error}\n        helperText={error}\n        value={serviceClass}\n        select\n        variant={variant}\n        fullWidth={fullWidth}\n        onChange={handleChange}>\n        <MenuItem key=\"none\" value=\"NaN\">No service selected</MenuItem>\n        {specs.map(spec => <MenuItem\n            key={spec.classIdentifier}\n            value={spec.classIdentifier}>{spec.name}</MenuItem>)}\n    </TextField>\n}","/* eslint-disable @typescript-eslint/triple-slash-reference */\n/// <reference path=\"jdspec.d.ts\" />\n/// <reference path=\"jdtest.d.ts\" />\n\nimport { \n    parseIntFloat, \n    getRegister, \n    exprVisitor\n} from \"./jdutils\"\nimport { getTestCommandFunctions, getTestExpressionFunctions } from \"./jdtestfuns\"\nimport jsep from \"jsep\"\n\nconst supportedExpressions: jsep.ExpressionType[] = [\n    \"MemberExpression\",\n    \"ArrayExpression\",\n    \"BinaryExpression\",\n    \"CallExpression\",\n    \"Identifier\",\n    \"Literal\",\n    \"UnaryExpression\",\n    \"LogicalExpression\",\n]\n\n// we parse a test with respect to an existing ServiceSpec\nexport function parseSpecificationTestMarkdownToJSON(\n    filecontent: string,\n    spec: jdspec.ServiceSpec,\n    filename = \"\"\n): jdtest.ServiceTestSpec {\n    if (!spec)\n        return undefined;\n\n    filecontent = (filecontent || \"\").replace(/\\r/g, \"\")\n    const info: jdtest.ServiceTestSpec = {\n        description: \"\",\n        serviceClassIdentifier: spec.classIdentifier,\n        tests: [],\n    }\n\n    let backticksType = \"\"\n    const errors: jdspec.Diagnostic[] = []\n    let lineNo = 0\n    let currentTest: jdtest.TestSpec = null\n    let testHeading = \"\"\n    let testPrompt = \"\"\n\n    try {\n        for (const line of filecontent.split(/\\n/)) {\n            lineNo++\n            processLine(line)\n        }\n    } catch (e) {\n        error(\"exception: \" + e.message)\n    }\n\n    if (currentTest) finishTest()\n\n    if (errors.length) info.errors = errors\n\n    return info\n\n    function processLine(line: string) {\n        if (backticksType) {\n            if (line.trim() == \"```\") {\n                backticksType = null\n                if (backticksType == \"default\") return\n            }\n        } else {\n            const m = /^```(.*)/.exec(line)\n            if (m) {\n                backticksType = m[1] || \"default\"\n                if (backticksType == \"default\") return\n            }\n        }\n\n        const interpret =\n            backticksType == \"default\" || \n            line.slice(0, 4) == \"    \" ||\n            /^\\t/.exec(line)\n\n        if (!interpret) {\n            const m = /^(#+)\\s*(.*)/.exec(line)\n            if (m) {\n                testHeading = \"\"\n                testPrompt = \"\"\n                const [, hd, cont] = m\n                if (hd == \"#\") {\n                    if (!info.description)\n                        info.description = cont.trim()\n                    else \n                        error(\"use ## to start a test, not #\")\n                } else if (hd == \"##\") {\n                    if (currentTest) finishTest()\n                    testHeading = cont.trim()\n                }\n            } else {\n                testPrompt += line\n            }\n        } else {\n            const expanded = line.replace(/\\/\\/.*/, \"\").trim()\n            if (!expanded) return\n            processCommand(expanded)\n        }\n    }\n\n    function processCommand(expanded: string) {\n        // TODO: if there is a prompt, the test has no commands, and\n        // TODO: the first command is not ask/say\n        // TODO: then add a say command\n\n        if (!currentTest) {\n            if (!testHeading)\n                error(`every test must have a description (via ##)`)\n            currentTest = {\n                description: testHeading,\n                prompt: testPrompt,\n                registers: [],\n                events: [],\n                testCommands: [],\n            }\n            testHeading = \"\"\n            testPrompt = \"\"\n        }\n        const call = /^([a-zA-Z]\\w*)\\(.*\\)$/.exec(expanded)\n        if (!call) {\n            error(\n                `a command must be a call to a registered test function (JavaScript syntax)`\n            )\n            return\n        }\n        const [, callee] = call\n        const testCommandFunctions = getTestCommandFunctions();\n        const cmdIndex = testCommandFunctions.findIndex(r => callee == r.id)\n        if (cmdIndex < 0) {\n            error(`${callee} is not a registered test command function.`)\n            return\n        }\n        const root: jsep.CallExpression = <jsep.CallExpression>jsep(expanded)\n        if (\n            !root ||\n            !root.type ||\n            root.type != \"CallExpression\" ||\n            !root.callee ||\n            !root.arguments\n        ) {\n            error(`a command must be a call expression in JavaScript syntax`)\n        } else {\n            // check for unsupported expression types\n            exprVisitor(null, root, (p, c) => {\n                if (supportedExpressions.indexOf(c.type) < 0)\n                    error(`Expression of type ${c.type} not currently supported`)\n            })\n            // check arguments\n            const expected = testCommandFunctions[cmdIndex].args.length\n            if (expected !== root.arguments.length)\n                error(\n                    `${callee} expects ${expected} arguments; got ${root.arguments.length}`\n                )\n            else {\n                // type checking of arguments.\n                processArguments();\n                // check all calls in subexpressions\n                processCalls()\n            }\n            currentTest.testCommands.push({ prompt: testPrompt, call: root })\n            testPrompt = \"\"\n        }\n\n        function processArguments() {\n            let eventSymTable: jdspec.PacketInfo[] = []\n            root.arguments.forEach((arg, a) => {\n                const argType = testCommandFunctions[cmdIndex].args[a]\n                if (argType === \"register\" || argType === \"event\") {\n                   if (arg.type !== \"Identifier\")\n                        error(\n                            `${callee} expects a ${argType} in argument position ${a + 1}`\n                        )\n                   else if (argType === \"event\" && a === 0) { \n                        let pkt = lookupEvent(arg)\n                        if (pkt && eventSymTable.indexOf(pkt) === -1)\n                        eventSymTable.push(pkt)\n                   } else if (argType === \"register\") {\n                        try {\n                            lookupRegister((arg as jsep.Identifier).name, \"\")\n                        } catch (e) {\n                            error(e)\n                        }\n                   }\n                } else if (argType === \"events\") {\n                    if (arg.type != 'ArrayExpression')\n                        error(`events function expects a list of service events`)\n                    else {\n                        (arg as jsep.ArrayExpression).elements.forEach(lookupEvent)\n                    }\n                } else if (argType === \"number\" || argType === \"boolean\") {\n                    exprVisitor(root, arg, (p, c) => {\n                        if (p.type !== 'MemberExpression' && c.type === 'Identifier') {\n                            lookupReplace(eventSymTable, p, c as jsep.Identifier)\n                        } else if (c.type === 'ArrayExpression') {\n                            error(\n                                `array expression not allowed in this context`\n                            )\n                        } else if (c.type === 'MemberExpression') {\n                            const member = c as jsep.MemberExpression;\n                            // A member expression must be of form id1.id2\n                            if (member.object.type !== 'Identifier' || member.property.type !== 'Identifier' || member.computed) {\n                                error('property access must be of form id.property')\n                            } else {\n                                lookupReplace(eventSymTable, p, c as jsep.MemberExpression)\n                            }\n                        }\n                    })\n                } else {\n                    error(`unexpected argument type (${argType}) in jdtestfuns.ts`)\n                }\n            })\n        }\n\n        function processCalls() { \n            const testExpressionFunctions = getTestExpressionFunctions()\n            root.arguments.forEach((arg, a) => {\n                const argType = testCommandFunctions[cmdIndex].args[a]\n                exprVisitor(root, arg, (parent, callExpr: jsep.CallExpression) => {\n                    if (callExpr.type !== 'CallExpression')\n                        return;\n                    if (callExpr.callee.type !== \"Identifier\")\n                        error(`all calls must be direct calls`)\n                    const id = (<jsep.Identifier>callExpr.callee).name\n                    const tef = testExpressionFunctions.find(r => id == r.id)\n                    if (!tef)\n                        error(\n                            `${id} is not a registered test expression function.`\n                        )\n                    if (tef.context === \"expression\" || tef.context === \"either\") {\n                        if (argType != \"boolean\")\n                            error(`${id} expression function can only be used inside a boolean expression`)\n                        // no nested calls\n                        const rootFun = testCommandFunctions[cmdIndex]\n                        if (rootFun.context === \"expression\" || rootFun.context === \"either\") \n                            error(`cannot nest ${tef.id} underneath ${rootFun.id}`)\n                        // look under tef\n                        exprVisitor(null, callExpr, (parent, ce: jsep.CallExpression) => {\n                            if (ce.type !== 'CallExpression')\n                                return;\n                            if (ce.callee.type === \"Identifier\" && (<jsep.Identifier>ce.callee).name)\n                                error(`cannot nest ${(<jsep.Identifier>ce.callee).name} underneath ${id}`)\n                        })\n                    }\n                    const expected = tef.args.length\n                    if (expected !== callExpr.arguments.length)\n                        error(\n                            `${callee} expects ${expected} arguments; got ${callExpr.arguments.length}`\n                        )\n                })\n            })\n        }\n\n        function lookupEvent(e: jsep.Expression) {\n            const events = spec.packets?.filter(pkt => pkt.kind == \"event\")\n            if (e.type !== 'Identifier') {\n                error(`event identifier expected`)\n            } else {\n                const id = (e as jsep.Identifier).name\n                const pkt = events.find(p => p.name === id)\n                if (!pkt) {\n                    error(`no event ${id} in specification`)\n                } else {\n                    if (currentTest.events.indexOf(id) < 0)\n                        currentTest.events.push(id)\n                    return pkt;\n                }\n            }\n            return null;\n        }\n    }\n\n    function lookupRegister(root:string, fld:string)  {\n        getRegister(spec, root, fld)\n        // if (!fld && regField.pkt.fields.length > 0)\n        //    error(`register ${root} has fields, but no field specified`)\n        if (currentTest.registers.indexOf(root) < 0)\n            currentTest.registers.push(root)\n    }\n\n    function lookupReplace(events: jdspec.PacketInfo[], parent: jsep.Expression, child: jsep.Identifier | jsep.MemberExpression) {\n        if (Array.isArray(parent)) {\n            let replace = lookup(events, parent, child)\n            parent.forEach(i => {\n                if (parent[i] === child)\n                    parent[i] = replace\n            })\n        } else {\n            // don't process identifiers that are callees of CallExpression\n            if (parent?.type === \"CallExpression\" && child === (<jsep.CallExpression>parent).callee)\n                return;\n            let replace = lookup(events, parent, child)\n            if (replace) {\n                Object.keys(parent).forEach(k => {\n                    if ((parent as any)[k] === child)\n                        (parent as any)[k] = replace\n                })\n            }\n        }\n\n        function lookup(events: jdspec.PacketInfo[], parent: jsep.Expression, child: jsep.Identifier | jsep.MemberExpression) {\n            try {\n                try {\n                    let [root,fld] = toName()\n                    const val = parseIntFloat(spec, fld ? `${root}.${fld}` : root)\n                    const lit: jsep.Literal = {\n                        type: \"Literal\",\n                        value: val,\n                        raw: val.toString(),\n                    }\n                    return lit\n                } catch (e) {\n                    let [root,fld] = toName()\n                    lookupRegister(root, fld)\n                }\n            } catch (e) {\n                if (events.length > 0) {\n                    let [root,fld] = toName()\n                    let pkt = events.find(pkt => pkt.name === root)\n                    if (!pkt)\n                        error(`event ${root} not bound correctly`)\n                    else if (!fld && pkt.fields.length > 0)\n                        error(`event ${root} has fields, but no field specified`)\n                    else if (fld && !pkt.fields.find(f => f.name === fld))\n                        error(`Field ${fld} of event ${root} not found in specification`)\n                } else {\n                    error(e.message)\n                }\n            }\n            return undefined\n            function toName() {\n                if (child.type !== 'MemberExpression')\n                    return [child.name, \"\"];\n                else {\n                    return [(child.object as jsep.Identifier).name,\n                            (child.property as jsep.Identifier).name]\n                }\n            }\n        }\n    }\n\n    function finishTest() {\n        info.tests.push(currentTest)\n        currentTest = null\n    }\n\n    function error(msg: string) {\n        if (!msg) msg = \"syntax error\"\n        if (errors.some(e => e.line == lineNo && e.message == msg)) return\n        errors.push({ file: filename, line: lineNo, message: msg })\n    }\n}\n","import React, { useContext, useEffect, useMemo } from \"react\"\nimport { Button, Grid } from \"@material-ui/core\"\nimport { parseSpecificationTestMarkdownToJSON } from \"../../../jacdac-ts/jacdac-spec/spectool/jdtest\"\nimport { serviceSpecificationFromClassIdentifier } from \"../../../jacdac-ts/src/jdom/spec\"\nimport useLocalStorage from \"../useLocalStorage\"\nimport HighlightTextField from \"../ui/HighlightTextField\"\nimport ServiceSpecificationSelect from \"../ServiceSpecificationSelect\"\nimport { SRV_BUTTON } from \"../../../jacdac-ts/src/jdom/constants\"\nimport ServiceTest from \"../test/ServiceTest\"\nimport { fetchText } from \"../github\"\nimport AppContext from \"../AppContext\"\n\nconst SERVICE_TEST_SERVICE_STORAGE_KEY = \"jacdac:servicetesteditor:service\"\nconst SERVICE_TEST_SOURCE_STORAGE_KEY = \"jacdac:servicetesteditorsource\"\n\nexport default function ServiceTestEditor() {\n    const { setError } = useContext(AppContext)\n    const [serviceClass, setServiceClass] = useLocalStorage<number>(SERVICE_TEST_SERVICE_STORAGE_KEY, SRV_BUTTON)\n    const [source, setSource] = useLocalStorage(SERVICE_TEST_SOURCE_STORAGE_KEY, \"\")\n    const serviceSpec = useMemo(\n        () => serviceSpecificationFromClassIdentifier(serviceClass),\n        [serviceClass]\n    )\n    const json = useMemo(\n        () => parseSpecificationTestMarkdownToJSON(source, serviceSpec),\n        [source, serviceSpec]\n    )\n    const servicePath =\n        json &&\n        `services/tests/${(\n            serviceSpec.camelName ||\n            serviceSpec.shortId ||\n            `0x${serviceSpec.classIdentifier.toString(16)}`\n        ).toLowerCase()}`\n    const handleLoadFromGithub = async () => {\n        try {\n            const ghSource = await fetchText(\n                \"microsoft/jacdac\",\n                \"main\",\n                `services/tests/${serviceSpec.shortId}.md`,\n                \"text/plain\"\n            )\n            if (ghSource)\n                setSource(ghSource)\n            else\n                setError(\"Test source not found\")\n        } catch (e) {\n            setError(e)\n        }\n    }\n    return (\n        <Grid spacing={2} container>\n            <Grid item xs={12}>\n                <Grid container spacing={2} direction=\"row\">\n                    <Grid item>\n                        <ServiceSpecificationSelect\n                            label={\"Select a service to test\"}\n                            serviceClass={serviceClass}\n                            setServiceClass={setServiceClass}\n                        />\n                    </Grid>\n                    <Grid item>\n                        <Button\n                            variant=\"outlined\"\n                            disabled={!serviceSpec}\n                            onClick={handleLoadFromGithub}\n                        >\n                            Load tests from GitHub\n                        </Button>\n                    </Grid>\n                </Grid>\n            </Grid>\n            <Grid item xs={12} xl={5}>\n                <HighlightTextField\n                    code={source}\n                    language={\"markdown\"}\n                    onChange={setSource}\n                    annotations={json?.errors}\n                    pullRequestTitle={\n                        json && `Service test: ${serviceSpec.name}`\n                    }\n                    pullRequestPath={servicePath}\n                />\n            </Grid>\n            {json && (\n                <Grid item xs={12} xl={7}>\n                    <ServiceTest showStartSimulator={true} serviceSpec={serviceSpec} serviceTest={json} />\n                </Grid>\n            )}\n        </Grid>\n    )\n}\n","import { Link } from \"gatsby-theme-material-ui\"\nimport React from \"react\"\nimport ServiceTestEditor from \"../../components/tools/ServiceTestEditor\"\n\nexport default function Page() {\n    return (\n        <>\n            <h1>Service Test Editor</h1>\n            <p>\n                Read the{\" \"}\n                <Link to=\"/reference/service-tests\">\n                    service test\n                </Link>{\" \"}\n                documentation.\n            </p>\n            <ServiceTestEditor />\n        </>\n    )\n}\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport { withStyles } from '@material-ui/core/styles';\nimport { Typography } from '@material-ui/core';\nimport clsx from 'clsx';\nexport var styles = function styles(theme) {\n  return {\n    /* Styles applied to the root element. */\n    root: {\n      fontWeight: theme.typography.fontWeightMedium,\n      marginTop: -2\n    }\n  };\n};\nvar AlertTitle = /*#__PURE__*/React.forwardRef(function AlertTitle(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      other = _objectWithoutProperties(props, [\"classes\", \"className\"]);\n\n  return /*#__PURE__*/React.createElement(Typography, _extends({\n    gutterBottom: true,\n    component: \"div\",\n    ref: ref,\n    className: clsx(classes.root, className)\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? void 0 : void 0;\nexport default withStyles(styles, {\n  name: 'MuiAlertTitle'\n})(AlertTitle);","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z\"\n}), 'Info');\n\nexports.default = _default;","import React, { useContext } from \"react\"\nimport useGridBreakpoints from \"./useGridBreakpoints\"\nimport JacdacContext, { JacdacContextProps } from \"../jacdac/Context\"\nimport useChange from \"../jacdac/useChange\"\nimport { Grid, Card, CardActions, Button } from \"@material-ui/core\"\nimport DeviceCardHeader from \"./DeviceCardHeader\"\nimport Alert from \"./ui/Alert\"\nimport { JDService } from \"../../jacdac-ts/src/jdom/service\"\n\nexport default function SelectService(props: {\n    serviceClass: number\n    onSelect: (service: JDService) => void\n}) {\n    const { bus } = useContext<JacdacContextProps>(JacdacContext)\n    const { serviceClass, onSelect } = props\n    const services = useChange(bus, n => n.services({ serviceClass }), [])\n    const gridBreakpoints = useGridBreakpoints()\n\n    const handleSelect = (service: JDService) => () => onSelect(service)\n\n    return (\n        <>\n            {!!services.length && (\n                <Grid container spacing={2}>\n                    {services.map(service => (\n                        <Grid key={service.id} item {...gridBreakpoints}>\n                            <Card>\n                                <DeviceCardHeader device={service.device} showAvatar={true} />\n                                <CardActions>\n                                    <Button\n                                        variant=\"contained\"\n                                        color=\"primary\"\n                                        onClick={handleSelect(service)}\n                                    >\n                                        Select\n                                    </Button>\n                                </CardActions>\n                            </Card>\n                        </Grid>\n                    ))}\n                </Grid>\n            )}\n            {!services?.length && (\n                <Alert severity=\"info\">\n                    Not seeing your device? Try some of the following.\n                    <ul>\n                        <li>Check that your device is connected</li>\n                        <li>\n                            Use the <strong>packet console</strong> to monitor\n                            packets on the bus\n                        </li>\n                        <li>\n                            Check the class identifier in your annoucement\n                            packets\n                        </li>\n                    </ul>\n                </Alert>\n            )}\n        </>\n    )\n}\n","import React, { useContext, useEffect, useState } from \"react\"\nimport JacdacContext, { JacdacContextProps } from \"../../jacdac/Context\"\nimport { Button } from \"@material-ui/core\"\n// tslint:disable-next-line: no-submodule-imports\nimport { AlertTitle } from \"@material-ui/lab\"\n// tslint:disable-next-line: match-default-export-name no-submodule-imports\nimport InfoIcon from \"@material-ui/icons/Info\"\nimport Alert from \"../ui/Alert\"\nimport IconButtonWithTooltip from \"../ui/IconButtonWithTooltip\"\nimport {\n    addHost,\n    hostDefinitionFromServiceClass,\n} from \"../../../jacdac-ts/src/hosts/hosts\"\nimport Flags from \"../../../jacdac-ts/src/jdom/flags\"\nimport { JDService } from \"../../../jacdac-ts/src/jdom/service\"\nimport { serviceTestFromServiceClass } from \"../../../jacdac-ts/src/test/testspec\"\nimport SelectService from \"../SelectService\"\nimport ServiceTestRunner from \"./ServiceTestRunner\"\nimport { DISCONNECT } from \"../../../jacdac-ts/src/jdom/constants\"\n\nfunction Diagnostics(props: { serviceClass: number }) {\n    const { serviceClass } = props\n    const { bus } = useContext<JacdacContextProps>(JacdacContext)\n\n    const hostDefinition = hostDefinitionFromServiceClass(serviceClass)\n    const handleStartSimulator = () => addHost(bus, hostDefinition)\n\n    if (!hostDefinition) return null\n\n    return (\n        <Alert severity=\"info\">\n            <AlertTitle>Developer zone</AlertTitle>\n            <Button variant=\"outlined\" onClick={handleStartSimulator}>\n                start simulator\n            </Button>\n        </Alert>\n    )\n}\n\nfunction ServiceTestRunnerSelect(props: {\n    serviceClass: number\n    onSelect: (service: JDService) => void\n}) {\n    const { serviceClass, onSelect } = props\n    return (\n        <>\n            <h3>Select a device to test</h3>\n            <SelectService serviceClass={serviceClass} onSelect={onSelect} />\n        </>\n    )\n}\n\nexport default function ServiceTest(props: {\n    serviceSpec: jdspec.ServiceSpec\n    serviceTest?: jdtest.ServiceTestSpec\n    showStartSimulator?: boolean\n}) {\n    const {\n        serviceSpec,\n        showStartSimulator,\n        serviceTest = serviceTestFromServiceClass(serviceSpec?.classIdentifier),\n    } = props\n    const { classIdentifier: serviceClass } = serviceSpec\n    const [service, setService] = useState<JDService>(undefined)\n    const handleSelect = (service: JDService) => setService(service)\n    // clear selected service when json changes\n    useEffect(() => {\n        setService(undefined)\n    }, [serviceTest])\n    // clear service if device disconnects\n    useEffect(() => service?.device?.subscribe(DISCONNECT, () => {\n        setService(undefined)\n    }), [service])\n\n    return (\n        <>\n            <h1>\n                {`${serviceSpec.name} tests`}\n                <IconButtonWithTooltip\n                    title=\"go to specification\"\n                    to={`/services/${serviceSpec.shortId}/`}\n                >\n                    <InfoIcon />\n                </IconButtonWithTooltip>\n            </h1>\n            {(Flags.diagnostics || showStartSimulator) && (\n                <Diagnostics serviceClass={serviceClass} />\n            )}\n            {!service && (\n                <ServiceTestRunnerSelect\n                    serviceClass={serviceClass}\n                    onSelect={handleSelect}\n                />\n            )}\n            {service && (\n                <ServiceTestRunner\n                    service={service}\n                    serviceTest={serviceTest}\n                />\n            )}\n        </>\n    )\n}\n","import { useState, useCallback, useLayoutEffect } from \"react\";\nvar m = {\n  characterData: !0,\n  characterDataOldValue: !0,\n  childList: !0,\n  subtree: !0\n};\n\nfunction p(a) {\n  a = [a.firstChild];\n\n  for (var d, c = \"\"; d = a.pop();) {\n    d.nodeType === Node.TEXT_NODE ? c += d.textContent : d.nodeType === Node.ELEMENT_NODE && \"BR\" === d.nodeName && (c += \"\\n\"), d.nextSibling && a.push(d.nextSibling), d.firstChild && a.push(d.firstChild);\n  }\n\n  \"\\n\" !== c[c.length - 1] && (c += \"\\n\");\n  return c;\n}\n\nfunction r(a) {\n  var c = window.getSelection();\n  a = [a.firstChild];\n  var d = c.focusNode;\n  c = c.focusOffset;\n  d && d.nodeType !== Node.TEXT_NODE && (c <= d.childNodes.length - 1 && (d = d.childNodes[c]), c = 0);\n\n  for (var h, k = 0, l = 0, g = \"\"; h = a.pop();) {\n    if (h.nodeType === Node.TEXT_NODE) {\n      var e = h.textContent;\n      h === d && (e = e.slice(0, c));\n      k += e.length;\n      g += e;\n\n      for (var f, n = /\\n/g; f = n.exec(e);) {\n        g = e.slice(f.index + 1), l++;\n      }\n\n      if (h === d) {\n        break;\n      }\n    } else {\n      h.nodeType === Node.ELEMENT_NODE && \"BR\" === h.nodeName && (g = \"\", l++, k++);\n    }\n\n    h.nextSibling && h !== d && a.push(h.nextSibling);\n    h.firstChild && a.push(h.firstChild);\n  }\n\n  return {\n    position: k,\n    content: g,\n    line: l\n  };\n}\n\nfunction t(a, c) {\n  for (var d = window.getSelection(), k = document.createRange(), l = [a.firstChild], g = 0; a = l.pop();) {\n    if (a.nodeType === Node.TEXT_NODE) {\n      var h = a.textContent.length;\n\n      if (g + h >= c) {\n        (c -= g) === h ? k.setStartAfter(a) : k.setStart(a, c);\n        break;\n      }\n\n      g += a.textContent.length;\n    } else if (a.nodeType === Node.ELEMENT_NODE && \"BR\" === a.nodeName) {\n      if (g + 1 >= c) {\n        k.setStartAfter(a);\n        break;\n      }\n\n      g++;\n    }\n\n    a.nextSibling && l.push(a.nextSibling);\n    a.firstChild && l.push(a.firstChild);\n  }\n\n  d.empty();\n  d.addRange(k);\n}\n\nfunction B(a) {\n  var c = window.getSelection(),\n      d = window.getSelection().getRangeAt(0);\n  a = document.createTextNode(a);\n  c.getRangeAt(0).deleteContents();\n  d.insertNode(a);\n  (d = document.createRange()).setStartAfter(a);\n  c.empty();\n  c.addRange(d);\n}\n\nexport function useEditable(a, c, d) {\n  function k() {\n    e[0].disconnect();\n  }\n\n  function l() {\n    e[0].disconnect();\n    e[1] = !0;\n  }\n\n  function g() {\n    e[6] = -1;\n  }\n\n  d || (d = {});\n  var h = useState([])[1],\n      e = useState(function () {\n    var a = [null, !1, c, [], [], -1, -1];\n    \"undefined\" != typeof MutationObserver && (a[0] = new MutationObserver(function e(e) {\n      var d;\n      (d = a[3]).push.apply(d, e);\n    }));\n    return a;\n  })[0],\n      n = useCallback(function (d) {\n    var f = a.current;\n\n    if (f) {\n      var c = r(f);\n      f = p(f);\n      e[6] = c.position + (d.length - f.length);\n      e[2](d, c);\n    }\n  }, []);\n\n  if (\"object\" != typeof navigator) {\n    return n;\n  }\n\n  useLayoutEffect(function () {\n    e[2] = c;\n\n    if (a.current && !d.disabled) {\n      return e[1] = !1, e[0].observe(a.current, m), 0 <= e[6] && t(a.current, e[6]), k;\n    }\n  });\n  useLayoutEffect(function () {\n    if (!a.current || d.disabled) {\n      e[4].length = 0, e[5] = -1;\n    } else {\n      var f = a.current;\n      -1 < e[6] && (f.focus(), t(f, e[6]));\n      var c = f.style.whiteSpace,\n          k = f.contentEditable,\n          u = !0;\n\n      try {\n        f.contentEditable = \"plaintext-only\";\n      } catch (b) {\n        f.contentEditable = \"true\", u = !1;\n      }\n\n      \"pre\" !== c && (f.style.whiteSpace = \"pre-wrap\");\n      d.indentation && (f.style.tabSize = f.style.MozTabSize = \"\" + d.indentation);\n\n      var v,\n          C = new RegExp(\"^(?:\" + \" \".repeat(d.indentation || 0) + \"|\\\\t)\"),\n          q = function q(b) {\n        if (a.current && -1 !== e[6]) {\n          var d = e[4],\n              c = p(f),\n              h = r(f),\n              g = new Date().valueOf(),\n              k = d[e[5]];\n          !b && 500 > g - v || k && k[1] === c ? v = g : (d[b = ++e[5]] = [h, c], d.splice(b + 1), 500 < b && (e[5]--, d.shift()));\n        }\n      },\n          w = function w() {\n        var b;\n        (b = e[3]).push.apply(b, e[0].takeRecords());\n\n        if (e[3].length) {\n          l();\n          b = p(f);\n          var d = r(f);\n          e[6] = d.position;\n\n          for (var a, c; a = e[3].pop();) {\n            null !== a.oldValue && (a.target.textContent = a.oldValue);\n\n            for (c = a.removedNodes.length - 1; 0 <= c; c--) {\n              a.target.insertBefore(a.removedNodes[c], a.nextSibling);\n            }\n\n            for (c = a.addedNodes.length - 1; 0 <= c; c--) {\n              a.addedNodes[c].parentNode && a.target.removeChild(a.addedNodes[c]);\n            }\n          }\n\n          e[2](b, d);\n        }\n      },\n          x = function x(b) {\n        if (!b.defaultPrevented && b.target === f) {\n          if (e[1]) {\n            return b.preventDefault(), h([]);\n          }\n\n          if ((b.metaKey || b.ctrlKey) && \"KeyZ\" === b.code) {\n            b.preventDefault(), b.shiftKey ? (b = ++e[5], (b = e[4][b]) || (e[5] = e[4].length - 1)) : (b = --e[5], (b = e[4][b]) || (e[5] = 0)), b && (l(), e[6] = b[0].position, e[2](b[1], b[0]));\n          } else if (q(), \"Enter\" === b.key) {\n            b.preventDefault();\n            b = r(f);\n            var a = /\\S/g.exec(b.content);\n            B(b = \"\\n\" + b.content.slice(0, a ? a.index : b.content.length));\n          } else if (!u && \"Backspace\" === b.key) {\n            b.preventDefault(), (b = window.getSelection().getRangeAt(0)).startContainer !== b.endContainer || b.startOffset !== b.endOffset ? b.deleteContents() : (l(), b = r(f), b = Math.max(0, b.position - 1), a = p(f), n(a.slice(0, b) + a.slice(b + 1)));\n          } else if (d.indentation && \"Tab\" === b.key) {\n            b.preventDefault();\n            var c = (a = r(f)).position - a.content.length,\n                g = p(f);\n            b = b.shiftKey ? g.slice(0, c) + a.content.replace(C, \"\") + g.slice(c + a.content.length) : g.slice(0, c) + \"\\t\" + g.slice(c);\n            n(b);\n          }\n        }\n      },\n          y = function y(a) {\n        a.defaultPrevented || a.isComposing || ((a.metaKey || a.ctrlKey) && \"KeyZ\" === a.code || q(), w(), f.focus());\n      },\n          z = function z() {\n        e[6] = r(f).position;\n      },\n          A = function A(a) {\n        a.preventDefault();\n        q(!0);\n        B(a.clipboardData.getData(\"text/plain\"));\n        q(!0);\n        w();\n      };\n\n      window.addEventListener(\"keydown\", x);\n      f.addEventListener(\"focus\", z);\n      f.addEventListener(\"blur\", g);\n      f.addEventListener(\"paste\", A);\n      f.addEventListener(\"keyup\", y);\n      return function () {\n        window.removeEventListener(\"keydown\", x);\n        f.removeEventListener(\"focus\", z);\n        f.removeEventListener(\"blur\", g);\n        f.removeEventListener(\"paste\", A);\n        f.removeEventListener(\"keyup\", y);\n        f.style.whiteSpace = c;\n        f.contentEditable = k;\n      };\n    }\n  }, [a.current, d.disabled, d.indentation]);\n  return n;\n}","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable react/jsx-key */\nimport React, { useContext, useRef, lazy } from \"react\"\nimport Highlight, {\n    defaultProps,\n    Language,\n    PrismTheme,\n} from \"prism-react-renderer\"\n// tslint:disable-next-line: no-submodule-imports match-default-export-name\nimport LIGHT_THEME from \"prism-react-renderer/themes/github\"\n// tslint:disable-next-line: no-submodule-imports match-default-export-name\nimport DARK_THEME from \"prism-react-renderer/themes/vsDark\"\nimport DarkModeContext from \"./DarkModeContext\"\nimport { useEditable } from \"use-editable\"\nimport { Alert } from \"@material-ui/lab\"\nimport { Grid, Tooltip, withStyles } from \"@material-ui/core\"\nimport Suspense from \"../ui/Suspense\";\nconst GithubPullRequestButton = lazy(() => import('../GithubPullRequestButton'));\n\nconst AnnotationTooltip = withStyles(theme => ({\n    arrow: {\n        color: theme.palette.error.main,\n    },\n    tooltip: {\n        backgroundColor: theme.palette.error.main,\n        color: theme.palette.common.white,\n        boxShadow: theme.shadows[1],\n        fontSize: theme.typography.body2.fontSize,\n    },\n}))(Tooltip)\n\nexport default function HighlightTextField(props: {\n    language: string\n    code: string\n    onChange: (newValue: string) => void\n    annotations?: jdspec.Diagnostic[]\n    pullRequestTitle?: string\n    pullRequestPath?: string\n    pullRequestDescription?: string\n}) {\n    const {\n        code,\n        onChange,\n        language,\n        annotations,\n        pullRequestTitle,\n        pullRequestPath,\n        pullRequestDescription,\n    } = props\n    const { darkMode } = useContext(DarkModeContext)\n    const theme = (darkMode === \"dark\" ? DARK_THEME : LIGHT_THEME) as PrismTheme\n    const editorRef = useRef(null)\n\n    useEditable(editorRef, onChange, {\n        disabled: false,\n        indentation: 4,\n    })\n    return (\n        <Grid container spacing={1} direction=\"row\">\n            <Grid item xs={12}>\n                <Highlight\n                    {...defaultProps}\n                    code={code}\n                    language={language as Language}\n                    theme={theme}\n                >\n                    {({ className, style, tokens, getTokenProps }) => (\n                        <pre\n                            ref={editorRef}\n                            className={className}\n                            spellCheck={false}\n                            style={{\n                                ...style,\n                                ...{\n                                    minHeight: \"12rem\",\n                                    whiteSpace: \"pre-wrap\",\n                                },\n                            }}\n                        >\n                            {tokens.map((line, i) => {\n                                const annotation = annotations?.find(\n                                    a => a.line === i + 1\n                                )\n                                const title = annotation?.message\n                                const el = (\n                                    <span\n                                        key={i}\n                                        style={\n                                            annotation && {\n                                                borderBottom: \"dashed 1px red\",\n                                            }\n                                        }\n                                    >\n                                        {line\n                                            .filter(token => !token.empty)\n                                            .map((token, key) => (\n                                                <span\n                                                    {...getTokenProps({\n                                                        token,\n                                                        key,\n                                                    })}\n                                                />\n                                            ))}\n                                        {i < tokens.length - 1 ? \"\\n\" : null}\n                                    </span>\n                                )\n                                return title ? (\n                                    <AnnotationTooltip\n                                        title={title}\n                                        arrow\n                                        key={i}\n                                    >\n                                        {el}\n                                    </AnnotationTooltip>\n                                ) : (\n                                    el\n                                )\n                            })}\n                        </pre>\n                    )}\n                </Highlight>\n            </Grid>\n            {!!annotations?.length && (\n                <Grid item xs={12}>\n                    <Alert severity=\"error\">\n                        <ul>\n                            {annotations.map((a, i) => (\n                                <li key={i}>\n                                    line {a.line}: {a.message}\n                                </li>\n                            ))}\n                        </ul>\n                    </Alert>\n                </Grid>\n            )}\n            {pullRequestTitle && pullRequestPath && (\n                <Grid item>\n                    <Suspense>\n                        <GithubPullRequestButton\n                            title={pullRequestTitle}\n                            head={pullRequestPath}\n                            description={pullRequestDescription}\n                            files={{\n                                [pullRequestPath + \".md\"]: code,\n                            }}\n                        />\n                    </Suspense>\n                </Grid>\n            )}\n        </Grid>\n    )\n}\n","//     JavaScript Expression Parser (JSEP) 0.3.5\n//     JSEP may be freely distributed under the MIT License\n//     https://ericsmekens.github.io/jsep/\n\n/*global module: true, exports: true, console: true */\n(function (root) {\n  'use strict'; // Node Types\n  // ----------\n  // This is the full set of types that any JSEP node can be.\n  // Store them here to save space when minified\n\n  var COMPOUND = 'Compound',\n      IDENTIFIER = 'Identifier',\n      MEMBER_EXP = 'MemberExpression',\n      LITERAL = 'Literal',\n      THIS_EXP = 'ThisExpression',\n      CALL_EXP = 'CallExpression',\n      UNARY_EXP = 'UnaryExpression',\n      BINARY_EXP = 'BinaryExpression',\n      LOGICAL_EXP = 'LogicalExpression',\n      CONDITIONAL_EXP = 'ConditionalExpression',\n      ARRAY_EXP = 'ArrayExpression',\n      PERIOD_CODE = 46,\n      // '.'\n  COMMA_CODE = 44,\n      // ','\n  SQUOTE_CODE = 39,\n      // single quote\n  DQUOTE_CODE = 34,\n      // double quotes\n  OPAREN_CODE = 40,\n      // (\n  CPAREN_CODE = 41,\n      // )\n  OBRACK_CODE = 91,\n      // [\n  CBRACK_CODE = 93,\n      // ]\n  QUMARK_CODE = 63,\n      // ?\n  SEMCOL_CODE = 59,\n      // ;\n  COLON_CODE = 58,\n      // :\n  throwError = function throwError(message, index) {\n    var error = new Error(message + ' at character ' + index);\n    error.index = index;\n    error.description = message;\n    throw error;\n  },\n      // Operations\n  // ----------\n  // Set `t` to `true` to save space (when minified, not gzipped)\n  t = true,\n      // Use a quickly-accessible map to store all of the unary operators\n  // Values are set to `true` (it really doesn't matter)\n  unary_ops = {\n    '-': t,\n    '!': t,\n    '~': t,\n    '+': t\n  },\n      // Also use a map for the binary operations but set their values to their\n  // binary precedence for quick reference:\n  // see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n  binary_ops = {\n    '||': 1,\n    '&&': 2,\n    '|': 3,\n    '^': 4,\n    '&': 5,\n    '==': 6,\n    '!=': 6,\n    '===': 6,\n    '!==': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '<<': 8,\n    '>>': 8,\n    '>>>': 8,\n    '+': 9,\n    '-': 9,\n    '*': 10,\n    '/': 10,\n    '%': 10\n  },\n      // Get return the longest key length of any object\n  getMaxKeyLen = function getMaxKeyLen(obj) {\n    var max_len = 0,\n        len;\n\n    for (var key in obj) {\n      if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n        max_len = len;\n      }\n    }\n\n    return max_len;\n  },\n      max_unop_len = getMaxKeyLen(unary_ops),\n      max_binop_len = getMaxKeyLen(binary_ops),\n      // Literals\n  // ----------\n  // Store the values to return for the various literals we may encounter\n  literals = {\n    'true': true,\n    'false': false,\n    'null': null\n  },\n      // Except for `this`, which is special. This could be changed to something like `'self'` as well\n  this_str = 'this',\n      // Returns the precedence of a binary operator or `0` if it isn't a binary operator\n  binaryPrecedence = function binaryPrecedence(op_val) {\n    return binary_ops[op_val] || 0;\n  },\n      // Utility function (gets called from multiple places)\n  // Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n  createBinaryExpression = function createBinaryExpression(operator, left, right) {\n    var type = operator === '||' || operator === '&&' ? LOGICAL_EXP : BINARY_EXP;\n    return {\n      type: type,\n      operator: operator,\n      left: left,\n      right: right\n    };\n  },\n      // `ch` is a character code in the next three functions\n  isDecimalDigit = function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0...9\n  },\n      isIdentifierStart = function isIdentifierStart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // a...z\n    ch >= 128 && !binary_ops[String.fromCharCode(ch)]; // any non-ASCII that is not an operator\n  },\n      isIdentifierPart = function isIdentifierPart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // a...z\n    ch >= 48 && ch <= 57 || // 0...9\n    ch >= 128 && !binary_ops[String.fromCharCode(ch)]; // any non-ASCII that is not an operator\n  },\n      // Parsing\n  // -------\n  // `expr` is a string with the passed in expression\n  jsep = function jsep(expr) {\n    // `index` stores the character number we are currently at while `length` is a constant\n    // All of the gobbles below will modify `index` as we move along\n    var index = 0,\n        charAtFunc = expr.charAt,\n        charCodeAtFunc = expr.charCodeAt,\n        exprI = function exprI(i) {\n      return charAtFunc.call(expr, i);\n    },\n        exprICode = function exprICode(i) {\n      return charCodeAtFunc.call(expr, i);\n    },\n        length = expr.length,\n        // Push `index` up to the next non-space character\n    gobbleSpaces = function gobbleSpaces() {\n      var ch = exprICode(index); // space or tab\n\n      while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {\n        ch = exprICode(++index);\n      }\n    },\n        // The main parsing function. Much of this code is dedicated to ternary expressions\n    gobbleExpression = function gobbleExpression() {\n      var test = gobbleBinaryExpression(),\n          consequent,\n          alternate;\n      gobbleSpaces();\n\n      if (exprICode(index) === QUMARK_CODE) {\n        // Ternary expression: test ? consequent : alternate\n        index++;\n        consequent = gobbleExpression();\n\n        if (!consequent) {\n          throwError('Expected expression', index);\n        }\n\n        gobbleSpaces();\n\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          alternate = gobbleExpression();\n\n          if (!alternate) {\n            throwError('Expected expression', index);\n          }\n\n          return {\n            type: CONDITIONAL_EXP,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n          };\n        } else {\n          throwError('Expected :', index);\n        }\n      } else {\n        return test;\n      }\n    },\n        // Search for the operation portion of the string (e.g. `+`, `===`)\n    // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n    // and move down from 3 to 2 to 1 character until a matching binary operation is found\n    // then, return that binary operation\n    gobbleBinaryOp = function gobbleBinaryOp() {\n      gobbleSpaces();\n      var biop,\n          to_check = expr.substr(index, max_binop_len),\n          tc_len = to_check.length;\n\n      while (tc_len > 0) {\n        // Don't accept a binary op when it is an identifier.\n        // Binary ops that start with a identifier-valid character must be followed\n        // by a non identifier-part valid character\n        if (binary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {\n          index += tc_len;\n          return to_check;\n        }\n\n        to_check = to_check.substr(0, --tc_len);\n      }\n\n      return false;\n    },\n        // This function is responsible for gobbling an individual expression,\n    // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n    gobbleBinaryExpression = function gobbleBinaryExpression() {\n      var ch_i, node, biop, prec, stack, biop_info, left, right, i, cur_biop; // First, try to get the leftmost thing\n      // Then, check to see if there's a binary operator operating on that leftmost thing\n\n      left = gobbleToken();\n      biop = gobbleBinaryOp(); // If there wasn't a binary operator, just return the leftmost node\n\n      if (!biop) {\n        return left;\n      } // Otherwise, we need to start a stack to properly place the binary operations in their\n      // precedence structure\n\n\n      biop_info = {\n        value: biop,\n        prec: binaryPrecedence(biop)\n      };\n      right = gobbleToken();\n\n      if (!right) {\n        throwError(\"Expected expression after \" + biop, index);\n      }\n\n      stack = [left, biop_info, right]; // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\n      while (biop = gobbleBinaryOp()) {\n        prec = binaryPrecedence(biop);\n\n        if (prec === 0) {\n          break;\n        }\n\n        biop_info = {\n          value: biop,\n          prec: prec\n        };\n        cur_biop = biop; // Reduce: make a binary expression from the three topmost entries.\n\n        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n          right = stack.pop();\n          biop = stack.pop().value;\n          left = stack.pop();\n          node = createBinaryExpression(biop, left, right);\n          stack.push(node);\n        }\n\n        node = gobbleToken();\n\n        if (!node) {\n          throwError(\"Expected expression after \" + cur_biop, index);\n        }\n\n        stack.push(biop_info, node);\n      }\n\n      i = stack.length - 1;\n      node = stack[i];\n\n      while (i > 1) {\n        node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\n        i -= 2;\n      }\n\n      return node;\n    },\n        // An individual part of a binary expression:\n    // e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n    gobbleToken = function gobbleToken() {\n      var ch, to_check, tc_len;\n      gobbleSpaces();\n      ch = exprICode(index);\n\n      if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n        // Char code 46 is a dot `.` which can start off a numeric literal\n        return gobbleNumericLiteral();\n      } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n        // Single or double quotes\n        return gobbleStringLiteral();\n      } else if (ch === OBRACK_CODE) {\n        return gobbleArray();\n      } else {\n        to_check = expr.substr(index, max_unop_len);\n        tc_len = to_check.length;\n\n        while (tc_len > 0) {\n          // Don't accept an unary op when it is an identifier.\n          // Unary ops that start with a identifier-valid character must be followed\n          // by a non identifier-part valid character\n          if (unary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {\n            index += tc_len;\n            return {\n              type: UNARY_EXP,\n              operator: to_check,\n              argument: gobbleToken(),\n              prefix: true\n            };\n          }\n\n          to_check = to_check.substr(0, --tc_len);\n        }\n\n        if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n          // open parenthesis\n          // `foo`, `bar.baz`\n          return gobbleVariable();\n        }\n      }\n\n      return false;\n    },\n        // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n    // keep track of everything in the numeric literal and then calling `parseFloat` on that string\n    gobbleNumericLiteral = function gobbleNumericLiteral() {\n      var number = '',\n          ch,\n          chCode;\n\n      while (isDecimalDigit(exprICode(index))) {\n        number += exprI(index++);\n      }\n\n      if (exprICode(index) === PERIOD_CODE) {\n        // can start with a decimal marker\n        number += exprI(index++);\n\n        while (isDecimalDigit(exprICode(index))) {\n          number += exprI(index++);\n        }\n      }\n\n      ch = exprI(index);\n\n      if (ch === 'e' || ch === 'E') {\n        // exponent marker\n        number += exprI(index++);\n        ch = exprI(index);\n\n        if (ch === '+' || ch === '-') {\n          // exponent sign\n          number += exprI(index++);\n        }\n\n        while (isDecimalDigit(exprICode(index))) {\n          //exponent itself\n          number += exprI(index++);\n        }\n\n        if (!isDecimalDigit(exprICode(index - 1))) {\n          throwError('Expected exponent (' + number + exprI(index) + ')', index);\n        }\n      }\n\n      chCode = exprICode(index); // Check to make sure this isn't a variable name that start with a number (123abc)\n\n      if (isIdentifierStart(chCode)) {\n        throwError('Variable names cannot start with a number (' + number + exprI(index) + ')', index);\n      } else if (chCode === PERIOD_CODE) {\n        throwError('Unexpected period', index);\n      }\n\n      return {\n        type: LITERAL,\n        value: parseFloat(number),\n        raw: number\n      };\n    },\n        // Parses a string literal, staring with single or double quotes with basic support for escape codes\n    // e.g. `\"hello world\"`, `'this is\\nJSEP'`\n    gobbleStringLiteral = function gobbleStringLiteral() {\n      var str = '',\n          quote = exprI(index++),\n          closed = false,\n          ch;\n\n      while (index < length) {\n        ch = exprI(index++);\n\n        if (ch === quote) {\n          closed = true;\n          break;\n        } else if (ch === '\\\\') {\n          // Check for all of the common escape codes\n          ch = exprI(index++);\n\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            default:\n              str += ch;\n          }\n        } else {\n          str += ch;\n        }\n      }\n\n      if (!closed) {\n        throwError('Unclosed quote after \"' + str + '\"', index);\n      }\n\n      return {\n        type: LITERAL,\n        value: str,\n        raw: quote + str + quote\n      };\n    },\n        // Gobbles only identifiers\n    // e.g.: `foo`, `_value`, `$x1`\n    // Also, this function checks if that identifier is a literal:\n    // (e.g. `true`, `false`, `null`) or `this`\n    gobbleIdentifier = function gobbleIdentifier() {\n      var ch = exprICode(index),\n          start = index,\n          identifier;\n\n      if (isIdentifierStart(ch)) {\n        index++;\n      } else {\n        throwError('Unexpected ' + exprI(index), index);\n      }\n\n      while (index < length) {\n        ch = exprICode(index);\n\n        if (isIdentifierPart(ch)) {\n          index++;\n        } else {\n          break;\n        }\n      }\n\n      identifier = expr.slice(start, index);\n\n      if (literals.hasOwnProperty(identifier)) {\n        return {\n          type: LITERAL,\n          value: literals[identifier],\n          raw: identifier\n        };\n      } else if (identifier === this_str) {\n        return {\n          type: THIS_EXP\n        };\n      } else {\n        return {\n          type: IDENTIFIER,\n          name: identifier\n        };\n      }\n    },\n        // Gobbles a list of arguments within the context of a function call\n    // or array literal. This function also assumes that the opening character\n    // `(` or `[` has already been gobbled, and gobbles expressions and commas\n    // until the terminator character `)` or `]` is encountered.\n    // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n    gobbleArguments = function gobbleArguments(termination) {\n      var ch_i,\n          args = [],\n          node,\n          closed = false;\n      var separator_count = 0;\n\n      while (index < length) {\n        gobbleSpaces();\n        ch_i = exprICode(index);\n\n        if (ch_i === termination) {\n          // done parsing\n          closed = true;\n          index++;\n\n          if (termination === CPAREN_CODE && separator_count && separator_count >= args.length) {\n            throwError('Unexpected token ' + String.fromCharCode(termination), index);\n          }\n\n          break;\n        } else if (ch_i === COMMA_CODE) {\n          // between expressions\n          index++;\n          separator_count++;\n\n          if (separator_count !== args.length) {\n            // missing argument\n            if (termination === CPAREN_CODE) {\n              throwError('Unexpected token ,', index);\n            } else if (termination === CBRACK_CODE) {\n              for (var arg = args.length; arg < separator_count; arg++) {\n                args.push(null);\n              }\n            }\n          }\n        } else {\n          node = gobbleExpression();\n\n          if (!node || node.type === COMPOUND) {\n            throwError('Expected comma', index);\n          }\n\n          args.push(node);\n        }\n      }\n\n      if (!closed) {\n        throwError('Expected ' + String.fromCharCode(termination), index);\n      }\n\n      return args;\n    },\n        // Gobble a non-literal variable name. This variable name may include properties\n    // e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n    // It also gobbles function calls:\n    // e.g. `Math.acos(obj.angle)`\n    gobbleVariable = function gobbleVariable() {\n      var ch_i, node;\n      ch_i = exprICode(index);\n\n      if (ch_i === OPAREN_CODE) {\n        node = gobbleGroup();\n      } else {\n        node = gobbleIdentifier();\n      }\n\n      gobbleSpaces();\n      ch_i = exprICode(index);\n\n      while (ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n        index++;\n\n        if (ch_i === PERIOD_CODE) {\n          gobbleSpaces();\n          node = {\n            type: MEMBER_EXP,\n            computed: false,\n            object: node,\n            property: gobbleIdentifier()\n          };\n        } else if (ch_i === OBRACK_CODE) {\n          node = {\n            type: MEMBER_EXP,\n            computed: true,\n            object: node,\n            property: gobbleExpression()\n          };\n          gobbleSpaces();\n          ch_i = exprICode(index);\n\n          if (ch_i !== CBRACK_CODE) {\n            throwError('Unclosed [', index);\n          }\n\n          index++;\n        } else if (ch_i === OPAREN_CODE) {\n          // A function call is being made; gobble all the arguments\n          node = {\n            type: CALL_EXP,\n            'arguments': gobbleArguments(CPAREN_CODE),\n            callee: node\n          };\n        }\n\n        gobbleSpaces();\n        ch_i = exprICode(index);\n      }\n\n      return node;\n    },\n        // Responsible for parsing a group of things within parentheses `()`\n    // This function assumes that it needs to gobble the opening parenthesis\n    // and then tries to gobble everything within that parenthesis, assuming\n    // that the next thing it should see is the close parenthesis. If not,\n    // then the expression probably doesn't have a `)`\n    gobbleGroup = function gobbleGroup() {\n      index++;\n      var node = gobbleExpression();\n      gobbleSpaces();\n\n      if (exprICode(index) === CPAREN_CODE) {\n        index++;\n        return node;\n      } else {\n        throwError('Unclosed (', index);\n      }\n    },\n        // Responsible for parsing Array literals `[1, 2, 3]`\n    // This function assumes that it needs to gobble the opening bracket\n    // and then tries to gobble the expressions as arguments.\n    gobbleArray = function gobbleArray() {\n      index++;\n      return {\n        type: ARRAY_EXP,\n        elements: gobbleArguments(CBRACK_CODE)\n      };\n    },\n        nodes = [],\n        ch_i,\n        node;\n\n    while (index < length) {\n      ch_i = exprICode(index); // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n\n      if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n        index++; // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        if (node = gobbleExpression()) {\n          nodes.push(node); // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n        } else if (index < length) {\n          throwError('Unexpected \"' + exprI(index) + '\"', index);\n        }\n      }\n    } // If there's only one expression just try returning the expression\n\n\n    if (nodes.length === 1) {\n      return nodes[0];\n    } else {\n      return {\n        type: COMPOUND,\n        body: nodes\n      };\n    }\n  }; // To be filled in by the template\n\n\n  jsep.version = '0.3.5';\n\n  jsep.toString = function () {\n    return 'JavaScript Expression Parser (JSEP) v' + jsep.version;\n  };\n  /**\n   * @method jsep.addUnaryOp\n   * @param {string} op_name The name of the unary op to add\n   * @return jsep\n   */\n\n\n  jsep.addUnaryOp = function (op_name) {\n    max_unop_len = Math.max(op_name.length, max_unop_len);\n    unary_ops[op_name] = t;\n    return this;\n  };\n  /**\n   * @method jsep.addBinaryOp\n   * @param {string} op_name The name of the binary op to add\n   * @param {number} precedence The precedence of the binary op (can be a float)\n   * @return jsep\n   */\n\n\n  jsep.addBinaryOp = function (op_name, precedence) {\n    max_binop_len = Math.max(op_name.length, max_binop_len);\n    binary_ops[op_name] = precedence;\n    return this;\n  };\n  /**\n   * @method jsep.addLiteral\n   * @param {string} literal_name The name of the literal to add\n   * @param {*} literal_value The value of the literal\n   * @return jsep\n   */\n\n\n  jsep.addLiteral = function (literal_name, literal_value) {\n    literals[literal_name] = literal_value;\n    return this;\n  };\n  /**\n   * @method jsep.removeUnaryOp\n   * @param {string} op_name The name of the unary op to remove\n   * @return jsep\n   */\n\n\n  jsep.removeUnaryOp = function (op_name) {\n    delete unary_ops[op_name];\n\n    if (op_name.length === max_unop_len) {\n      max_unop_len = getMaxKeyLen(unary_ops);\n    }\n\n    return this;\n  };\n  /**\n   * @method jsep.removeAllUnaryOps\n   * @return jsep\n   */\n\n\n  jsep.removeAllUnaryOps = function () {\n    unary_ops = {};\n    max_unop_len = 0;\n    return this;\n  };\n  /**\n   * @method jsep.removeBinaryOp\n   * @param {string} op_name The name of the binary op to remove\n   * @return jsep\n   */\n\n\n  jsep.removeBinaryOp = function (op_name) {\n    delete binary_ops[op_name];\n\n    if (op_name.length === max_binop_len) {\n      max_binop_len = getMaxKeyLen(binary_ops);\n    }\n\n    return this;\n  };\n  /**\n   * @method jsep.removeAllBinaryOps\n   * @return jsep\n   */\n\n\n  jsep.removeAllBinaryOps = function () {\n    binary_ops = {};\n    max_binop_len = 0;\n    return this;\n  };\n  /**\n   * @method jsep.removeLiteral\n   * @param {string} literal_name The name of the literal to remove\n   * @return jsep\n   */\n\n\n  jsep.removeLiteral = function (literal_name) {\n    delete literals[literal_name];\n    return this;\n  };\n  /**\n   * @method jsep.removeAllLiterals\n   * @return jsep\n   */\n\n\n  jsep.removeAllLiterals = function () {\n    literals = {};\n    return this;\n  }; // In desktop environments, have a way to restore the old value for `jsep`\n\n\n  if (typeof exports === 'undefined') {\n    var old_jsep = root.jsep; // The star of the show! It's a function!\n\n    root.jsep = jsep; // And a courteous function willing to move out of the way for other similarly-named objects!\n\n    jsep.noConflict = function () {\n      if (root.jsep === jsep) {\n        root.jsep = old_jsep;\n      }\n\n      return jsep;\n    };\n  } else {\n    // In Node.JS environments\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = jsep;\n    } else {\n      exports.parse = jsep;\n    }\n  }\n})(this);"],"sourceRoot":""}