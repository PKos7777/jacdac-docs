(self["webpackChunkjacdac_docs"] = self["webpackChunkjacdac_docs"] || []).push([[1954],{

/***/ 93192:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var _defineProperty = __webpack_require__(59713);

var _get = __webpack_require__(16525);

var _assertThisInitialized = __webpack_require__(81506);

var _wrapNativeSuper = __webpack_require__(65957);

var _inherits = __webpack_require__(2205);

var _possibleConstructorReturn = __webpack_require__(78585);

var _getPrototypeOf = __webpack_require__(29754);

var _toConsumableArray = __webpack_require__(319);

var _slicedToArray = __webpack_require__(63038);

var _regeneratorRuntime = __webpack_require__(87757);

var _asyncToGenerator = __webpack_require__(48926);

var _classCallCheck = __webpack_require__(34575);

var _createClass = __webpack_require__(93913);

__webpack_require__(25438);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e541) { throw _e541; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e542) { didErr = true; err = _e542; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function e() {
  return (e = Object.assign || function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];

      for (var s in n) {
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
      }
    }

    return e;
  }).apply(this, arguments);
}

var t = /*#__PURE__*/function () {
  "use strict";

  function t(e, _t2) {
    _classCallCheck(this, t);

    this.backend = e, this.dataMover = _t2, this.data = new WeakMap(), this.dataIdsCount = 0;
  }

  _createClass(t, [{
    key: "get",
    value: function get(e) {
      return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
    }
  }, {
    key: "set",
    value: function set(e, _t3) {
      this.dataIdsCount++, this.data.set(e, _t3);
    }
  }, {
    key: "has",
    value: function has(e) {
      return this.data.has(e);
    }
  }, {
    key: "delete",
    value: function _delete(e) {
      return this.dataIdsCount--, this.data.delete(e);
    }
  }, {
    key: "numDataIds",
    value: function numDataIds() {
      return this.dataIdsCount;
    }
  }]);

  return t;
}();

var n = /*#__PURE__*/function () {
  "use strict";

  function n() {
    _classCallCheck(this, n);
  }

  _createClass(n, [{
    key: "refCount",
    value: function refCount(e) {
      return s("refCount");
    }
  }, {
    key: "incRef",
    value: function incRef(e) {
      return s("incRef");
    }
  }, {
    key: "timerAvailable",
    value: function timerAvailable() {
      return !0;
    }
  }, {
    key: "time",
    value: function time(e) {
      return s("time");
    }
  }, {
    key: "read",
    value: function read(e) {
      return s("read");
    }
  }, {
    key: "readSync",
    value: function readSync(e) {
      return s("readSync");
    }
  }, {
    key: "numDataIds",
    value: function numDataIds() {
      return s("numDataIds");
    }
  }, {
    key: "disposeData",
    value: function disposeData(e, t) {
      return s("disposeData");
    }
  }, {
    key: "write",
    value: function write(e, t, _n2) {
      return s("write");
    }
  }, {
    key: "move",
    value: function move(e, t, _n3, r, a) {
      return s("move");
    }
  }, {
    key: "memory",
    value: function memory() {
      return s("memory");
    }
  }, {
    key: "floatPrecision",
    value: function floatPrecision() {
      return s("floatPrecision");
    }
  }, {
    key: "epsilon",
    value: function epsilon() {
      return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      return s("dispose");
    }
  }]);

  return n;
}();

function s(e) {
  throw new Error("'".concat(e, "' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen"));
}

function r(e) {
  var t = e.length,
      n = 0;

  for (; t > 0;) {
    n = Math.random() * t | 0, t--, o(e, t, n);
  }
}

function a(e, t, n) {
  return Math.max(e, Math.min(t, n));
}

function i(e) {
  return e % 2 == 0 ? e : e + 1;
}

function o(e, t, n) {
  var s = e[t];
  e[t] = e[n], e[n] = s;
}

function l(e, t) {
  if (!e) throw new Error("string" == typeof t ? t : t());
}

function u(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  l(p(e, t), function () {
    return n + " Shapes ".concat(e, " and ").concat(t, " must match");
  });
}

function c(e) {
  l(null != e, function () {
    return "The input to the tensor constructor must be a non-null value.";
  });
}

function h(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (null == t && (t = []), Array.isArray(e) || $(e) && !n) for (var _s2 = 0; _s2 < e.length; ++_s2) {
    h(e[_s2], t, n);
  } else t.push(e);
  return t;
}

function d(e) {
  if (0 === e.length) return 1;
  var t = e[0];

  for (var _n4 = 1; _n4 < e.length; _n4++) {
    t *= e[_n4];
  }

  return t;
}

function p(e, t) {
  if (e === t) return !0;
  if (null == e || null == t) return !1;
  if (e.length !== t.length) return !1;

  for (var _n5 = 0; _n5 < e.length; _n5++) {
    if (e[_n5] !== t[_n5]) return !1;
  }

  return !0;
}

function f(e) {
  return e % 1 == 0;
}

function g(e) {
  var t = Math.ceil(Math.sqrt(e));
  return [t, Math.ceil(e / t)];
}

function m(e, t) {
  return t <= e.length ? e : e + " ".repeat(t - e.length);
}

function b(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (e) {
    return 0;
  };
  var n = arguments.length > 2 ? arguments[2] : undefined;
  return new Promise(function (s, r) {
    var a = 0;

    var i = function i() {
      if (e()) return void s();
      a++;
      var o = t(a);
      null != n && a >= n ? r() : setTimeout(i, o);
    };

    i();
  });
}

function x(e, t) {
  var n = 1,
      s = -1;

  for (var _t4 = 0; _t4 < e.length; ++_t4) {
    if (e[_t4] >= 0) n *= e[_t4];else if (-1 === e[_t4]) {
      if (-1 !== s) throw Error("Shapes can only have 1 implicit size. Found -1 at dim ".concat(s, " and dim ").concat(_t4));
      s = _t4;
    } else if (e[_t4] < 0) throw Error("Shapes can not be < 0. Found ".concat(e[_t4], " at dim ").concat(_t4));
  }

  if (-1 === s) {
    if (t > 0 && t !== n) throw Error("Size(".concat(t, ") must match the product of shape ").concat(e));
    return e;
  }

  if (0 === n) throw Error("Cannot infer the missing size in [".concat(e, "] when there are 0 elements"));
  if (t % n != 0) throw Error("The implicit shape can't be a fractional number. Got ".concat(t, " / ").concat(n));
  var r = e.slice();
  return r[s] = t / n, r;
}

function y(e, t) {
  var n = t.length;
  return l((e = null == e ? t.map(function (e, t) {
    return t;
  }) : [].concat(e)).every(function (e) {
    return e >= -n && e < n;
  }), function () {
    return "All values in axis param must be in range [-".concat(n, ", ").concat(n, ") but got axis ").concat(e);
  }), l(e.every(function (e) {
    return f(e);
  }), function () {
    return "All values in axis param must be integers but got axis ".concat(e);
  }), e.map(function (e) {
    return e < 0 ? n + e : e;
  });
}

function k(e, t) {
  var n = [],
      s = [],
      r = null != t && Array.isArray(t) && 0 === t.length,
      a = null == t || r ? null : y(t, e).sort();
  var i = 0;

  for (var _t5 = 0; _t5 < e.length; ++_t5) {
    if (null != a) {
      if (a[i] === _t5 && 1 !== e[_t5]) throw new Error("Can't squeeze axis ".concat(_t5, " since its dim '").concat(e[_t5], "' is not 1"));
      (null == a[i] || a[i] > _t5) && 1 === e[_t5] && (n.push(e[_t5]), s.push(_t5)), a[i] <= _t5 && i++;
    }

    1 !== e[_t5] && (n.push(e[_t5]), s.push(_t5));
  }

  return {
    newShape: n,
    keptDims: s
  };
}

function w(e, t) {
  var n = null;
  if (null == e || "float32" === e) n = new Float32Array(t);else if ("int32" === e) n = new Int32Array(t);else {
    if ("bool" !== e) throw new Error("Unknown data type ".concat(e));
    n = new Uint8Array(t);
  }
  return n;
}

function v(e, t) {
  var n = null;
  if (null == e || "float32" === e) n = new Float32Array(t);else if ("int32" === e) n = new Int32Array(t);else if ("bool" === e) n = new Uint8Array(t);else {
    if ("string" !== e) throw new Error("Unknown data type ".concat(e));
    n = new Array(t);
  }
  return n;
}

function I(e, t) {
  return !("complex64" === t || "float32" === t && "complex64" !== e || "int32" === t && "float32" !== e && "complex64" !== e || "bool" === t && "bool" === e);
}

function $(e) {
  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array;
}

function N(e) {
  if ("float32" === e || "int32" === e) return 4;
  if ("complex64" === e) return 8;
  if ("bool" === e) return 1;
  throw new Error("Unknown dtype ".concat(e));
}

function C(e) {
  return "string" == typeof e || e instanceof String;
}

function S(e) {
  return "number" == typeof e;
}

function T(e) {
  return Array.isArray(e) ? T(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array ? "int32" : S(e) ? "float32" : C(e) ? "string" : "boolean" == typeof e ? "bool" : "float32";
}

function E(e) {
  return !!(e && e.constructor && e.call && e.apply);
}

function R(e, t) {
  for (var _n6 = t; _n6 < e; ++_n6) {
    if (e % _n6 == 0) return _n6;
  }

  return e;
}

function A(e) {
  var t = e.length;
  if (t < 2) return [];
  var n = new Array(t - 1);
  n[t - 2] = e[t - 1];

  for (var _s3 = t - 3; _s3 >= 0; --_s3) {
    n[_s3] = n[_s3 + 1] * e[_s3 + 1];
  }

  return n;
}

function F(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = new Array();

  if (1 === t.length) {
    var _a2 = t[0] * (s ? 2 : 1);

    for (var _t6 = 0; _t6 < _a2; _t6++) {
      r[_t6] = n[e + _t6];
    }
  } else {
    var _a3 = t[0],
        _i2 = t.slice(1),
        _o2 = _i2.reduce(function (e, t) {
      return e * t;
    }) * (s ? 2 : 1);

    for (var _t7 = 0; _t7 < _a3; _t7++) {
      r[_t7] = F(e + _t7 * _o2, _i2, n, s);
    }
  }

  return r;
}

function D(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (0 === e.length) return t[0];
  var s = e.reduce(function (e, t) {
    return e * t;
  }) * (n ? 2 : 1);
  if (0 === s) return [];
  if (s !== t.length) throw new Error("[".concat(e, "] does not match the input size ").concat(t.length).concat(n ? " for a complex tensor" : "", "."));
  return F(0, e, t, n);
}

function _(e, t) {
  var n = O(e, t);

  for (var _e2 = 0; _e2 < n.length; _e2++) {
    n[_e2] = 1;
  }

  return n;
}

function O(e, t) {
  if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
  if ("int32" === t) return new Int32Array(e);
  if ("bool" === t) return new Uint8Array(e);
  throw new Error("Unknown data type ".concat(t));
}

function M(e, t) {
  var n = e.reduce(function (e, t) {
    return e * t;
  }, 1);
  if (null == t || "float32" === t) return D(e, new Float32Array(n));
  if ("int32" === t) return D(e, new Int32Array(n));
  if ("bool" === t) return D(e, new Uint8Array(n));
  throw new Error("Unknown data type ".concat(t));
}

function L(e) {
  e.forEach(function (t) {
    l(Number.isInteger(t) && t >= 0, function () {
      return "Tensor must have a shape comprised of positive integers but got shape [".concat(e, "].");
    });
  });
}

function z(e, t, n) {
  if (0 === t) return 0;
  if (1 === t) return e[0];
  var s = e[e.length - 1];

  for (var _t8 = 0; _t8 < e.length - 1; ++_t8) {
    s += n[_t8] * e[_t8];
  }

  return s;
}

function B(e, t, n) {
  if (0 === t) return [];
  if (1 === t) return [e];
  var s = new Array(t);

  for (var _t9 = 0; _t9 < s.length - 1; ++_t9) {
    s[_t9] = Math.floor(e / n[_t9]), e -= s[_t9] * n[_t9];
  }

  return s[s.length - 1] = e, s;
}

function P(e) {
  return e && e.then && "function" == typeof e.then;
}

var W = /*#__PURE__*/function () {
  "use strict";

  function W(e) {
    _classCallCheck(this, W);

    this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = U, this.populateURLFlags();
  }

  _createClass(W, [{
    key: "setPlatform",
    value: function setPlatform(e, t) {
      null != this.platform && console.warn("Platform ".concat(this.platformName, " has already been set. Overwriting the platform with ").concat(t, ".")), this.platformName = e, this.platform = t;
    }
  }, {
    key: "registerFlag",
    value: function registerFlag(e, t, n) {
      if (this.flagRegistry[e] = {
        evaluationFn: t,
        setHook: n
      }, null != this.urlFlags[e]) {
        var _t10 = this.urlFlags[e];
        console.warn("Setting feature override from URL ".concat(e, ": ").concat(_t10, ".")), this.set(e, _t10);
      }
    }
  }, {
    key: "getAsync",
    value: function () {
      var _getAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = e in this.flags;

                if (_context.t0) {
                  _context.next = 5;
                  break;
                }

                _context.next = 4;
                return this.evaluateFlag(e);

              case 4:
                this.flags[e] = _context.sent;

              case 5:
                return _context.abrupt("return", this.flags[e]);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAsync(_x2) {
        return _getAsync.apply(this, arguments);
      }

      return getAsync;
    }()
  }, {
    key: "get",
    value: function get(e) {
      if (e in this.flags) return this.flags[e];
      var t = this.evaluateFlag(e);
      if (P(t)) throw new Error("Flag ".concat(e, " cannot be synchronously evaluated. Please use getAsync() instead."));
      return this.flags[e] = t, this.flags[e];
    }
  }, {
    key: "getNumber",
    value: function getNumber(e) {
      return this.get(e);
    }
  }, {
    key: "getBool",
    value: function getBool(e) {
      return this.get(e);
    }
  }, {
    key: "getFlags",
    value: function getFlags() {
      return this.flags;
    }
  }, {
    key: "features",
    get: function get() {
      return this.flags;
    }
  }, {
    key: "set",
    value: function set(e, t) {
      if (null == this.flagRegistry[e]) throw new Error("Cannot set flag ".concat(e, " as it has not been registered."));
      this.flags[e] = t, null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t);
    }
  }, {
    key: "evaluateFlag",
    value: function evaluateFlag(e) {
      if (null == this.flagRegistry[e]) throw new Error("Cannot evaluate flag '".concat(e, "': no evaluation function found."));
      return this.flagRegistry[e].evaluationFn();
    }
  }, {
    key: "setFlags",
    value: function setFlags(e) {
      this.flags = Object.assign({}, e);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }
  }, {
    key: "populateURLFlags",
    value: function populateURLFlags() {
      var _this = this;

      if (void 0 === this.global || void 0 === this.global.location || void 0 === this.global.location.search) return;
      var e = this.getQueryParams(this.global.location.search);
      "tfjsflags" in e && e.tfjsflags.split(",").forEach(function (e) {
        var _e$split = e.split(":"),
            _e$split2 = _slicedToArray(_e$split, 2),
            t = _e$split2[0],
            n = _e$split2[1];

        _this.urlFlags[t] = function (e, t) {
          if ("true" === (t = t.toLowerCase()) || "false" === t) return "true" === t;
          if ("" + +t === t) return +t;
          throw new Error("Could not parse value flag value ".concat(t, " for flag ").concat(e, "."));
        }(t, n);
      });
    }
  }]);

  return W;
}();

function U(e) {
  var t = {};
  return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {
    for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      n[_key - 1] = arguments[_key];
    }

    return function (e, t, n) {
      e[decodeURIComponent(t)] = decodeURIComponent(n || "");
    }(t, n[0], n[1]), n.join("=");
  }), t;
}

function V() {
  return H;
}

var G,
    H = null;

function j() {
  if (null == G) {
    var _e3;

    if ("undefined" != typeof window) _e3 = window;else if ("undefined" != typeof __webpack_require__.g) _e3 = __webpack_require__.g;else if ("undefined" != typeof process) _e3 = process;else {
      if ("undefined" == typeof self) throw new Error("Could not find a global object");
      _e3 = self;
    }
    G = _e3;
  }

  return G;
}

function q(e, t) {
  var n = function () {
    var e = j();
    return null == e._tfGlobals && (e._tfGlobals = new Map()), e._tfGlobals;
  }();

  if (n.has(e)) return n.get(e);
  {
    var _s4 = t();

    return n.set(e, _s4), n.get(e);
  }
}

var K = q("kernelRegistry", function () {
  return new Map();
}),
    X = q("gradRegistry", function () {
  return new Map();
});

function Y(e, t) {
  var n = te(e, t);
  return K.get(n);
}

function J(e) {
  return X.get(e);
}

function Z(e) {
  var t = K.entries(),
      n = [];

  for (;;) {
    var _t$next = t.next(),
        _s5 = _t$next.done,
        _r2 = _t$next.value;

    if (_s5) break;

    var _r3 = _slicedToArray(_r2, 2),
        _a4 = _r3[0],
        _i3 = _r3[1],
        _a4$split = _a4.split("_"),
        _a4$split2 = _slicedToArray(_a4$split, 1),
        _o3 = _a4$split2[0];

    _o3 === e && n.push(_i3);
  }

  return n;
}

function Q(e) {
  var t = e.kernelName,
      n = e.backendName,
      s = te(t, n);
  K.has(s) && console.warn("The kernel '".concat(t, "' for backend '").concat(n, "' is already registered")), K.set(s, e);
}

function ee(e) {
  var t = e.kernelName;
  X.has(t) && V().getBool("DEBUG") && console.warn("Overriding the gradient for '".concat(t, "'")), X.set(t, e);
}

function te(e, t) {
  return "".concat(t, "_").concat(e);
}

var ne = re,
    se = null;

try {
  se = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch (e) {}

function re(e, t, n) {
  this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n;
}

function ae(e) {
  return !0 === (e && e.__isLong__);
}

Object.defineProperty(re.prototype, "__isLong__", {
  value: !0
}), re.isLong = ae;
var ie = {},
    oe = {};

function le(e, t) {
  var n, s, r;
  return t ? (r = 0 <= (e >>>= 0) && e < 256) && (s = oe[e]) ? s : (n = ce(e, (0 | e) < 0 ? -1 : 0, !0), r && (oe[e] = n), n) : (r = -128 <= (e |= 0) && e < 128) && (s = ie[e]) ? s : (n = ce(e, e < 0 ? -1 : 0, !1), r && (ie[e] = n), n);
}

function ue(e, t) {
  if (isNaN(e)) return t ? ye : xe;

  if (t) {
    if (e < 0) return ye;
    if (e >= ge) return $e;
  } else {
    if (e <= -me) return Ne;
    if (e + 1 >= me) return Ie;
  }

  return e < 0 ? ue(-e, t).neg() : ce(e % fe | 0, e / fe | 0, t);
}

function ce(e, t, n) {
  return new re(e, t, n);
}

re.fromInt = le, re.fromNumber = ue, re.fromBits = ce;
var he = Math.pow;

function de(e, t, n) {
  if (0 === e.length) throw Error("empty string");
  if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return xe;
  if ("number" == typeof t ? (n = t, t = !1) : t = !!t, (n = n || 10) < 2 || 36 < n) throw RangeError("radix");
  var s;
  if ((s = e.indexOf("-")) > 0) throw Error("interior hyphen");
  if (0 === s) return de(e.substring(1), t, n).neg();

  for (var r = ue(he(n, 8)), a = xe, i = 0; i < e.length; i += 8) {
    var o = Math.min(8, e.length - i),
        l = parseInt(e.substring(i, i + o), n);

    if (o < 8) {
      var u = ue(he(n, o));
      a = a.mul(u).add(ue(l));
    } else a = (a = a.mul(r)).add(ue(l));
  }

  return a.unsigned = t, a;
}

function pe(e, t) {
  return "number" == typeof e ? ue(e, t) : "string" == typeof e ? de(e, t) : ce(e.low, e.high, "boolean" == typeof t ? t : e.unsigned);
}

re.fromString = de, re.fromValue = pe;
var fe = 4294967296,
    ge = fe * fe,
    me = ge / 2,
    be = le(1 << 24),
    xe = le(0);
re.ZERO = xe;
var ye = le(0, !0);
re.UZERO = ye;
var ke = le(1);
re.ONE = ke;
var we = le(1, !0);
re.UONE = we;
var ve = le(-1);
re.NEG_ONE = ve;
var Ie = ce(-1, 2147483647, !1);
re.MAX_VALUE = Ie;
var $e = ce(-1, -1, !0);
re.MAX_UNSIGNED_VALUE = $e;
var Ne = ce(0, -2147483648, !1);
re.MIN_VALUE = Ne;
var Ce = re.prototype;
Ce.toInt = function () {
  return this.unsigned ? this.low >>> 0 : this.low;
}, Ce.toNumber = function () {
  return this.unsigned ? (this.high >>> 0) * fe + (this.low >>> 0) : this.high * fe + (this.low >>> 0);
}, Ce.toString = function (e) {
  if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";

  if (this.isNegative()) {
    if (this.eq(Ne)) {
      var t = ue(e),
          n = this.div(t),
          s = n.mul(t).sub(this);
      return n.toString(e) + s.toInt().toString(e);
    }

    return "-" + this.neg().toString(e);
  }

  for (var r = ue(he(e, 6), this.unsigned), a = this, i = "";;) {
    var o = a.div(r),
        l = (a.sub(o.mul(r)).toInt() >>> 0).toString(e);
    if ((a = o).isZero()) return l + i;

    for (; l.length < 6;) {
      l = "0" + l;
    }

    i = "" + l + i;
  }
}, Ce.getHighBits = function () {
  return this.high;
}, Ce.getHighBitsUnsigned = function () {
  return this.high >>> 0;
}, Ce.getLowBits = function () {
  return this.low;
}, Ce.getLowBitsUnsigned = function () {
  return this.low >>> 0;
}, Ce.getNumBitsAbs = function () {
  if (this.isNegative()) return this.eq(Ne) ? 64 : this.neg().getNumBitsAbs();

  for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--) {
    ;
  }

  return 0 != this.high ? t + 33 : t + 1;
}, Ce.isZero = function () {
  return 0 === this.high && 0 === this.low;
}, Ce.eqz = Ce.isZero, Ce.isNegative = function () {
  return !this.unsigned && this.high < 0;
}, Ce.isPositive = function () {
  return this.unsigned || this.high >= 0;
}, Ce.isOdd = function () {
  return 1 == (1 & this.low);
}, Ce.isEven = function () {
  return 0 == (1 & this.low);
}, Ce.equals = function (e) {
  return ae(e) || (e = pe(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low;
}, Ce.eq = Ce.equals, Ce.notEquals = function (e) {
  return !this.eq(e);
}, Ce.neq = Ce.notEquals, Ce.ne = Ce.notEquals, Ce.lessThan = function (e) {
  return this.comp(e) < 0;
}, Ce.lt = Ce.lessThan, Ce.lessThanOrEqual = function (e) {
  return this.comp(e) <= 0;
}, Ce.lte = Ce.lessThanOrEqual, Ce.le = Ce.lessThanOrEqual, Ce.greaterThan = function (e) {
  return this.comp(e) > 0;
}, Ce.gt = Ce.greaterThan, Ce.greaterThanOrEqual = function (e) {
  return this.comp(e) >= 0;
}, Ce.gte = Ce.greaterThanOrEqual, Ce.ge = Ce.greaterThanOrEqual, Ce.compare = function (e) {
  if (ae(e) || (e = pe(e)), this.eq(e)) return 0;
  var t = this.isNegative(),
      n = e.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
}, Ce.comp = Ce.compare, Ce.negate = function () {
  return !this.unsigned && this.eq(Ne) ? Ne : this.not().add(ke);
}, Ce.neg = Ce.negate, Ce.add = function (e) {
  ae(e) || (e = pe(e));
  var t = 0,
      n = 0,
      s = 0,
      r = 0;
  return s += (r += (65535 & this.low) + (65535 & e.low)) >>> 16, n += (s += (this.low >>> 16) + (e.low >>> 16)) >>> 16, t += (n += (65535 & this.high) + (65535 & e.high)) >>> 16, t += (this.high >>> 16) + (e.high >>> 16), ce((s &= 65535) << 16 | (r &= 65535), (t &= 65535) << 16 | (n &= 65535), this.unsigned);
}, Ce.subtract = function (e) {
  return ae(e) || (e = pe(e)), this.add(e.neg());
}, Ce.sub = Ce.subtract, Ce.multiply = function (e) {
  if (this.isZero()) return xe;
  if (ae(e) || (e = pe(e)), se) return ce(se.mul(this.low, this.high, e.low, e.high), se.get_high(), this.unsigned);
  if (e.isZero()) return xe;
  if (this.eq(Ne)) return e.isOdd() ? Ne : xe;
  if (e.eq(Ne)) return this.isOdd() ? Ne : xe;
  if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(be) && e.lt(be)) return ue(this.toNumber() * e.toNumber(), this.unsigned);
  var t = 65535 & this.high,
      n = this.low >>> 16,
      s = 65535 & this.low,
      r = 65535 & e.high,
      a = e.low >>> 16,
      i = 65535 & e.low,
      o = 0,
      l = 0,
      u = 0,
      c = 0;
  return u += (c += s * i) >>> 16, l += (u += n * i) >>> 16, u &= 65535, l += (u += s * a) >>> 16, o += (l += t * i) >>> 16, l &= 65535, o += (l += n * a) >>> 16, l &= 65535, o += (l += s * r) >>> 16, o += (this.high >>> 16) * i + t * a + n * r + s * (e.high >>> 16), ce((u &= 65535) << 16 | (c &= 65535), (o &= 65535) << 16 | (l &= 65535), this.unsigned);
}, Ce.mul = Ce.multiply, Ce.divide = function (e) {
  if (ae(e) || (e = pe(e)), e.isZero()) throw Error("division by zero");
  var t, n, s;
  if (se) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? ce((this.unsigned ? se.div_u : se.div_s)(this.low, this.high, e.low, e.high), se.get_high(), this.unsigned) : this;
  if (this.isZero()) return this.unsigned ? ye : xe;

  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return ye;
    if (e.gt(this.shru(1))) return we;
    s = ye;
  } else {
    if (this.eq(Ne)) return e.eq(ke) || e.eq(ve) ? Ne : e.eq(Ne) ? ke : (t = this.shr(1).div(e).shl(1)).eq(xe) ? e.isNegative() ? ke : ve : (n = this.sub(e.mul(t)), s = t.add(n.div(e)));
    if (e.eq(Ne)) return this.unsigned ? ye : xe;
    if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = xe;
  }

  for (n = this; n.gte(e);) {
    t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));

    for (var r = Math.ceil(Math.log(t) / Math.LN2), a = r <= 48 ? 1 : he(2, r - 48), i = ue(t), o = i.mul(e); o.isNegative() || o.gt(n);) {
      o = (i = ue(t -= a, this.unsigned)).mul(e);
    }

    i.isZero() && (i = ke), s = s.add(i), n = n.sub(o);
  }

  return s;
}, Ce.div = Ce.divide, Ce.modulo = function (e) {
  return ae(e) || (e = pe(e)), se ? ce((this.unsigned ? se.rem_u : se.rem_s)(this.low, this.high, e.low, e.high), se.get_high(), this.unsigned) : this.sub(this.div(e).mul(e));
}, Ce.mod = Ce.modulo, Ce.rem = Ce.modulo, Ce.not = function () {
  return ce(~this.low, ~this.high, this.unsigned);
}, Ce.and = function (e) {
  return ae(e) || (e = pe(e)), ce(this.low & e.low, this.high & e.high, this.unsigned);
}, Ce.or = function (e) {
  return ae(e) || (e = pe(e)), ce(this.low | e.low, this.high | e.high, this.unsigned);
}, Ce.xor = function (e) {
  return ae(e) || (e = pe(e)), ce(this.low ^ e.low, this.high ^ e.high, this.unsigned);
}, Ce.shiftLeft = function (e) {
  return ae(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? ce(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : ce(0, this.low << e - 32, this.unsigned);
}, Ce.shl = Ce.shiftLeft, Ce.shiftRight = function (e) {
  return ae(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? ce(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : ce(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
}, Ce.shr = Ce.shiftRight, Ce.shiftRightUnsigned = function (e) {
  if (ae(e) && (e = e.toInt()), 0 == (e &= 63)) return this;
  var t = this.high;
  return e < 32 ? ce(this.low >>> e | t << 32 - e, t >>> e, this.unsigned) : ce(32 === e ? t : t >>> e - 32, 0, this.unsigned);
}, Ce.shru = Ce.shiftRightUnsigned, Ce.shr_u = Ce.shiftRightUnsigned, Ce.toSigned = function () {
  return this.unsigned ? ce(this.low, this.high, !1) : this;
}, Ce.toUnsigned = function () {
  return this.unsigned ? this : ce(this.low, this.high, !0);
}, Ce.toBytes = function (e) {
  return e ? this.toBytesLE() : this.toBytesBE();
}, Ce.toBytesLE = function () {
  var e = this.high,
      t = this.low;
  return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
}, Ce.toBytesBE = function () {
  var e = this.high,
      t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t];
}, re.fromBytes = function (e, t, n) {
  return n ? re.fromBytesLE(e, t) : re.fromBytesBE(e, t);
}, re.fromBytesLE = function (e, t) {
  return new re(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
}, re.fromBytesBE = function (e, t) {
  return new re(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
var Se = ne;
var Te = Se || Object.assign(Object.create(null), ne, {
  default: Se
});

function Ee(e) {
  return Te.fromString(e, !0, 16);
}

var Re = Ee("c3a5c85c97cb3127"),
    Ae = Ee("b492b66fbe98f273"),
    Fe = Ee("9ae16a3b2f90404f");

function De(e) {
  return e.xor(e.shru(47));
}

function _e(e, t, n) {
  var s = e.slice(t, t + n);
  return Te.fromBytes(Array.from(s), !0, !0);
}

function Oe(e, t) {
  return _e(e, t, 8);
}

function Me(e, t) {
  return _e(e, t, 4);
}

function Le(e, t) {
  return 0 === t ? e : e.shru(t).or(e.shl(64 - t));
}

function ze(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Ee("9ddfea08eb382d69");
  var s = e.xor(t).mul(n);
  s = s.xor(s.shru(47));
  var r = t.xor(s).mul(n);
  return r = r.xor(r.shru(47)), r = r.mul(n), r;
}

function Be(e, t, n, s) {
  return function (e, t, n, s, r, a) {
    r = r.add(e), a = Le(a.add(r).add(s), 21);
    var i = r;
    return r = (r = r.add(t)).add(n), a = a.add(Le(r, 44)), [r.add(s), a.add(i)];
  }(Oe(e, t), Oe(e, t + 8), Oe(e, t + 16), Oe(e, t + 24), n, s);
}

function Pe(e) {
  var _ref2;

  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
  var n = Te.fromNumber(81, !0);
  if (t <= 32) return t <= 16 ? function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;

    if (t >= 8) {
      var _n7 = Fe.add(2 * t),
          _s6 = Oe(e, 0).add(Fe),
          _r4 = Oe(e, t - 8);

      return ze(Le(_r4, 37).mul(_n7).add(_s6), Le(_s6, 25).add(_r4).mul(_n7), _n7);
    }

    if (t >= 4) {
      var _n8 = Fe.add(2 * t);

      return ze(Me(e, 0).shl(3).add(t), Me(e, t - 4), _n8);
    }

    if (t > 0) {
      var _n9 = t + (e[t - 1] << 2);

      return De(Fe.mul(e[0] + (e[t >> 1] << 8)).xor(Re.mul(_n9))).mul(Fe);
    }

    return Fe;
  }(e, t) : function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
    var n = Fe.add(2 * t),
        s = Oe(e, 0).mul(Ae),
        r = Oe(e, 8),
        a = Oe(e, t - 8).mul(n),
        i = Oe(e, t - 16).mul(Fe);
    return ze(Le(s.add(r), 43).add(Le(a, 30)).add(i), s.add(Le(r.add(Fe), 18)).add(a), n);
  }(e, t);
  if (t <= 64) return function (e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.length;
    var n = Fe.add(2 * t),
        s = Oe(e, 0).mul(Fe),
        r = Oe(e, 8),
        a = Oe(e, t - 8).mul(n),
        i = Oe(e, t - 16).mul(Fe),
        o = Le(s.add(r), 43).add(Le(a, 30)).add(i),
        l = ze(o, s.add(Le(r.add(Fe), 18)).add(a), n),
        u = Oe(e, 16).mul(n),
        c = Oe(e, 24),
        h = o.add(Oe(e, t - 32)).mul(n),
        d = l.add(Oe(e, t - 24)).mul(n);
    return ze(Le(u.add(c), 43).add(Le(h, 30)).add(d), u.add(Le(c.add(s), 18)).add(h), n);
  }(e, t);
  var s = n,
      r = n.mul(Ae).add(113),
      a = De(r.mul(Fe).add(113)).mul(Fe),
      i = [Te.UZERO, Te.UZERO],
      o = [Te.UZERO, Te.UZERO];
  s = s.mul(Fe).add(Oe(e, 0));
  var l = 0;
  var u = 64 * (t - 1 >> 6),
      c = u + (t - 1 & 63) - 63;

  do {
    var _ref;

    s = Le(s.add(r).add(i[0]).add(Oe(e, l + 8)), 37).mul(Ae), r = Le(r.add(i[1]).add(Oe(e, l + 48)), 42).mul(Ae), s = s.xor(o[1]), r = r.add(i[0]).add(Oe(e, l + 40)), a = Le(a.add(o[0]), 33).mul(Ae), i = Be(e, l, i[1].mul(Ae), s.add(o[0])), o = Be(e, l + 32, a.add(o[1]), r.add(Oe(e, l + 16))), (_ref = [s, a], a = _ref[0], s = _ref[1], _ref), l += 64;
  } while (l !== u);

  var h = Ae.add(a.and(255).shl(1));
  return l = c, o[0] = o[0].add(t - 1 & 63), i[0] = i[0].add(o[0]), o[0] = o[0].add(i[0]), s = Le(s.add(r).add(i[0]).add(Oe(e, l + 8)), 37).mul(h), r = Le(r.add(i[1]).add(Oe(e, l + 48)), 42).mul(h), s = s.xor(o[1].mul(9)), r = r.add(i[0].mul(9).add(Oe(e, l + 40))), a = Le(a.add(o[0]), 33).mul(h), i = Be(e, l, i[1].mul(h), s.add(o[0])), o = Be(e, l + 32, a.add(o[1]), r.add(Oe(e, l + 16))), (_ref2 = [s, a], a = _ref2[0], s = _ref2[1], _ref2), ze(ze(i[0], o[0], h).add(De(r).mul(Re)).add(a), ze(i[1], o[1], h).add(s), h);
}

function We(e, t) {
  return "string" === t ? Ge(e) : Ue([e], t);
}

function Ue(e, t) {
  if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(e) && (e = h(e)), V().getBool("DEBUG") && function (e, t) {
    for (var _n10 = 0; _n10 < e.length; _n10++) {
      var _s7 = e[_n10];
      if (isNaN(_s7) || !isFinite(_s7)) throw Error("A tensor of type ".concat(t, " being uploaded contains ").concat(_s7, "."));
    }
  }(e, t), function (e, t) {
    return e instanceof Float32Array && "float32" === t || e instanceof Int32Array && "int32" === t || e instanceof Uint8Array && "bool" === t;
  }(e, t)) return e;
  if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
  if ("int32" === t) return new Int32Array(e);

  if ("bool" === t) {
    var _t11 = new Uint8Array(e.length);

    for (var _n11 = 0; _n11 < _t11.length; ++_n11) {
      0 !== Math.round(e[_n11]) && (_t11[_n11] = 1);
    }

    return _t11;
  }

  throw new Error("Unknown data type ".concat(t));
}

function Ve() {
  return V().platform.now();
}

function Ge(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf-8";
  return t = t || "utf-8", V().platform.encode(e, t);
}

function He(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf-8";
  return t = t || "utf-8", V().platform.decode(e, t);
}

var je = /*#__PURE__*/function () {
  "use strict";

  function je(e, t) {
    _classCallCheck(this, je);

    this.backendTimer = e, this.logger = t, null == t && (this.logger = new Ke());
  }

  _createClass(je, [{
    key: "profileKernel",
    value: function profileKernel(e, t, n) {
      var s;

      var r = function r() {
        s = n();
      };

      var a;
      var i = Ve();
      if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(r);else {
        r();

        var _iterator = _createForOfIteratorHelper(s),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _e4 = _step.value;

            _e4.dataSync();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        a = Promise.resolve({
          kernelMs: Ve() - i
        });
      }

      if (V().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
        var _loop = function _loop(_t12) {
          var n = s[_t12];
          n.data().then(function (t) {
            qe(t, n.dtype, e);
          });
        };

        for (var _t12 = 0; _t12 < s.length; _t12++) {
          _loop(_t12);
        }
      }

      return {
        kernelName: e,
        outputs: s,
        inputs: t,
        timeMs: a.then(function (e) {
          return e.kernelMs;
        }),
        extraInfo: a.then(function (e) {
          return null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : "";
        })
      };
    }
  }, {
    key: "logKernelProfile",
    value: function logKernelProfile(e) {
      var _this2 = this;

      var t = e.kernelName,
          n = e.outputs,
          s = e.timeMs,
          r = e.inputs,
          a = e.extraInfo;
      n.forEach(function (e) {
        Promise.all([e.data(), s, a]).then(function (n) {
          _this2.logger.logKernelProfile(t, e, n[0], n[1], r, n[2]);
        });
      });
    }
  }]);

  return je;
}();

function qe(e, t, n) {
  if ("float32" !== t) return !1;

  for (var _t13 = 0; _t13 < e.length; _t13++) {
    var _s8 = e[_t13];
    if (isNaN(_s8) || !isFinite(_s8)) return console.warn("Found ".concat(_s8, " in the result of '").concat(n, "'")), !0;
  }

  return !1;
}

var Ke = /*#__PURE__*/function () {
  "use strict";

  function Ke() {
    _classCallCheck(this, Ke);
  }

  _createClass(Ke, [{
    key: "logKernelProfile",
    value: function logKernelProfile(e, t, n, s, r, a) {
      var i = "number" == typeof s ? m("".concat(s, "ms"), 9) : s.error,
          o = m(e, 25),
          l = t.rank,
          u = t.size,
          c = m(t.shape.toString(), 14);
      var h = "";

      for (var _e5 in r) {
        var _n12 = r[_e5];

        if (null != _n12) {
          var _s9 = _n12.shape || t.shape,
              _r5 = _s9.length;

          h += "".concat(_e5, ": ").concat(_r5, "D ").concat(_r5 > 0 ? _s9 : "", " ");
        }
      }

      console.log("%c".concat(o, "\t%c").concat(i, "\t%c").concat(l, "D ").concat(c, "\t%c").concat(u, "\t%c").concat(h, "\t%c").concat(a), "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  }]);

  return Ke;
}();

function Xe(e, t, n, s) {
  var r = A(t),
      a = function (e, t, n, s) {
    var r = d(t),
        a = s[s.length - 1],
        i = new Array(a).fill(0),
        o = t.length,
        l = "complex64" === n ? Qe(e) : e;
    if (o > 1) for (var _e6 = 0; _e6 < r / a; _e6++) {
      var _t14 = _e6 * a;

      for (var _e7 = 0; _e7 < a; _e7++) {
        i[_e7] = Math.max(i[_e7], Ye(l[_t14 + _e7], 0, n).length);
      }
    }
    return i;
  }(e, t, n, r),
      i = t.length,
      o = Ze(e, t, n, r, a),
      l = ["Tensor"];

  return s && (l.push("  dtype: ".concat(n)), l.push("  rank: ".concat(i)), l.push("  shape: [".concat(t, "]")), l.push("  values:")), l.push(o.map(function (e) {
    return "    " + e;
  }).join("\n")), l.join("\n");
}

function Ye(e, t, n) {
  var s;
  return s = Array.isArray(e) ? "".concat(parseFloat(e[0].toFixed(7)), " + ").concat(parseFloat(e[1].toFixed(7)), "j") : C(e) ? "'".concat(e, "'") : "bool" === n ? Je(e) : parseFloat(e.toFixed(7)).toString(), m(s, t);
}

function Je(e) {
  return 0 === e ? "false" : "true";
}

function Ze(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !0;
  var i = "complex64" === n ? 2 : 1,
      o = t[0],
      l = t.length;
  if (0 === l) return "complex64" === n ? [Ye(Qe(e)[0], 0, n)] : "bool" === n ? [Je(e[0])] : [e[0].toString()];

  if (1 === l) {
    if (o > 20) {
      var _t15 = Array.from(e.slice(0, 3 * i)),
          _s10 = Array.from(e.slice((o - 3) * i, o * i));

      return "complex64" === n && (_t15 = Qe(_t15), _s10 = Qe(_s10)), ["[" + _t15.map(function (e, t) {
        return Ye(e, r[t], n);
      }).join(", ") + ", ..., " + _s10.map(function (e, t) {
        return Ye(e, r[o - 3 + t], n);
      }).join(", ") + "]"];
    }

    return ["[" + ("complex64" === n ? Qe(e) : Array.from(e)).map(function (e, t) {
      return Ye(e, r[t], n);
    }).join(", ") + "]"];
  }

  var u = t.slice(1),
      c = s.slice(1),
      h = s[0] * i,
      d = [];

  if (o > 20) {
    for (var _t16 = 0; _t16 < 3; _t16++) {
      var _s11 = _t16 * h;

      d.push.apply(d, _toConsumableArray(Ze(e.slice(_s11, _s11 + h), u, n, c, r, !1)));
    }

    d.push("...");

    for (var _t17 = o - 3; _t17 < o; _t17++) {
      var _s12 = _t17 * h;

      d.push.apply(d, _toConsumableArray(Ze(e.slice(_s12, _s12 + h), u, n, c, r, _t17 === o - 1)));
    }
  } else for (var _t18 = 0; _t18 < o; _t18++) {
    var _s13 = _t18 * h;

    d.push.apply(d, _toConsumableArray(Ze(e.slice(_s13, _s13 + h), u, n, c, r, _t18 === o - 1)));
  }

  var p = 2 === l ? "," : "";
  d[0] = "[" + d[0] + p;

  for (var _e8 = 1; _e8 < d.length - 1; _e8++) {
    d[_e8] = " " + d[_e8] + p;
  }

  var f = ",\n";

  for (var _e9 = 2; _e9 < l; _e9++) {
    f += "\n";
  }

  return d[d.length - 1] = " " + d[d.length - 1] + "]" + (a ? "" : f), d;
}

function Qe(e) {
  var t = [];

  for (var _n13 = 0; _n13 < e.length; _n13 += 2) {
    t.push([e[_n13], e[_n13 + 1]]);
  }

  return t;
}

var et = /*#__PURE__*/function () {
  "use strict";

  function et(e, t, n) {
    var _this3 = this;

    _classCallCheck(this, et);

    if (this.dtype = t, this.shape = e.slice(), this.size = d(e), null != n) {
      var _e10 = n.length;
      l(_e10 === this.size, function () {
        return "Length of values '".concat(_e10, "' does not match the size inferred by the shape '").concat(_this3.size, "'.");
      });
    }

    if ("complex64" === t) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n || v(t, this.size), this.strides = A(e);
  }

  _createClass(et, [{
    key: "set",
    value: function set(e) {
      var _this4 = this;

      for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        t[_key2 - 1] = arguments[_key2];
      }

      0 === t.length && (t = [0]), l(t.length === this.rank, function () {
        return "The number of provided coordinates (".concat(t.length, ") must match the rank (").concat(_this4.rank, ")");
      });
      var n = this.locToIndex(t);
      this.values[n] = e;
    }
  }, {
    key: "get",
    value: function get() {
      for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        e[_key3] = arguments[_key3];
      }

      0 === e.length && (e = [0]);
      var t = 0;

      for (var _i4 = 0, _e11 = e; _i4 < _e11.length; _i4++) {
        var _n14 = _e11[_i4];
        if (_n14 < 0 || _n14 >= this.shape[t]) throw new Error("Requested out of range element at ".concat(e, ".   Buffer shape=").concat(this.shape));
        t++;
      }

      var n = e[e.length - 1];

      for (var _t19 = 0; _t19 < e.length - 1; ++_t19) {
        n += this.strides[_t19] * e[_t19];
      }

      return this.values[n];
    }
  }, {
    key: "locToIndex",
    value: function locToIndex(e) {
      if (0 === this.rank) return 0;
      if (1 === this.rank) return e[0];
      var t = e[e.length - 1];

      for (var _n15 = 0; _n15 < e.length - 1; ++_n15) {
        t += this.strides[_n15] * e[_n15];
      }

      return t;
    }
  }, {
    key: "indexToLoc",
    value: function indexToLoc(e) {
      if (0 === this.rank) return [];
      if (1 === this.rank) return [e];
      var t = new Array(this.shape.length);

      for (var _n16 = 0; _n16 < t.length - 1; ++_n16) {
        t[_n16] = Math.floor(e / this.strides[_n16]), e -= t[_n16] * this.strides[_n16];
      }

      return t[t.length - 1] = e, t;
    }
  }, {
    key: "rank",
    get: function get() {
      return this.shape.length;
    }
  }, {
    key: "toTensor",
    value: function toTensor() {
      return tt().makeTensor(this.values, this.shape, this.dtype);
    }
  }]);

  return et;
}();

var tt = null,
    nt = null;

var st = /*#__PURE__*/function () {
  "use strict";

  function st(e, t, n, s) {
    _classCallCheck(this, st);

    this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", this.size = d(e), this.strides = A(e), this.dataId = n, this.id = s, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }

  _createClass(st, [{
    key: "rank",
    get: function get() {
      return this.shape.length;
    }
  }, {
    key: "buffer",
    value: function () {
      var _buffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var e;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.data();

              case 2:
                e = _context2.sent;
                return _context2.abrupt("return", nt.buffer(this.shape, this.dtype, e));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function buffer() {
        return _buffer.apply(this, arguments);
      }

      return buffer;
    }()
  }, {
    key: "bufferSync",
    value: function bufferSync() {
      return nt.buffer(this.shape, this.dtype, this.dataSync());
    }
  }, {
    key: "array",
    value: function () {
      var _array = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var e;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.data();

              case 2:
                e = _context3.sent;
                return _context3.abrupt("return", D(this.shape, e, "complex64" === this.dtype));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function array() {
        return _array.apply(this, arguments);
      }

      return array;
    }()
  }, {
    key: "arraySync",
    value: function arraySync() {
      return D(this.shape, this.dataSync(), "complex64" === this.dtype);
    }
  }, {
    key: "data",
    value: function () {
      var _data = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var e, _t20;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.throwIfDisposed();
                e = tt().read(this.dataId);

                if (!("string" === this.dtype)) {
                  _context4.next = 13;
                  break;
                }

                _context4.next = 5;
                return e;

              case 5:
                _t20 = _context4.sent;
                _context4.prev = 6;
                return _context4.abrupt("return", _t20.map(function (e) {
                  return He(e);
                }));

              case 10:
                _context4.prev = 10;
                _context4.t0 = _context4["catch"](6);
                throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");

              case 13:
                return _context4.abrupt("return", e);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[6, 10]]);
      }));

      function data() {
        return _data.apply(this, arguments);
      }

      return data;
    }()
  }, {
    key: "dataSync",
    value: function dataSync() {
      this.throwIfDisposed();
      var e = tt().readSync(this.dataId);
      if ("string" === this.dtype) try {
        return e.map(function (e) {
          return He(e);
        });
      } catch (e) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
      return e;
    }
  }, {
    key: "bytes",
    value: function () {
      var _bytes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var e;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.throwIfDisposed();
                _context5.next = 3;
                return tt().read(this.dataId);

              case 3:
                e = _context5.sent;
                return _context5.abrupt("return", "string" === this.dtype ? e : new Uint8Array(e.buffer));

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function bytes() {
        return _bytes.apply(this, arguments);
      }

      return bytes;
    }()
  }, {
    key: "dispose",
    value: function dispose() {
      this.isDisposed || (tt().disposeTensor(this), this.isDisposedInternal = !0);
    }
  }, {
    key: "isDisposed",
    get: function get() {
      return this.isDisposedInternal;
    }
  }, {
    key: "throwIfDisposed",
    value: function throwIfDisposed() {
      if (this.isDisposed) throw new Error("Tensor is disposed.");
    }
  }, {
    key: "print",
    value: function print() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
      return nt.print(this, e);
    }
  }, {
    key: "clone",
    value: function clone() {
      return this.throwIfDisposed(), nt.clone(this);
    }
  }, {
    key: "toString",
    value: function toString() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
      return Xe(this.dataSync(), this.shape, this.dtype, e);
    }
  }, {
    key: "cast",
    value: function cast(e) {
      return this.throwIfDisposed(), nt.cast(this, e);
    }
  }, {
    key: "variable",
    value: function variable() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var n = arguments.length > 2 ? arguments[2] : undefined;
      return this.throwIfDisposed(), tt().makeVariable(this, e, t, n);
    }
  }]);

  return st;
}();

function rt() {
  return q("Tensor", function () {
    return st;
  });
}

Object.defineProperty(st, Symbol.hasInstance, {
  value: function value(e) {
    return !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed;
  }
}), rt();

var at = /*#__PURE__*/function (_st) {
  "use strict";

  _inherits(at, _st);

  var _super = _createSuper(at);

  function at(e, t, n, s) {
    var _this5;

    _classCallCheck(this, at);

    _this5 = _super.call(this, e.shape, e.dtype, e.dataId, s), _this5.trainable = t, _this5.name = n;
    return _this5;
  }

  _createClass(at, [{
    key: "assign",
    value: function assign(e) {
      if (e.dtype !== this.dtype) throw new Error("dtype of the new value (".concat(e.dtype, ") and previous value (").concat(this.dtype, ") must match"));
      if (!p(e.shape, this.shape)) throw new Error("shape of the new value (".concat(e.shape, ") and previous value (").concat(this.shape, ") must match"));
      tt().disposeTensor(this), this.dataId = e.dataId, tt().incRef(this, null);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      tt().disposeVariable(this), this.isDisposedInternal = !0;
    }
  }]);

  return at;
}(st);

var it, ot, lt, ut, ct;
Object.defineProperty(at, Symbol.hasInstance, {
  value: function value(e) {
    return e instanceof st && null != e.assign && e.assign instanceof Function;
  }
}), function (e) {
  e.R0 = "R0", e.R1 = "R1", e.R2 = "R2", e.R3 = "R3", e.R4 = "R4", e.R5 = "R5", e.R6 = "R6";
}(it || (it = {})), function (e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64";
}(ot || (ot = {})), function (e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64";
}(lt || (lt = {})), function (e) {
  e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64";
}(ut || (ut = {})), function (e) {
  e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64";
}(ct || (ct = {}));
var ht = {
  float32: ut,
  int32: ot,
  bool: lt,
  complex64: ct
};

function dt(e, t) {
  if ("string" === e || "string" === t) {
    if ("string" === e && "string" === t) return "string";
    throw new Error("Can not upcast ".concat(e, " with ").concat(t));
  }

  return ht[e][t];
}

function pt(e) {
  return dt(e, "int32");
}

function ft(e, t) {
  if (e.dtype === t.dtype) return [e, t];
  var n = dt(e.dtype, t.dtype);
  return [e.cast(n), t.cast(n)];
}

function gt(e) {
  var t = [];
  return mt(e, t, new Set()), t;
}

function mt(e, t, n) {
  if (null == e) return;
  if (e instanceof st) return void t.push(e);
  if (s = e, !Array.isArray(s) && "object" != typeof s) return;
  var s;
  var r = e;

  for (var _e12 in r) {
    var _s14 = r[_e12];
    n.has(_s14) || (n.add(_s14), mt(_s14, t, n));
  }
}

function bt(e) {
  return null != e.kernelName;
}

var xt = /*#__PURE__*/function () {
  "use strict";

  function xt() {
    _classCallCheck(this, xt);

    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,

      get kernelNames() {
        return Array.from(new Set(this.kernels.map(function (e) {
          return e.name;
        })));
      }

    };
  }

  _createClass(xt, [{
    key: "dispose",
    value: function dispose() {
      for (var _e13 in this.registeredVariables) {
        this.registeredVariables[_e13].dispose();
      }
    }
  }]);

  return xt;
}();

var yt = /*#__PURE__*/function () {
  "use strict";

  function yt(e) {
    _classCallCheck(this, yt);

    this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new xt();
  }

  _createClass(yt, [{
    key: "ready",
    value: function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var e, _t21, _n17;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(null != this.pendingBackendInit)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return", this.pendingBackendInit.then(function () {}));

              case 2:
                if (!(null != this.backendInstance)) {
                  _context6.next = 4;
                  break;
                }

                return _context6.abrupt("return");

              case 4:
                e = this.getSortedBackends();
                _t21 = 0;

              case 6:
                if (!(_t21 < e.length)) {
                  _context6.next = 17;
                  break;
                }

                _n17 = e[_t21];
                _context6.next = 10;
                return this.initializeBackend(_n17).success;

              case 10:
                if (!_context6.sent) {
                  _context6.next = 14;
                  break;
                }

                _context6.next = 13;
                return this.setBackend(_n17);

              case 13:
                return _context6.abrupt("return", void _context6.sent);

              case 14:
                _t21++;
                _context6.next = 6;
                break;

              case 17:
                throw new Error("Could not initialize any backends, all backend initializations failed.");

              case 18:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function ready() {
        return _ready.apply(this, arguments);
      }

      return ready;
    }()
  }, {
    key: "backend",
    get: function get() {
      if (null != this.pendingBackendInit) throw new Error("Backend '".concat(this.backendName, "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));

      if (null == this.backendInstance) {
        var _this$initializeBacke = this.initializeBackendsAndReturnBest(),
            _e14 = _this$initializeBacke.name,
            _t22 = _this$initializeBacke.asyncInit;

        if (_t22) throw new Error("The highest priority backend '".concat(_e14, "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods"));
        this.setBackend(_e14);
      }

      return this.backendInstance;
    }
  }, {
    key: "backendNames",
    value: function backendNames() {
      return Object.keys(this.registryFactory);
    }
  }, {
    key: "findBackend",
    value: function findBackend(e) {
      if (!(e in this.registry)) {
        if (!(e in this.registryFactory)) return null;
        {
          var _this$initializeBacke2 = this.initializeBackend(e),
              _t23 = _this$initializeBacke2.asyncInit;

          if (_t23) return null;
        }
      }

      return this.registry[e];
    }
  }, {
    key: "findBackendFactory",
    value: function findBackendFactory(e) {
      return e in this.registryFactory ? this.registryFactory[e].factory : null;
    }
  }, {
    key: "registerBackend",
    value: function registerBackend(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return e in this.registryFactory ? (console.warn("".concat(e, " backend was already registered. Reusing existing backend factory.")), !1) : (this.registryFactory[e] = {
        factory: t,
        priority: n
      }, !0);
    }
  }, {
    key: "setBackend",
    value: function () {
      var _setBackend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(e) {
        var _this$initializeBacke3, _t24, _n18;

        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(null == this.registryFactory[e])) {
                  _context7.next = 2;
                  break;
                }

                throw new Error("Backend name '".concat(e, "' not found in registry"));

              case 2:
                if (!(this.backendName = e, null == this.registry[e])) {
                  _context7.next = 14;
                  break;
                }

                this.backendInstance = null;
                _this$initializeBacke3 = this.initializeBackend(e), _t24 = _this$initializeBacke3.success, _n18 = _this$initializeBacke3.asyncInit;

                if (!_n18) {
                  _context7.next = 11;
                  break;
                }

                _context7.next = 8;
                return _t24;

              case 8:
                _context7.t0 = _context7.sent;
                _context7.next = 12;
                break;

              case 11:
                _context7.t0 = _t24;

              case 12:
                if (_context7.t0) {
                  _context7.next = 14;
                  break;
                }

                return _context7.abrupt("return", !1);

              case 14:
                return _context7.abrupt("return", (this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new je(this.backendInstance), !0));

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function setBackend(_x3) {
        return _setBackend.apply(this, arguments);
      }

      return setBackend;
    }()
  }, {
    key: "setupRegisteredKernels",
    value: function setupRegisteredKernels() {
      var _this6 = this;

      Z(this.backendName).forEach(function (e) {
        null != e.setupFunc && e.setupFunc(_this6.backendInstance);
      });
    }
  }, {
    key: "disposeRegisteredKernels",
    value: function disposeRegisteredKernels(e) {
      var _this7 = this;

      Z(e).forEach(function (t) {
        null != t.disposeFunc && t.disposeFunc(_this7.registry[e]);
      });
    }
  }, {
    key: "initializeBackend",
    value: function initializeBackend(e) {
      var _this8 = this;

      var t = this.registryFactory[e];
      if (null == t) throw new Error("Cannot initialize backend ".concat(e, ", no registration found."));

      try {
        var _s15 = t.factory();

        if (!_s15 || _s15 instanceof n || "function" != typeof _s15.then) return this.registry[e] = _s15, {
          success: !0,
          asyncInit: !1
        };
        {
          var _t25 = ++this.pendingBackendInitId,
              _n19 = _s15.then(function (n) {
            return !(_t25 < _this8.pendingBackendInitId || (_this8.registry[e] = n, _this8.pendingBackendInit = null, 0));
          }).catch(function (n) {
            return _t25 < _this8.pendingBackendInitId || (_this8.pendingBackendInit = null, console.warn("Initialization of backend ".concat(e, " failed")), console.warn(n.stack || n.message)), !1;
          });

          return this.pendingBackendInit = _n19, {
            success: _n19,
            asyncInit: !0
          };
        }
      } catch (t) {
        return console.warn("Initialization of backend ".concat(e, " failed")), console.warn(t.stack || t.message), {
          success: !1,
          asyncInit: !1
        };
      }
    }
  }, {
    key: "removeBackend",
    value: function removeBackend(e) {
      if (!(e in this.registryFactory)) throw new Error("".concat(e, " backend not found in registry"));
      this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }
  }, {
    key: "getSortedBackends",
    value: function getSortedBackends() {
      var _this9 = this;

      if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
      return Object.keys(this.registryFactory).sort(function (e, t) {
        return _this9.registryFactory[t].priority - _this9.registryFactory[e].priority;
      });
    }
  }, {
    key: "initializeBackendsAndReturnBest",
    value: function initializeBackendsAndReturnBest() {
      var e = this.getSortedBackends();

      for (var _t26 = 0; _t26 < e.length; _t26++) {
        var _n20 = e[_t26],
            _this$initializeBacke4 = this.initializeBackend(_n20),
            _s16 = _this$initializeBacke4.success,
            _r6 = _this$initializeBacke4.asyncInit;

        if (_r6 || _s16) return {
          name: _n20,
          asyncInit: _r6
        };
      }

      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
  }, {
    key: "moveData",
    value: function moveData(e, t) {
      var n = this.state.tensorInfo.get(t),
          s = n.backend,
          r = this.readSync(t),
          a = s.refCount(t);
      s.disposeData(t, !0), n.backend = e, e.move(t, r, n.shape, n.dtype, a), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
  }, {
    key: "tidy",
    value: function tidy(e, t) {
      var _this10 = this;

      var n,
          s = null;

      if (null == t) {
        if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
        t = e;
      } else {
        if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        s = e;
      }

      return this.scopedRun(function () {
        return _this10.startScope(s);
      }, function () {
        return _this10.endScope(n);
      }, function () {
        return n = t(), n instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n;
      });
    }
  }, {
    key: "scopedRun",
    value: function scopedRun(e, t, n) {
      e();

      try {
        var _e15 = n();

        return t(), _e15;
      } catch (e) {
        throw t(), e;
      }
    }
  }, {
    key: "nextTensorId",
    value: function nextTensorId() {
      return yt.nextTensorId++;
    }
  }, {
    key: "nextVariableId",
    value: function nextVariableId() {
      return yt.nextVariableId++;
    }
  }, {
    key: "clone",
    value: function clone(e) {
      var t = wt.runKernel("Identity", {
        x: e
      });
      return this.addTapeNode(this.state.activeScope.name, {
        x: e
      }, [t], function (e) {
        return {
          x: function x() {
            return wt.runKernel("Cast", {
              x: e
            }, {
              dtype: "float32"
            });
          }
        };
      }, [], {}), t;
    }
  }, {
    key: "runKernel",
    value: function runKernel(e, t, n) {
      if (null == Y(e, this.backendName)) throw new Error("Kernel '".concat(e, "' not registered for backend '").concat(this.backendName, "'"));
      return this.runKernelFunc({
        kernelName: e,
        inputs: t,
        attrs: n
      });
    }
  }, {
    key: "shouldCheckForMemLeaks",
    value: function shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
  }, {
    key: "checkKernelForMemLeak",
    value: function checkKernelForMemLeak(e, t, n) {
      var s = this.backend.numDataIds();
      var r = 0;
      n.forEach(function (e) {
        r += "complex64" === e.dtype ? 3 : 1;
      });
      var a = s - t - r - this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
      if (a > 0) throw new Error("Backend '".concat(this.backendName, "' has an internal memory leak (").concat(a, " data ids) after running '").concat(e, "'"));
    }
  }, {
    key: "runKernelFunc",
    value: function runKernelFunc(e) {
      var _this11 = this;

      var t,
          n = [];
      var s = this.isTapeOn(),
          r = this.state.numBytes,
          a = this.state.numTensors;
      var i, o;
      this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
      var u = bt(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";

      if (bt(e)) {
        var _t27 = e.kernelName,
            _r7 = e.inputs,
            _a5 = e.attrs,
            _u2 = Y(_t27, this.backendName);

        l(null != _u2, function () {
          return "Cannot find registered kernel '".concat(_t27, "' for backend '").concat(_this11.backendName, "'");
        }), i = function i() {
          var e = _this11.backend.numDataIds();

          o = _u2.kernelFunc({
            inputs: _r7,
            attrs: _a5,
            backend: _this11.backend
          });
          var i = Array.isArray(o) ? o : [o];
          _this11.shouldCheckForMemLeaks() && _this11.checkKernelForMemLeak(_t27, e, i);
          var l = i.map(function (e) {
            if (null != e.rank) return e;
            var t = e.dataId,
                n = e.shape,
                s = e.dtype;
            return _this11.makeTensorFromDataId(t, n, s);
          });

          if (s) {
            var _e16 = _this11.getTensorsForGradient(_t27, _r7, l);

            n = _this11.saveTensorsForBackwardMode(_e16);
          }

          return l;
        };
      } else {
        var _t28 = e.forwardFunc,
            _r8 = function _r8(e) {
          s && (n = e.map(function (e) {
            return _this11.keep(_this11.clone(e));
          }));
        };

        i = function i() {
          var e = _this11.backend.numDataIds();

          o = _this11.tidy(function () {
            return _t28(_this11.backend, _r8);
          });
          var n = Array.isArray(o) ? o : [o];
          return _this11.shouldCheckForMemLeaks() && _this11.checkKernelForMemLeak(u, e, n), n;
        };
      }

      var c = e.inputs,
          h = e.attrs,
          d = bt(e) ? null : e.backwardsFunc;
      var p;
      return this.scopedRun(function () {
        return _this11.state.kernelDepth++;
      }, function () {
        return _this11.state.kernelDepth--;
      }, function () {
        _this11.ENV.getBool("DEBUG") || _this11.state.profiling ? (p = _this11.profiler.profileKernel(u, c, function () {
          return i();
        }), _this11.ENV.getBool("DEBUG") && _this11.profiler.logKernelProfile(p), t = p.outputs) : t = i();
      }), s && this.addTapeNode(u, c, t, d, n, h), this.state.profiling && this.state.activeProfile.kernels.push({
        name: u,
        bytesAdded: this.state.numBytes - r,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - a,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(c).map(function (e) {
          return null != c[e] ? c[e].shape : null;
        }),
        outputShapes: t.map(function (e) {
          return e.shape;
        }),
        kernelTimeMs: p.timeMs,
        extraInfo: p.extraInfo
      }), Array.isArray(o) ? t : t[0];
    }
  }, {
    key: "saveTensorsForBackwardMode",
    value: function saveTensorsForBackwardMode(e) {
      var _this12 = this;

      return e.map(function (e) {
        return _this12.keep(_this12.clone(e));
      });
    }
  }, {
    key: "getTensorsForGradient",
    value: function getTensorsForGradient(e, t, n) {
      var s = J(e);

      if (null != s) {
        var _e17 = s.inputsToSave || [],
            _r9 = s.outputsToSave || [];

        var _a6;

        s.saveAllInputs ? (l(Array.isArray(t), function () {
          return "saveAllInputs is true, expected inputs to be an array.";
        }), _a6 = Object.keys(t).map(function (e) {
          return t[e];
        })) : _a6 = _e17.map(function (e) {
          return t[e];
        });

        var _i5 = n.filter(function (e, t) {
          return _r9[t];
        });

        return _a6.concat(_i5);
      }

      return [];
    }
  }, {
    key: "makeTensor",
    value: function makeTensor(e, t, n, s) {
      if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
      s = s || this.backend;
      var r = e;
      "string" === (n = n || "float32") && C(e[0]) && (r = e.map(function (e) {
        return Ge(e);
      }));
      var a = s.write(r, t, n),
          i = new st(t, n, a, this.nextTensorId());

      if (this.trackTensor(i, s), "string" === n) {
        var _e18 = this.state.tensorInfo.get(a),
            _t29 = function (e) {
          if (null == e) return 0;
          var t = 0;
          return e.forEach(function (e) {
            return t += e.length;
          }), t;
        }(r);

        this.state.numBytes += _t29 - _e18.bytes, _e18.bytes = _t29;
      }

      return i;
    }
  }, {
    key: "makeTensorFromDataId",
    value: function makeTensorFromDataId(e, t, n, s) {
      var r = new st(t, n = n || "float32", e, this.nextTensorId());
      return this.trackTensor(r, s), r;
    }
  }, {
    key: "makeVariable",
    value: function makeVariable(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 ? arguments[2] : undefined;
      var s = arguments.length > 3 ? arguments[3] : undefined;
      n = n || this.nextVariableId().toString(), null != s && s !== e.dtype && (e = e.cast(s));
      var r = new at(e, t, n, this.nextTensorId());
      if (null != this.state.registeredVariables[r.name]) throw new Error("Variable with name ".concat(r.name, " was already registered"));
      return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r;
    }
  }, {
    key: "trackTensor",
    value: function trackTensor(e, t) {
      this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
      var n = 0;
      "complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * N(e.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
        backend: t || this.backend,
        dtype: e.dtype,
        shape: e.shape,
        bytes: n
      })), e instanceof at || this.track(e);
    }
  }, {
    key: "incRef",
    value: function incRef(e, t) {
      this.trackTensor(e, t), this.backend.incRef(e.dataId);
    }
  }, {
    key: "removeDataId",
    value: function removeDataId(e, t) {
      this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
    }
  }, {
    key: "disposeTensor",
    value: function disposeTensor(e) {
      if (!this.state.tensorInfo.has(e.dataId)) return;
      var t = this.state.tensorInfo.get(e.dataId);

      if (this.state.numTensors--, "string" === e.dtype && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), "complex64" !== e.dtype && "string" !== e.dtype) {
        var _t30 = e.size * N(e.dtype);

        this.state.numBytes -= _t30;
      }

      t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend);
    }
  }, {
    key: "disposeVariables",
    value: function disposeVariables() {
      for (var _e19 in this.state.registeredVariables) {
        this.disposeVariable(this.state.registeredVariables[_e19]);
      }
    }
  }, {
    key: "disposeVariable",
    value: function disposeVariable(e) {
      this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name];
    }
  }, {
    key: "memory",
    value: function memory() {
      var e = this.backend.memory();
      return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
    }
  }, {
    key: "profile",
    value: function () {
      var _profile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(e) {
        var t, n, _iterator2, _step2, _e20;

        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.state.profiling = !0;
                t = this.state.numBytes, n = this.state.numTensors;
                this.state.activeProfile.kernels = [];
                _context8.next = 5;
                return e();

              case 5:
                this.state.activeProfile.result = _context8.sent;
                this.state.profiling = !1;
                this.state.activeProfile.peakBytes = Math.max.apply(Math, _toConsumableArray(this.state.activeProfile.kernels.map(function (e) {
                  return e.totalBytesSnapshot;
                })));
                this.state.activeProfile.newBytes = this.state.numBytes - t;
                this.state.activeProfile.newTensors = this.state.numTensors - n;
                _iterator2 = _createForOfIteratorHelper(this.state.activeProfile.kernels);
                _context8.prev = 11;

                _iterator2.s();

              case 13:
                if ((_step2 = _iterator2.n()).done) {
                  _context8.next = 23;
                  break;
                }

                _e20 = _step2.value;
                _context8.next = 17;
                return _e20.kernelTimeMs;

              case 17:
                _e20.kernelTimeMs = _context8.sent;
                _context8.next = 20;
                return _e20.extraInfo;

              case 20:
                _e20.extraInfo = _context8.sent;

              case 21:
                _context8.next = 13;
                break;

              case 23:
                _context8.next = 28;
                break;

              case 25:
                _context8.prev = 25;
                _context8.t0 = _context8["catch"](11);

                _iterator2.e(_context8.t0);

              case 28:
                _context8.prev = 28;

                _iterator2.f();

                return _context8.finish(28);

              case 31:
                return _context8.abrupt("return", this.state.activeProfile);

              case 32:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[11, 25, 28, 31]]);
      }));

      function profile(_x4) {
        return _profile.apply(this, arguments);
      }

      return profile;
    }()
  }, {
    key: "isTapeOn",
    value: function isTapeOn() {
      return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
    }
  }, {
    key: "addTapeNode",
    value: function addTapeNode(e, t, n, s, r, a) {
      var _this13 = this;

      var i = {
        id: this.state.nextTapeNodeId++,
        kernelName: e,
        inputs: t,
        outputs: n,
        saved: r
      },
          o = J(e);
      null != o && (s = o.gradFunc), null != s && (i.gradient = function (e) {
        return e = e.map(function (e, t) {
          if (null == e) {
            var _e21 = n[t],
                _s17 = O(_e21.size, _e21.dtype);

            return _this13.makeTensor(_s17, _e21.shape, _e21.dtype);
          }

          return e;
        }), s(e.length > 1 ? e : e[0], r, a);
      }), this.state.activeTape.push(i);
    }
  }, {
    key: "keep",
    value: function keep(e) {
      return e.kept = !0, e;
    }
  }, {
    key: "startTape",
    value: function startTape() {
      0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
    }
  }, {
    key: "endTape",
    value: function endTape() {
      this.state.gradientDepth--;
    }
  }, {
    key: "startScope",
    value: function startScope(e) {
      var t = {
        track: [],
        name: "unnamed scope",
        id: this.state.nextScopeId++
      };
      e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t;
    }
  }, {
    key: "endScope",
    value: function endScope(e) {
      var _this14 = this;

      var t = gt(e),
          n = new Set(t.map(function (e) {
        return e.id;
      }));

      for (var _e22 = 0; _e22 < this.state.activeScope.track.length; _e22++) {
        var _t31 = this.state.activeScope.track[_e22];
        _t31.kept || n.has(_t31.id) || _t31.dispose();
      }

      var s = this.state.scopeStack.pop();
      this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach(function (e) {
        e.kept || e.scopeId !== s.id || _this14.track(e);
      });
    }
  }, {
    key: "gradients",
    value: function gradients(e, t, n) {
      var _this15 = this;

      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      if (l(t.length > 0, function () {
        return "gradients() received an empty list of xs.";
      }), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype, "'"));
      var r = this.scopedRun(function () {
        return _this15.startTape();
      }, function () {
        return _this15.endTape();
      }, function () {
        return _this15.tidy("forward", e);
      });
      l(r instanceof st, function () {
        return "The result y returned by f() must be a tensor.";
      });

      var a = function (e, t, n) {
        var s = {},
            r = {};

        for (var _e23 = 0; _e23 < t.length; _e23++) {
          s[t[_e23].id] = !0;
        }

        for (var _n21 = 0; _n21 < e.length; _n21++) {
          var _a7 = e[_n21],
              _i6 = _a7.inputs;

          for (var _e24 in _i6) {
            var _n22 = _i6[_e24];

            var _o4 = !1;

            for (var _e25 = 0; _e25 < t.length; _e25++) {
              if (s[_n22.id]) {
                _a7.outputs.forEach(function (e) {
                  return s[e.id] = !0;
                }), _o4 = !0, r[_a7.id] = !0;
                break;
              }
            }

            if (_o4) break;
          }
        }

        var a = {};
        a[n.id] = !0;
        var i = {};

        for (var _t32 = e.length - 1; _t32 >= 0; _t32--) {
          var _n23 = e[_t32],
              _s18 = _n23.inputs;

          for (var _e26 = 0; _e26 < _n23.outputs.length; _e26++) {
            if (a[_n23.outputs[_e26].id]) {
              for (var _e27 in _s18) {
                a[_s18[_e27].id] = !0, i[_n23.id] = !0;
              }

              break;
            }
          }
        }

        var o = [];

        for (var _t33 = 0; _t33 < e.length; _t33++) {
          var _n24 = e[_t33];

          if (r[_n24.id] && i[_n24.id]) {
            var _e28 = {};

            for (var _t35 in _n24.inputs) {
              var _r10 = _n24.inputs[_t35];
              s[_r10.id] && (_e28[_t35] = _r10);
            }

            var _t34 = Object.assign({}, _n24);

            _t34.inputs = _e28, _t34.outputs = _n24.outputs, o.push(_t34);
          }
        }

        return o;
      }(this.state.activeTape, t, r);

      if (!s && 0 === a.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      return this.tidy("backward", function () {
        var e = {};
        e[r.id] = null == n ? function (e) {
          var t = _(d(e), "float32");

          return wt.makeTensor(t, e, "float32");
        }(r.shape) : n, function (e, t, n, s) {
          var _loop2 = function _loop2(_r11) {
            var a = t[_r11],
                i = [];
            if (a.outputs.forEach(function (t) {
              var n = e[t.id];
              i.push(null != n ? n : null);
            }), null == a.gradient) throw new Error("Cannot compute gradient: gradient function not found for ".concat(a.kernelName, "."));
            var o = a.gradient(i);

            var _loop3 = function _loop3(_t36) {
              if (!(_t36 in o)) throw new Error("Cannot backprop through input ".concat(_t36, ". Available gradients found: ").concat(Object.keys(o), "."));
              var r = n(function () {
                return o[_t36]();
              });
              if ("float32" !== r.dtype) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input ").concat(_t36, " must have 'float32' dtype, but has '").concat(r.dtype, "'"));
              var i = a.inputs[_t36];
              if (!p(r.shape, i.shape)) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input '").concat(_t36, "' has shape '").concat(r.shape, "', which does not match the shape of the input '").concat(i.shape, "'"));
              if (null == e[i.id]) e[i.id] = r;else {
                var _t37 = e[i.id];
                e[i.id] = s(_t37, r), _t37.dispose();
              }
            };

            for (var _t36 in a.inputs) {
              _loop3(_t36);
            }
          };

          for (var _r11 = t.length - 1; _r11 >= 0; _r11--) {
            _loop2(_r11);
          }
        }(e, a, function (e) {
          return _this15.tidy(e);
        }, vt);
        var s = t.map(function (t) {
          return e[t.id];
        });
        return 0 === _this15.state.gradientDepth && (_this15.state.activeTape.forEach(function (e) {
          var _iterator3 = _createForOfIteratorHelper(e.saved),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _t38 = _step3.value;

              _t38.dispose();
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }), _this15.state.activeTape = null), {
          value: r,
          grads: s
        };
      });
    }
  }, {
    key: "customGrad",
    value: function customGrad(e) {
      var _this16 = this;

      return l(E(e), function () {
        return "The f passed in customGrad(f) must be a function.";
      }), function () {
        for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          t[_key4] = arguments[_key4];
        }

        var n;
        l(t.every(function (e) {
          return e instanceof st;
        }), function () {
          return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
        });
        var s = {};
        return t.forEach(function (e, t) {
          s[t] = e;
        }), _this16.runKernelFunc({
          forwardFunc: function forwardFunc(s, r) {
            return n = e.apply(void 0, t.concat([r])), l(n.value instanceof st, function () {
              return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
            }), l(E(n.gradFunc), function () {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
            }), n.value;
          },
          backwardsFunc: function backwardsFunc(e, s) {
            var r = n.gradFunc(e, s),
                a = Array.isArray(r) ? r : [r];
            l(a.length === t.length, function () {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
            }), l(a.every(function (e) {
              return e instanceof st;
            }), function () {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
            });
            var i = {};
            return a.forEach(function (e, t) {
              i[t] = function () {
                return e;
              };
            }), i;
          },
          inputs: s
        });
      };
    }
  }, {
    key: "readSync",
    value: function readSync(e) {
      return this.state.tensorInfo.get(e).backend.readSync(e);
    }
  }, {
    key: "read",
    value: function read(e) {
      return this.state.tensorInfo.get(e).backend.read(e);
    }
  }, {
    key: "time",
    value: function () {
      var _time = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(e) {
        var t, n;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                t = Ve();
                _context9.next = 3;
                return this.backend.time(e);

              case 3:
                n = _context9.sent;
                return _context9.abrupt("return", (n.wallMs = Ve() - t, n));

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function time(_x5) {
        return _time.apply(this, arguments);
      }

      return time;
    }()
  }, {
    key: "track",
    value: function track(e) {
      return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
    }
  }, {
    key: "registeredVariables",
    get: function get() {
      return this.state.registeredVariables;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new xt();

      for (var _e29 in this.registry) {
        this.disposeRegisteredKernels(_e29), this.registry[_e29].dispose(), delete this.registry[_e29];
      }

      this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }
  }]);

  return yt;
}();

function kt() {
  var e = j();

  if (null == e._tfengine) {
    var _t39 = new W(e);

    e._tfengine = new yt(_t39);
  }

  return H = e._tfengine.ENV, tt = function tt() {
    return e._tfengine;
  }, e._tfengine;
}

yt.nextTensorId = 0, yt.nextVariableId = 0;
var wt = kt();

function vt(e, t) {
  return wt.runKernel("Add", {
    a: e,
    b: t
  });
}

function It(e) {
  if (e || "undefined" != typeof navigator && null != navigator) {
    if (e || (e = navigator), "ReactNative" === e.product) return !0;

    var _t40 = e.userAgent || e.vendor || window.opera;

    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(_t40) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(_t40.substr(0, 4));
  }

  return !1;
}

function $t() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}

var Nt = V();

function Ct(e, t) {
  var n = e;
  if ($(e)) return "string" === t ? [] : [e.length];
  if (!Array.isArray(e)) return [];
  var s = [];

  for (; Array.isArray(n) || $(n) && "string" !== t;) {
    s.push(n.length), n = n[0];
  }

  return Array.isArray(e) && V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && St(e, s, []), s;
}

function St(e, t, n) {
  if (n = n || [], !Array.isArray(e) && !$(e)) return void l(0 === t.length, function () {
    return "Element arr[".concat(n.join("]["), "] is a primitive, but should be an array/TypedArray of ").concat(t[0], " elements");
  });
  l(t.length > 0, function () {
    return "Element arr[".concat(n.join("]["), "] should be a primitive, but is an array of ").concat(e.length, " elements");
  }), l(e.length === t[0], function () {
    return "Element arr[".concat(n.join("]["), "] should have ").concat(t[0], " elements, but has ").concat(e.length, " elements");
  });
  var s = t.slice(1);

  for (var _t41 = 0; _t41 < e.length; ++_t41) {
    St(e[_t41], s, n.concat(_t41));
  }
}

function Tt(e, t, n, s) {
  if ("string_or_numeric" !== e) {
    if (null == e) throw new Error("Expected dtype cannot be null.");
    if ("numeric" !== e && e !== t || "numeric" === e && "string" === t) throw new Error("Argument '".concat(n, "' passed to '").concat(s, "' must be ").concat(e, " tensor, but got ").concat(t, " tensor"));
  }
}

function Et(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "numeric";
  if (e instanceof st) return Tt(s, e.dtype, t, n), e;
  var r = T(e);
  if ("string" !== r && ["bool", "int32", "float32"].indexOf(s) >= 0 && (r = s), Tt(s, r, t, n), null == e || !$(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("Argument '".concat(t, "' passed to '").concat(n, "' must be a Tensor or TensorLike, but got '").concat(null == e ? "null" : e.constructor.name, "'"));
  var a = Ct(e, r);
  $(e) || Array.isArray(e) || (e = [e]);
  var i = "string" !== r ? Ue(e, r) : h(e, [], !0);
  return wt.makeTensor(i, a, r);
}

function Rt(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "numeric";
  if (!Array.isArray(e)) throw new Error("Argument ".concat(t, " passed to ").concat(n, " must be a `Tensor[]` or `TensorLike[]`"));
  return e.map(function (e, r) {
    return Et(e, "".concat(t, "[").concat(r, "]"), n, s);
  });
}

function At(e) {
  var t = Object.keys(e);
  if (1 !== t.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with ".concat(t.length, " keys."));
  var n = t[0];
  var s = e[n];
  n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += "__op";

  var r = function r() {
    wt.startScope(n);

    try {
      var _t42 = s.apply(void 0, arguments);

      return P(_t42) && console.error("Cannot return a Promise inside of tidy."), wt.endScope(_t42), _t42;
    } catch (e) {
      throw wt.endScope(null), e;
    }
  };

  return Object.defineProperty(r, "name", {
    value: n,
    configurable: !0
  }), r;
}

Nt.registerFlag("DEBUG", function () {
  return !1;
}, function (e) {
  e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Nt.registerFlag("IS_BROWSER", function () {
  return $t();
}), Nt.registerFlag("IS_NODE", function () {
  return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Nt.registerFlag("IS_CHROME", function () {
  return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Nt.registerFlag("PROD", function () {
  return !1;
}), Nt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
  return Nt.getBool("DEBUG");
}), Nt.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
  return !0;
}), Nt.registerFlag("IS_TEST", function () {
  return !1;
}), Nt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", function () {
  return !0;
}), Nt.registerFlag("WRAP_TO_IMAGEBITMAP", function () {
  return !1;
});
var Ft = At({
  complex_: function complex_(e, t) {
    var n = Et(e, "real", "complex"),
        s = Et(t, "imag", "complex");
    return u(n.shape, s.shape, "real and imag shapes, ".concat(n.shape, " and ").concat(s.shape, ", must match in call to tf.complex().")), wt.runKernel("Complex", {
      real: n,
      imag: s
    });
  }
});

function Dt(e, t, n, s) {
  if (null == s && (s = T(e)), "complex64" === s) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!$(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");

  if (null != t) {
    L(t);

    var _e30 = d(t),
        _s19 = d(n);

    l(_e30 === _s19, function () {
      return "Based on the provided shape, [".concat(t, "], the tensor should have ").concat(_e30, " values but has ").concat(_s19);
    });

    for (var _e31 = 0; _e31 < n.length; ++_e31) {
      var _s20 = n[_e31],
          _r12 = _e31 !== n.length - 1 || _s20 !== d(t.slice(_e31));

      l(n[_e31] === t[_e31] || !_r12, function () {
        return "Error creating a new Tensor. Inferred shape (".concat(n, ") does not match the provided shape (").concat(t, "). ");
      });
    }
  }

  return $(e) || Array.isArray(e) || (e = [e]), t = t || n, e = "string" !== s ? Ue(e, s) : h(e, [], !0), wt.makeTensor(e, t, s);
}

function _t(e, t, n) {
  return Dt(e, t, Ct(e, n), n);
}

var Ot = {
  float32: 4,
  float16: 2,
  int32: 4,
  uint16: 2,
  uint8: 1,
  bool: 1,
  complex64: 8
};

function Mt(_x6, _x7) {
  return _Mt.apply(this, arguments);
}

function _Mt() {
  _Mt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee98(e, t) {
    var n, s, r, _loop32, a;

    return _regeneratorRuntime.wrap(function _callee98$(_context101) {
      while (1) {
        switch (_context101.prev = _context101.next) {
          case 0:
            n = [], s = [], r = Array.isArray(e) ? e.map(function (e) {
              return e.name;
            }) : Object.keys(e);

            _loop32 = function _loop32(a) {
              var i = r[a],
                  o = Array.isArray(e) ? e[a].tensor : e[i];
              if ("float32" !== o.dtype && "int32" !== o.dtype && "bool" !== o.dtype && "string" !== o.dtype && "complex64" !== o.dtype) throw new Error("Unsupported dtype in weight '".concat(i, "': ").concat(o.dtype));
              var l = {
                name: i,
                shape: o.shape,
                dtype: o.dtype
              };

              if ("string" === o.dtype) {
                var _e538 = new Promise( /*#__PURE__*/function () {
                  var _ref71 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee97(e) {
                    var t, n, s, r, _e539, _n310, _a128;

                    return _regeneratorRuntime.wrap(function _callee97$(_context100) {
                      while (1) {
                        switch (_context100.prev = _context100.next) {
                          case 0:
                            _context100.next = 2;
                            return o.bytes();

                          case 2:
                            t = _context100.sent;
                            n = t.reduce(function (e, t) {
                              return e + t.length;
                            }, 0) + 4 * t.length;
                            s = new Uint8Array(n);
                            r = 0;

                            for (_e539 = 0; _e539 < t.length; _e539++) {
                              _n310 = t[_e539], _a128 = new Uint8Array(new Uint32Array([_n310.length]).buffer);
                              s.set(_a128, r), r += 4, s.set(_n310, r), r += _n310.length;
                            }

                            e(s);

                          case 8:
                          case "end":
                            return _context100.stop();
                        }
                      }
                    }, _callee97);
                  }));

                  return function (_x153) {
                    return _ref71.apply(this, arguments);
                  };
                }());

                s.push(_e538);
              } else s.push(o.data());

              null != t && (l.group = t), n.push(l);
            };

            for (a = 0; a < r.length; ++a) {
              _loop32(a);
            }

            _context101.t0 = Lt;
            _context101.next = 6;
            return Promise.all(s);

          case 6:
            _context101.t1 = _context101.sent;
            _context101.t2 = (0, _context101.t0)(_context101.t1);
            _context101.t3 = n;
            return _context101.abrupt("return", {
              data: _context101.t2,
              specs: _context101.t3
            });

          case 10:
          case "end":
            return _context101.stop();
        }
      }
    }, _callee98);
  }));
  return _Mt.apply(this, arguments);
}

function Lt(e) {
  if (null === e) throw new Error("Invalid input value: ".concat(JSON.stringify(e)));
  var t = 0;
  var n = [];
  e.forEach(function (e) {
    if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name));
  });
  var s = new Uint8Array(t);
  var r = 0;
  return n.forEach(function (e) {
    s.set(new Uint8Array(e.buffer), r), r += e.byteLength;
  }), s.buffer;
}

var zt = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

function Bt(e) {
  return zt ? Buffer.byteLength(e) : new Blob([e]).size;
}

function Pt(e) {
  if (1 === e.length) return e[0];
  var t = 0;
  e.forEach(function (e) {
    t += e.byteLength;
  });
  var n = new Uint8Array(t);
  var s = 0;
  return e.forEach(function (e) {
    n.set(new Uint8Array(e), s), s += e.byteLength;
  }), n.buffer;
}

function Wt(e, t) {
  var n = {
    modelTopology: e.modelTopology,
    format: e.format,
    generatedBy: e.generatedBy,
    convertedBy: e.convertedBy,
    weightsManifest: t
  };
  return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), n;
}

function Ut(e) {
  if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {
    dateSaved: new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: null == e.modelTopology ? 0 : Bt(JSON.stringify(e.modelTopology)),
    weightSpecsBytes: null == e.weightSpecs ? 0 : Bt(JSON.stringify(e.weightSpecs)),
    weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength
  };
}

function Vt() {
  var e = function () {
    var e = function e(_e32) {
      var t = _e32 << 13,
          n = 0;

      for (; 0 == (8388608 & t);) {
        n -= 8388608, t <<= 1;
      }

      return t &= -8388609, n += 947912704, t | n;
    },
        t = new Uint32Array(2048);

    t[0] = 0;

    for (var _n25 = 1; _n25 < 1024; _n25++) {
      t[_n25] = e(_n25);
    }

    for (var _e33 = 1024; _e33 < 2048; _e33++) {
      t[_e33] = 939524096 + (_e33 - 1024 << 13);
    }

    return t;
  }(),
      t = function () {
    var e = new Uint32Array(64);
    e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;

    for (var _t43 = 1; _t43 < 31; _t43++) {
      e[_t43] = _t43 << 23;
    }

    for (var _t44 = 33; _t44 < 63; _t44++) {
      e[_t44] = 2147483648 + (_t44 - 32 << 23);
    }

    return e;
  }(),
      n = function () {
    var e = new Uint32Array(64);

    for (var _t45 = 0; _t45 < 64; _t45++) {
      e[_t45] = 1024;
    }

    return e[0] = e[32] = 0, e;
  }();

  return function (s) {
    var r = new ArrayBuffer(4 * s.length),
        a = new Uint32Array(r);

    for (var _r13 = 0; _r13 < s.length; _r13++) {
      var _i7 = s[_r13];
      a[_r13] = e[n[_i7 >> 10] + (1023 & _i7)] + t[_i7 >> 10];
    }

    return new Float32Array(r);
  };
}

var Gt = /*#__PURE__*/function () {
  "use strict";

  function Gt() {
    _classCallCheck(this, Gt);

    this.saveRouters = [], this.loadRouters = [];
  }

  _createClass(Gt, null, [{
    key: "getInstance",
    value: function getInstance() {
      return null == Gt.instance && (Gt.instance = new Gt()), Gt.instance;
    }
  }, {
    key: "registerSaveRouter",
    value: function registerSaveRouter(e) {
      Gt.getInstance().saveRouters.push(e);
    }
  }, {
    key: "registerLoadRouter",
    value: function registerLoadRouter(e) {
      Gt.getInstance().loadRouters.push(e);
    }
  }, {
    key: "getSaveHandlers",
    value: function getSaveHandlers(e) {
      return Gt.getHandlers(e, "save");
    }
  }, {
    key: "getLoadHandlers",
    value: function getLoadHandlers(e, t) {
      return Gt.getHandlers(e, "load", t);
    }
  }, {
    key: "getHandlers",
    value: function getHandlers(e, t, n) {
      var s = [];
      return ("load" === t ? Gt.getInstance().loadRouters : Gt.getInstance().saveRouters).forEach(function (t) {
        var r = t(e, n);
        null !== r && s.push(r);
      }), s;
    }
  }]);

  return Gt;
}();

function Ht() {
  if (!V().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var e = "undefined" == typeof window ? self : window,
      t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
  if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
  return t;
}

function jt(e) {
  var t = e.result;
  t.createObjectStore("models_store", {
    keyPath: "modelPath"
  }), t.createObjectStore("model_info_store", {
    keyPath: "modelPath"
  });
}

var qt = /*#__PURE__*/function () {
  "use strict";

  function qt(e) {
    _classCallCheck(this, qt);

    if (this.indexedDB = Ht(), null == e || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e;
  }

  _createClass(qt, [{
    key: "save",
    value: function () {
      var _save = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(e) {
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!(e.modelTopology instanceof ArrayBuffer)) {
                  _context10.next = 2;
                  break;
                }

                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");

              case 2:
                return _context10.abrupt("return", this.databaseAction(this.modelPath, e));

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function save(_x8) {
        return _save.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", this.databaseAction(this.modelPath));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function load() {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "databaseAction",
    value: function databaseAction(e, t) {
      var _this17 = this;

      return new Promise(function (e, n) {
        var s = _this17.indexedDB.open("tensorflowjs", 1);

        s.onupgradeneeded = function () {
          return jt(s);
        }, s.onsuccess = function () {
          var r = s.result;

          if (null == t) {
            var _t46 = r.transaction("models_store", "readonly"),
                _s21 = _t46.objectStore("models_store").get(_this17.modelPath);

            _s21.onsuccess = function () {
              if (null == _s21.result) return r.close(), n(new Error("Cannot find model with path '".concat(_this17.modelPath, "' in IndexedDB.")));
              e(_s21.result.modelArtifacts);
            }, _s21.onerror = function (e) {
              return r.close(), n(_s21.error);
            }, _t46.oncomplete = function () {
              return r.close();
            };
          } else {
            var _s22 = Ut(t),
                _a8 = r.transaction("model_info_store", "readwrite");

            var _i8 = _a8.objectStore("model_info_store");

            var _o5 = _i8.put({
              modelPath: _this17.modelPath,
              modelArtifactsInfo: _s22
            });

            var _l2;

            _o5.onsuccess = function () {
              _l2 = r.transaction("models_store", "readwrite");

              var o = _l2.objectStore("models_store").put({
                modelPath: _this17.modelPath,
                modelArtifacts: t,
                modelArtifactsInfo: _s22
              });

              o.onsuccess = function () {
                return e({
                  modelArtifactsInfo: _s22
                });
              }, o.onerror = function (e) {
                _i8 = _a8.objectStore("model_info_store");

                var t = _i8.delete(_this17.modelPath);

                t.onsuccess = function () {
                  return r.close(), n(o.error);
                }, t.onerror = function (e) {
                  return r.close(), n(o.error);
                };
              };
            }, _o5.onerror = function (e) {
              return r.close(), n(_o5.error);
            }, _a8.oncomplete = function () {
              null == _l2 ? r.close() : _l2.oncomplete = function () {
                return r.close();
              };
            };
          }
        }, s.onerror = function (e) {
          return n(s.error);
        };
      });
    }
  }]);

  return qt;
}();

qt.URL_SCHEME = "indexeddb://";

var Kt = function Kt(e) {
  return V().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(qt.URL_SCHEME) ? (t = e.slice(qt.URL_SCHEME.length), new qt(t)) : null;
  var t;
};

Gt.registerSaveRouter(Kt), Gt.registerLoadRouter(Kt);

var Xt = /*#__PURE__*/function () {
  "use strict";

  function Xt() {
    _classCallCheck(this, Xt);

    this.indexedDB = Ht();
  }

  _createClass(Xt, [{
    key: "listModels",
    value: function () {
      var _listModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {
        var _this18 = this;

        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                return _context12.abrupt("return", new Promise(function (e, t) {
                  var n = _this18.indexedDB.open("tensorflowjs", 1);

                  n.onupgradeneeded = function () {
                    return jt(n);
                  }, n.onsuccess = function () {
                    var s = n.result,
                        r = s.transaction("model_info_store", "readonly"),
                        a = r.objectStore("model_info_store").getAll();
                    a.onsuccess = function () {
                      var t = {};

                      var _iterator4 = _createForOfIteratorHelper(a.result),
                          _step4;

                      try {
                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                          var _e34 = _step4.value;
                          t[_e34.modelPath] = _e34.modelArtifactsInfo;
                        }
                      } catch (err) {
                        _iterator4.e(err);
                      } finally {
                        _iterator4.f();
                      }

                      e(t);
                    }, a.onerror = function (e) {
                      return s.close(), t(a.error);
                    }, r.oncomplete = function () {
                      return s.close();
                    };
                  }, n.onerror = function (e) {
                    return t(n.error);
                  };
                }));

              case 1:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }));

      function listModels() {
        return _listModels.apply(this, arguments);
      }

      return listModels;
    }()
  }, {
    key: "removeModel",
    value: function () {
      var _removeModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(e) {
        var _this19 = this;

        var t;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                return _context13.abrupt("return", (e = (t = e).startsWith(qt.URL_SCHEME) ? t.slice(qt.URL_SCHEME.length) : t, new Promise(function (t, n) {
                  var s = _this19.indexedDB.open("tensorflowjs", 1);

                  s.onupgradeneeded = function () {
                    return jt(s);
                  }, s.onsuccess = function () {
                    var r = s.result,
                        a = r.transaction("model_info_store", "readwrite"),
                        i = a.objectStore("model_info_store"),
                        o = i.get(e);
                    var l;
                    o.onsuccess = function () {
                      if (null == o.result) return r.close(), n(new Error("Cannot find model with path '".concat(e, "' in IndexedDB.")));
                      {
                        var _s23 = i.delete(e),
                            _a9 = function _a9() {
                          l = r.transaction("models_store", "readwrite");
                          var s = l.objectStore("models_store").delete(e);
                          s.onsuccess = function () {
                            return t(o.result.modelArtifactsInfo);
                          }, s.onerror = function (e) {
                            return n(o.error);
                          };
                        };

                        _s23.onsuccess = _a9, _s23.onerror = function (e) {
                          return _a9(), r.close(), n(o.error);
                        };
                      }
                    }, o.onerror = function (e) {
                      return r.close(), n(o.error);
                    }, a.oncomplete = function () {
                      null == l ? r.close() : l.oncomplete = function () {
                        return r.close();
                      };
                    };
                  }, s.onerror = function (e) {
                    return n(s.error);
                  };
                })));

              case 1:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));

      function removeModel(_x9) {
        return _removeModel.apply(this, arguments);
      }

      return removeModel;
    }()
  }]);

  return Xt;
}();

var Yt = "tensorflowjs_models",
    Jt = "info",
    Zt = "model_topology",
    Qt = "weight_specs",
    en = "weight_data",
    tn = "model_metadata";

function nn(e) {
  return {
    info: [Yt, e, Jt].join("/"),
    topology: [Yt, e, Zt].join("/"),
    weightSpecs: [Yt, e, Qt].join("/"),
    weightData: [Yt, e, en].join("/"),
    modelMetadata: [Yt, e, tn].join("/")
  };
}

function sn(e) {
  for (var _i9 = 0, _Object$values = Object.values(e); _i9 < _Object$values.length; _i9++) {
    var t = _Object$values[_i9];
    window.localStorage.removeItem(t);
  }
}

function rn(e) {
  var t = e.split("/");
  if (t.length < 3) throw new Error("Invalid key format: ".concat(e));
  return t.slice(1, t.length - 1).join("/");
}

var an = /*#__PURE__*/function () {
  "use strict";

  function an(e) {
    _classCallCheck(this, an);

    if (!V().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == e || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e, this.keys = nn(this.modelPath);
  }

  _createClass(an, [{
    key: "save",
    value: function () {
      var _save2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(e) {
        var t, _n26, _s24;

        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (!(e.modelTopology instanceof ArrayBuffer)) {
                  _context14.next = 2;
                  break;
                }

                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");

              case 2:
                t = JSON.stringify(e.modelTopology), _n26 = JSON.stringify(e.weightSpecs), _s24 = Ut(e);
                _context14.prev = 3;
                return _context14.abrupt("return", (this.LS.setItem(this.keys.info, JSON.stringify(_s24)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, _n26), this.LS.setItem(this.keys.weightData, function (e) {
                  if (zt) return Buffer.from(e).toString("base64");
                  var t = new Uint8Array(e);
                  var n = "";

                  for (var _e35 = 0, _s25 = t.length; _e35 < _s25; _e35++) {
                    n += String.fromCharCode(t[_e35]);
                  }

                  return btoa(n);
                }(e.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
                  format: e.format,
                  generatedBy: e.generatedBy,
                  convertedBy: e.convertedBy,
                  signature: null != e.signature ? e.signature : void 0,
                  userDefinedMetadata: null != e.userDefinedMetadata ? e.userDefinedMetadata : void 0,
                  modelInitializer: null != e.modelInitializer ? e.modelInitializer : void 0,
                  trainingConfig: null != e.trainingConfig ? e.trainingConfig : void 0
                })), {
                  modelArtifactsInfo: _s24
                }));

              case 7:
                _context14.prev = 7;
                _context14.t0 = _context14["catch"](3);
                throw sn(this.keys), new Error("Failed to save model '".concat(this.modelPath, "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=").concat(_s24.modelTopologyBytes, ", weightSpecsBytes=").concat(_s24.weightSpecsBytes, ", weightDataBytes=").concat(_s24.weightDataBytes, "."));

              case 10:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[3, 7]]);
      }));

      function save(_x10) {
        return _save2.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "load",
    value: function () {
      var _load2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {
        var e, t, n, s, r, _e36, a;

        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                e = JSON.parse(this.LS.getItem(this.keys.info));

                if (!(null == e)) {
                  _context15.next = 3;
                  break;
                }

                throw new Error("In local storage, there is no model with name '".concat(this.modelPath, "'"));

              case 3:
                if (!("JSON" !== e.modelTopologyType)) {
                  _context15.next = 5;
                  break;
                }

                throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");

              case 5:
                t = {}, n = JSON.parse(this.LS.getItem(this.keys.topology));

                if (!(null == n)) {
                  _context15.next = 8;
                  break;
                }

                throw new Error("In local storage, the topology of model '".concat(this.modelPath, "' is missing."));

              case 8:
                t.modelTopology = n;
                s = JSON.parse(this.LS.getItem(this.keys.weightSpecs));

                if (!(null == s)) {
                  _context15.next = 12;
                  break;
                }

                throw new Error("In local storage, the weight specs of model '".concat(this.modelPath, "' are missing."));

              case 12:
                t.weightSpecs = s;
                r = this.LS.getItem(this.keys.modelMetadata);

                if (null != r) {
                  _e36 = JSON.parse(r);
                  t.format = _e36.format, t.generatedBy = _e36.generatedBy, t.convertedBy = _e36.convertedBy, null != _e36.signature && (t.signature = _e36.signature), null != _e36.userDefinedMetadata && (t.userDefinedMetadata = _e36.userDefinedMetadata), null != _e36.modelInitializer && (t.modelInitializer = _e36.modelInitializer), null != _e36.trainingConfig && (t.trainingConfig = _e36.trainingConfig);
                }

                a = this.LS.getItem(this.keys.weightData);

                if (!(null == a)) {
                  _context15.next = 18;
                  break;
                }

                throw new Error("In local storage, the binary weight values of model '".concat(this.modelPath, "' are missing."));

              case 18:
                return _context15.abrupt("return", (t.weightData = function (e) {
                  if (zt) {
                    var _t47 = Buffer.from(e, "base64");

                    return _t47.buffer.slice(_t47.byteOffset, _t47.byteOffset + _t47.byteLength);
                  }

                  var t = atob(e),
                      n = new Uint8Array(t.length);

                  for (var _e37 = 0; _e37 < t.length; ++_e37) {
                    n.set([t.charCodeAt(_e37)], _e37);
                  }

                  return n.buffer;
                }(a), t));

              case 19:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function load() {
        return _load2.apply(this, arguments);
      }

      return load;
    }()
  }]);

  return an;
}();

an.URL_SCHEME = "localstorage://";

var on = function on(e) {
  return V().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(an.URL_SCHEME) ? (t = e.slice(an.URL_SCHEME.length), new an(t)) : null;
  var t;
};

Gt.registerSaveRouter(on), Gt.registerLoadRouter(on);

var ln = /*#__PURE__*/function () {
  "use strict";

  function ln() {
    _classCallCheck(this, ln);

    l(V().getBool("IS_BROWSER"), function () {
      return "Current environment is not a web browser";
    }), l("undefined" == typeof window || void 0 !== window.localStorage, function () {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }

  _createClass(ln, [{
    key: "listModels",
    value: function () {
      var _listModels2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {
        var e, t, n, _s26, _r14;

        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                e = {}, t = Yt + "/", n = "/" + Jt;

                for (_s26 = 0; _s26 < this.LS.length; ++_s26) {
                  _r14 = this.LS.key(_s26);
                  _r14.startsWith(t) && _r14.endsWith(n) && (e[rn(_r14)] = JSON.parse(this.LS.getItem(_r14)));
                }

                return _context16.abrupt("return", e);

              case 3:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function listModels() {
        return _listModels2.apply(this, arguments);
      }

      return listModels;
    }()
  }, {
    key: "removeModel",
    value: function () {
      var _removeModel2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(e) {
        var t, n, s;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                n = nn(e = (t = e).startsWith(an.URL_SCHEME) ? t.slice(an.URL_SCHEME.length) : t);

                if (!(null == this.LS.getItem(n.info))) {
                  _context17.next = 3;
                  break;
                }

                throw new Error("Cannot find model at path '".concat(e, "'"));

              case 3:
                s = JSON.parse(this.LS.getItem(n.info));
                return _context17.abrupt("return", (sn(n), s));

              case 5:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function removeModel(_x11) {
        return _removeModel2.apply(this, arguments);
      }

      return removeModel;
    }()
  }]);

  return ln;
}();

var un = /*#__PURE__*/function () {
  "use strict";

  function un() {
    _classCallCheck(this, un);

    this.managers = {};
  }

  _createClass(un, null, [{
    key: "getInstance",
    value: function getInstance() {
      return null == un.instance && (un.instance = new un()), un.instance;
    }
  }, {
    key: "registerManager",
    value: function registerManager(e, t) {
      l(null != e, function () {
        return "scheme must not be undefined or null.";
      }), e.endsWith("://") && (e = e.slice(0, e.indexOf("://"))), l(e.length > 0, function () {
        return "scheme must not be an empty string.";
      });
      var n = un.getInstance();
      l(null == n.managers[e], function () {
        return "A model store manager is already registered for scheme '".concat(e, "'.");
      }), n.managers[e] = t;
    }
  }, {
    key: "getManager",
    value: function getManager(e) {
      var t = this.getInstance().managers[e];
      if (null == t) throw new Error("Cannot find model manager for scheme '".concat(e, "'"));
      return t;
    }
  }, {
    key: "getSchemes",
    value: function getSchemes() {
      return Object.keys(this.getInstance().managers);
    }
  }]);

  return un;
}();

var cn = /*#__PURE__*/function () {
  "use strict";

  function cn() {
    _classCallCheck(this, cn);
  }

  _createClass(cn, [{
    key: "fetch",
    value: function (_fetch) {
      function fetch(_x12, _x13) {
        return _fetch.apply(this, arguments);
      }

      fetch.toString = function () {
        return _fetch.toString();
      };

      return fetch;
    }(function (e, t) {
      return fetch(e, t);
    })
  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }, {
    key: "encode",
    value: function encode(e, t) {
      if ("utf-8" !== t && "utf8" !== t) throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));
      return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
    }
  }, {
    key: "decode",
    value: function decode(e, t) {
      return new TextDecoder(t).decode(e);
    }
  }]);

  return cn;
}();

if (V().get("IS_BROWSER")) {
  V().setPlatform("browser", new cn());

  try {
    un.registerManager(an.URL_SCHEME, new ln());
  } catch (e) {}

  try {
    un.registerManager(qt.URL_SCHEME, new Xt());
  } catch (e) {}
}

var hn;

function dn(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";
  var n = arguments.length > 2 ? arguments[2] : undefined;
  return t = t || "float32", L(e), new et(e, t, n);
}

V().get("IS_NODE") && V().setPlatform("node", new ( /*#__PURE__*/function () {
  "use strict";

  function _class() {
    _classCallCheck(this, _class);

    this.util = __webpack_require__(15895), this.textEncoder = new this.util.TextEncoder();
  }

  _createClass(_class, [{
    key: "fetch",
    value: function fetch(e, t) {
      return null != V().global.fetch ? V().global.fetch(e, t) : (null == hn && (hn = __webpack_require__(76474)), hn(e, t));
    }
  }, {
    key: "now",
    value: function now() {
      var e = process.hrtime();
      return 1e3 * e[0] + e[1] / 1e6;
    }
  }, {
    key: "encode",
    value: function encode(e, t) {
      if ("utf-8" !== t && "utf8" !== t) throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));
      return this.textEncoder.encode(e);
    }
  }, {
    key: "decode",
    value: function decode(e, t) {
      return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e);
    }
  }]);

  return _class;
}())());
var pn = At({
  cast_: function cast_(e, t) {
    var n = Et(e, "x", "cast");
    if (!function (e) {
      return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e;
    }(t)) throw new Error("Failed to cast to unknown dtype ".concat(t));
    if ("string" === t && "string" !== n.dtype || "string" !== t && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
    return wt.runKernel("Cast", {
      x: n
    }, {
      dtype: t
    });
  }
}),
    fn = At({
  clone_: function clone_(e) {
    var t = Et(e, "x", "clone", "string_or_numeric");
    return wt.runKernel("Identity", {
      x: t
    });
  }
});

function gn(e) {
  return new Promise(function (e) {
    return setTimeout(e);
  }).then(e);
}

kt(), nt = {
  buffer: dn,
  cast: pn,
  clone: fn,
  print: function print(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    console.log(e.toString(t));
  }
};

var mn = /*#__PURE__*/function () {
  "use strict";

  function mn(e) {
    _classCallCheck(this, mn);

    if (!V().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e.startsWith(mn.URL_SCHEME) && (e = e.slice(mn.URL_SCHEME.length)), null != e && 0 !== e.length || (e = "model"), this.modelJsonFileName = e + ".json", this.weightDataFileName = e + ".weights.bin";
  }

  _createClass(mn, [{
    key: "save",
    value: function () {
      var _save3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(e) {
        var t, _n27, _s27, _r15, _e38;

        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!("undefined" == typeof document)) {
                  _context18.next = 2;
                  break;
                }

                throw new Error("Browser downloads are not supported in this environment since `document` is not present");

              case 2:
                t = window.URL.createObjectURL(new Blob([e.weightData], {
                  type: "application/octet-stream"
                }));

                if (!(e.modelTopology instanceof ArrayBuffer)) {
                  _context18.next = 5;
                  break;
                }

                throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");

              case 5:
                _n27 = Wt(e, [{
                  paths: ["./" + this.weightDataFileName],
                  weights: e.weightSpecs
                }]), _s27 = window.URL.createObjectURL(new Blob([JSON.stringify(_n27)], {
                  type: "application/json"
                })), _r15 = null == this.modelJsonAnchor ? document.createElement("a") : this.modelJsonAnchor;
                _r15.download = this.modelJsonFileName;
                _r15.href = _s27;
                _context18.next = 10;
                return gn(function () {
                  return _r15.dispatchEvent(new MouseEvent("click"));
                });

              case 10:
                if (!(null != e.weightData)) {
                  _context18.next = 16;
                  break;
                }

                _e38 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor;
                _e38.download = this.weightDataFileName;
                _e38.href = t;
                _context18.next = 16;
                return gn(function () {
                  return _e38.dispatchEvent(new MouseEvent("click"));
                });

              case 16:
                return _context18.abrupt("return", {
                  modelArtifactsInfo: Ut(e)
                });

              case 17:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function save(_x14) {
        return _save3.apply(this, arguments);
      }

      return save;
    }()
  }]);

  return mn;
}();

function bn(e, t, n, s) {
  !function (e) {
    l(null != e && Array.isArray(e) && e.length > 0, function () {
      return "promises must be a none empty array";
    });
  }(e), function (e, t) {
    l(e >= 0 && e <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got startFraction ".concat(e);
    }), l(t >= 0 && t <= 1, function () {
      return "Progress fraction must be in range [0, 1], but got endFraction ".concat(t);
    }), l(t >= e, function () {
      return "startFraction must be no more than endFraction, but got startFraction ".concat(e, " and endFraction ").concat(t);
    });
  }(n = null == n ? 0 : n, s = null == s ? 1 : s);
  var r = 0;
  return Promise.all(e.map(function (a) {
    return a.then(function (a) {
      var i = n + ++r / e.length * (s - n);
      return t(i), a;
    }), a;
  }));
}

mn.URL_SCHEME = "downloads://", Gt.registerSaveRouter(function (e) {
  return V().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(mn.URL_SCHEME) ? function () {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "model";
    return new mn(e);
  }(e.slice(mn.URL_SCHEME.length)) : null;
});

var xn = /*#__PURE__*/function () {
  "use strict";

  function xn(e, t) {
    _classCallCheck(this, xn);

    if (this.DEFAULT_METHOD = "POST", null == t && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, this.weightUrlConverter = t.weightUrlConverter, null != t.fetchFunc ? (l("function" == typeof t.fetchFunc, function () {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = t.fetchFunc) : this.fetch = V().platform.fetch, l(null != e && e.length > 0, function () {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(e) && l(2 === e.length, function () {
      return "URL paths for http must have a length of 2, (actual length is ".concat(e.length, ").");
    }), this.path = e, null != t.requestInit && null != t.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t.requestInit || {};
  }

  _createClass(xn, [{
    key: "save",
    value: function () {
      var _save4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(e) {
        var t, n, s;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!(e.modelTopology instanceof ArrayBuffer)) {
                  _context19.next = 2;
                  break;
                }

                throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");

              case 2:
                t = Object.assign({
                  method: this.DEFAULT_METHOD
                }, this.requestInit);
                t.body = new FormData();
                n = Wt(e, [{
                  paths: ["./model.weights.bin"],
                  weights: e.weightSpecs
                }]);
                t.body.append("model.json", new Blob([JSON.stringify(n)], {
                  type: "application/json"
                }), "model.json"), null != e.weightData && t.body.append("model.weights.bin", new Blob([e.weightData], {
                  type: "application/octet-stream"
                }), "model.weights.bin");
                _context19.next = 8;
                return this.fetch(this.path, t);

              case 8:
                s = _context19.sent;

                if (!s.ok) {
                  _context19.next = 11;
                  break;
                }

                return _context19.abrupt("return", {
                  modelArtifactsInfo: Ut(e),
                  responses: [s]
                });

              case 11:
                throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status ".concat(s.status, "."));

              case 12:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function save(_x15) {
        return _save4.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "load",
    value: function () {
      var _load3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {
        var _this20 = this;

        var e, t, _t48;

        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.fetch(this.path, this.requestInit);

              case 2:
                e = _context21.sent;

                if (e.ok) {
                  _context21.next = 5;
                  break;
                }

                throw new Error("Request to ".concat(this.path, " failed with status code ").concat(e.status, ". Please verify this URL points to the model JSON of the model to load."));

              case 5:
                _context21.prev = 5;
                _context21.next = 8;
                return e.json();

              case 8:
                t = _context21.sent;
                _context21.next = 15;
                break;

              case 11:
                _context21.prev = 11;
                _context21.t0 = _context21["catch"](5);
                _t48 = "Failed to parse model JSON of response from ".concat(this.path, ".");
                throw this.path.endsWith(".pb") ? _t48 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : _t48 += " Please make sure the server is serving valid JSON for this request.", new Error(_t48);

              case 15:
                if (!(null == t.modelTopology && null == t.weightsManifest)) {
                  _context21.next = 17;
                  break;
                }

                throw new Error("The JSON from HTTP path ".concat(this.path, " contains neither model topology or manifest for weights."));

              case 17:
                return _context21.abrupt("return", function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(e, t) {
                    var n, _yield$t, _yield$t2, _s28, _r16;

                    return _regeneratorRuntime.wrap(function _callee20$(_context20) {
                      while (1) {
                        switch (_context20.prev = _context20.next) {
                          case 0:
                            n = {
                              modelTopology: e.modelTopology,
                              format: e.format,
                              generatedBy: e.generatedBy,
                              convertedBy: e.convertedBy
                            };

                            if (!(null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), null != e.weightsManifest)) {
                              _context20.next = 9;
                              break;
                            }

                            _context20.next = 4;
                            return t(e.weightsManifest);

                          case 4:
                            _yield$t = _context20.sent;
                            _yield$t2 = _slicedToArray(_yield$t, 2);
                            _s28 = _yield$t2[0];
                            _r16 = _yield$t2[1];
                            n.weightSpecs = _s28, n.weightData = _r16;

                          case 9:
                            return _context20.abrupt("return", (null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), n));

                          case 10:
                          case "end":
                            return _context20.stop();
                        }
                      }
                    }, _callee20);
                  }));

                  return function (_x16, _x17) {
                    return _ref3.apply(this, arguments);
                  };
                }()(t, function (e) {
                  return _this20.loadWeights(e);
                }));

              case 18:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this, [[5, 11]]);
      }));

      function load() {
        return _load3.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "loadWeights",
    value: function () {
      var _loadWeights = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(e) {
        var t, _ref4, _ref5, n, s, r, a, _iterator5, _step5, _t49, i, o, _iterator6, _step6, _t50, _iterator7, _step7, _e39;

        return _regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                t = Array.isArray(this.path) ? this.path[1] : this.path, _ref4 = function (e) {
                  var t = e.lastIndexOf("/"),
                      n = e.lastIndexOf("?");
                  return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""];
                }(t), _ref5 = _slicedToArray(_ref4, 2), n = _ref5[0], s = _ref5[1], r = this.weightPathPrefix || n, a = [];
                _iterator5 = _createForOfIteratorHelper(e);

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    _t49 = _step5.value;
                    a.push.apply(a, _toConsumableArray(_t49.weights));
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }

                i = [], o = [];
                _iterator6 = _createForOfIteratorHelper(e);

                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    _t50 = _step6.value;
                    _iterator7 = _createForOfIteratorHelper(_t50.paths);

                    try {
                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                        _e39 = _step7.value;
                        null != this.weightUrlConverter ? o.push(this.weightUrlConverter(_e39)) : i.push(r + _e39 + s);
                      }
                    } catch (err) {
                      _iterator7.e(err);
                    } finally {
                      _iterator7.f();
                    }
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }

                _context23.t0 = this.weightUrlConverter;

                if (!_context23.t0) {
                  _context23.next = 16;
                  break;
                }

                _context23.t1 = i.push;
                _context23.t2 = i;
                _context23.t3 = _toConsumableArray;
                _context23.next = 13;
                return Promise.all(o);

              case 13:
                _context23.t4 = _context23.sent;
                _context23.t5 = (0, _context23.t3)(_context23.t4);

                _context23.t1.apply.call(_context23.t1, _context23.t2, _context23.t5);

              case 16:
                _context23.t6 = a;
                _context23.t7 = Pt;
                _context23.next = 20;
                return function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(e, t) {
                    var n, s, r;
                    return _regeneratorRuntime.wrap(function _callee22$(_context22) {
                      while (1) {
                        switch (_context22.prev = _context22.next) {
                          case 0:
                            null == t && (t = {});
                            n = null == t.fetchFunc ? V().platform.fetch : t.fetchFunc;
                            s = e.map(function (e) {
                              return n(e, t.requestInit, {
                                isBinary: !0
                              });
                            });

                            if (!(null == t.onProgress)) {
                              _context22.next = 9;
                              break;
                            }

                            _context22.next = 6;
                            return Promise.all(s);

                          case 6:
                            _context22.t0 = _context22.sent;
                            _context22.next = 12;
                            break;

                          case 9:
                            _context22.next = 11;
                            return bn(s, t.onProgress, 0, .5);

                          case 11:
                            _context22.t0 = _context22.sent;

                          case 12:
                            r = _context22.t0.map(function (e) {
                              return e.arrayBuffer();
                            });

                            if (!(null == t.onProgress)) {
                              _context22.next = 19;
                              break;
                            }

                            _context22.next = 16;
                            return Promise.all(r);

                          case 16:
                            _context22.t1 = _context22.sent;
                            _context22.next = 22;
                            break;

                          case 19:
                            _context22.next = 21;
                            return bn(r, t.onProgress, .5, 1);

                          case 21:
                            _context22.t1 = _context22.sent;

                          case 22:
                            return _context22.abrupt("return", _context22.t1);

                          case 23:
                          case "end":
                            return _context22.stop();
                        }
                      }
                    }, _callee22);
                  }));

                  return function (_x19, _x20) {
                    return _ref6.apply(this, arguments);
                  };
                }()(i, {
                  requestInit: this.requestInit,
                  fetchFunc: this.fetch,
                  onProgress: this.onProgress
                });

              case 20:
                _context23.t8 = _context23.sent;
                _context23.t9 = (0, _context23.t7)(_context23.t8);
                return _context23.abrupt("return", [_context23.t6, _context23.t9]);

              case 23:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function loadWeights(_x18) {
        return _loadWeights.apply(this, arguments);
      }

      return loadWeights;
    }()
  }]);

  return xn;
}();

function yn(e) {
  return null != e.match(xn.URL_SCHEME_REGEX);
}

xn.URL_SCHEME_REGEX = /^https?:\/\//;

var kn = function kn(e, t) {
  if ("undefined" == typeof fetch && (null == t || null == t.fetchFunc)) return null;
  {
    var _n28 = !0;

    if (_n28 = Array.isArray(e) ? e.every(function (e) {
      return yn(e);
    }) : yn(e), _n28) return wn(e, t);
  }
  return null;
};

function wn(e, t) {
  return new xn(e, t);
}

Gt.registerSaveRouter(kn), Gt.registerLoadRouter(kn);
var vn = At({
  matMul_: function matMul_(e, t) {
    var _ft, _ft2;

    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "a", "matMul"),
        a = Et(t, "b", "matMul");
    return (_ft = ft(r, a), _ft2 = _slicedToArray(_ft, 2), r = _ft2[0], a = _ft2[1], _ft), wt.runKernel("BatchMatMul", {
      a: r,
      b: a
    }, {
      transposeA: n,
      transposeB: s
    });
  }
}),
    In = At({
  oneHot_: function oneHot_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    if (t < 2) throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));
    var r = Et(e, "indices", "oneHot", "int32");
    return wt.runKernel("OneHot", {
      indices: r
    }, {
      depth: t,
      onValue: n,
      offValue: s
    });
  }
}),
    $n = At({
  transpose_: function transpose_(e, t) {
    var n = Et(e, "x", "transpose");
    return null == t && (t = n.shape.map(function (e, t) {
      return t;
    }).reverse()), l(n.rank === t.length, function () {
      return "Error in transpose: rank of input ".concat(n.rank, " must match length of perm ").concat(t, ".");
    }), t.forEach(function (e) {
      l(e >= 0 && e < n.rank, function () {
        return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got ".concat(t);
      });
    }), n.rank <= 1 ? n.clone() : wt.runKernel("Transpose", {
      x: n
    }, {
      perm: t
    });
  }
});

function Nn(e, t) {
  var n = e.shape.length,
      s = t.shape.length;
  if (n < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was ".concat(n, "."));
  if (s < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ".concat(s, "."));
  if ("int32" !== t.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was ".concat(t.dtype, "."));
  if (t.shape[s - 1] > n) throw new Error("index innermost dimension length must be <= tensor rank; saw: ".concat(t.shape[s - 1], " vs. ").concat(n));
  if (0 === d(e.shape)) throw new Error("Requested more than 0 entries, but input is empty. Input shape: ".concat(e.shape, "."));
  var r = t.shape,
      a = r[r.length - 1];
  var i = 1;

  for (var _e40 = 0; _e40 < r.length - 1; ++_e40) {
    i *= r[_e40];
  }

  var o = e.shape,
      l = r.slice();
  l.pop();
  var u = 1;

  for (var _e41 = a; _e41 < n; ++_e41) {
    u *= o[_e41], l.push(o[_e41]);
  }

  var c = [].concat(_toConsumableArray(A(e.shape).map(function (e) {
    return e / u;
  })), [1]).slice(0, a);
  return [l, i, u, c];
}

function Cn(e, t, n) {
  var s = t.rank > 1 ? t.shape[t.rank - 1] : 1,
      r = t.rank > 1 ? t.rank - 1 : 1,
      a = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ".concat(n.shape, ", indices.shape: ").concat(t.shape, ", shape: ").concat(e, ", sliceDim: ").concat(s, ", and batchDim: ").concat(r, ".");
  if (n.rank < r) throw new Error(a + " update.rank < ".concat(r, ". "));
  if (e.length < s + (n.rank - r)) throw new Error(a + " Output shape length < ".concat(s + (n.rank - r)));
  if (n.rank !== r + e.length - s) throw new Error(a + " update.rank != " + (r + e.length - s));

  for (var _e42 = 0; _e42 < r; ++_e42) {
    if (n.shape[_e42] !== t.shape[_e42]) throw new Error(a + " updates.shape[".concat(_e42, "] (").concat(n.shape[_e42], ") != indices.shape[").concat(_e42, "] (").concat(t.shape[_e42], ")."));
  }

  for (var _t51 = 0; _t51 < n.rank - r; ++_t51) {
    if (n.shape[_t51 + r] !== e[_t51 + s]) throw new Error(a + " updates.shape[".concat(_t51 + r, "] (").concat(n.shape[_t51 + r], ") != shape[").concat(_t51 + r, "] (").concat(e[_t51 + r], ")"));
  }
}

function Sn(e, t, n) {
  var s = t.shape.length,
      r = s > 1 ? t.shape[s - 1] : 1,
      a = n.length;
  var i = 1;

  for (var _e43 = r; _e43 < a; ++_e43) {
    i *= n[_e43];
  }

  var o = r < 1 ? 1 : r;
  return {
    sliceRank: r,
    numUpdates: d(t.shape) / o,
    sliceSize: i,
    strides: [].concat(_toConsumableArray(A(n.slice(0, r))), [1]),
    outputSize: d(n)
  };
}

function Tn(e, t, n) {
  var s = e.shape.length;
  l(s === t.length, function () {
    return "Error in slice".concat(s, "D: Length of begin ").concat(t, " must match the rank of the array (").concat(s, ").");
  }), l(s === n.length, function () {
    return "Error in slice".concat(s, "D: Length of size ").concat(n, " must match the rank of the array (").concat(s, ").");
  });

  var _loop4 = function _loop4(_r17) {
    l(t[_r17] + n[_r17] <= e.shape[_r17], function () {
      return "Error in slice".concat(s, "D: begin[").concat(_r17, "] + size[").concat(_r17, "] (").concat(t[_r17] + n[_r17], ") would overflow input.shape[").concat(_r17, "] (").concat(e.shape[_r17], ")");
    });
  };

  for (var _r17 = 0; _r17 < s; ++_r17) {
    _loop4(_r17);
  }
}

function En(e) {
  var t = [];
  var n = 0;

  for (; e > 0;) {
    1 & e && t.push(n), e /= 2, n++;
  }

  return t;
}

function Rn(e, t, n) {
  var s = [];

  for (var _r18 = 0; _r18 < e.length; _r18++) {
    s[_r18] = Math.ceil((t[_r18] - e[_r18]) / n[_r18]);
  }

  return s;
}

function An(e, t, n, s) {
  var r = _toConsumableArray(e);

  for (var _e44 = r.length; _e44 < s.length; _e44++) {
    r.push(1);
  }

  for (var _e45 = 0; _e45 < n; _e45++) {
    0 === _e45 ? r[t] = 1 : (r.splice(t, 0, 1), r.pop());
  }

  return r;
}

function Fn(e, t, n) {
  return n <= e ? n : n - (t - 1);
}

function Dn(e, t) {
  var n = [];

  for (var _s29 = 0; _s29 < e; _s29++) {
    n.push(t + _s29);
  }

  return n;
}

function _n(e, t, n, s, r, a, i, o, l) {
  var u = e.length;
  var c = new Array(u),
      h = new Array(u),
      d = new Array(u);

  if (t.length && n > 0) {
    var _l3 = t[0],
        _u3 = n + 1;

    c = On(i, _l3, _u3, s, e), h = Mn(o, _l3, _u3, r, e), d = An(a, _l3, _u3, e);
  } else for (var _t52 = 0; _t52 < u; _t52++) {
    c[_t52] = zn(i, s, a, e, _t52, l), h[_t52] = Bn(o, r, a, e, _t52, l), d[_t52] = Ln(a, _t52, l);
  }

  return {
    begin: c,
    end: h,
    strides: d
  };
}

function On(e, t, n, s, r) {
  var a = _toConsumableArray(r),
      i = Dn(n, t);

  for (var _r19 = 0; _r19 < a.length; _r19++) {
    if (i.indexOf(_r19) > -1) a[_r19] = 0;else {
      var _i10 = Fn(t, n, _r19);

      var _o6 = s[_i10];
      e & 1 << _i10 && (_o6 = 0), a[_r19] = _o6;
    }
  }

  return a;
}

function Mn(e, t, n, s, r) {
  var i = _toConsumableArray(r),
      o = Dn(n, t);

  for (var _r20 = 0; _r20 < i.length; _r20++) {
    if (o.indexOf(_r20) > -1) i[_r20] = Number.MAX_SAFE_INTEGER;else {
      var _a10 = Fn(t, n, _r20);

      var _o7 = s[_a10];
      e & 1 << _a10 && (_o7 = Number.MAX_SAFE_INTEGER), i[_r20] = _o7;
    }
  }

  for (var _e46 = 0; _e46 < i.length; _e46++) {
    var _t53 = r[_e46];
    i[_e46] < 0 && (i[_e46] += _t53), i[_e46] = a(0, i[_e46], r[_e46]);
  }

  return i;
}

function Ln(e, t, n) {
  var s = e[t];
  return (n & 1 << t || null == s) && (s = 1), s;
}

function zn(e, t, n, s, r, i) {
  var o = t[r];
  (e & 1 << r || i & 1 << r || null == o) && (o = (n[r] || 1) > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var l = s[r];
  return o < 0 && (o += l), o = a(0, o, l - 1), o;
}

function Bn(e, t, n, s, r, i) {
  var o = t[r];
  var l = n[r] || 1;
  (e & 1 << r || i & 1 << r || null == o) && (o = l > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var u = s[r];
  return o < 0 && (o += u), o = l > 0 ? a(0, o, u) : a(-1, o, u - 1), o;
}

function Pn(e, t, n) {
  var s = n.length;

  for (var _e47 = 0; _e47 < n.length; _e47++) {
    if (n[_e47] > 1) {
      s = _e47;
      break;
    }
  }

  for (var _r21 = s + 1; _r21 < n.length; _r21++) {
    if (t[_r21] > 0 || n[_r21] !== e[_r21]) return !1;
  }

  return !0;
}

function Wn(e, t) {
  var n = e.length > 0 ? e[e.length - 1] : 1;

  for (var _s30 = 0; _s30 < e.length - 1; _s30++) {
    n += e[_s30] * t[_s30];
  }

  return n;
}

function Un(e, t, n) {
  var s;
  var r = e.shape.length;
  var a;
  return s = "number" == typeof t ? [t].concat(_toConsumableArray(new Array(r - 1).fill(0))) : t.length < r ? t.concat(new Array(r - t.length).fill(0)) : t.slice(), s.forEach(function (e) {
    l(-1 !== e, function () {
      return "slice() does not support negative begin indexing.";
    });
  }), a = null == n ? new Array(r).fill(-1) : "number" == typeof n ? [n].concat(_toConsumableArray(new Array(r - 1).fill(-1))) : n.length < r ? n.concat(new Array(r - n.length).fill(-1)) : n, a = a.map(function (t, n) {
    return t >= 0 ? t : (l(-1 === t, function () {
      return "Negative size values should be exactly -1 but got ".concat(t, " for the slice() size at index ").concat(n, ".");
    }), e.shape[n] - s[n]);
  }), [s, a];
}

function Vn(e, t, n, s, r, a, i, o, l) {
  var u = t.slice(),
      c = n.slice(),
      h = s;
  null == s && (h = new Array(u.length));
  var d = En(i);
  if (d.length > 1) throw new Error("Multiple ellipses in slice is not allowed.");
  if (0 !== i && 0 !== o) throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
  if (0 !== i && 0 !== l) throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
  var p = e.length - u.length,
      f = En(o),
      g = e.slice();
  f.forEach(function (e) {
    u[e] = 0, c[e] = 1, g.splice(e, 0, 1);
  });

  var _n29 = _n(g, d, p, u, c, h, r, a, i),
      m = _n29.begin,
      b = _n29.end,
      x = _n29.strides;

  u = m, c = b, h = x;
  var y = En(l);
  y.forEach(function (e) {
    c[e] = u[e] + 1, h[e] = 1;
  });
  var k = Rn(u, c, h),
      w = k.filter(function (e, t) {
    return -1 === y.indexOf(t);
  });
  return {
    nonStrided: h.every(function (e) {
      return 1 === e;
    }),
    $begin: u,
    $end: c,
    $strides: h,
    size: k,
    newShape: g,
    outShape: w
  };
}

var Gn = {
  __proto__: null,
  assertParamsValid: Tn,
  maskToAxes: En,
  computeOutShape: Rn,
  stridesWithElidedDims: An,
  getNormalizedAxes: _n,
  startIndicesWithElidedDims: On,
  stopIndicesWithElidedDims: Mn,
  stridesForAxis: Ln,
  startForAxis: zn,
  stopForAxis: Bn,
  isSliceContinous: Pn,
  computeFlatOffset: Wn,
  parseSliceParams: Un,
  sliceInfo: Vn
};

var Hn = /*#__PURE__*/function () {
  "use strict";

  function Hn() {
    _classCallCheck(this, Hn);
  }

  _createClass(Hn, [{
    key: "getClassName",
    value: function getClassName() {
      return this.constructor.className;
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t);
    }
  }]);

  return Hn;
}();

var jn = /*#__PURE__*/function () {
  "use strict";

  function jn() {
    _classCallCheck(this, jn);

    this.classNameMap = {};
  }

  _createClass(jn, null, [{
    key: "getMap",
    value: function getMap() {
      return null == jn.instance && (jn.instance = new jn()), jn.instance;
    }
  }, {
    key: "register",
    value: function register(e) {
      jn.getMap().classNameMap[e.className] = [e, e.fromConfig];
    }
  }]);

  return jn;
}();

function qn(e) {
  l(null != e.className, function () {
    return "Class being registered does not have the static className property defined.";
  }), l("string" == typeof e.className, function () {
    return "className is required to be a string, but got type " + typeof e.className;
  }), l(e.className.length > 0, function () {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), jn.register(e);
}

function Kn() {
  return wt;
}

function Xn() {
  return wt.memory();
}

function Yn(e, t) {
  return wt.tidy(e, t);
}

function Jn(e) {
  gt(e).forEach(function (e) {
    return e.dispose();
  });
}

function Zn(e) {
  return wt.keep(e);
}

function Qn(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return wt.registerBackend(e, t, n);
}

var es = At({
  add_: function add_(e, t) {
    var _ft3, _ft4;

    var n = Et(e, "a", "add"),
        s = Et(t, "b", "add");
    return (_ft3 = ft(n, s), _ft4 = _slicedToArray(_ft3, 2), n = _ft4[0], s = _ft4[1], _ft3), wt.runKernel("Add", {
      a: n,
      b: s
    });
  }
}),
    ts = At({
  floorDiv_: function floorDiv_(e, t) {
    var _ft5, _ft6;

    var n = Et(e, "a", "floorDiv"),
        s = Et(t, "b", "floorDiv");
    return (_ft5 = ft(n, s), _ft6 = _slicedToArray(_ft5, 2), n = _ft6[0], s = _ft6[1], _ft5), wt.runKernel("FloorDiv", {
      a: n,
      b: s
    });
  }
}),
    ns = At({
  div_: function div_(e, t) {
    var _ft7, _ft8;

    var n = Et(e, "a", "div"),
        s = Et(t, "b", "div");
    return (_ft7 = ft(n, s), _ft8 = _slicedToArray(_ft7, 2), n = _ft8[0], s = _ft8[1], _ft7), "int32" === n.dtype && "int32" === s.dtype ? ts(n, s) : wt.runKernel("RealDiv", {
      a: n,
      b: s
    }, {});
  }
}),
    ss = At({
  mul_: function mul_(e, t) {
    var _ft9, _ft10;

    var n = Et(e, "a", "mul"),
        s = Et(t, "b", "mul");
    return (_ft9 = ft(n, s), _ft10 = _slicedToArray(_ft9, 2), n = _ft10[0], s = _ft10[1], _ft9), wt.runKernel("Multiply", {
      a: n,
      b: s
    });
  }
}),
    rs = At({
  abs_: function abs_(e) {
    var t = Et(e, "x", "abs");
    return wt.runKernel("complex64" === t.dtype ? "ComplexAbs" : "Abs", {
      x: t
    });
  }
}),
    as = At({
  acos_: function acos_(e) {
    var t = Et(e, "x", "acos");
    return wt.runKernel("Acos", {
      x: t
    });
  }
}),
    is = At({
  acosh_: function acosh_(e) {
    var t = Et(e, "x", "acosh");
    return wt.runKernel("Acosh", {
      x: t
    });
  }
}),
    os = At({
  all_: function all_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "all", "bool");
    return wt.runKernel("All", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    ls = At({
  any_: function any_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "any", "bool");
    return wt.runKernel("Any", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    us = At({
  argMax_: function argMax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "argMax");
    return wt.runKernel("ArgMax", {
      x: n
    }, {
      axis: t
    });
  }
}),
    cs = At({
  argMin_: function argMin_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "argMin");
    return wt.runKernel("ArgMin", {
      x: n
    }, {
      axis: t
    });
  }
}),
    hs = At({
  asin_: function asin_(e) {
    var t = Et(e, "x", "asin");
    return wt.runKernel("Asin", {
      x: t
    });
  }
}),
    ds = At({
  asinh_: function asinh_(e) {
    var t = Et(e, "x", "asinh");
    return wt.runKernel("Asinh", {
      x: t
    });
  }
}),
    ps = At({
  atan_: function atan_(e) {
    var t = Et(e, "x", "atan");
    return wt.runKernel("Atan", {
      x: t
    });
  }
}),
    fs = At({
  atan2_: function atan2_(e, t) {
    var _ft11, _ft12;

    var n = Et(e, "a", "atan2"),
        s = Et(t, "b", "atan2");
    return (_ft11 = ft(n, s), _ft12 = _slicedToArray(_ft11, 2), n = _ft12[0], s = _ft12[1], _ft11), wt.runKernel("Atan2", {
      a: n,
      b: s
    });
  }
}),
    gs = At({
  atanh_: function atanh_(e) {
    var t = Et(e, "x", "atanh");
    return wt.runKernel("Atanh", {
      x: t
    });
  }
});

function ms(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
  var a = arguments.length > 5 ? arguments[5] : undefined;
  return ys(e, [].concat(_toConsumableArray(t), [e[3]]), n, a, s, null, null, Ts(r));
}

function bs(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";

  var _vs = vs(t),
      _vs2 = _slicedToArray(_vs, 2),
      o = _vs2[0],
      l = _vs2[1];

  var u;
  if ("channelsLast" === i) u = [o, l, e[3], e[3]];else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat ".concat(i));
    u = [o, l, e[1], e[1]];
  }
  return ys(e, u, n, s, r, a, !1, i);
}

function xs(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NDHWC";

  var _Is = Is(t),
      _Is2 = _slicedToArray(_Is, 3),
      o = _Is2[0],
      l = _Is2[1],
      u = _Is2[2];

  var c, h;
  if ("NDHWC" === i) h = "channelsLast", c = [o, l, u, e[4], e[4]];else {
    if ("NCDHW" !== i) throw new Error("Unknown dataFormat ".concat(i));
    h = "channelsFirst", c = [o, l, u, e[1], e[1]];
  }
  return ks(e, c, n, s, r, !1, h, a);
}

function ys(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "channelsLast";
  var l = -1,
      u = -1,
      c = -1,
      h = -1;

  if ("channelsLast" === o) {
    var _e48 = _slicedToArray(e, 4);

    l = _e48[0];
    u = _e48[1];
    c = _e48[2];
    h = _e48[3];
  } else {
    if ("channelsFirst" !== o) throw new Error("Unknown dataFormat ".concat(o));

    var _e49 = _slicedToArray(e, 4);

    l = _e49[0];
    h = _e49[1];
    u = _e49[2];
    c = _e49[3];
  }

  var _t54 = _slicedToArray(t, 4),
      d = _t54[0],
      p = _t54[1],
      f = _t54[3],
      _vs3 = vs(n),
      _vs4 = _slicedToArray(_vs3, 2),
      g = _vs4[0],
      m = _vs4[1],
      _vs5 = vs(s),
      _vs6 = _slicedToArray(_vs5, 2),
      b = _vs6[0],
      x = _vs6[1],
      y = $s(d, b),
      k = $s(p, x),
      _ref7 = function (e, t, n, s, r, a, i, o, l) {
    var u, c, h;

    if ("number" == typeof e) {
      u = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        type: 0 === e ? "VALID" : "NUMBER"
      };

      var _r22 = function (e, t, n, s, r) {
        null == s && (s = ws(e, t, n));
        var a = e[1];
        return [Ns((e[0] - t + 2 * s) / n + 1, r), Ns((a - t + 2 * s) / n + 1, r)];
      }([t, n], a, s, e, o);

      c = _r22[0], h = _r22[1];
    } else if ("same" === e) {
      c = Math.ceil(t / s), h = Math.ceil(n / r);

      var _e50 = Math.max(0, (c - 1) * s + a - t),
          _o8 = Math.max(0, (h - 1) * r + i - n),
          _l4 = Math.floor(_e50 / 2),
          _d2 = _e50 - _l4,
          _p2 = Math.floor(_o8 / 2);

      u = {
        top: _l4,
        bottom: _d2,
        left: _p2,
        right: _o8 - _p2,
        type: "SAME"
      };
    } else if ("valid" === e) u = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      type: "VALID"
    }, c = Math.ceil((t - a + 1) / s), h = Math.ceil((n - i + 1) / r);else {
      if ("object" != typeof e) throw Error("Unknown padding parameter: ".concat(e));
      {
        var _d3 = "channelsLast" === l ? e[1][0] : e[2][0],
            _p3 = "channelsLast" === l ? e[1][1] : e[2][1],
            _f2 = "channelsLast" === l ? e[2][0] : e[3][0],
            _g2 = "channelsLast" === l ? e[2][1] : e[3][1];

        u = {
          top: _d3,
          bottom: _p3,
          left: _f2,
          right: _g2,
          type: 0 === _d3 && 0 === _p3 && 0 === _f2 && 0 === _g2 ? "VALID" : "EXPLICIT"
        }, c = Ns((t - a + _d3 + _p3) / s + 1, o), h = Ns((n - i + _f2 + _g2) / r + 1, o);
      }
    }

    return {
      padInfo: u,
      outHeight: c,
      outWidth: h
    };
  }(r, u, c, g, m, y, k, a, o),
      w = _ref7.padInfo,
      v = _ref7.outHeight,
      I = _ref7.outWidth,
      $ = i ? f * h : f;

  var N;
  return "channelsFirst" === o ? N = [l, $, v, I] : "channelsLast" === o && (N = [l, v, I, $]), {
    batchSize: l,
    dataFormat: o,
    inHeight: u,
    inWidth: c,
    inChannels: h,
    outHeight: v,
    outWidth: I,
    outChannels: $,
    padInfo: w,
    strideHeight: g,
    strideWidth: m,
    filterHeight: d,
    filterWidth: p,
    effectiveFilterHeight: y,
    effectiveFilterWidth: k,
    dilationHeight: b,
    dilationWidth: x,
    inShape: e,
    outShape: N,
    filterShape: t
  };
}

function ks(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";
  var o = arguments.length > 7 ? arguments[7] : undefined;
  var l = -1,
      u = -1,
      c = -1,
      h = -1,
      d = -1;

  if ("channelsLast" === i) {
    var _e51 = _slicedToArray(e, 5);

    l = _e51[0];
    u = _e51[1];
    c = _e51[2];
    h = _e51[3];
    d = _e51[4];
  } else {
    if ("channelsFirst" !== i) throw new Error("Unknown dataFormat ".concat(i));

    var _e52 = _slicedToArray(e, 5);

    l = _e52[0];
    d = _e52[1];
    u = _e52[2];
    c = _e52[3];
    h = _e52[4];
  }

  var _t55 = _slicedToArray(t, 5),
      p = _t55[0],
      f = _t55[1],
      g = _t55[2],
      m = _t55[4],
      _Is3 = Is(n),
      _Is4 = _slicedToArray(_Is3, 3),
      b = _Is4[0],
      x = _Is4[1],
      y = _Is4[2],
      _Is5 = Is(s),
      _Is6 = _slicedToArray(_Is5, 3),
      k = _Is6[0],
      w = _Is6[1],
      v = _Is6[2],
      I = $s(p, k),
      $ = $s(f, w),
      N = $s(g, v),
      _ref8 = function (e, t, n, s, r, a, i, o, l, u, c) {
    var h, d, p, f;

    if ("number" == typeof e) {
      h = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        front: e,
        back: e,
        type: 0 === e ? "VALID" : "NUMBER"
      };

      var _a11 = function (e, t, n, s, r, a) {
        null == r && (r = ws(e, t, s));
        var i = e[1],
            o = e[2];
        return [Ns((e[0] - t + 2 * r) / s + 1, a), Ns((i - t + 2 * r) / s + 1, a), Ns((o - t + 2 * r) / s + 1, a), 1];
      }([t, n, s, 1], o, 0, r, e, c);

      d = _a11[0], p = _a11[1], f = _a11[2];
    } else if ("same" === e) {
      d = Math.ceil(t / r), p = Math.ceil(n / a), f = Math.ceil(s / i);

      var _e53 = (d - 1) * r + o - t,
          _c2 = (p - 1) * a + l - n,
          _g3 = (f - 1) * i + u - s,
          _m2 = Math.floor(_e53 / 2),
          _b2 = _e53 - _m2,
          _x21 = Math.floor(_c2 / 2),
          _y2 = _c2 - _x21,
          _k2 = Math.floor(_g3 / 2);

      h = {
        top: _x21,
        bottom: _y2,
        left: _k2,
        right: _g3 - _k2,
        front: _m2,
        back: _b2,
        type: "SAME"
      };
    } else {
      if ("valid" !== e) throw Error("Unknown padding parameter: ".concat(e));
      h = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      }, d = Math.ceil((t - o + 1) / r), p = Math.ceil((n - l + 1) / a), f = Math.ceil((s - u + 1) / i);
    }

    return {
      padInfo: h,
      outDepth: d,
      outHeight: p,
      outWidth: f
    };
  }(r, u, c, h, b, x, y, I, $, N, o),
      C = _ref8.padInfo,
      S = _ref8.outDepth,
      T = _ref8.outHeight,
      E = _ref8.outWidth,
      R = a ? m * d : m;

  var A;
  return "channelsFirst" === i ? A = [l, R, S, T, E] : "channelsLast" === i && (A = [l, S, T, E, R]), {
    batchSize: l,
    dataFormat: i,
    inDepth: u,
    inHeight: c,
    inWidth: h,
    inChannels: d,
    outDepth: S,
    outHeight: T,
    outWidth: E,
    outChannels: R,
    padInfo: C,
    strideDepth: b,
    strideHeight: x,
    strideWidth: y,
    filterDepth: p,
    filterHeight: f,
    filterWidth: g,
    effectiveFilterDepth: I,
    effectiveFilterHeight: $,
    effectiveFilterWidth: N,
    dilationDepth: k,
    dilationHeight: w,
    dilationWidth: v,
    inShape: e,
    outShape: A,
    filterShape: t
  };
}

function ws(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var r = $s(t, s);
  return Math.floor((e[0] * (n - 1) - n + r) / 2);
}

function vs(e) {
  return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e;
}

function Is(e) {
  return "number" == typeof e ? [e, e, e] : e;
}

function $s(e, t) {
  return t <= 1 ? e : e + (e - 1) * (t - 1);
}

function Ns(e, t) {
  if (!t) return Math.trunc(e);

  switch (t) {
    case "round":
      return Math.round(e);

    case "ceil":
      return Math.ceil(e);

    case "floor":
      return Math.floor(e);

    default:
      throw new Error("Unknown roundingMode ".concat(t));
  }
}

function Cs(e) {
  var _vs7 = vs(e),
      _vs8 = _slicedToArray(_vs7, 3),
      t = _vs8[0],
      n = _vs8[1],
      s = _vs8[2];

  return 1 === t && 1 === n && 1 === s;
}

function Ss(e, t) {
  return Cs(e) || Cs(t);
}

function Ts(e) {
  if ("NHWC" === e) return "channelsLast";
  if ("NCHW" === e) return "channelsFirst";
  throw new Error("Unknown dataFormat ".concat(e));
}

var Es = At({
  reshape_: function reshape_(e, t) {
    var n = Et(e, "x", "reshape", "string_or_numeric");
    return wt.runKernel("Reshape", {
      x: n
    }, {
      shape: t
    });
  }
}),
    Rs = At({
  avgPool_: function avgPool_(e, t, n, s, r) {
    var a = Et(e, "x", "avgPool", "float32");
    l(Ss(n, 1), function () {
      return "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '1'");
    });
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === i.rank, function () {
      return "Error in avgPool: x must be rank 4 but got rank ".concat(i.rank, ".");
    }), null != r && l(f(s), function () {
      return "Error in avgPool: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, ".");
    });
    var u = wt.runKernel("AvgPool", {
      x: i
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r
    });
    return u = pn(u, a.dtype), o ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    As = At({
  avgPool3d_: function avgPool3d_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NDHWC";
    var i = Et(e, "x", "avgPool3d", "float32");
    var o = i,
        u = !1;
    4 === i.rank && (u = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === o.rank, function () {
      return "Error in avgPool3d: x must be rank 5 but got rank ".concat(o.rank, ".");
    }), l("NDHWC" === a, function () {
      return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(a);
    }), null != r && l(f(s), function () {
      return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, ".");
    });
    var c = wt.runKernel("AvgPool3D", {
      x: o
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r,
      dataFormat: a
    });
    return c = pn(c, o.dtype), u ? Es(c, [c.shape[1], c.shape[2], c.shape[3], c.shape[4]]) : c;
  }
}),
    Fs = At({
  concat_: function concat_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    l(e.length >= 1, function () {
      return "Pass at least one tensor to concat";
    });
    var n = Rt(e, "tensors", "concat", "string_or_numeric");
    return "complex64" === n[0].dtype && n.forEach(function (e) {
      if ("complex64" !== e.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype, ". "));
    }), 1 === n.length ? fn(n[0]) : wt.runKernel("Concat", n, {
      axis: t
    });
  }
}),
    Ds = At({
  sigmoid_: function sigmoid_(e) {
    var t = Et(e, "x", "sigmoid");
    return wt.runKernel("Sigmoid", {
      x: t
    });
  }
}),
    _s = At({
  slice_: function slice_(e, t, n) {
    var s = Et(e, "x", "slice", "string_or_numeric");
    if (0 === s.rank) throw new Error("Slicing scalar is not possible");
    return wt.runKernel("Slice", {
      x: s
    }, {
      begin: t,
      size: n
    });
  }
}),
    Os = At({
  tanh_: function tanh_(e) {
    var t = Et(e, "x", "tanh");
    return wt.runKernel("Tanh", {
      x: t
    });
  }
}),
    Ms = At({
  batchToSpaceND_: function batchToSpaceND_(e, t, n) {
    var s = Et(e, "x", "batchToSpaceND"),
        r = t.reduce(function (e, t) {
      return e * t;
    });
    return l(s.rank >= 1 + t.length, function () {
      return "input rank is ".concat(s.rank, " but should be > than blockShape.length ").concat(t.length);
    }), l(n.length === t.length, function () {
      return "crops.length is ".concat(n.length, " but should be equal to blockShape.length  ").concat(t.length);
    }), l(s.shape[0] % r == 0, function () {
      return "input tensor batch is ".concat(s.shape[0], " but is not divisible by the product of the elements of blockShape ").concat(t.join(" * "), " === ").concat(r);
    }), wt.runKernel("BatchToSpaceND", {
      x: s
    }, {
      blockShape: t,
      crops: n
    });
  }
}),
    Ls = At({
  batchNorm_: function batchNorm_(e, t, n, s, r, a) {
    null == a && (a = .001);
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(o.rank === u.rank, function () {
      return "Batch normalization gradient requires mean and variance to have equal ranks.";
    }), l(null == h || o.rank === h.rank, function () {
      return "Batch normalization gradient requires mean and offset to have equal ranks.";
    }), l(null == c || o.rank === c.rank, function () {
      return "Batch normalization gradient requires mean and scale to have equal ranks.";
    });

    var d = function (e) {
      var t;
      return t = 0 === e.rank || 1 === e.rank ? Es(e, [1, 1, 1, e.size]) : 2 === e.rank ? Es(e, [1, 1, e.shape[0], e.shape[1]]) : 3 === e.rank ? Es(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : e, t;
    }(i),
        p = wt.runKernel("FusedBatchNorm", {
      x: d,
      scale: c,
      offset: h,
      mean: o,
      variance: u
    }, {
      varianceEpsilon: a
    });

    return Es(p, i.shape);
  }
}),
    zs = At({
  batchNorm2d_: function batchNorm2d_(e, t, n, s, r, a) {
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(2 === i.rank, function () {
      return "Error in batchNorm2D: x must be rank 2 but got rank ".concat(i.rank, ".");
    }), l(2 === o.rank || 1 === o.rank, function () {
      return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ".concat(o.rank, ".");
    }), l(2 === u.rank || 1 === u.rank, function () {
      return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ".concat(u.rank, ".");
    }), null != c && l(2 === c.rank || 1 === c.rank, function () {
      return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ".concat(c.rank, ".");
    }), null != h && l(2 === h.rank || 1 === h.rank, function () {
      return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ".concat(h.rank, ".");
    }), Ls(i, o, u, h, c, a);
  }
}),
    Bs = At({
  batchNorm3d_: function batchNorm3d_(e, t, n, s, r, a) {
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(3 === i.rank, function () {
      return "Error in batchNorm3D: x must be rank 3 but got rank ".concat(i.rank, ".");
    }), l(3 === o.rank || 1 === o.rank, function () {
      return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ".concat(o.rank, ".");
    }), l(3 === u.rank || 1 === u.rank, function () {
      return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ".concat(u.rank, ".");
    }), null != c && l(3 === c.rank || 1 === c.rank, function () {
      return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ".concat(c.rank, ".");
    }), null != h && l(3 === h.rank || 1 === h.rank, function () {
      return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ".concat(h.rank, ".");
    }), Ls(i, o, u, h, c, a);
  }
}),
    Ps = At({
  batchNorm4d_: function batchNorm4d_(e, t, n, s, r, a) {
    var i = Et(e, "x", "batchNorm"),
        o = Et(t, "mean", "batchNorm"),
        u = Et(n, "variance", "batchNorm");
    var c, h;
    return null != r && (c = Et(r, "scale", "batchNorm")), null != s && (h = Et(s, "offset", "batchNorm")), l(4 === i.rank, function () {
      return "Error in batchNorm4D: x must be rank 4 but got rank ".concat(i.rank, ".");
    }), l(4 === o.rank || 1 === o.rank, function () {
      return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ".concat(o.rank, ".");
    }), l(4 === u.rank || 1 === u.rank, function () {
      return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ".concat(u.rank, ".");
    }), null != c && l(4 === c.rank || 1 === c.rank, function () {
      return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ".concat(c.rank, ".");
    }), null != h && l(4 === h.rank || 1 === h.rank, function () {
      return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ".concat(h.rank, ".");
    }), Ls(i, o, u, h, c, a);
  }
}),
    Ws = At({
  bincount_: function bincount_(e, t, n) {
    var s = Et(e, "x", "bincount"),
        r = Et(t, "weights", "bincount");
    return l("int32" === s.dtype, function () {
      return "Error in bincount: input dtype must be int32, but got ".concat(s.dtype);
    }), l(n >= 0, function () {
      return "size must be non-negative, but got ".concat(n, ".");
    }), l(r.size === s.size || 0 === r.size, function () {
      return "Error in bincount: weights must have the same size as input or0-length, but got input shape: ".concat(s.shape, ", weights shape: ").concat(r.shape, ".");
    }), wt.runKernel("Bincount", {
      x: s,
      weights: r
    }, {
      size: n
    });
  }
}),
    Us = At({
  broadcastTo_: function broadcastTo_(e, t) {
    var n = Et(e, "broadcastTo", "x");
    var s = n.shape;
    if (t.some(function (e) {
      return !(e > 0) || e % 1 != 0;
    })) throw new Error("broadcastTo(): Invalid broadcast shape [".concat(t, "]."));
    if (t.length < n.rank) throw new Error("broadcastTo(): shape.length=".concat(t.length, " < input.rank=").concat(n.rank, "."));

    if (t.length > n.rank) {
      var _e54 = n.shape.slice();

      for (; _e54.length < t.length;) {
        _e54.unshift(1);
      }

      n = Es(n, _e54);
    }

    var r = n.shape,
        a = Array.from(t);

    for (var _e55 = t.length - 1; _e55 >= 0; _e55--) {
      if (r[_e55] === t[_e55]) a[_e55] = 1;else if (1 !== n.shape[_e55]) throw new Error("broadcastTo(): [".concat(s, "] cannot be broadcast to [").concat(t, "]."));
    }

    return 0 === a.map(function (e, t) {
      return e > 1 ? t : -1;
    }).filter(function (e) {
      return e >= 0;
    }).length ? fn(n) : wt.runKernel("Tile", {
      x: n
    }, {
      reps: a
    });
  }
}),
    Vs = At({
  ceil_: function ceil_(e) {
    var t = Et(e, "x", "ceil");
    return wt.runKernel("Ceil", {
      x: t
    });
  }
}),
    Gs = At({
  clipByValue_: function clipByValue_(e, t, n) {
    var s = Et(e, "x", "clipByValue");
    return l(t <= n, function () {
      return "Error in clip: min (".concat(t, ") must be less than or equal to max (").concat(n, ").");
    }), wt.runKernel("ClipByValue", {
      x: s
    }, {
      clipValueMin: t,
      clipValueMax: n
    });
  }
}),
    Hs = At({
  concat1d_: function concat1d_(e) {
    return Fs(e, 0);
  }
}),
    js = At({
  concat2d_: function concat2d_(e, t) {
    return Fs(e, t);
  }
}),
    qs = At({
  concat3d_: function concat3d_(e, t) {
    return Fs(e, t);
  }
}),
    Ks = At({
  concat4d_: function concat4d_(e, t) {
    return Fs(e, t);
  }
}),
    Xs = At({
  conv2d_: function conv2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Et(e, "x", "conv2d"),
        u = Et(t, "filter", "conv2d");
    var c = o,
        h = !1;
    3 === o.rank && (h = !0, c = Es(o, [1, o.shape[0], o.shape[1], o.shape[2]])), l(4 === c.rank, function () {
      return "Error in conv2d: input must be rank 4, but got rank ".concat(c.rank, ".");
    }), l(4 === u.rank, function () {
      return "Error in conv2d: filter must be rank 4, but got rank ".concat(u.rank, ".");
    }), null != i && l(f(s), function () {
      return "Error in conv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".");
    });
    var d = "NHWC" === r ? c.shape[3] : c.shape[1];
    l(d === u.shape[2], function () {
      return "Error in conv2d: depth of input (".concat(d, ") must match input depth for filter ").concat(u.shape[2], ".");
    }), l(Ss(n, a), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'");
    });
    var p = wt.runKernel("Conv2D", {
      x: c,
      filter: u
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i
    });
    return h ? Es(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
}),
    Ys = At({
  conv1d_: function conv1d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Et(e, "x", "conv1d"),
        u = Et(t, "filter", "conv1d");
    var c = o,
        h = !1;
    2 === o.rank && (h = !0, c = Es(o, [1, o.shape[0], o.shape[1]])), l(3 === c.rank, function () {
      return "Error in conv1d: input must be rank 3, but got rank ".concat(c.rank, ".");
    }), l(3 === u.rank, function () {
      return "Error in conv1d: filter must be rank 3, but got rank ".concat(u.rank, ".");
    }), null != i && l(f(s), function () {
      return "Error in conv1d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".");
    }), l(c.shape[2] === u.shape[1], function () {
      return "Error in conv1d: depth of input (".concat(c.shape[2], ") must match input depth for filter ").concat(u.shape[1], ".");
    }), l(Ss(n, a), function () {
      return "Error in conv1D: Either stride or dilation must be 1. Got stride ".concat(n, " and dilation '").concat(a, "'");
    }), l("NWC" === r, function () {
      return "Error in conv1d: got dataFormat of ".concat(r, " but only NWC is currently supported.");
    });
    var d = Es(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
        p = Es(c, [c.shape[0], 1, c.shape[1], c.shape[2]]),
        g = Xs(p, d, [1, n], s, "NHWC", [1, a], i);
    return Es(g, h ? [g.shape[2], g.shape[3]] : [g.shape[0], g.shape[2], g.shape[3]]);
  }
}),
    Js = At({
  conv2DBackpropInput_: function conv2DBackpropInput_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = arguments.length > 6 ? arguments[6] : undefined;
    l(e.length === t.rank, function () {
      return "Length of inShape (".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match");
    });
    var o = e,
        u = t,
        c = !1;
    3 === t.rank && (c = !0, u = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]]), o = [1, e[0], e[1], e[2]]), l(4 === o.length, function () {
      return "Error in conv2dDerInput: inShape must be length 4, but got length ".concat(o.length, ".");
    }), l(4 === u.rank, function () {
      return "Error in conv2dDerInput: dy must be rank 4, but got rank ".concat(u.rank);
    }), l(4 === n.rank, function () {
      return "Error in conv2dDerInput: filter must be rank 4, but got rank ".concat(n.rank);
    });
    var h = "NHWC" === a ? o[3] : o[1],
        d = "NHWC" === a ? u.shape[3] : u.shape[1];
    l(h === n.shape[2], function () {
      return "Error in conv2dDerInput: depth of input (".concat(h, ") must match input depth for filter ").concat(n.shape[2], ".");
    }), l(d === n.shape[3], function () {
      return "Error in conv2dDerInput: depth of output (".concat(d, ") must match output depth for filter ").concat(n.shape[3], ".");
    }), null != i && l(f(r), function () {
      return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(r, ".");
    });
    var p = wt.runKernel("Conv2DBackpropInput", {
      dy: u,
      filter: n
    }, {
      strides: s,
      pad: r,
      dataFormat: a,
      dimRoundingMode: i,
      inputShape: o
    });
    return c ? Es(p, [p.shape[1], p.shape[2], p.shape[3]]) : p;
  }
}),
    Zs = At({
  conv2dTranspose_: function conv2dTranspose_(e, t, n, s, r, a) {
    var i = Et(e, "x", "conv2dTranspose"),
        o = Et(t, "filter", "conv2dTranspose");
    return Js(n, i, o, s, r, "NHWC", a);
  }
}),
    Qs = At({
  conv3d_: function conv3d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NDHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1, 1];
    var i = Et(e, "x", "conv3d"),
        o = Et(t, "filter", "conv3d");
    var u = i,
        c = !1;
    4 === i.rank && (c = !0, u = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === u.rank, function () {
      return "Error in conv3d: input must be rank 5, but got rank ".concat(u.rank, ".");
    }), l(5 === o.rank, function () {
      return "Error in conv3d: filter must be rank 5, but got rank ".concat(o.rank, ".");
    }), l(u.shape[4] === o.shape[3], function () {
      return "Error in conv3d: depth of input (".concat(u.shape[4], ") must match input depth for filter ").concat(o.shape[3], ".");
    }), l(Ss(n, a), function () {
      return "Error in conv3D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'");
    }), l("NDHWC" === r, function () {
      return "Error in conv3d: got dataFormat of ".concat(r, " but only NDHWC is currently supported.");
    });
    var h = wt.runKernel("Conv3D", {
      x: u,
      filter: o
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a
    });
    return c ? Es(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
  }
}),
    er = At({
  conv3DBackpropInput_: function conv3DBackpropInput_(e, t, n, s, r) {
    l(e.length === t.rank, function () {
      return "Length of inShape (".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match");
    });
    var a = e,
        i = t,
        o = !1;
    4 === t.rank && (o = !0, i = Es(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), a = [1, e[0], e[1], e[2], e[3]]);
    var u = a[4],
        c = i.shape[4];
    l(5 === a.length, function () {
      return "Error in conv3dDerInput: inShape must be length 5, but got length ".concat(a.length, ".");
    }), l(5 === i.rank, function () {
      return "Error in conv3dDerInput: dy must be rank 5, but got rank ".concat(i.rank);
    }), l(5 === n.rank, function () {
      return "Error in conv3dDerInput: filter must be rank 5, but got rank ".concat(n.rank);
    }), l(u === n.shape[3], function () {
      return "Error in conv3dDerInput: depth of input (".concat(u, ") must match input depth for filter ").concat(n.shape[3], ".");
    }), l(c === n.shape[4], function () {
      return "Error in conv3dDerInput: depth of output (".concat(c, ") must match output depth for filter ").concat(n.shape[4], ".");
    });
    var h = wt.runKernel("Conv3DBackpropInputV2", {
      dy: i,
      filter: n
    }, {
      pad: r,
      strides: s,
      inputShape: a
    });
    return o ? Es(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h;
  }
}),
    tr = At({
  conv3dTranspose_: function conv3dTranspose_(e, t, n, s, r) {
    var a = Et(e, "x", "conv3dTranspose"),
        i = Et(t, "filter", "conv3dTranspose");
    return er(n, a, i, s, r);
  }
}),
    nr = At({
  cos_: function cos_(e) {
    var t = Et(e, "x", "cos");
    return wt.runKernel("Cos", {
      x: t
    });
  }
}),
    sr = At({
  cosh_: function cosh_(e) {
    var t = Et(e, "x", "cosh");
    return wt.runKernel("Cosh", {
      x: t
    });
  }
}),
    rr = At({
  cumsum_: function cumsum_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "x", "cumsum");
    return wt.runKernel("Cumsum", {
      x: r
    }, {
      axis: t,
      exclusive: n,
      reverse: s
    });
  }
}),
    ar = At({
  depthToSpace_: function depthToSpace_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "NHWC";
    var s = Et(e, "x", "depthToSpace"),
        r = "NHWC" === n ? s.shape[1] : s.shape[2],
        a = "NHWC" === n ? s.shape[2] : s.shape[3],
        i = "NHWC" === n ? s.shape[3] : s.shape[1];
    return l(r * t >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n    ".concat(r, " and ").concat(t, "  for depthToSpace with input shape\n    ").concat(s.shape);
    }), l(a * t >= 0, function () {
      return "Negative dimension size caused by overflow when multiplying\n    ".concat(a, " and ").concat(t, " for depthToSpace with input shape\n        ").concat(s.shape);
    }), l(i % (t * t) == 0, function () {
      return "Dimension size must be evenly divisible by ".concat(t * t, " but is ").concat(i, " for depthToSpace with input shape ").concat(s.shape);
    }), wt.runKernel("DepthToSpace", {
      x: s
    }, {
      blockSize: t,
      dataFormat: n
    });
  }
}),
    ir = At({
  depthwiseConv2d_: function depthwiseConv2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "NHWC";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = Et(e, "x", "depthwiseConv2d"),
        u = Et(t, "filter", "depthwiseConv2d");
    var c = o,
        h = !1;
    3 === o.rank && (h = !0, c = Es(o, [1, o.shape[0], o.shape[1], o.shape[2]])), l(4 === c.rank, function () {
      return "Error in depthwiseConv2d: input must be rank 4, but got rank ".concat(c.rank, ".");
    }), l(4 === u.rank, function () {
      return "Error in depthwiseConv2d: filter must be rank 4, but got rank ".concat(u.rank, ".");
    }), l(c.shape[3] === u.shape[2], function () {
      return "Error in depthwiseConv2d: number of input channels (".concat(c.shape[3], ") must match the inChannels dimension in filter ").concat(u.shape[2], ".");
    }), null != i && l(f(s), function () {
      return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".");
    });
    var d = wt.runKernel("DepthwiseConv2dNative", {
      x: c,
      filter: u
    }, {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i
    });
    return h ? Es(d, [d.shape[1], d.shape[2], d.shape[3]]) : d;
  }
}),
    or = At({
  dilation2d_: function dilation2d_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [1, 1];
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = Et(e, "x", "dilation2d"),
        o = Et(t, "filter", "dilation2d");
    l(3 === i.rank || 4 === i.rank, function () {
      return "Error in dilation2d: input must be rank 3 or 4, but got rank ".concat(i.rank, ".");
    }), l(3 === o.rank, function () {
      return "Error in dilation2d: filter must be rank 3, but got rank ".concat(o.rank, ".");
    }), l("NHWC" === a, function () {
      return "Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ".concat(a);
    });
    var u = i,
        c = !1;
    3 === i.rank && (u = Es(i, [1, i.shape[0], i.shape[1], i.shape[2]]), c = !0);
    var h = wt.runKernel("Dilation2D", {
      x: u,
      filter: o
    }, {
      strides: n,
      pad: s,
      dilations: r
    });
    return c ? Es(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
});

function lr(e, t) {
  var n = e.length,
      s = [];

  for (var _r23 = 0; _r23 < n; _r23++) {
    var _a12 = n - 1 - _r23,
        _i11 = e[_a12] || 1;

    (t[t.length - 1 - _r23] || 1) > 1 && 1 === _i11 && s.unshift(_a12);
  }

  return s;
}

function ur(e, t) {
  var n = [];

  for (var _s31 = 0; _s31 < t.length; _s31++) {
    var _r24 = e[e.length - _s31 - 1],
        _a13 = t.length - _s31 - 1,
        _i12 = t[_a13];

    (null == _r24 || 1 === _r24 && _i12 > 1) && n.unshift(_a13);
  }

  return n;
}

function cr(e, t) {
  var n = [],
      s = Math.max(e.length, t.length);

  for (var _r25 = 0; _r25 < s; _r25++) {
    var _s32 = e[e.length - _r25 - 1];
    null == _s32 && (_s32 = 1);
    var _a14 = t[t.length - _r25 - 1];
    if (null == _a14 && (_a14 = 1), 1 === _s32) n.unshift(_a14);else if (1 === _a14) n.unshift(_s32);else {
      if (_s32 !== _a14) throw Error("Operands could not be broadcast together with shapes ".concat(e, " and ").concat(t, "."));
      n.unshift(_s32);
    }
  }

  return n;
}

var hr = At({
  equal_: function equal_(e, t) {
    var _ft13, _ft14;

    var n = Et(e, "a", "equal", "string_or_numeric"),
        s = Et(t, "b", "equal", "string_or_numeric");
    return (_ft13 = ft(n, s), _ft14 = _slicedToArray(_ft13, 2), n = _ft14[0], s = _ft14[1], _ft13), cr(n.shape, s.shape), wt.runKernel("Equal", {
      a: n,
      b: s
    });
  }
}),
    dr = At({
  where_: function where_(e, t, n) {
    var s = Et(t, "a", "where"),
        r = Et(n, "b", "where"),
        a = Et(e, "condition", "where", "bool"),
        i = cr(cr(a.shape, s.shape), r.shape),
        o = Us(a, i),
        l = Us(s, i),
        u = Us(r, i);
    return wt.runKernel("Select", {
      condition: o,
      t: l,
      e: u
    });
  }
}),
    pr = At({
  zerosLike_: function zerosLike_(e) {
    var t = Et(e, "x", "zerosLike");
    return wt.runKernel("ZerosLike", {
      x: t
    });
  }
}),
    fr = At({
  divNoNan_: function divNoNan_(e, t) {
    var n = Et(e, "a", "div"),
        s = Et(t, "b", "div");

    var _ft15 = ft(n, s);

    var _ft16 = _slicedToArray(_ft15, 2);

    n = _ft16[0];
    s = _ft16[1];
    var r = ns(n, s),
        a = pr(r),
        i = hr(s, a);
    return dr(i, a, r);
  }
}),
    gr = At({
  dot_: function dot_(e, t) {
    var n = Et(e, "t1", "dot"),
        s = Et(t, "t2", "dot");
    l(!(1 !== n.rank && 2 !== n.rank || 1 !== s.rank && 2 !== s.rank), function () {
      return "Error in dot: inputs must all be rank 1 or 2, but got ranks ".concat(n.rank, " and ").concat(s.rank, ".");
    });
    var r = 1 === n.rank ? n.size : n.shape[1],
        a = 1 === s.rank ? s.size : s.shape[0];

    if (l(r === a, function () {
      return "Error in dot: inner dimensions of inputs must match, but got ".concat(r, " and ").concat(a, ".");
    }), 1 === n.rank && 1 === s.rank) {
      var _e56 = Es(n, [1, -1]),
          _t56 = Es(s, [-1, 1]),
          _r26 = vn(_e56, _t56);

      return Es(_r26, []);
    }

    if (1 === n.rank && 2 === s.rank) {
      var _e57 = Es(n, [1, -1]),
          _t57 = Es(s, [s.shape[0], s.shape[1]]),
          _r27 = vn(_e57, _t57);

      return Es(_r27, [_r27.size]);
    }

    if (2 === n.rank && 1 === s.rank) {
      var _e58 = Es(s, [-1, 1]),
          _t58 = vn(n, _e58);

      return Es(_t58, [_t58.size]);
    }

    {
      var _e59 = Es(s, [s.shape[0], s.shape[1]]);

      return vn(n, _e59);
    }
  }
}),
    mr = At({
  elu_: function elu_(e) {
    var t = Et(e, "x", "elu");
    return wt.runKernel("Elu", {
      x: t
    });
  }
}),
    br = At({
  erf_: function erf_(e) {
    var t = Et(e, "x", "erf");
    return l("int32" === t.dtype || "float32" === t.dtype, function () {
      return "Input dtype must be `int32` or `float32`.";
    }), "int32" === t.dtype && (t = pn(t, "float32")), wt.runKernel("Erf", {
      x: t
    });
  }
}),
    xr = At({
  exp_: function exp_(e) {
    var t = Et(e, "x", "exp");
    return wt.runKernel("Exp", {
      x: t
    });
  }
}),
    yr = At({
  expandDims_: function expandDims_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "expandDims", "string_or_numeric");
    return l(t <= n.rank, function () {
      return "Axis must be <= rank of the tensor";
    }), wt.runKernel("ExpandDims", {
      input: n
    }, {
      dim: t
    });
  }
}),
    kr = At({
  expm1_: function expm1_(e) {
    var t = Et(e, "x", "expm1");
    return wt.runKernel("Expm1", {
      x: t
    });
  }
}),
    wr = At({
  tile_: function tile_(e, t) {
    var n = Et(e, "x", "tile", "string_or_numeric");
    return l(n.rank === t.length, function () {
      return "Error in transpose: rank of input ".concat(n.rank, " must match length of reps ").concat(t, ".");
    }), wt.runKernel("Tile", {
      x: n
    }, {
      reps: t
    });
  }
}),
    vr = At({
  eye_: function eye_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
    null == t && (t = e);
    var r = dn([e, t], s),
        a = e <= t ? e : t;

    for (var _e60 = 0; _e60 < a; ++_e60) {
      r.set(1, _e60, _e60);
    }

    var i = Es(r.toTensor(), [e, t]);
    if (null == n) return i;
    if (1 === n.length) return wr(yr(i, 0), [n[0], 1, 1]);
    if (2 === n.length) return wr(yr(yr(i, 0), 0), [n[0], n[1], 1, 1]);
    if (3 === n.length) return wr(yr(yr(yr(i, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
    throw new Error("eye() currently supports only 1D and 2D batchShapes, but received ".concat(n.length, "D."));
  }
});

function Ir(e, t, n) {
  return wt.runKernel("Fill", {}, {
    shape: e,
    value: t,
    dtype: n
  });
}

var $r = At({
  floor_: function floor_(e) {
    var t = Et(e, "x", "floor");
    return wt.runKernel("Floor", {
      x: t
    });
  }
}),
    Nr = At({
  gather_: function gather_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = Et(e, "x", "gather"),
        a = Et(t, "indices", "gather", "int32");
    return wt.runKernel("GatherV2", {
      x: r,
      indices: a
    }, {
      axis: n,
      batchDims: s
    });
  }
}),
    Cr = At({
  greater_: function greater_(e, t) {
    var _ft17, _ft18;

    var n = Et(e, "a", "greater", "string_or_numeric"),
        s = Et(t, "b", "greater", "string_or_numeric");
    return (_ft17 = ft(n, s), _ft18 = _slicedToArray(_ft17, 2), n = _ft18[0], s = _ft18[1], _ft17), cr(n.shape, s.shape), wt.runKernel("Greater", {
      a: n,
      b: s
    });
  }
}),
    Sr = At({
  greaterEqual_: function greaterEqual_(e, t) {
    var _ft19, _ft20;

    var n = Et(e, "a", "greaterEqual", "string_or_numeric"),
        s = Et(t, "b", "greaterEqual", "string_or_numeric");
    return (_ft19 = ft(n, s), _ft20 = _slicedToArray(_ft19, 2), n = _ft20[0], s = _ft20[1], _ft19), cr(n.shape, s.shape), wt.runKernel("GreaterEqual", {
      a: n,
      b: s
    });
  }
}),
    Tr = At({
  imag_: function imag_(e) {
    var t = Et(e, "input", "imag");
    return wt.runKernel("Imag", {
      input: t
    });
  }
}),
    Er = At({
  isFinite_: function isFinite_(e) {
    var t = Et(e, "x", "isFinite");
    return wt.runKernel("IsFinite", {
      x: t
    });
  }
}),
    Rr = At({
  isInf_: function isInf_(e) {
    var t = Et(e, "x", "isInf");
    return wt.runKernel("IsInf", {
      x: t
    });
  }
}),
    Ar = At({
  isNaN_: function isNaN_(e) {
    var t = Et(e, "x", "isNaN");
    return wt.runKernel("IsNan", {
      x: t
    });
  }
}),
    Fr = At({
  leakyRelu_: function leakyRelu_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .2;
    var n = Et(e, "x", "leakyRelu");
    return wt.runKernel("LeakyRelu", {
      x: n
    }, {
      alpha: t
    });
  }
}),
    Dr = At({
  less_: function less_(e, t) {
    var _ft21, _ft22;

    var n = Et(e, "a", "less", "string_or_numeric"),
        s = Et(t, "b", "less", "string_or_numeric");
    return (_ft21 = ft(n, s), _ft22 = _slicedToArray(_ft21, 2), n = _ft22[0], s = _ft22[1], _ft21), cr(n.shape, s.shape), wt.runKernel("Less", {
      a: n,
      b: s
    });
  }
}),
    _r = At({
  lessEqual_: function lessEqual_(e, t) {
    var _ft23, _ft24;

    var n = Et(e, "a", "lessEqual", "string_or_numeric"),
        s = Et(t, "b", "lessEqual", "string_or_numeric");
    return (_ft23 = ft(n, s), _ft24 = _slicedToArray(_ft23, 2), n = _ft24[0], s = _ft24[1], _ft23), cr(n.shape, s.shape), wt.runKernel("LessEqual", {
      a: n,
      b: s
    });
  }
}),
    Or = At({
  localResponseNormalization_: function localResponseNormalization_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .5;
    var a = Et(e, "x", "localResponseNormalization");
    l(4 === a.rank || 3 === a.rank, function () {
      return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(a.rank, ".");
    }), l(f(t), function () {
      return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ".concat(t, ".");
    });
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
    var u = wt.runKernel("LRN", {
      x: i
    }, {
      depthRadius: t,
      bias: n,
      alpha: s,
      beta: r
    });
    return o ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Mr = At({
  log_: function log_(e) {
    var t = Et(e, "x", "log");
    return wt.runKernel("Log", {
      x: t
    });
  }
}),
    Lr = At({
  log1p_: function log1p_(e) {
    var t = Et(e, "x", "log1p");
    return wt.runKernel("Log1p", {
      x: t
    });
  }
});

function zr(e) {
  return wt.customGrad(e);
}

var Br = At({
  neg_: function neg_(e) {
    var t = Et(e, "x", "neg");
    return wt.runKernel("Neg", {
      x: t
    });
  }
}),
    Pr = At({
  softplus_: function softplus_(e) {
    var t = Et(e, "x", "softplus");
    return wt.runKernel("Softplus", {
      x: t
    });
  }
}),
    Wr = At({
  logSigmoid_: function logSigmoid_(e) {
    var t = Et(e, "x", "logSigmoid");
    return zr(function (e) {
      return {
        value: Br(Pr(Br(e))),
        gradFunc: function gradFunc(t) {
          return ss(t, Ds(Br(e)));
        }
      };
    })(t);
  }
}),
    Ur = At({
  max_: function max_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "max");
    return wt.runKernel("Max", {
      x: s
    }, {
      reductionIndices: t,
      keepDims: n
    });
  }
}),
    Vr = At({
  sub_: function sub_(e, t) {
    var _ft25, _ft26;

    var n = Et(e, "a", "sub"),
        s = Et(t, "b", "sub");
    return (_ft25 = ft(n, s), _ft26 = _slicedToArray(_ft25, 2), n = _ft26[0], s = _ft26[1], _ft25), wt.runKernel("Sub", {
      a: n,
      b: s
    });
  }
}),
    Gr = At({
  sum_: function sum_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "sum");
    return "bool" === s.dtype && (s = pn(s, "int32")), wt.runKernel("Sum", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    Hr = At({
  logSoftmax_: function logSoftmax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = Et(e, "logits", "logSoftmax");
    if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank, " and axis was ").concat(t));
    return zr(function (e, n) {
      var s = Ur(e, t, !0),
          r = Vr(e, s),
          a = Vr(pn(r, "float32"), Mr(Gr(xr(r), t, !0)));
      return n([a]), {
        value: a,
        gradFunc: function gradFunc(e, n) {
          var _n30 = _slicedToArray(n, 1),
              s = _n30[0],
              r = xr(s);

          return Vr(e, ss(Gr(e, t, !0), r));
        }
      };
    })(n);
  }
});

function jr(e, t) {
  for (var _n31 = 0; _n31 < e.length; ++_n31) {
    if (e[e.length - _n31 - 1] !== t - 1 - _n31) return !1;
  }

  return !0;
}

function qr(e, t, n) {
  var s = e.length + t.length,
      r = [];
  var a = 0,
      i = 0;

  for (var _o9 = 0; _o9 < s; _o9++) {
    -1 === n.indexOf(_o9) ? r.push(e[a++]) : r.push(t[i++]);
  }

  return r;
}

function Kr(e, t) {
  var n = [],
      s = e.length;

  for (var _r28 = 0; _r28 < s; _r28++) {
    -1 === t.indexOf(_r28) && n.push(e[_r28]);
  }

  return [n, t.map(function (t) {
    return e[t];
  })];
}

function Xr(e, t) {
  return qr(e, t.map(function (e) {
    return 1;
  }), t);
}

function Yr(e, t, n) {
  l(jr(t, n), function () {
    return "".concat(e, " supports only inner-most axes for now. Got axes ").concat(t, " and rank-").concat(n, " input.");
  });
}

function Jr(e, t) {
  if (jr(e, t)) return null;
  var n = [];

  for (var _s33 = 0; _s33 < t; ++_s33) {
    -1 === e.indexOf(_s33) && n.push(_s33);
  }

  return e.forEach(function (e) {
    return n.push(e);
  }), n;
}

function Zr(e) {
  return e.map(function (e, t) {
    return [t, e];
  }).sort(function (e, t) {
    return e[1] - t[1];
  }).map(function (e) {
    return e[0];
  });
}

function Qr(e, t) {
  var n = [];

  for (var _s34 = t - e; _s34 < t; ++_s34) {
    n.push(_s34);
  }

  return n;
}

var ea = At({
  logSumExp_: function logSumExp_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "logSumExp"),
        r = y(t, s.shape),
        a = Ur(s, r, !0),
        i = Vr(s, a),
        o = xr(i),
        l = Gr(o, r),
        u = Mr(l),
        c = es(Es(a, u.shape), u);

    if (n) {
      var _e61 = Xr(c.shape, r);

      return Es(c, _e61);
    }

    return c;
  }
}),
    ta = At({
  logicalAnd_: function logicalAnd_(e, t) {
    var n = Et(e, "a", "logicalAnd", "bool"),
        s = Et(t, "b", "logicalAnd", "bool");
    return cr(n.shape, s.shape), wt.runKernel("LogicalAnd", {
      a: n,
      b: s
    });
  }
}),
    na = At({
  logicalNot_: function logicalNot_(e) {
    var t = Et(e, "x", "logicalNot", "bool");
    return wt.runKernel("LogicalNot", {
      x: t
    });
  }
}),
    sa = At({
  logicalOr_: function logicalOr_(e, t) {
    var n = Et(e, "a", "logicalOr", "bool"),
        s = Et(t, "b", "logicalOr", "bool");
    return cr(n.shape, s.shape), wt.runKernel("LogicalOr", {
      a: n,
      b: s
    });
  }
}),
    ra = At({
  logicalXor_: function logicalXor_(e, t) {
    var n = Et(e, "a", "logicalXor", "bool"),
        s = Et(t, "b", "logicalXor", "bool");
    return cr(n.shape, s.shape), ta(sa(e, t), na(ta(e, t)));
  }
}),
    aa = At({
  maxPool_: function maxPool_(e, t, n, s, r) {
    var a = Et(e, "x", "maxPool");
    var i = a,
        o = !1;
    3 === a.rank && (o = !0, i = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === i.rank, function () {
      return "Error in maxPool: input must be rank 4 but got rank ".concat(i.rank, ".");
    }), l(Ss(n, 1), function () {
      return "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '1'");
    }), null != r && l(f(s), function () {
      return "Error in maxPool: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, ".");
    });
    var u = wt.runKernel("MaxPool", {
      x: i
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r
    });
    return o ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    ia = At({
  maxPool3d_: function maxPool3d_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NDHWC";
    var i = Et(e, "x", "maxPool3d");
    var o = i,
        u = !1;
    4 === i.rank && (u = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), l(5 === o.rank, function () {
      return "Error in maxPool3d: x must be rank 5 but got rank ".concat(o.rank, ".");
    }), l("NDHWC" === a, function () {
      return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ".concat(a);
    }), null != r && l(f(s), function () {
      return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode ".concat(r, " but got pad ").concat(s, ".");
    });
    var c = wt.runKernel("MaxPool3D", {
      x: o
    }, {
      filterSize: t,
      strides: n,
      pad: s,
      dimRoundingMode: r,
      dataFormat: a
    });
    return u ? Es(c, [c.shape[1], c.shape[2], c.shape[3], c.shape[4]]) : c;
  }
}),
    oa = At({
  maximum_: function maximum_(e, t) {
    var _ft27, _ft28;

    var n = Et(e, "a", "maximum"),
        s = Et(t, "b", "maximum");
    return (_ft27 = ft(n, s), _ft28 = _slicedToArray(_ft27, 2), n = _ft28[0], s = _ft28[1], _ft27), "bool" === n.dtype && (n = pn(n, "int32"), s = pn(s, "int32")), cr(n.shape, s.shape), wt.runKernel("Maximum", {
      a: n,
      b: s
    });
  }
}),
    la = At({
  mean_: function mean_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "mean");
    return wt.runKernel("Mean", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
});

function ua(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";

  if ("complex64" === t) {
    var _t59 = ua(e, "float32"),
        _n32 = ua(e, "float32");

    return Ft(_t59, _n32);
  }

  var n = O(d(e), t);
  return wt.makeTensor(n, e, t);
}

function ca(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";

  if ("complex64" === t) {
    var _t60 = ca(e, "float32"),
        _n33 = ua(e, "float32");

    return Ft(_t60, _n33);
  }

  var n = _(d(e), t);

  return wt.makeTensor(n, e, t);
}

var ha = At({
  min_: function min_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "min");
    return wt.runKernel("Min", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
}),
    da = At({
  minimum_: function minimum_(e, t) {
    var _ft29, _ft30;

    var n = Et(e, "a", "minimum"),
        s = Et(t, "b", "minimum");
    return (_ft29 = ft(n, s), _ft30 = _slicedToArray(_ft29, 2), n = _ft30[0], s = _ft30[1], _ft29), "bool" === n.dtype && (n = pn(n, "int32"), s = pn(s, "int32")), cr(n.shape, s.shape), wt.runKernel("Minimum", {
      a: n,
      b: s
    });
  }
}),
    pa = At({
  mirrorPad_: function mirrorPad_(e, t, n) {
    l("reflect" === n || "symmetric" === n, function () {
      return "Invalid mode. Mode must be either reflect or symmetric. Got ".concat(n, ".");
    });
    var s = Et(e, "x", "mirrorPad");
    if (0 === s.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    l(t.length === s.rank, function () {
      return "Padding doesn't match input. Must be ".concat(s.rank, ". Got ").concat(t.length, ".");
    });
    var r = "reflect" === n ? 1 : 0;

    var _loop5 = function _loop5(_e62) {
      l(2 === t[_e62].length, function () {
        return "Invalid number of paddings. Must be length of 2 each.";
      }), l(t[_e62][0] >= 0 && t[_e62][0] <= s.shape[_e62] - r && t[_e62][1] >= 0 && t[_e62][1] <= s.shape[_e62] - r, function () {
        return "Padding in dimension ".concat(_e62, " cannot be greater than or equal to ").concat(s.shape[_e62] - r, " or less than 0 for input of shape ").concat(s.shape);
      });
    };

    for (var _e62 = 0; _e62 < s.rank; _e62++) {
      _loop5(_e62);
    }

    return wt.runKernel("MirrorPad", {
      x: s
    }, {
      paddings: t,
      mode: n
    });
  }
}),
    fa = At({
  mod_: function mod_(e, t) {
    var _ft31, _ft32;

    var n = Et(e, "a", "mod"),
        s = Et(t, "b", "mod");
    return (_ft31 = ft(n, s), _ft32 = _slicedToArray(_ft31, 2), n = _ft32[0], s = _ft32[1], _ft31), wt.runKernel("Mod", {
      a: n,
      b: s
    });
  }
}),
    ga = At({
  square_: function square_(e) {
    var t = Et(e, "x", "square");
    return wt.runKernel("Square", {
      x: t
    }, {});
  }
}),
    ma = At({
  moments_: function moments_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = y(t, (e = Et(e, "x", "moments")).shape),
        r = la(e, s, n);
    var a = r.shape;
    n || (a = Xr(r.shape, s));
    var i = ga(Vr(pn(e, "float32"), Es(r, a)));
    return {
      mean: r,
      variance: la(i, s, n)
    };
  }
}),
    ba = At({
  notEqual_: function notEqual_(e, t) {
    var _ft33, _ft34;

    var n = Et(e, "a", "notEqual", "string_or_numeric"),
        s = Et(t, "b", "notEqual", "string_or_numeric");
    return (_ft33 = ft(n, s), _ft34 = _slicedToArray(_ft33, 2), n = _ft34[0], s = _ft34[1], _ft33), cr(n.shape, s.shape), wt.runKernel("NotEqual", {
      a: n,
      b: s
    });
  }
}),
    xa = At({
  onesLike_: function onesLike_(e) {
    var t = Et(e, "x", "onesLike");
    return wt.runKernel("OnesLike", {
      x: t
    });
  }
}),
    ya = At({
  pad_: function pad_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = Et(e, "x", "pad");
    if (0 === s.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    return wt.runKernel("PadV2", {
      x: s
    }, {
      paddings: t,
      constantValue: n
    });
  }
}),
    ka = At({
  spaceToBatchND_: function spaceToBatchND_(e, t, n) {
    var s = Et(e, "x", "spaceToBatchND");
    return l(s.rank >= 1 + t.length, function () {
      return "input rank ".concat(s.rank, " should be > than [blockShape] ").concat(t.length);
    }), l(n.length === t.length, function () {
      return "paddings.shape[0] ".concat(n.length, " must be equal to [blockShape] ").concat(t.length);
    }), l(s.shape.reduce(function (e, s, r) {
      return r > 0 && r <= t.length ? e && (s + n[r - 1][0] + n[r - 1][1]) % t[r - 1] == 0 : e;
    }, !0), function () {
      return "input spatial dimensions ".concat(s.shape.slice(1), " with paddings ").concat(n.toString(), " must be divisible by blockShapes ").concat(t.toString());
    }), wt.runKernel("SpaceToBatchND", {
      x: s
    }, {
      blockShape: t,
      paddings: n
    });
  }
}),
    wa = At({
  pool_: function pool_(e, t, n, s, r, a) {
    null == r && (r = [1, 1]), null == a && (a = 1), 0 === s && (s = "valid");
    var i = Et(e, "x", "maxPool");
    var o = i,
        u = !1;
    3 === i.rank && (u = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2]])), l(Ss(a, r), function () {
      return "Error in pool: Either strides or dilations must be 1. Got strides ".concat(a, " and dilations '").concat(r, "'");
    });
    var c = bs(o.shape, t, a, r, s),
        h = [c.dilationHeight, c.dilationWidth];
    var d;
    d = "same" === s ? function (e, t) {
      var n = e.map(function (e, n) {
        return e + (e - 1) * (t[n] - 1);
      }).map(function (e) {
        return e - 1;
      }),
          s = n.map(function (e) {
        return Math.floor(e / 2);
      }),
          r = n.map(function (e, t) {
        return e - s[t];
      });
      return n.map(function (e, t) {
        return [s[t], r[t]];
      });
    }([c.filterHeight, c.filterWidth], h) : [[0, 0], [0, 0]];

    var p = 1 === h[0] && 1 === h[1],
        _ref9 = function (e, t, n) {
      var s = n.map(function (e) {
        return e[0];
      }),
          r = n.map(function (e) {
        return e[1];
      }),
          a = e.concat(s, r),
          i = t.map(function (e, t) {
        return (e - a[t] % e) % e;
      }),
          o = r.map(function (e, t) {
        return e + i[t];
      });
      return [t.map(function (e, t) {
        return [s[t], o[t]];
      }), t.map(function (e, t) {
        return [0, i[t]];
      })];
    }([c.inHeight, c.inWidth], h, d),
        _ref10 = _slicedToArray(_ref9, 2),
        f = _ref10[0],
        g = _ref10[1],
        m = p ? s : "valid",
        b = p ? o : ka(o, h, f),
        x = ("avg" === n ? function () {
      return Rs(b, t, a, m);
    } : function () {
      return aa(b, t, a, m);
    })(),
        y = p ? x : Ms(x, h, g);

    return u ? Es(y, [y.shape[1], y.shape[2], y.shape[3]]) : y;
  }
}),
    va = At({
  pow_: function pow_(e, t) {
    var _ft35, _ft36;

    var n = Et(e, "base", "pow"),
        s = Et(t, "exp", "pow");
    return (_ft35 = ft(n, s), _ft36 = _slicedToArray(_ft35, 2), n = _ft36[0], s = _ft36[1], _ft35), wt.runKernel("Pow", {
      a: n,
      b: s
    });
  }
}),
    Ia = At({
  prelu_: function prelu_(e, t) {
    var n = Et(e, "x", "prelu"),
        s = Et(t, "alpha", "prelu");
    return wt.runKernel("Prelu", {
      x: n,
      alpha: s
    });
  }
}),
    $a = At({
  prod_: function prod_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = Et(e, "x", "prod");
    return "bool" === s.dtype && (s = pn(s, "int32")), wt.runKernel("Prod", {
      x: s
    }, {
      axis: t,
      keepDims: n
    });
  }
});

function Na(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports), t.exports;
}

"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self && self;
var Ca = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t,
          n = this,
          s = (t = 4022871197, function (e) {
        e = e.toString();

        for (var n = 0; n < e.length; n++) {
          var s = .02519603282416938 * (t += e.charCodeAt(n));
          s -= t = s >>> 0, t = (s *= t) >>> 0, t += 4294967296 * (s -= t);
        }

        return 2.3283064365386963e-10 * (t >>> 0);
      });
      n.next = function () {
        var e = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
        return n.s0 = n.s1, n.s1 = n.s2, n.s2 = e - (n.c = 0 | e);
      }, n.c = 1, n.s0 = s(" "), n.s1 = s(" "), n.s2 = s(" "), n.s0 -= s(e), n.s0 < 0 && (n.s0 += 1), n.s1 -= s(e), n.s1 < 0 && (n.s1 += 1), n.s2 -= s(e), n.s2 < 0 && (n.s2 += 1), s = null;
    }

    function r(e, t) {
      return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = n.next;
      return i.int32 = function () {
        return 4294967296 * n.next() | 0;
      }, i.double = function () {
        return i() + 11102230246251565e-32 * (2097152 * i() | 0);
      }, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.alea = a;
  }(0, e);
}),
    Sa = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function () {
        var e = t.x ^ t.x << 11;
        return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8;
      }, e === (0 | e) ? t.x = e : n += e;

      for (var s = 0; s < n.length + 64; s++) {
        t.x ^= 0 | n.charCodeAt(s), t.next();
      }
    }

    function r(e, t) {
      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xor128 = a;
  }(0, e);
}),
    Ta = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.next = function () {
        var e = t.x ^ t.x >>> 2;
        return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0;
      }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;

      for (var s = 0; s < n.length + 64; s++) {
        t.x ^= 0 | n.charCodeAt(s), s == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next();
      }
    }

    function r(e, t) {
      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xorwow = a;
  }(0, e);
}),
    Ea = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this;
      t.next = function () {
        var e,
            n,
            s = t.x,
            r = t.i;
        return e = s[r], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = s[r + 1 & 7]) ^ e >>> 10, n ^= (e = s[r + 3 & 7]) ^ e >>> 3, n ^= (e = s[r + 4 & 7]) ^ e << 7, e = s[r + 7 & 7], s[r] = n ^= (e ^= e << 13) ^ e << 9, t.i = r + 1 & 7, n;
      }, function (e, t) {
        var n,
            s = [];
        if (t === (0 | t)) s[0] = t;else for (t = "" + t, n = 0; n < t.length; ++n) {
          s[7 & n] = s[7 & n] << 15 ^ t.charCodeAt(n) + s[n + 1 & 7] << 13;
        }

        for (; s.length < 8;) {
          s.push(0);
        }

        for (n = 0; n < 8 && 0 === s[n]; ++n) {
          ;
        }

        for (8 == n && (s[7] = -1), e.x = s, e.i = 0, n = 256; n > 0; --n) {
          e.next();
        }
      }(t, e);
    }

    function r(e, t) {
      return t.x = e.x.slice(), t.i = e.i, t;
    }

    function a(e, t) {
      null == e && (e = +new Date());

      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && (a.x && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xorshift7 = a;
  }(0, e);
}),
    Ra = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this;
      t.next = function () {
        var e,
            n,
            s = t.w,
            r = t.X,
            a = t.i;
        return t.w = s = s + 1640531527 | 0, n = r[a + 34 & 127], e = r[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n = r[a] = (n ^= n >>> 15) ^ (e ^= e >>> 12), t.i = a, n + (s ^ s >>> 16) | 0;
      }, function (e, t) {
        var n,
            s,
            r,
            a,
            i,
            o = [],
            l = 128;

        for (t === (0 | t) ? (s = t, t = null) : (t += "\0", s = 0, l = Math.max(l, t.length)), r = 0, a = -32; a < l; ++a) {
          t && (s ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = s), s ^= s << 10, s ^= s >>> 15, s ^= s << 4, s ^= s >>> 13, a >= 0 && (r = 0 == (n = o[127 & a] ^= s + (i = i + 1640531527 | 0)) ? r + 1 : 0);
        }

        for (r >= 128 && (o[127 & (t && t.length || 0)] = -1), r = 127, a = 512; a > 0; --a) {
          s = o[r + 34 & 127], n = o[r = r + 1 & 127], s ^= s << 13, n ^= n << 17, o[r] = (s ^= s >>> 15) ^ (n ^= n >>> 12);
        }

        e.w = i, e.X = o, e.i = r;
      }(t, e);
    }

    function r(e, t) {
      return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t;
    }

    function a(e, t) {
      null == e && (e = +new Date());

      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && (a.X && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.xor4096 = a;
  }(0, e);
}),
    Aa = Na(function (e) {
  !function (e, t, n) {
    function s(e) {
      var t = this,
          n = "";
      t.next = function () {
        var e = t.b,
            n = t.c,
            s = t.d,
            r = t.a;
        return e = e << 25 ^ e >>> 7 ^ n, n = n - s | 0, s = s << 24 ^ s >>> 8 ^ r, r = r - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - s | 0, t.d = s << 16 ^ n >>> 16 ^ r, t.a = r - e | 0;
      }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;

      for (var s = 0; s < n.length + 20; s++) {
        t.b ^= 0 | n.charCodeAt(s), t.next();
      }
    }

    function r(e, t) {
      return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t;
    }

    function a(e, t) {
      var n = new s(e),
          a = t && t.state,
          i = function i() {
        return (n.next() >>> 0) / 4294967296;
      };

      return i.double = function () {
        do {
          var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e);

        return e;
      }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
        return r(n, {});
      }), i;
    }

    t && t.exports ? t.exports = a : this.tychei = a;
  }(0, e);
}),
    Fa = {
  __proto__: null,
  default: {}
},
    Da = Na(function (e) {
  !function (t, n) {
    var s,
        r = this,
        a = 256,
        i = n.pow(a, 6),
        o = n.pow(2, 52),
        l = 2 * o,
        u = 255;

    function c(e, u, c) {
      var m = [],
          b = f(p((u = 1 == u ? {
        entropy: !0
      } : u || {}).entropy ? [e, g(t)] : null == e ? function () {
        try {
          var e;
          return s && (e = s.randomBytes) ? e = e(a) : (e = new Uint8Array(a), (r.crypto || r.msCrypto).getRandomValues(e)), g(e);
        } catch (e) {
          var n = r.navigator,
              i = n && n.plugins;
          return [+new Date(), r, i, r.screen, g(t)];
        }
      }() : e, 3), m),
          x = new h(m),
          y = function y() {
        for (var e = x.g(6), t = i, n = 0; e < o;) {
          e = (e + n) * a, t *= a, n = x.g(1);
        }

        for (; e >= l;) {
          e /= 2, t /= 2, n >>>= 1;
        }

        return (e + n) / t;
      };

      return y.int32 = function () {
        return 0 | x.g(4);
      }, y.quick = function () {
        return x.g(4) / 4294967296;
      }, y.double = y, f(g(x.S), t), (u.pass || c || function (e, t, s, r) {
        return r && (r.S && d(r, x), e.state = function () {
          return d(x, {});
        }), s ? (n.random = e, t) : e;
      })(y, b, "global" in u ? u.global : this == n, u.state);
    }

    function h(e) {
      var t,
          n = e.length,
          s = this,
          r = 0,
          i = s.i = s.j = 0,
          o = s.S = [];

      for (n || (e = [n++]); r < a;) {
        o[r] = r++;
      }

      for (r = 0; r < a; r++) {
        o[r] = o[i = u & i + e[r % n] + (t = o[r])], o[i] = t;
      }

      (s.g = function (e) {
        for (var t, n = 0, r = s.i, i = s.j, o = s.S; e--;) {
          t = o[r = u & r + 1], n = n * a + o[u & (o[r] = o[i = u & i + t]) + (o[i] = t)];
        }

        return s.i = r, s.j = i, n;
      })(a);
    }

    function d(e, t) {
      return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t;
    }

    function p(e, t) {
      var n,
          s = [],
          r = typeof e;
      if (t && "object" == r) for (n in e) {
        try {
          s.push(p(e[n], t - 1));
        } catch (e) {}
      }
      return s.length ? s : "string" == r ? e : e + "\0";
    }

    function f(e, t) {
      for (var n, s = e + "", r = 0; r < s.length;) {
        t[u & r] = u & (n ^= 19 * t[u & r]) + s.charCodeAt(r++);
      }

      return g(t);
    }

    function g(e) {
      return String.fromCharCode.apply(0, e);
    }

    if (n.seedrandom = c, f(n.random(), t), e.exports) {
      e.exports = c;

      try {
        s = Fa;
      } catch (e) {}
    }
  }([], Math);
});
Da.alea = Ca, Da.xor128 = Sa, Da.xorwow = Ta, Da.xorshift7 = Ea, Da.xor4096 = Ra, Da.tychei = Aa;
var _a = Da;

var Oa = /*#__PURE__*/function () {
  "use strict";

  function Oa(e, t, n, s, r) {
    _classCallCheck(this, Oa);

    this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = s, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a = r || Math.random();
    this.random = _a.alea(a.toString());
  }

  _createClass(Oa, [{
    key: "nextValue",
    value: function nextValue() {
      if (!isNaN(this.nextVal)) {
        var _e63 = this.nextVal;
        return this.nextVal = NaN, _e63;
      }

      var e,
          t,
          n = !1;

      for (; !n;) {
        var _s35 = void 0,
            _r29 = void 0,
            _a15 = void 0;

        do {
          _s35 = 2 * this.random() - 1, _r29 = 2 * this.random() - 1, _a15 = _s35 * _s35 + _r29 * _r29;
        } while (_a15 >= 1 || 0 === _a15);

        var _i13 = Math.sqrt(-2 * Math.log(_a15) / _a15);

        e = this.mean + this.stdDev * _s35 * _i13, t = this.mean + this.stdDev * _r29 * _i13, this.truncated && !this.isValidTruncated(e) || (n = !0);
      }

      return this.truncated && !this.isValidTruncated(t) || (this.nextVal = this.convertValue(t)), this.convertValue(e);
    }
  }, {
    key: "convertValue",
    value: function convertValue(e) {
      return null == this.dtype || "float32" === this.dtype ? e : Math.round(e);
    }
  }, {
    key: "isValidTruncated",
    value: function isValidTruncated(e) {
      return e <= this.upper && e >= this.lower;
    }
  }]);

  return Oa;
}();

var Ma = /*#__PURE__*/function () {
  "use strict";

  function Ma() {
    var _this21 = this;

    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var s = arguments.length > 3 ? arguments[3] : undefined;

    _classCallCheck(this, Ma);

    if (this.canReturnFloat = function () {
      return null == _this21.dtype || "float32" === _this21.dtype;
    }, this.min = e, this.range = t - e, this.dtype = n, null == s && (s = Math.random()), "number" == typeof s && (s = s.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between ".concat(e, " - ").concat(t, " <= 1 and dtype is not float"));
    this.random = _a.alea(s);
  }

  _createClass(Ma, [{
    key: "convertValue",
    value: function convertValue(e) {
      return this.canReturnFloat() ? e : Math.round(e);
    }
  }, {
    key: "nextValue",
    value: function nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  }]);

  return Ma;
}();

var La = At({
  randomNormal_: function randomNormal_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    if (null != s && "bool" === s) throw new Error("Unsupported data type ".concat(s));
    var a = new Oa(t, n, s, !1, r),
        i = dn(e, s);

    for (var _e64 = 0; _e64 < i.values.length; _e64++) {
      i.values[_e64] = a.nextValue();
    }

    return i.toTensor();
  }
}),
    za = At({
  randomUniform_: function randomUniform_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
    var r = arguments.length > 4 ? arguments[4] : undefined;
    var a = dn(e, s),
        i = new Ma(t, n, null, r);

    for (var _e65 = 0; _e65 < a.values.length; _e65++) {
      a.values[_e65] = i.nextValue();
    }

    return a.toTensor();
  }
});

function Ba(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "float32";
  if (0 === n) throw new Error("Cannot have a step of zero");
  return wt.runKernel("Range", {}, {
    start: e,
    stop: t,
    step: n,
    dtype: s
  });
}

var Pa = At({
  real_: function real_(e) {
    var t = Et(e, "input", "real");
    return wt.runKernel("Real", {
      input: t
    });
  }
}),
    Wa = At({
  reciprocal_: function reciprocal_(e) {
    var t = Et(e, "x", "reciprocal");
    return wt.runKernel("Reciprocal", {
      x: t
    });
  }
}),
    Ua = At({
  relu_: function relu_(e) {
    var t = Et(e, "x", "relu");
    return wt.runKernel("Relu", {
      x: t
    });
  }
}),
    Va = At({
  relu6_: function relu6_(e) {
    var t = Et(e, "x", "relu6");
    return wt.runKernel("Relu6", {
      x: t
    });
  }
}),
    Ga = At({
  reverse_: function reverse_(e, t) {
    var n = Et(e, "x", "reverse");
    return wt.runKernel("Reverse", {
      x: n
    }, {
      dims: t
    });
  }
}),
    Ha = At({
  round_: function round_(e) {
    var t = Et(e, "x", "round");
    return wt.runKernel("Round", {
      x: t
    });
  }
}),
    ja = At({
  rsqrt_: function rsqrt_(e) {
    var t = Et(e, "x", "rsqrt");
    return wt.runKernel("Rsqrt", {
      x: t
    });
  }
});

function qa(e, t) {
  if (($(e) && "string" !== t || Array.isArray(e)) && "complex64" !== t) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === t && $(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Dt(e, [], [], t);
}

var Ka = At({
  selu_: function selu_(e) {
    var t = Et(e, "x", "selu");
    return wt.runKernel("Selu", {
      x: t
    });
  }
}),
    Xa = At({
  separableConv2d_: function separableConv2d_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NHWC";
    var o = Et(e, "x", "separableConv2d"),
        u = Et(t, "depthwiseFilter", "separableConv2d"),
        c = Et(n, "pointwiseFilter", "separableConv2d");
    var h = o,
        d = !1;
    if (3 === o.rank && (d = !0, h = Es(o, [1, o.shape[0], o.shape[1], o.shape[2]])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    l(4 === h.rank, function () {
      return "Error in separableConv2d: input must be rank 4, but got rank ".concat(h.rank, ".");
    }), l(4 === u.rank, function () {
      return "Error in separableConv2d: depthwise filter must be rank 4, but got rank ".concat(u.rank, ".");
    }), l(4 === c.rank, function () {
      return "Error in separableConv2d: pointwise filter must be rank 4, but got rank ".concat(u.rank, ".");
    }), l(1 === c.shape[0], function () {
      return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ".concat(c.shape[0], ".");
    }), l(1 === c.shape[1], function () {
      return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ".concat(c.shape[1], ".");
    });
    var p = u.shape[2],
        f = u.shape[3];
    l(c.shape[2] === p * f, function () {
      return "Error in separableConv2d: the third dimension of pointwise filter must be ".concat(p * f, ", but got ").concat(c.shape[2], ".");
    });
    var g = ir(h, u, s, r, i, a),
        m = Xs(g, c, 1, "valid", i);
    return d ? Es(m, [m.shape[1], m.shape[2], m.shape[3]]) : m;
  }
}),
    Ya = At({
  sign_: function sign_(e) {
    var t = Et(e, "x", "sign");
    return wt.runKernel("Sign", {
      x: t
    });
  }
}),
    Ja = At({
  sin_: function sin_(e) {
    var t = Et(e, "x", "sin");
    return wt.runKernel("Sin", {
      x: t
    });
  }
}),
    Za = At({
  sinh_: function sinh_(e) {
    var t = Et(e, "x", "sinh");
    return wt.runKernel("Sinh", {
      x: t
    });
  }
}),
    Qa = At({
  slice1d_: function slice1d_(e, t, n) {
    var s = Et(e, "x", "slice1d");
    return l(1 === s.rank, function () {
      return "slice1d expects a rank-1 tensor, but got a rank-".concat(s.rank, " tensor");
    }), _s(s, [t], [n]);
  }
}),
    ei = At({
  slice2d_: function slice2d_(e, t, n) {
    var s = Et(e, "x", "slice2d");
    return l(2 === s.rank, function () {
      return "slice2d expects a rank-2 tensor, but got a rank-".concat(s.rank, " tensor");
    }), _s(s, t, n);
  }
}),
    ti = At({
  slice3d_: function slice3d_(e, t, n) {
    var s = Et(e, "x", "slice3d");
    return l(3 === s.rank, function () {
      return "slice3d expects a rank-3 tensor, but got a rank-".concat(s.rank, " tensor");
    }), _s(s, t, n);
  }
}),
    ni = At({
  slice4d_: function slice4d_(e, t, n) {
    var s = Et(e, "x", "slice4d");
    return l(4 === s.rank, function () {
      return "slice4d expects a rank-4 tensor, but got a rank-".concat(s.rank, " tensor");
    }), _s(s, t, n);
  }
}),
    si = At({
  softmax_: function softmax_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var n = Et(e, "logits", "softmax", "float32");
    if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(n.rank, " and dim was ").concat(t));
    return wt.runKernel("Softmax", {
      logits: n
    }, {
      dim: t
    });
  }
}),
    ri = At({
  fft_: function fft_(e) {
    return l("complex64" === e.dtype, function () {
      return "The dtype for tf.spectral.fft() must be complex64 but got ".concat(e.dtype, ".");
    }), wt.runKernel("FFT", {
      input: e
    });
  }
}),
    ai = At({
  ifft_: function ifft_(e) {
    return l("complex64" === e.dtype, function () {
      return "The dtype for tf.spectral.ifft() must be complex64 but got ".concat(e.dtype, ".");
    }), wt.runKernel("IFFT", {
      input: e
    });
  }
}),
    ii = At({
  irfft_: function irfft_(e) {
    var t = e.shape[e.shape.length - 1],
        n = e.size / t;
    var s;

    if (t <= 2) {
      var _r30 = Es(e, [n, t]);

      s = ai(_r30);
    } else {
      var _r31 = [n, 2 * (t - 1)],
          _a16 = Es(Pa(e), [n, t]),
          _i14 = Es(Tr(e), [n, t]),
          _o10 = Ga(_s(_a16, [0, 1], [n, t - 2]), 1),
          _l5 = ss(Ga(_s(_i14, [0, 1], [n, t - 2]), 1), qa(-1)),
          _u4 = Fs([_a16, _o10], 1),
          _c3 = Fs([_i14, _l5], 1),
          _h2 = Es(Ft(_u4, _c3), [_r31[0], _r31[1]]);

      s = ai(_h2);
    }

    if (s = Pa(s), 3 === e.rank && 0 !== e.shape[0]) {
      var _t61 = s,
          _n34 = e.shape[0];
      s = Es(s, [_n34, s.shape[0] / _n34, s.shape[1]]), _t61.dispose();
    }

    return s;
  }
}),
    oi = At({
  split_: function split_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = Et(e, "x", "split");
    return wt.runKernel("SplitV", {
      x: s
    }, {
      numOrSizeSplits: t,
      axis: n
    });
  }
}),
    li = At({
  rfft_: function rfft_(e, t) {
    l("float32" === e.dtype, function () {
      return "The dtype for rfft() must be real value but got ".concat(e.dtype);
    });
    var n = e.shape[e.shape.length - 1];
    var s = e.size / n;
    var r;

    if (null != t && t < n) {
      var _s36 = e.shape.map(function (e) {
        return 0;
      }),
          _a17 = e.shape.map(function (e) {
        return e;
      });

      _a17[e.shape.length - 1] = t, r = _s(e, _s36, _a17), n = t;
    } else if (null != t && t > n) {
      var _s37 = e.shape.map(function (e) {
        return e;
      });

      _s37[e.shape.length - 1] = t - n, r = Fs([e, ua(_s37)], e.shape.length - 1), n = t;
    } else r = e;

    var a = pr(r),
        i = Es(Ft(r, a), [s, n]),
        o = ri(i),
        u = Math.floor(n / 2) + 1,
        c = Pa(o),
        h = Tr(o),
        d = oi(c, [u, n - u], c.shape.length - 1),
        p = oi(h, [u, n - u], h.shape.length - 1),
        f = r.shape.slice();
    return f[r.shape.length - 1] = u, Es(Ft(d[0], p[0]), f);
  }
}),
    ui = At({
  sqrt_: function sqrt_(e) {
    var t = Et(e, "x", "sqrt");
    return wt.runKernel("Sqrt", {
      x: t
    });
  }
}),
    ci = At({
  squaredDifference_: function squaredDifference_(e, t) {
    var _ft37, _ft38;

    var n = Et(e, "a", "squaredDifference"),
        s = Et(t, "b", "squaredDifference");
    return (_ft37 = ft(n, s), _ft38 = _slicedToArray(_ft37, 2), n = _ft38[0], s = _ft38[1], _ft37), cr(n.shape, s.shape), wt.runKernel("SquaredDifference", {
      a: n,
      b: s
    }, {});
  }
}),
    hi = At({
  squeeze_: function squeeze_(e, t) {
    var n = Et(e, "x", "squeeze");
    return Es(n, k(n.shape, t).newShape);
  }
}),
    di = At({
  stack_: function stack_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Rt(e, "tensors", "stack", "string_or_numeric");
    return l(n.length >= 1, function () {
      return "Pass at least one tensor to tf.stack";
    }), n.length > 0 && l(t <= n[0].rank, function () {
      return "Axis must be <= rank of the tensor";
    }), wt.runKernel("Pack", n, {
      axis: t
    });
  }
}),
    pi = At({
  step_: function step_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "step");
    return wt.runKernel("Step", {
      x: n
    }, {
      alpha: t
    });
  }
}),
    fi = At({
  stridedSlice_: function stridedSlice_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var u = Et(e, "x", "stridedSlice", "string_or_numeric");
    return wt.runKernel("StridedSlice", {
      x: u
    }, {
      begin: t,
      end: n,
      strides: s,
      beginMask: r,
      endMask: a,
      ellipsisMask: i,
      newAxisMask: o,
      shrinkAxisMask: l
    });
  }
}),
    gi = At({
  tan_: function tan_(e) {
    var t = Et(e, "x", "tan");
    return wt.runKernel("Tan", {
      x: t
    });
  }
});

function mi(e, t) {
  c(e);
  var n = Ct(e, t);
  if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Dt(e, null, n, t);
}

function bi(e, t, n) {
  if (c(e), null != t && 2 !== t.length) throw new Error("tensor2d() requires shape to have two numbers");
  var s = Ct(e, n);
  if (2 !== s.length && 1 !== s.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === s.length && null == t) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Dt(e, t, s, n);
}

var xi = At({
  topk_: function topk_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = Et(e, "x", "topk");
    if (0 === s.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
    var r = s.shape[s.shape.length - 1];
    if (t < 0) throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));
    if (t > r) throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r, ") but got ").concat(t));

    var a = {
      x: s
    },
        i = {
      k: t,
      sorted: n
    },
        _wt$runKernel = wt.runKernel("TopK", a, i),
        _wt$runKernel2 = _slicedToArray(_wt$runKernel, 2),
        o = _wt$runKernel2[0],
        l = _wt$runKernel2[1];

    return {
      values: o,
      indices: l
    };
  }
}),
    yi = At({
  truncatedNormal_: function truncatedNormal_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var s = arguments.length > 3 ? arguments[3] : undefined;
    var r = arguments.length > 4 ? arguments[4] : undefined;
    if (null != s && "bool" === s) throw new Error("Unsupported data type $ { dtype }");
    var a = new Oa(t, n, s, !0, r),
        i = dn(e, s);

    for (var _e66 = 0; _e66 < i.values.length; _e66++) {
      i.values[_e66] = a.nextValue();
    }

    return i.toTensor();
  }
}),
    ki = At({
  unique_: function unique_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "unique", "string_or_numeric");
    l(n.rank > 0, function () {
      return "The input tensor must be at least 1D";
    });

    var s = {
      x: n
    },
        r = {
      axis: t
    },
        _wt$runKernel3 = wt.runKernel("Unique", s, r),
        _wt$runKernel4 = _slicedToArray(_wt$runKernel3, 2),
        a = _wt$runKernel4[0],
        i = _wt$runKernel4[1];

    return {
      values: a,
      indices: i
    };
  }
}),
    wi = At({
  unsortedSegmentSum_: function unsortedSegmentSum_(e, t, n) {
    var s = Et(e, "x", "unsortedSegmentSum"),
        r = Et(t, "segmentIds", "unsortedSegmentSum", "int32");
    return l(f(n), function () {
      return "numSegments must be of dtype int";
    }), wt.runKernel("UnsortedSegmentSum", {
      x: s,
      segmentIds: r
    }, {
      numSegments: n
    });
  }
}),
    vi = At({
  unstack_: function unstack_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var n = Et(e, "x", "unstack", "string_or_numeric");
    return l(t >= -n.shape.length && t < n.shape.length, function () {
      return "Axis = ".concat(t, " is not in [-").concat(n.shape.length, ", ").concat(n.shape.length, ")");
    }), wt.runKernel("Unpack", {
      value: n
    }, {
      axis: t
    });
  }
});

function Ii(e, t) {
  var n = [];

  for (var _e67 = 0; _e67 < t.length; _e67++) {
    t[_e67] && n.push(_e67);
  }

  var s = dn(e, "int32"),
      r = dn([n.length, e.length], "int32");

  for (var _t62 = 0; _t62 < n.length; _t62++) {
    var _a18 = s.indexToLoc(n[_t62]);

    r.values.set(_a18, _t62 * e.length);
  }

  return r.toTensor();
}

function $i(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (0 === e.rank) return rs(e);
  if (1 !== e.rank && null === n) return $i(Es(e, [-1]), t, n);

  if (1 === e.rank || "number" == typeof n || Array.isArray(n) && 1 === n.length) {
    if (1 === t) return Gr(rs(e), n);
    if (Infinity === t) return Ur(rs(e), n);
    if (-Infinity === t) return ha(rs(e), n);
    if ("euclidean" === t || 2 === t) return ui(Gr(va(rs(e), qa(2, "int32")), n));
    throw new Error("Error in norm: invalid ord value: ".concat(t));
  }

  if (Array.isArray(n) && 2 === n.length) {
    if (1 === t) return Ur(Gr(rs(e), n[0]), n[1] - 1);
    if (Infinity === t) return Ur(Gr(rs(e), n[1]), n[0]);
    if (-Infinity === t) return ha(Gr(rs(e), n[1]), n[0]);
    if ("fro" === t || "euclidean" === t) return ui(Gr(ga(e), n));
    throw new Error("Error in norm: invalid ord value: ".concat(t));
  }

  throw new Error("Error in norm: invalid axis: ".concat(n));
}

var Ni = At({
  norm_: function norm_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "euclidean";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = $i(e = Et(e, "x", "norm"), t, n);
    var a = r.shape;

    if (s) {
      var _t63 = y(n, e.shape);

      a = Xr(r.shape, _t63);
    }

    return Es(r, a);
  }
}),
    Ci = At({
  dropout_: function dropout_(e, t, n, s) {
    var r = Et(e, "x", "dropout");
    if (l("float32" === r.dtype, function () {
      return "x has to be a floating point tensor since it's going to be scaled, but got a ".concat(r.dtype, " tensor instead.");
    }), l(t >= 0 && t < 1, function () {
      return "rate must be a float in the range [0, 1), but got ".concat(t, ".");
    }), 0 === t) return e instanceof st ? r.clone() : r;

    var a = function (e, t) {
      if (null == t) return e.shape.slice();
      if (p(e.shape, t)) return t;

      if (e.shape.length === t.length) {
        var _n35 = [];

        for (var _s38 = 0; _s38 < e.shape.length; _s38++) {
          _n35.push(null == t[_s38] && null != e.shape[_s38] ? e.shape[_s38] : t[_s38]);
        }

        return _n35;
      }

      return t;
    }(r, n),
        i = 1 - t,
        o = ns($r(es(za(a, 0, 1, "float32", s), i)), i);

    return ss(r, o);
  }
});

function Si(e, t, n) {
  var s = 1 - e % 2,
      r = new Float32Array(e);

  for (var _a19 = 0; _a19 < e; ++_a19) {
    var _i15 = 2 * Math.PI * _a19 / (e + s - 1);

    r[_a19] = t - n * Math.cos(_i15);
  }

  return mi(r, "float32");
}

var Ti = At({
  conv2DBackpropFilter_: function conv2DBackpropFilter_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "NHWC";
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = e;
    3 === e.rank && (o = Es(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
    var u = t;
    3 === u.rank && (u = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]])), l(4 === o.rank, function () {
      return "Error in conv2dDerFilter: input must be rank 4, but got shape ".concat(o.shape, ".");
    }), l(4 === u.rank, function () {
      return "Error in conv2dDerFilter: dy must be rank 4, but got shape ".concat(u.shape, ".");
    }), l(4 === n.length, function () {
      return "Error in conv2dDerFilter: filterShape must be length 4, but got ".concat(n, ".");
    });
    var c = "NHWC" === a ? o.shape[3] : o.shape[1],
        h = "NHWC" === a ? u.shape[3] : u.shape[1];
    return l(c === n[2], function () {
      return "Error in conv2dDerFilter: depth of input ".concat(c, ") must match input depth in filter (").concat(n[2], ".");
    }), l(h === n[3], function () {
      return "Error in conv2dDerFilter: depth of dy (".concat(h, ") must match output depth for filter (").concat(n[3], ").");
    }), null != i && l(f(r), function () {
      return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(r, ".");
    }), wt.runKernel("Conv2DBackpropFilter", {
      x: o,
      dy: u
    }, {
      strides: s,
      pad: r,
      dataFormat: a,
      dimRoundingMode: i,
      filterShape: n
    });
  }
});

function Ei(e, t, n) {
  if (null == n || "linear" === n) return e;
  if ("relu" === n) return ss(e, pi(t));
  throw new Error("Cannot compute gradient for fused activation ".concat(n, "."));
}

function Ri(e, t) {
  var n = t;
  var s = ur(e.shape, t.shape);
  return s.length > 0 && (n = Gr(n, s)), Es(n, e.shape);
}

function Ai(e, t, n, s) {
  if ("linear" === t) return e;
  if ("relu" === t) return Ua(e);
  if ("elu" === t) return mr(e);
  if ("relu6" === t) return Va(e);
  if ("prelu" === t) return Ia(e, n);
  if ("leakyrelu" === t) return Fr(e, s);
  if ("sigmoid" === t) return Ds(e);
  throw new Error("Unknown fused activation ".concat(t, "."));
}

var Fi = function Fi(e, t) {
  return !(e > 0) || "linear" === t;
},
    Di = At({
  fusedConv2d_: function fusedConv2d_(_ref11) {
    var _ft39, _ft40;

    var e = _ref11.x,
        t = _ref11.filter,
        n = _ref11.strides,
        s = _ref11.pad,
        _ref11$dataFormat = _ref11.dataFormat,
        r = _ref11$dataFormat === void 0 ? "NHWC" : _ref11$dataFormat,
        _ref11$dilations = _ref11.dilations,
        a = _ref11$dilations === void 0 ? [1, 1] : _ref11$dilations,
        i = _ref11.dimRoundingMode,
        o = _ref11.bias,
        _ref11$activation = _ref11.activation,
        u = _ref11$activation === void 0 ? "linear" : _ref11$activation,
        c = _ref11.preluActivationWeights,
        h = _ref11.leakyreluAlpha;

    if (!1 === Fi(wt.state.gradientDepth, u = u || "linear")) {
      var _l6 = Xs(e, t, n, s, r, a, i);

      return null != o && (_l6 = es(_l6, o)), Ai(_l6, u, c, h);
    }

    var d = Et(e, "x", "conv2d"),
        p = Et(t, "filter", "conv2d");
    var g = d,
        m = !1;
    3 === d.rank && (m = !0, g = Es(d, [1, d.shape[0], d.shape[1], d.shape[2]])), l(4 === g.rank, function () {
      return "Error in fused conv2d: input must be rank 4, but got rank ".concat(g.rank, ".");
    }), l(4 === p.rank, function () {
      return "Error in fused conv2d: filter must be rank 4, but got rank ".concat(p.rank, ".");
    }), null != i && l(f(s), function () {
      return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(s, ".");
    }), l(g.shape[3] === p.shape[2], function () {
      return "Error in conv2d: depth of input (".concat(g.shape[3], ") must match input depth for filter ").concat(p.shape[2], ".");
    }), l(Ss(n, a), function () {
      return "Error in conv2D: Either strides or dilations must be 1. Got strides ".concat(n, " and dilations '").concat(a, "'");
    }), l("NHWC" === r, function () {
      return "Error in conv2d: got dataFormat of ".concat(r, " but only NHWC is currently supported.");
    });
    var b = ys(g.shape, p.shape, n, a, s, i);
    var x, y;
    null != o && (x = Et(o, "bias", "fused conv2d"), (_ft39 = ft(x, d), _ft40 = _slicedToArray(_ft39, 1), x = _ft40[0], _ft39), cr(b.outShape, x.shape)), null != c && (y = Et(c, "prelu weights", "fused conv2d"));

    var k = function k(e, t) {
      var _t64 = _slicedToArray(t, 4),
          r = _t64[0],
          i = _t64[1],
          o = _t64[2],
          c = _t64[3],
          h = Ei(e, o, u);

      l(Cs(a), function () {
        return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a, "'");
      });
      var d = [Js(i.shape, h, r, n, s), Ti(i, h, r.shape, n, s)];

      if (null != c) {
        var _e68 = Ri(c, h);

        d.push(_e68);
      }

      return d;
    },
        w = {
      x: g,
      filter: p,
      bias: x,
      preluActivationWeights: y
    },
        v = {
      strides: n,
      pad: s,
      dataFormat: r,
      dilations: a,
      dimRoundingMode: i,
      activation: u,
      leakyreluAlpha: h
    };

    return null == o ? zr(function (e, t, n) {
      var s = wt.runKernel("FusedConv2D", w, v);
      return n([t, e, s]), m && (s = Es(s, [s.shape[1], s.shape[2], s.shape[3]])), {
        value: s,
        gradFunc: k
      };
    })(g, p) : zr(function (e, t, n, s) {
      var r = wt.runKernel("FusedConv2D", w, v);
      return s([t, e, r, n]), m && (r = Es(r, [r.shape[1], r.shape[2], r.shape[3]])), {
        value: r,
        gradFunc: k
      };
    })(g, p, x);
  }
}),
    _i = At({
  depthwiseConv2dNativeBackpropFilter_: function depthwiseConv2dNativeBackpropFilter_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = e;
    3 === e.rank && (o = Es(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
    var l = t;
    return 3 === l.rank && (l = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]])), wt.runKernel("DepthwiseConv2dNativeBackpropFilter", {
      x: o,
      dy: l
    }, {
      strides: s,
      pad: r,
      dimRoundingMode: i,
      dilations: a,
      filterShape: n
    });
  }
}),
    Oi = At({
  depthwiseConv2dNativeBackpropInput_: function depthwiseConv2dNativeBackpropInput_(e, t, n, s, r) {
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [1, 1];
    var i = arguments.length > 6 ? arguments[6] : undefined;
    var o = t,
        l = !1;
    3 === t.rank && (l = !0, o = Es(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
    var u = wt.runKernel("DepthwiseConv2dNativeBackpropInput", {
      dy: o,
      filter: n
    }, {
      strides: s,
      pad: r,
      dimRoundingMode: i,
      dilations: a,
      inputShape: e
    });
    return l ? Es(u, [u.shape[1], u.shape[2], u.shape[3]]) : u;
  }
}),
    Mi = At({
  fusedMatMul_: function fusedMatMul_(_ref12) {
    var _ft43, _ft44;

    var e = _ref12.a,
        t = _ref12.b,
        _ref12$transposeA = _ref12.transposeA,
        n = _ref12$transposeA === void 0 ? !1 : _ref12$transposeA,
        _ref12$transposeB = _ref12.transposeB,
        s = _ref12$transposeB === void 0 ? !1 : _ref12$transposeB,
        r = _ref12.bias,
        _ref12$activation = _ref12.activation,
        a = _ref12$activation === void 0 ? "linear" : _ref12$activation,
        i = _ref12.preluActivationWeights,
        o = _ref12.leakyreluAlpha;

    if (!1 === Fi(wt.state.gradientDepth, a)) {
      var _l7 = vn(e, t, n, s);

      return null != r && (_l7 = es(_l7, r)), Ai(_l7, a, i, o);
    }

    var u = Et(e, "a", "fused matMul"),
        c = Et(t, "b", "fused matMul");

    var _ft41 = ft(u, c);

    var _ft42 = _slicedToArray(_ft41, 2);

    u = _ft42[0];
    c = _ft42[1];
    var h = n ? u.shape[u.rank - 2] : u.shape[u.rank - 1],
        f = s ? c.shape[c.rank - 1] : c.shape[c.rank - 2],
        g = n ? u.shape[u.rank - 1] : u.shape[u.rank - 2],
        m = s ? c.shape[c.rank - 2] : c.shape[c.rank - 1],
        b = u.shape.slice(0, -2),
        x = c.shape.slice(0, -2),
        y = d(b),
        k = d(x);
    l(u.rank >= 2 && c.rank >= 2 && u.rank === c.rank, function () {
      return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks ".concat(u.rank, " and ").concat(c.rank, ".");
    }), l(p(b, x), function () {
      return "Error in fused matMul: outer dimensions (".concat(b, ") and (").concat(x, ") of Tensors with shapes ").concat(u.shape, " and ").concat(c.shape, " must match.");
    }), l(h === f, function () {
      return "Error in fused matMul: inner shapes (".concat(h, ") and (").concat(f, ") of Tensors with shapes ").concat(u.shape, " and ").concat(c.shape, " and transposeA=").concat(n, " and transposeB=").concat(s, " must match.");
    });
    var w = u.shape.slice(0, -2).concat([g, m]),
        v = Es(u, n ? [y, h, g] : [y, g, h]),
        I = Es(c, s ? [k, m, f] : [k, f, m]);
    var $, N;
    null != r && ($ = Et(r, "bias", "fused matMul"), (_ft43 = ft($, u), _ft44 = _slicedToArray(_ft43, 1), $ = _ft44[0], _ft43), cr(w, $.shape)), null != i && (N = Et(i, "prelu weights", "fused matMul"));

    var C = function C(e, t) {
      var _t65 = _slicedToArray(t, 4),
          i = _t65[0],
          o = _t65[1],
          l = _t65[2],
          u = _t65[3],
          c = Ei(Es(e, l.shape), l, a);

      var h, d;
      return n || s ? !n && s ? (h = vn(c, o, !1, !1), d = vn(c, i, !0, !1)) : n && !s ? (h = vn(o, c, !1, !0), d = vn(i, c, !1, !1)) : (h = vn(o, c, !0, !0), d = vn(c, i, !0, !0)) : (h = vn(c, o, !1, !0), d = vn(i, c, !0, !1)), null != r ? [h, d, Ri(u, c)] : [h, d];
    },
        S = {
      a: v,
      b: I,
      bias: $,
      preluActivationWeights: N
    },
        T = {
      transposeA: n,
      transposeB: s,
      activation: a,
      leakyreluAlpha: o
    };

    return null == r ? zr(function (e, t, n) {
      var s = wt.runKernel("_FusedMatMul", S, T);
      return n([e, t, s]), {
        value: Es(s, w),
        gradFunc: C
      };
    })(v, I) : zr(function (e, t, n, s) {
      var r = wt.runKernel("_FusedMatMul", S, T);
      return s([e, t, r, n]), {
        value: Es(r, w),
        gradFunc: C
      };
    })(v, I, $);
  }
});

At({
  hammingWindow_: function hammingWindow_(e) {
    return Si(e, .54, .46);
  }
});
var Li = At({
  hannWindow_: function hannWindow_(e) {
    return Si(e, .5, .5);
  }
}),
    zi = At({
  frame_: function frame_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = 0;
    var i = [];

    for (; a + t <= e.size;) {
      i.push(_s(e, a, t)), a += n;
    }

    if (s) for (; a < e.size;) {
      var _s39 = a + t - e.size,
          _o11 = Fs([_s(e, a, t - _s39), Ir([_s39], r)]);

      i.push(_o11), a += n;
    }
    return 0 === i.length ? bi([], [0, t]) : Es(Fs(i), [i.length, t]);
  }
});
At({
  stft_: function stft_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Li;
    null == s && (s = Math.floor(Math.pow(2, Math.ceil(Math.log(t) / Math.log(2)))));
    var a = zi(e, t, n),
        i = ss(a, r(t));
    return li(i, s);
  }
});
var Bi = At({
  cropAndResize_: function cropAndResize_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "bilinear";
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = Et(e, "image", "cropAndResize"),
        o = Et(t, "boxes", "cropAndResize", "float32"),
        u = Et(n, "boxInd", "cropAndResize", "int32"),
        c = o.shape[0];
    return l(4 === i.rank, function () {
      return "Error in cropAndResize: image must be rank 4,but got rank ".concat(i.rank, ".");
    }), l(2 === o.rank && 4 === o.shape[1], function () {
      return "Error in cropAndResize: boxes must be have size [".concat(c, ",4] but had shape ").concat(o.shape, ".");
    }), l(1 === u.rank && u.shape[0] === c, function () {
      return "Error in cropAndResize: boxInd must be have size [".concat(c, "] but had shape ").concat(o.shape, ".");
    }), l(2 === s.length, function () {
      return "Error in cropAndResize: cropSize must be of length 2, but got length ".concat(s.length, ".");
    }), l(s[0] >= 1 && s[1] >= 1, function () {
      return "cropSize must be atleast [1,1], but was ".concat(s);
    }), l("bilinear" === r || "nearest" === r, function () {
      return "method must be bilinear or nearest, but was ".concat(r);
    }), wt.runKernel("CropAndResize", {
      image: i,
      boxes: o,
      boxInd: u
    }, {
      method: r,
      extrapolationValue: a,
      cropSize: s
    });
  }
}),
    Pi = At({
  flipLeftRight_: function flipLeftRight_(e) {
    var t = Et(e, "image", "flipLeftRight", "float32");
    return l(4 === t.rank, function () {
      return "Error in flipLeftRight: image must be rank 4,but got rank ".concat(t.rank, ".");
    }), wt.runKernel("FlipLeftRight", {
      image: t
    }, {});
  }
}),
    Wi = At({
  rotateWithOffset_: function rotateWithOffset_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = Et(e, "image", "rotateWithOffset", "float32");
    return l(4 === r.rank, function () {
      return "Error in rotateWithOffset: image must be rank 4,but got rank ".concat(r.rank, ".");
    }), wt.runKernel("RotateWithOffset", {
      image: r
    }, {
      radians: t,
      fillValue: n,
      center: s
    });
  }
});

function Ui(e, t, n, s, r, a) {
  null == s && (s = .5), null == r && (r = Number.NEGATIVE_INFINITY), null == a && (a = 0);
  var i = e.shape[0];
  return n = Math.min(n, i), l(0 <= s && s <= 1, function () {
    return "iouThreshold must be in [0, 1], but was '".concat(s, "'");
  }), l(2 === e.rank, function () {
    return "boxes must be a 2D tensor, but was of rank '".concat(e.rank, "'");
  }), l(4 === e.shape[1], function () {
    return "boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]);
  }), l(1 === t.rank, function () {
    return "scores must be a 1D tensor";
  }), l(t.shape[0] === i, function () {
    return "scores has incompatible shape with boxes. Expected ".concat(i, ", but was ").concat(t.shape[0]);
  }), l(0 <= a && a <= 1, function () {
    return "softNmsSigma must be in [0, 1], but was '".concat(a, "'");
  }), {
    maxOutputSize: n,
    iouThreshold: s,
    scoreThreshold: r,
    softNmsSigma: a
  };
}

var Vi = At({
  nonMaxSuppression_: function nonMaxSuppression_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = Et(e, "boxes", "nonMaxSuppression"),
        i = Et(t, "scores", "nonMaxSuppression"),
        o = Ui(a, i, n, s, r);
    return wt.runKernel("NonMaxSuppressionV3", {
      boxes: a,
      scores: i
    }, {
      maxOutputSize: n = o.maxOutputSize,
      iouThreshold: s = o.iouThreshold,
      scoreThreshold: r = o.scoreThreshold
    });
  }
});

function Gi(e, t, n) {
  var s = function (e, t, n) {
    return function (e, t, n) {
      var s = 0,
          r = e.length,
          a = 0,
          i = !1;

      for (; s < r;) {
        a = s + (r - s >>> 1);

        var _o12 = n(t, e[a]);

        _o12 > 0 ? s = a + 1 : (r = a, i = !_o12);
      }

      return i ? s : -s - 1;
    }(e, t, n || Hi);
  }(e, t, n);

  e.splice(s < 0 ? -(s + 1) : s, 0, t);
}

function Hi(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}

function ji(e, t, n, s, r) {
  return Xi(e, t, n, s, r, 0);
}

function qi(e, t, n, s, r, a) {
  return Xi(e, t, n, s, r, 0, !1, a, !0);
}

function Ki(e, t, n, s, r, a) {
  return Xi(e, t, n, s, r, a, !0);
}

function Xi(e, t, n, s, r, a) {
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
  var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !1;
  var u = [];

  for (var _e69 = 0; _e69 < t.length; _e69++) {
    t[_e69] > r && u.push({
      score: t[_e69],
      boxIndex: _e69,
      suppressBeginIndex: 0
    });
  }

  u.sort(Zi);
  var c = a > 0 ? -.5 / a : 0,
      h = [],
      d = [];

  for (; h.length < n && u.length > 0;) {
    var _t66 = u.pop(),
        _n36 = _t66.score,
        _a20 = _t66.boxIndex,
        _i16 = _t66.suppressBeginIndex;

    if (_n36 < r) break;

    var _o13 = !1;

    for (var _n37 = h.length - 1; _n37 >= _i16; --_n37) {
      var _i17 = Yi(e, _a20, h[_n37]);

      if (_i17 >= s) {
        _o13 = !0;
        break;
      }

      if (_t66.score = _t66.score * Ji(s, c, _i17), _t66.score <= r) break;
    }

    _t66.suppressBeginIndex = h.length, _o13 || (_t66.score === _n36 ? (h.push(_a20), d.push(_t66.score)) : _t66.score > r && Gi(u, _t66, Zi));
  }

  var p = h.length,
      f = n - p;
  o && f > 0 && (h.push.apply(h, _toConsumableArray(new Array(f).fill(0))), d.push.apply(d, _toConsumableArray(new Array(f).fill(0))));
  var g = {
    selectedIndices: h
  };
  return i && (g.selectedScores = d), l && (g.validOutputs = p), g;
}

function Yi(e, t, n) {
  var s = e.subarray(4 * t, 4 * t + 4),
      r = e.subarray(4 * n, 4 * n + 4),
      a = Math.min(s[0], s[2]),
      i = Math.min(s[1], s[3]),
      o = Math.max(s[0], s[2]),
      l = Math.max(s[1], s[3]),
      u = Math.min(r[0], r[2]),
      c = Math.min(r[1], r[3]),
      h = Math.max(r[0], r[2]),
      d = Math.max(r[1], r[3]),
      p = (o - a) * (l - i),
      f = (h - u) * (d - c);
  if (p <= 0 || f <= 0) return 0;
  var g = Math.max(a, u),
      m = Math.max(i, c),
      b = Math.min(o, h),
      x = Math.min(l, d),
      y = Math.max(b - g, 0) * Math.max(x - m, 0);
  return y / (p + f - y);
}

function Ji(e, t, n) {
  var s = Math.exp(t * n * n);
  return n <= e ? s : 0;
}

function Zi(e, t) {
  return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex;
}

var Qi = At({
  nonMaxSuppressionWithScore_: function nonMaxSuppressionWithScore_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var i = Et(e, "boxes", "nonMaxSuppression"),
        o = Et(t, "scores", "nonMaxSuppression"),
        l = Ui(i, o, n, s, r, a),
        u = wt.runKernel("NonMaxSuppressionV5", {
      boxes: i,
      scores: o
    }, {
      maxOutputSize: n = l.maxOutputSize,
      iouThreshold: s = l.iouThreshold,
      scoreThreshold: r = l.scoreThreshold,
      softNmsSigma: a = l.softNmsSigma
    });
    return {
      selectedIndices: u[0],
      selectedScores: u[1]
    };
  }
}),
    eo = At({
  nonMaxSuppressionPadded_: function nonMaxSuppressionPadded_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Number.NEGATIVE_INFINITY;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var i = Et(e, "boxes", "nonMaxSuppression"),
        o = Et(t, "scores", "nonMaxSuppression"),
        l = Ui(i, o, n, s, r, null),
        u = wt.runKernel("NonMaxSuppressionV4", {
      boxes: i,
      scores: o
    }, {
      maxOutputSize: l.maxOutputSize,
      iouThreshold: l.iouThreshold,
      scoreThreshold: l.scoreThreshold,
      padToMaxOutputSize: a
    });
    return {
      selectedIndices: u[0],
      validOutputs: u[1]
    };
  }
}),
    to = At({
  resizeBilinear_: function resizeBilinear_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "images", "resizeBilinear");
    l(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeBilinear: x must be rank 3 or 4, but got rank ".concat(r.rank, ".");
    }), l(2 === t.length, function () {
      return "Error in resizeBilinear: new shape must 2D, but got shape ".concat(t, ".");
    }), l(!1 === s || !1 === n, function () {
      return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.";
    });
    var a = r,
        i = !1;
    3 === r.rank && (i = !0, a = Es(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
    var o = wt.runKernel("ResizeBilinear", {
      images: a
    }, {
      alignCorners: n,
      halfPixelCenters: s,
      size: t
    });
    return i ? Es(o, [o.shape[1], o.shape[2], o.shape[3]]) : o;
  }
}),
    no = At({
  resizeNearestNeighbor_: function resizeNearestNeighbor_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = Et(e, "images", "resizeNearestNeighbor");
    l(3 === r.rank || 4 === r.rank, function () {
      return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ".concat(r.rank, ".");
    }), l(2 === t.length, function () {
      return "Error in resizeNearestNeighbor: new shape must 2D, but got shape ".concat(t, ".");
    }), l("float32" === r.dtype || "int32" === r.dtype, function () {
      return "`images` must have `int32` or `float32` as dtype";
    }), l(!1 === s || !1 === n, function () {
      return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.";
    });
    var a = r,
        i = !1;
    3 === r.rank && (i = !0, a = Es(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
    var o = wt.runKernel("ResizeNearestNeighbor", {
      images: a
    }, {
      alignCorners: n,
      halfPixelCenters: s,
      size: t
    });
    return i ? Es(o, [o.shape[1], o.shape[2], o.shape[3]]) : o;
  }
}),
    so = At({
  threshold_: function threshold_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "binary";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var r = Et(e, "image", "threshold"),
        a = r.shape[0] * r.shape[1];
    var i,
        o,
        u,
        c,
        h = ss(mi([s]), 255);

    if (l(3 === r.rank, function () {
      return "Error in threshold: image must be rank 3,but got rank ".concat(r.rank, ".");
    }), l(3 === r.shape[2] || 1 === r.shape[2], function () {
      return "Error in threshold: image color channel must be equal to 3 or 1but got ".concat(r.shape[2], ".");
    }), l("int32" === r.dtype || "float32" === r.dtype, function () {
      return "Error in dtype: image dtype must be int32 or float32,but got dtype ".concat(r.dtype, ".");
    }), l("otsu" === t || "binary" === t, function () {
      return "Method must be binary or otsu, but was ".concat(t);
    }), 3 === r.shape[2]) {
      var _oi = oi(r, [1, 1, 1], -1);

      var _oi2 = _slicedToArray(_oi, 3);

      i = _oi2[0];
      o = _oi2[1];
      u = _oi2[2];

      var _e70 = ss(i, .2989),
          _t67 = ss(o, .587),
          _n38 = ss(u, .114);

      c = es(es(_e70, _t67), _n38);
    } else c = e;

    "otsu" === t && (h = function (e, t) {
      var n,
          s,
          r,
          a,
          i,
          o,
          l = mi([-1]),
          u = mi([0]),
          c = mi([0]);

      for (var _h3 = 0; _h3 < e.size - 1; _h3++) {
        n = _s(e, 0, _h3 + 1), s = _s(e, _h3 + 1), i = ns(Gr(n), t), o = ns(Gr(s), t);

        var _d4 = Gr(ss(n, Ba(0, n.size)));

        r = ns(_d4, Gr(n));

        var _p4 = Ir(s.shape, n.size),
            _f3 = es(Ba(0, s.size), _p4),
            _g4 = ss(s, _f3);

        a = ns(Gr(_g4), Gr(s));

        var _m3 = Vr(r, a),
            _b3 = Vr(r, a),
            _x22 = ss(i, o);

        c = ss(ss(_x22, _m3), _b3);

        var _y3 = Cr(c, u);

        u = dr(_y3, c, u), l = dr(_y3, mi([_h3]), l);
      }

      return l;
    }(Ws(pn(Ha(c), "int32"), _t([]), 256), a));
    var d = n ? _r(c, h) : Cr(c, h);
    return pn(ss(d, 255), "int32");
  }
}),
    ro = At({
  transform_: function transform_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "nearest";
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "constant";
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var a = arguments.length > 5 ? arguments[5] : undefined;
    var i = Et(e, "image", "transform", "float32"),
        o = Et(t, "transforms", "transform", "float32");
    return l(4 === i.rank, function () {
      return "Error in transform: image must be rank 4,but got rank ".concat(i.rank, ".");
    }), l(2 === o.rank && (o.shape[0] === i.shape[0] || 1 === o.shape[0]) && 8 === o.shape[1], function () {
      return "Error in transform: Input transform should be batch x 8 or 1 x 8";
    }), l(null == a || 2 === a.length, function () {
      return "Error in transform: outputShape must be [height, width] or null, but got ".concat(a, ".");
    }), wt.runKernel("Transform", {
      image: i,
      transforms: o
    }, {
      interpolation: n,
      fillMode: s,
      fillValue: r,
      outputShape: a
    });
  }
}),
    ao = At({
  bandPart_: function bandPart_(e, t, n) {
    l(t % 1 == 0, function () {
      return "bandPart(): numLower must be an integer, got ".concat(t, ".");
    }), l(n % 1 == 0, function () {
      return "bandPart(): numUpper must be an integer, got ".concat(n, ".");
    });
    var s = Et(e, "a", "bandPart");
    l(s.rank >= 2, function () {
      return "bandPart(): Rank must be at least 2, got ".concat(s.rank, ".");
    });

    var r = s.shape,
        _s$shape$slice = s.shape.slice(-2),
        _s$shape$slice2 = _slicedToArray(_s$shape$slice, 2),
        a = _s$shape$slice2[0],
        i = _s$shape$slice2[1];

    if (!(t <= a)) throw new Error("bandPart(): numLower (".concat(t, ") must not be greater than the number of rows (").concat(a, ")."));
    if (!(n <= i)) throw new Error("bandPart(): numUpper (".concat(n, ") must not be greater than the number of columns (").concat(i, ")."));
    t < 0 && (t = a), n < 0 && (n = i);
    var o = Es(Ba(0, a, 1, "int32"), [-1, 1]),
        u = Ba(0, i, 1, "int32"),
        c = Vr(o, u),
        h = ta(_r(c, qa(+t, "int32")), Sr(c, qa(-n, "int32"))),
        d = ua([a, i], s.dtype);
    return Es(di(vi(Es(s, [-1, a, i])).map(function (e) {
      return dr(h, e, d);
    })), r);
  }
}),
    io = At({
  gramSchmidt_: function gramSchmidt_(e) {
    var t;

    if (Array.isArray(e)) {
      (function () {
        t = !1, l(null != e && e.length > 0, function () {
          return "Gram-Schmidt process: input must not be null, undefined, or empty";
        });
        var n = e[0].shape[0];

        var _loop6 = function _loop6(_t68) {
          l(e[_t68].shape[0] === n, function () {
            return "Gram-Schmidt: Non-unique lengths found in the input vectors: (".concat(e[_t68].shape[0], " vs. ").concat(n, ")");
          });
        };

        for (var _t68 = 1; _t68 < e.length; ++_t68) {
          _loop6(_t68);
        }
      })();
    } else t = !0, e = oi(e, e.shape[0], 0).map(function (e) {
      return hi(e, [0]);
    });

    l(e.length <= e[0].shape[0], function () {
      return "Gram-Schmidt: Number of vectors (".concat(e.length, ") exceeds number of dimensions (").concat(e[0].shape[0], ").");
    });
    var n = [],
        s = e;

    var _loop7 = function _loop7(_t69) {
      n.push(wt.tidy(function () {
        var e = s[_t69];
        if (_t69 > 0) for (var _s40 = 0; _s40 < _t69; ++_s40) {
          var _t70 = ss(Gr(ss(n[_s40], e)), n[_s40]);

          e = Vr(e, _t70);
        }
        return ns(e, Ni(e, "euclidean"));
      }));
    };

    for (var _t69 = 0; _t69 < e.length; ++_t69) {
      _loop7(_t69);
    }

    return t ? di(n, 0) : n;
  }
});

function oo(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  return wt.tidy(function () {
    l(2 === e.shape.length, function () {
      return "qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length, "D Tensor.");
    });
    var n = e.shape[0],
        s = e.shape[1];
    var r = vr(n),
        a = fn(e);
    var i = bi([[1]], [1, 1]);
    var o = fn(i);
    var u = n >= s ? s : n;

    var _loop8 = function _loop8(_e71) {
      var _wt$tidy, _wt$tidy2;

      var t = a,
          l = o,
          u = r;
      (_wt$tidy = wt.tidy(function () {
        var t = _s(a, [_e71, _e71], [n - _e71, 1]),
            l = Ni(t),
            u = _s(a, [_e71, _e71], [1, 1]),
            c = dr(Cr(u, 0), bi([[-1]]), bi([[1]])),
            h = Vr(u, ss(c, l)),
            d = ns(t, h);

        o = 1 === d.shape[0] ? fn(i) : Fs([i, _s(d, [1, 0], [d.shape[0] - 1, d.shape[1]])], 0);

        var p = Br(ns(vn(c, h), l)),
            f = _s(a, [_e71, 0], [n - _e71, s]),
            g = ss(p, o),
            m = $n(o);

        if (0 === _e71) a = Vr(f, vn(g, vn(m, f)));else {
          var _t71 = Vr(f, vn(g, vn(m, f)));

          a = Fs([_s(a, [0, 0], [_e71, s]), _t71], 0);
        }

        var b = $n(g),
            x = _s(r, [0, _e71], [n, r.shape[1] - _e71]);

        if (0 === _e71) r = Vr(x, vn(vn(x, o), b));else {
          var _t72 = Vr(x, vn(vn(x, o), b));

          r = Fs([_s(r, [0, 0], [n, _e71]), _t72], 1);
        }
        return [o, a, r];
      }), _wt$tidy2 = _slicedToArray(_wt$tidy, 3), o = _wt$tidy2[0], a = _wt$tidy2[1], r = _wt$tidy2[2], _wt$tidy), Jn([t, l, u]);
    };

    for (var _e71 = 0; _e71 < u; ++_e71) {
      _loop8(_e71);
    }

    return !t && n > s && (r = _s(r, [0, 0], [n, s]), a = _s(a, [0, 0], [s, s])), [r, a];
  });
}

var lo = At({
  qr_: function qr_(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (l(e.rank >= 2, function () {
      return "qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank);
    }), 2 === e.rank) return oo(e, t);
    {
      var _n39 = e.shape.slice(0, e.shape.length - 2).reduce(function (e, t) {
        return e * t;
      }),
          _s41 = vi(Es(e, [_n39, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
          _r32 = [],
          _a21 = [];

      return _s41.forEach(function (e) {
        var _oo = oo(e, t),
            _oo2 = _slicedToArray(_oo, 2),
            n = _oo2[0],
            s = _oo2[1];

        _r32.push(n), _a21.push(s);
      }), [Es(di(_r32, 0), e.shape), Es(di(_a21, 0), e.shape)];
    }
  }
});
var uo;
!function (e) {
  e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(uo || (uo = {}));
var co = At({
  computeWeightedLoss_: function computeWeightedLoss_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uo.SUM_BY_NONZERO_WEIGHTS;
    var s = Et(e, "losses", "computeWeightedLoss");
    var r = null;
    null != t && (r = Et(t, "weights", "computeWeightedLoss"));
    var a = null == r ? s : ss(s, r);
    if (n === uo.NONE) return a;
    if (n === uo.SUM) return Gr(a);

    if (n === uo.MEAN) {
      if (null == r) return la(a);
      {
        var _e72 = s.size / r.size,
            _t73 = ns(Gr(a), Gr(r));

        return _e72 > 1 ? ns(_t73, qa(_e72)) : _t73;
      }
    }

    if (n === uo.SUM_BY_NONZERO_WEIGHTS) {
      if (null == r) return ns(Gr(a), qa(s.size));
      {
        var _e73 = ss(r, ca(s.shape)),
            _t74 = pn(Gr(ba(_e73, qa(0))), "float32");

        return ns(Gr(a), _t74);
      }
    }

    throw Error("Unknown reduction: ".concat(n));
  }
});
At({
  absoluteDifference_: function absoluteDifference_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uo.SUM_BY_NONZERO_WEIGHTS;
    var r = Et(e, "labels", "absoluteDifference"),
        a = Et(t, "predictions", "absoluteDifference");
    var i = null;
    null != n && (i = Et(n, "weights", "absoluteDifference")), u(r.shape, a.shape, "Error in absoluteDifference: ");
    var o = rs(Vr(r, a));
    return co(o, i, s);
  }
}), At({
  cosineDistance_: function cosineDistance_(e, t, n, s) {
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "labels", "cosineDistance"),
        i = Et(t, "predictions", "cosineDistance");
    var o = null;
    null != s && (o = Et(s, "weights", "cosineDistance")), u(a.shape, i.shape, "Error in cosineDistance: ");
    var l = qa(1),
        c = Vr(l, Gr(ss(a, i), n, !0));
    return co(c, o, r);
  }
}), At({
  hingeLoss_: function hingeLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uo.SUM_BY_NONZERO_WEIGHTS;
    var r = Et(e, "labels", "hingeLoss");
    var a = Et(t, "predictions", "hingeLoss");
    var i = null;
    null != n && (i = Et(n, "weights", "hingeLoss")), u(r.shape, a.shape, "Error in hingeLoss: ");
    var o = qa(1);
    r = Vr(ss(qa(2), r), o);
    var l = Ua(Vr(o, ss(r, a)));
    return co(l, i, s);
  }
}), At({
  huberLoss_: function huberLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "labels", "huberLoss"),
        i = Et(t, "predictions", "huberLoss");
    var o = null;
    null != n && (o = Et(n, "weights", "huberLoss")), u(a.shape, i.shape, "Error in huberLoss: ");
    var l = qa(s),
        c = rs(Vr(i, a)),
        h = da(c, l),
        d = Vr(c, h),
        p = es(ss(qa(.5), ga(h)), ss(l, d));
    return co(p, o, r);
  }
}), At({
  logLoss_: function logLoss_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "labels", "logLoss"),
        i = Et(t, "predictions", "logLoss");
    var o = null;
    null != n && (o = Et(n, "weights", "logLoss")), u(a.shape, i.shape, "Error in logLoss: ");
    var l = qa(1),
        c = qa(s),
        h = Br(ss(a, Mr(es(i, c)))),
        d = ss(Vr(l, a), Mr(es(Vr(l, i), c))),
        p = Vr(h, d);
    return co(p, o, r);
  }
}), At({
  meanSquaredError_: function meanSquaredError_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uo.SUM_BY_NONZERO_WEIGHTS;
    var r = Et(e, "labels", "meanSquaredError"),
        a = Et(t, "predictions", "meanSquaredError");
    var i = null;
    null != n && (i = Et(n, "weights", "meanSquaredError")), u(r.shape, a.shape, "Error in meanSquaredError: ");
    var o = ci(r, a);
    return co(o, i, s);
  }
}), At({
  sigmoidCrossEntropy_: function sigmoidCrossEntropy_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "multiClassLabels", "sigmoidCrossEntropy");
    var i = Et(t, "logits", "sigmoidCrossEntropy");
    var o = null;

    if (null != n && (o = Et(n, "weights", "sigmoidCrossEntropy")), u(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), s > 0) {
      var _e74 = qa(s),
          _t75 = qa(1),
          _n40 = qa(.5);

      a = es(ss(a, Vr(_t75, _e74)), ss(_n40, _e74));
    }

    var l = function (e, t) {
      var n = Et(e, "labels", "sigmoidCrossEntropyWithLogits"),
          s = Et(t, "logits", "sigmoidCrossEntropyWithLogits");
      u(n.shape, s.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      var r = Ua(s),
          a = ss(s, n),
          i = Lr(xr(Br(rs(s))));
      return es(Vr(r, a), i);
    }(a, i);

    return co(l, o, r);
  }
}), At({
  softmaxCrossEntropy_: function softmaxCrossEntropy_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : uo.SUM_BY_NONZERO_WEIGHTS;
    var a = Et(e, "onehotLabels", "softmaxCrossEntropy");
    var i = Et(t, "logits", "softmaxCrossEntropy");
    var o = null;

    if (null != n && (o = Et(n, "weights", "softmaxCrossEntropy")), u(a.shape, i.shape, "Error in softmaxCrossEntropy: "), s > 0) {
      var _e75 = qa(s),
          _t76 = qa(1),
          _n41 = qa(a.shape[1]);

      a = es(ss(a, Vr(_t76, _e75)), ns(_e75, _n41));
    }

    var l = function (e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      if (-1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ".concat(t.rank, " and dim was ").concat(n));
      return zr(function (e, t, s) {
        var r = ea(t, [n], !0),
            a = Vr(pn(t, "float32"), r);
        s([e, a]);
        var i = Br(ss(a, e));
        return {
          value: Gr(i, [n]),
          gradFunc: function gradFunc(e, t) {
            var _t77 = _slicedToArray(t, 2),
                s = _t77[0],
                r = _t77[1],
                a = Xr(e.shape, [n]);

            return [ss(Es(e, a), Vr(pn(s, "float32"), xr(r))), ss(Es(e, a), Vr(xr(r), pn(s, "float32")))];
          }
        };
      })(e, t);
    }(a, i);

    return co(l, o, r);
  }
}), At({
  sparseFillEmptyRows_: function sparseFillEmptyRows_(e, t, n, s) {
    var r = Et(e, "indices", "sparseFillEmptyRows"),
        a = Et(t, "values", "sparseFillEmptyRows"),
        i = Et(n, "denseShape", "sparseFillEmptyRows"),
        o = Et(s, "defaultValue", "sparseFillEmptyRows", a.dtype);
    if (2 !== r.rank) throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Values should be Tensor1D but received shape ".concat(a.shape));
    if (1 !== i.rank) throw new Error("Dense shape should be Tensor1D but received shape ".concat(i.shape));
    if (0 !== o.rank) throw new Error("Default value should be a scalar but received shape ".concat(o.shape));
    var l = wt.runKernel("SparseFillEmptyRows", {
      indices: r,
      values: a,
      denseShape: i,
      defaultValue: o
    });
    return {
      outputIndices: l[0],
      outputValues: l[1],
      emptyRowIndicator: l[2],
      reverseIndexMap: l[3]
    };
  }
}), At({
  sparseReshape_: function sparseReshape_(e, t, n) {
    var s = Et(e, "inputIndices", "sparseReshape"),
        r = Et(t, "inputShape", "sparseReshape"),
        a = Et(n, "newShape", "sparseReshape");
    if (2 !== s.rank) throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(s.shape));
    if (1 !== r.rank) throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));
    if (1 !== a.rank) throw new Error("New shape should be Tensor1D but received shape ".concat(a.shape));
    var i = wt.runKernel("SparseReshape", {
      inputIndices: s,
      inputShape: r,
      newShape: a
    });
    return {
      outputIndices: i[0],
      outputShape: i[1]
    };
  }
}), At({
  sparseSegmentMean_: function sparseSegmentMean_(e, t, n) {
    var s = Et(e, "data", "sparseSegmentMean"),
        r = Et(t, "indices", "sparseSegmentMean"),
        a = Et(n, "segmentIds", "sparseSegmentMean");
    if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.rank) throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(a.shape));
    return wt.runKernel("SparseSegmentMean", {
      data: s,
      indices: r,
      segmentIds: a
    });
  }
}), At({
  sparseSegmentSum_: function sparseSegmentSum_(e, t, n) {
    var s = Et(e, "data", "sparseSegmentSum"),
        r = Et(t, "indices", "sparseSegmentSum"),
        a = Et(n, "segmentIds", "sparseSegmentSum");
    if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.rank) throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));
    if (1 !== a.rank) throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(a.shape));
    return wt.runKernel("SparseSegmentSum", {
      data: s,
      indices: r,
      segmentIds: a
    });
  }
}), At({
  stringNGrams_: function stringNGrams_(e, t, n, s, r, a, i, o) {
    var l = Et(e, "data", "stringNGrams", "string");
    if ("string" !== l.dtype) throw new Error("Data must be of datatype string");
    if (1 !== l.shape.length) throw new Error("Data must be a vector, saw: ".concat(l.shape));
    var u = Et(t, "dataSplits", "stringNGrams");
    if ("int32" !== u.dtype) throw new Error("Data splits must be of datatype int32");
    var c = wt.runKernel("StringNGrams", {
      data: l,
      dataSplits: u
    }, {
      separator: n,
      nGramWidths: s,
      leftPad: r,
      rightPad: a,
      padWidth: i,
      preserveShortSequences: o
    });
    return {
      nGrams: c[0],
      nGramsSplits: c[1]
    };
  }
}), At({
  stringSplit_: function stringSplit_(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    var s = Et(e, "input", "stringSplit", "string"),
        r = Et(t, "delimiter", "stringSplit", "string");
    if (1 !== s.rank) throw new Error("Input should be Tensor1D but received shape ".concat(s.shape));
    if (0 !== r.rank) throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));
    var a = wt.runKernel("StringSplit", {
      input: s,
      delimiter: r
    }, {
      skipEmpty: n
    });
    return {
      indices: a[0],
      values: a[1],
      shape: a[2]
    };
  }
}), At({
  stringToHashBucketFast_: function stringToHashBucketFast_(e, t) {
    var n = Et(e, "input", "stringToHashBucketFast", "string"),
        s = {
      numBuckets: t
    };
    if (t <= 0) throw new Error("Number of buckets must be at least 1");
    return wt.runKernel("StringToHashBucketFast", {
      input: n
    }, s);
  }
});
var ho = {
  flipLeftRight: Pi,
  resizeNearestNeighbor: no,
  resizeBilinear: to,
  rotateWithOffset: Wi,
  cropAndResize: Bi,
  nonMaxSuppression: Vi,
  nonMaxSuppressionAsync: function () {
    var _nonMaxSuppressionAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(e, t, n) {
      var s,
          r,
          a,
          i,
          o,
          l,
          u,
          c,
          _ji,
          h,
          _args24 = arguments;

      return _regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              s = _args24.length > 3 && _args24[3] !== undefined ? _args24[3] : .5;
              r = _args24.length > 4 && _args24[4] !== undefined ? _args24[4] : Number.NEGATIVE_INFINITY;
              a = Et(e, "boxes", "nonMaxSuppressionAsync"), i = Et(t, "scores", "nonMaxSuppressionAsync"), o = Ui(a, i, n, s, r);
              n = o.maxOutputSize, s = o.iouThreshold, r = o.scoreThreshold;
              _context24.next = 6;
              return Promise.all([a.data(), i.data()]);

            case 6:
              l = _context24.sent;
              u = l[0];
              c = l[1];
              _ji = ji(u, c, n, s, r);
              h = _ji.selectedIndices;
              return _context24.abrupt("return", (a !== e && a.dispose(), i !== t && i.dispose(), mi(h, "int32")));

            case 12:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    }));

    function nonMaxSuppressionAsync(_x23, _x24, _x25) {
      return _nonMaxSuppressionAsync.apply(this, arguments);
    }

    return nonMaxSuppressionAsync;
  }(),
  nonMaxSuppressionWithScore: Qi,
  nonMaxSuppressionWithScoreAsync: function () {
    var _nonMaxSuppressionWithScoreAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(e, t, n) {
      var s,
          r,
          a,
          i,
          o,
          l,
          u,
          c,
          h,
          _Ki,
          d,
          p,
          _args25 = arguments;

      return _regeneratorRuntime.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              s = _args25.length > 3 && _args25[3] !== undefined ? _args25[3] : .5;
              r = _args25.length > 4 && _args25[4] !== undefined ? _args25[4] : Number.NEGATIVE_INFINITY;
              a = _args25.length > 5 && _args25[5] !== undefined ? _args25[5] : 0;
              i = Et(e, "boxes", "nonMaxSuppressionAsync"), o = Et(t, "scores", "nonMaxSuppressionAsync"), l = Ui(i, o, n, s, r, a);
              n = l.maxOutputSize, s = l.iouThreshold, r = l.scoreThreshold, a = l.softNmsSigma;
              _context25.next = 7;
              return Promise.all([i.data(), o.data()]);

            case 7:
              u = _context25.sent;
              c = u[0];
              h = u[1];
              _Ki = Ki(c, h, n, s, r, a);
              d = _Ki.selectedIndices;
              p = _Ki.selectedScores;
              return _context25.abrupt("return", (i !== e && i.dispose(), o !== t && o.dispose(), {
                selectedIndices: mi(d, "int32"),
                selectedScores: mi(p)
              }));

            case 14:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25);
    }));

    function nonMaxSuppressionWithScoreAsync(_x26, _x27, _x28) {
      return _nonMaxSuppressionWithScoreAsync.apply(this, arguments);
    }

    return nonMaxSuppressionWithScoreAsync;
  }(),
  nonMaxSuppressionPadded: eo,
  nonMaxSuppressionPaddedAsync: function () {
    var _nonMaxSuppressionPaddedAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(e, t, n) {
      var s,
          r,
          a,
          i,
          o,
          l,
          u,
          c,
          h,
          _yield$Promise$all,
          _yield$Promise$all2,
          d,
          p,
          _qi,
          f,
          g,
          _args26 = arguments;

      return _regeneratorRuntime.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              s = _args26.length > 3 && _args26[3] !== undefined ? _args26[3] : .5;
              r = _args26.length > 4 && _args26[4] !== undefined ? _args26[4] : Number.NEGATIVE_INFINITY;
              a = _args26.length > 5 && _args26[5] !== undefined ? _args26[5] : !1;
              i = Et(e, "boxes", "nonMaxSuppressionAsync");
              o = Et(t, "scores", "nonMaxSuppressionAsync");
              l = Ui(i, o, n, s, r, null);
              u = l.maxOutputSize;
              c = l.iouThreshold;
              h = l.scoreThreshold;
              _context26.next = 11;
              return Promise.all([i.data(), o.data()]);

            case 11:
              _yield$Promise$all = _context26.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              d = _yield$Promise$all2[0];
              p = _yield$Promise$all2[1];
              _qi = qi(d, p, u, c, h, a);
              f = _qi.selectedIndices;
              g = _qi.validOutputs;
              return _context26.abrupt("return", (i !== e && i.dispose(), o !== t && o.dispose(), {
                selectedIndices: mi(f, "int32"),
                validOutputs: qa(g, "int32")
              }));

            case 19:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26);
    }));

    function nonMaxSuppressionPaddedAsync(_x29, _x30, _x31) {
      return _nonMaxSuppressionPaddedAsync.apply(this, arguments);
    }

    return nonMaxSuppressionPaddedAsync;
  }(),
  threshold: so,
  transform: ro
},
    po = {
  bandPart: ao,
  gramSchmidt: io,
  qr: lo
};

var fo = /*#__PURE__*/function (_Hn) {
  "use strict";

  _inherits(fo, _Hn);

  var _super2 = _createSuper(fo);

  function fo() {
    _classCallCheck(this, fo);

    return _super2.apply(this, arguments);
  }

  _createClass(fo, [{
    key: "minimize",
    value: function minimize(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      var n = arguments.length > 2 ? arguments[2] : undefined;

      var _this$computeGradient = this.computeGradients(e, n),
          s = _this$computeGradient.value,
          r = _this$computeGradient.grads;

      if (null != n) {
        var _e76 = n.map(function (e) {
          return {
            name: e.name,
            tensor: r[e.name]
          };
        });

        this.applyGradients(_e76);
      } else this.applyGradients(r);

      return Jn(r), t ? s : (s.dispose(), null);
    }
  }, {
    key: "iterations",
    get: function get() {
      return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
    }
  }, {
    key: "incrementIterations",
    value: function incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
  }, {
    key: "computeGradients",
    value: function computeGradients(e, t) {
      return function (e, t) {
        l(E(e), function () {
          return "The f passed in variableGrads(f) must be a function";
        }), l(null == t || Array.isArray(t) && t.every(function (e) {
          return e instanceof at;
        }), function () {
          return "The varList passed in variableGrads(f, varList) must be an array of variables";
        });
        var n = null != t;

        if (!n) {
          t = [];

          for (var _e77 in wt.registeredVariables) {
            t.push(wt.registeredVariables[_e77]);
          }
        }

        var s = n ? t.filter(function (e) {
          return !e.trainable;
        }) : null,
            r = t.length;
        l((t = t.filter(function (e) {
          return e.trainable;
        })).length > 0, function () {
          return "variableGrads() expects at least one of the input variables to be trainable, but none of the ".concat(r, " variables is trainable.");
        });

        var _wt$gradients = wt.gradients(e, t, null, !0),
            a = _wt$gradients.value,
            i = _wt$gradients.grads;

        l(i.some(function (e) {
          return null != e;
        }), function () {
          return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
        }), l(0 === a.rank, function () {
          return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-".concat(a.rank, " tensor");
        });
        var o = {};
        return t.forEach(function (e, t) {
          null != i[t] && (o[e.name] = i[t]);
        }), null != s && s.forEach(function (e) {
          return o[e.name] = null;
        }), {
          value: a,
          grads: o
        };
      }(e, t);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null != this.iterations_ && Jn(this.iterations_);
    }
  }, {
    key: "saveIterations",
    value: function () {
      var _saveIterations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {
        return _regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                return _context27.abrupt("return", (null == this.iterations_ && (this.iterations_ = 0), {
                  name: "iter",
                  tensor: qa(this.iterations_, "int32")
                }));

              case 1:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function saveIterations() {
        return _saveIterations.apply(this, arguments);
      }

      return saveIterations;
    }()
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {
        return _regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                throw new Error("getWeights() is not implemented for this optimizer yet.");

              case 1:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28);
      }));

      function getWeights() {
        return _getWeights.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(e) {
        return _regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                throw new Error("setWeights() is not implemented for this optimizer class ".concat(this.getClassName()));

              case 1:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function setWeights(_x32) {
        return _setWeights.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "extractIterations",
    value: function () {
      var _extractIterations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(e) {
        return _regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return e[0].tensor.data();

              case 2:
                this.iterations_ = _context30.sent[0];
                return _context30.abrupt("return", e.slice(1));

              case 4:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function extractIterations(_x33) {
        return _extractIterations.apply(this, arguments);
      }

      return extractIterations;
    }()
  }]);

  return fo;
}(Hn);

Object.defineProperty(fo, Symbol.hasInstance, {
  value: function value(e) {
    return null != e.minimize && null != e.computeGradients && null != e.applyGradients;
  }
});

var go = /*#__PURE__*/function (_fo) {
  "use strict";

  _inherits(go, _fo);

  var _super3 = _createSuper(go);

  function go(e, t) {
    var _this22;

    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, go);

    _this22 = _super3.call(this), _this22.learningRate = e, _this22.rho = t, _this22.epsilon = n, _this22.accumulatedGrads = [], _this22.accumulatedUpdates = [], null == n && (_this22.epsilon = wt.backend.epsilon());
    return _this22;
  }

  _createClass(go, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this23 = this;

      (Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e)).forEach(function (t, n) {
        var s = wt.registeredVariables[t];
        null == _this23.accumulatedGrads[n] && (_this23.accumulatedGrads[n] = {
          originalName: "".concat(t, "/accum_grad"),
          variable: Yn(function () {
            return pr(s).variable(!1);
          })
        }), null == _this23.accumulatedUpdates[n] && (_this23.accumulatedUpdates[n] = {
          originalName: "".concat(t, "/accum_var"),
          variable: Yn(function () {
            return pr(s).variable(!1);
          })
        });
        var r = Array.isArray(e) ? e[n].tensor : e[t];
        if (null == r) return;
        var a = _this23.accumulatedGrads[n].variable,
            i = _this23.accumulatedUpdates[n].variable;
        Yn(function () {
          var e = es(ss(a, _this23.rho), ss(ga(r), 1 - _this23.rho)),
              t = ss(ns(ui(es(i, _this23.epsilon)), ui(es(a, _this23.epsilon))), r),
              n = es(ss(i, _this23.rho), ss(ga(t), 1 - _this23.rho));
          a.assign(e), i.assign(n);
          var o = es(ss(t, -_this23.learningRate), s);
          s.assign(o);
        });
      }), this.incrementIterations();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null != this.accumulatedUpdates && (Jn(this.accumulatedGrads.map(function (e) {
        return e.variable;
      })), Jn(this.accumulatedUpdates.map(function (e) {
        return e.variable;
      })));
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {
        var e;
        return _regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                e = [].concat(_toConsumableArray(this.accumulatedGrads), _toConsumableArray(this.accumulatedUpdates));
                _context31.next = 3;
                return this.saveIterations();

              case 3:
                _context31.t0 = _context31.sent;
                return _context31.abrupt("return", [_context31.t0].concat(e.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));

              case 5:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this);
      }));

      function getWeights() {
        return _getWeights2.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(e) {
        var t;
        return _regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.extractIterations(e);

              case 2:
                _context32.t0 = (e = _context32.sent).length;
                t = _context32.t0 / 2;
                this.accumulatedGrads = e.slice(0, t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                  };
                }), this.accumulatedUpdates = e.slice(t, 2 * t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                  };
                });

              case 5:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this);
      }));

      function setWeights(_x34) {
        return _setWeights2.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate,
        rho: this.rho,
        epsilon: this.epsilon
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate, t.rho, t.epsilon);
    }
  }]);

  return go;
}(fo);

go.className = "Adadelta", qn(go);

var mo = /*#__PURE__*/function (_fo2) {
  "use strict";

  _inherits(mo, _fo2);

  var _super4 = _createSuper(mo);

  function mo(e) {
    var _this24;

    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .1;

    _classCallCheck(this, mo);

    _this24 = _super4.call(this), _this24.learningRate = e, _this24.initialAccumulatorValue = t, _this24.accumulatedGrads = [];
    return _this24;
  }

  _createClass(mo, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this25 = this;

      (Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e)).forEach(function (t, n) {
        var s = wt.registeredVariables[t];

        if (null == _this25.accumulatedGrads[n]) {
          var _e78 = !1;

          _this25.accumulatedGrads[n] = {
            originalName: "".concat(t, "/accumulator"),
            variable: Yn(function () {
              return Ir(s.shape, _this25.initialAccumulatorValue).variable(_e78);
            })
          };
        }

        var r = Array.isArray(e) ? e[n].tensor : e[t];
        if (null == r) return;
        var a = _this25.accumulatedGrads[n].variable;
        Yn(function () {
          var e = es(a, ga(r));
          a.assign(e);
          var t = es(ss(ns(r, ui(es(e, wt.backend.epsilon()))), -_this25.learningRate), s);
          s.assign(t);
        });
      }), this.incrementIterations();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null != this.accumulatedGrads && Jn(this.accumulatedGrads.map(function (e) {
        return e.variable;
      }));
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee33() {
        return _regeneratorRuntime.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.next = 2;
                return this.saveIterations();

              case 2:
                _context33.t0 = _context33.sent;
                return _context33.abrupt("return", [_context33.t0].concat(this.accumulatedGrads.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));

              case 4:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this);
      }));

      function getWeights() {
        return _getWeights3.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee34(e) {
        return _regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.extractIterations(e);

              case 2:
                e = _context34.sent;
                this.accumulatedGrads = e.map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                  };
                });

              case 4:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));

      function setWeights(_x35) {
        return _setWeights3.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate,
        initialAccumulatorValue: this.initialAccumulatorValue
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate, t.initialAccumulatorValue);
    }
  }]);

  return mo;
}(fo);

mo.className = "Adagrad", qn(mo);

var bo = /*#__PURE__*/function (_fo3) {
  "use strict";

  _inherits(bo, _fo3);

  var _super5 = _createSuper(bo);

  function bo(e, t, n) {
    var _this26;

    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, bo);

    _this26 = _super5.call(this), _this26.learningRate = e, _this26.beta1 = t, _this26.beta2 = n, _this26.epsilon = s, _this26.accumulatedFirstMoment = [], _this26.accumulatedSecondMoment = [], Yn(function () {
      _this26.accBeta1 = qa(t).variable(), _this26.accBeta2 = qa(n).variable();
    }), null == s && (_this26.epsilon = wt.backend.epsilon());
    return _this26;
  }

  _createClass(bo, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this27 = this;

      var t = Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e);
      Yn(function () {
        var n = Vr(1, _this27.accBeta1),
            s = Vr(1, _this27.accBeta2);
        t.forEach(function (t, r) {
          var a = wt.registeredVariables[t];
          null == _this27.accumulatedFirstMoment[r] && (_this27.accumulatedFirstMoment[r] = {
            originalName: "".concat(t, "/m"),
            variable: Yn(function () {
              return pr(a).variable(!1);
            })
          }), null == _this27.accumulatedSecondMoment[r] && (_this27.accumulatedSecondMoment[r] = {
            originalName: "".concat(t, "/v"),
            variable: Yn(function () {
              return pr(a).variable(!1);
            })
          });
          var i = Array.isArray(e) ? e[r].tensor : e[t];
          if (null == i) return;
          var o = _this27.accumulatedFirstMoment[r].variable,
              l = _this27.accumulatedSecondMoment[r].variable,
              u = es(ss(o, _this27.beta1), ss(i, 1 - _this27.beta1)),
              c = es(ss(l, _this27.beta2), ss(ga(i), 1 - _this27.beta2)),
              h = ns(u, n),
              d = ns(c, s);
          o.assign(u), l.assign(c);
          var p = es(ss(ns(h, es(ui(d), _this27.epsilon)), -_this27.learningRate), a);
          a.assign(p);
        }), _this27.accBeta1.assign(ss(_this27.accBeta1, _this27.beta1)), _this27.accBeta2.assign(ss(_this27.accBeta2, _this27.beta2));
      }), this.incrementIterations();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Jn(this.accumulatedFirstMoment.map(function (e) {
        return e.variable;
      })), null != this.accumulatedSecondMoment && Jn(this.accumulatedSecondMoment.map(function (e) {
        return e.variable;
      }));
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee35() {
        var e;
        return _regeneratorRuntime.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                e = [].concat(_toConsumableArray(this.accumulatedFirstMoment), _toConsumableArray(this.accumulatedSecondMoment));
                _context35.next = 3;
                return this.saveIterations();

              case 3:
                _context35.t0 = _context35.sent;
                return _context35.abrupt("return", [_context35.t0].concat(e.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));

              case 5:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getWeights() {
        return _getWeights4.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee36(e) {
        var _this28 = this;

        var t;
        return _regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.extractIterations(e);

              case 2:
                e = _context36.sent;
                Yn(function () {
                  _this28.accBeta1.assign(va(_this28.beta1, _this28.iterations_ + 1)), _this28.accBeta2.assign(va(_this28.beta2, _this28.iterations_ + 1));
                });
                t = e.length / 2;
                this.accumulatedFirstMoment = e.slice(0, t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                  };
                }), this.accumulatedSecondMoment = e.slice(t, 2 * t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                  };
                });

              case 6:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function setWeights(_x36) {
        return _setWeights4.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
    }
  }]);

  return bo;
}(fo);

bo.className = "Adam", qn(bo);

var xo = /*#__PURE__*/function (_fo4) {
  "use strict";

  _inherits(xo, _fo4);

  var _super6 = _createSuper(xo);

  function xo(e, t, n) {
    var _this29;

    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    _classCallCheck(this, xo);

    _this29 = _super6.call(this), _this29.learningRate = e, _this29.beta1 = t, _this29.beta2 = n, _this29.epsilon = s, _this29.decay = r, _this29.accumulatedFirstMoment = [], _this29.accumulatedWeightedInfNorm = [], Yn(function () {
      _this29.iteration = qa(0).variable(), _this29.accBeta1 = qa(t).variable();
    }), null == s && (_this29.epsilon = wt.backend.epsilon());
    return _this29;
  }

  _createClass(xo, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this30 = this;

      var t = Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e);
      Yn(function () {
        var n = Vr(1, _this30.accBeta1),
            s = ns(-_this30.learningRate, es(ss(_this30.iteration, _this30.decay), 1));
        t.forEach(function (t, r) {
          var a = wt.registeredVariables[t];
          null == _this30.accumulatedFirstMoment[r] && (_this30.accumulatedFirstMoment[r] = {
            originalName: "".concat(t, "/m"),
            variable: pr(a).variable(!1)
          }), null == _this30.accumulatedWeightedInfNorm[r] && (_this30.accumulatedWeightedInfNorm[r] = {
            originalName: "".concat(t, "/v"),
            variable: pr(a).variable(!1)
          });
          var i = Array.isArray(e) ? e[r].tensor : e[t];
          if (null == i) return;
          var o = _this30.accumulatedFirstMoment[r].variable,
              l = _this30.accumulatedWeightedInfNorm[r].variable,
              u = es(ss(o, _this30.beta1), ss(i, 1 - _this30.beta1)),
              c = ss(l, _this30.beta2),
              h = rs(i),
              d = oa(c, h);
          o.assign(u), l.assign(d);
          var p = es(ss(ns(s, n), ns(u, es(d, _this30.epsilon))), a);
          a.assign(p);
        }), _this30.iteration.assign(es(_this30.iteration, 1)), _this30.accBeta1.assign(ss(_this30.accBeta1, _this30.beta1));
      }), this.incrementIterations();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Jn(this.accumulatedFirstMoment.map(function (e) {
        return e.variable;
      })), null != this.accumulatedWeightedInfNorm && Jn(this.accumulatedWeightedInfNorm.map(function (e) {
        return e.variable;
      }));
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee37() {
        return _regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                throw new Error("getWeights() is not implemented for Adamax yet.");

              case 1:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37);
      }));

      function getWeights() {
        return _getWeights5.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee38(e) {
        return _regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                throw new Error("setWeights() is not implemented for Adamax yet.");

              case 1:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38);
      }));

      function setWeights(_x37) {
        return _setWeights5.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon,
        decay: this.decay
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
    }
  }]);

  return xo;
}(fo);

xo.className = "Adamax", qn(xo);

var yo = /*#__PURE__*/function (_fo5) {
  "use strict";

  _inherits(yo, _fo5);

  var _super7 = _createSuper(yo);

  function yo(e) {
    var _this31;

    _classCallCheck(this, yo);

    _this31 = _super7.call(this), _this31.learningRate = e, _this31.setLearningRate(e);
    return _this31;
  }

  _createClass(yo, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this32 = this;

      (Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e)).forEach(function (t, n) {
        var s = Array.isArray(e) ? e[n].tensor : e[t];
        if (null == s) return;
        var r = wt.registeredVariables[t];
        Yn(function () {
          var e = es(ss(_this32.c, s), r);
          r.assign(e);
        });
      }), this.incrementIterations();
    }
  }, {
    key: "setLearningRate",
    value: function setLearningRate(e) {
      this.learningRate = e, null != this.c && this.c.dispose(), this.c = Zn(qa(-e));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.c.dispose();
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee39() {
        return _regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                _context39.next = 2;
                return this.saveIterations();

              case 2:
                _context39.t0 = _context39.sent;
                return _context39.abrupt("return", [_context39.t0]);

              case 4:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function getWeights() {
        return _getWeights6.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee40(e) {
        return _regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.extractIterations(e);

              case 2:
                _context40.t0 = (e = _context40.sent).length;

                if (!(0 !== _context40.t0)) {
                  _context40.next = 5;
                  break;
                }

                throw new Error("SGD optimizer does not have settable weights.");

              case 5:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function setWeights(_x38) {
        return _setWeights6.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate);
    }
  }]);

  return yo;
}(fo);

yo.className = "SGD", qn(yo);

var ko = /*#__PURE__*/function (_yo) {
  "use strict";

  _inherits(ko, _yo);

  var _super8 = _createSuper(ko);

  function ko(e, t) {
    var _this33;

    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;

    _classCallCheck(this, ko);

    _this33 = _super8.call(this, e), _this33.learningRate = e, _this33.momentum = t, _this33.useNesterov = n, _this33.accumulations = [], _this33.m = qa(_this33.momentum);
    return _this33;
  }

  _createClass(ko, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this34 = this;

      (Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e)).forEach(function (t, n) {
        var s = wt.registeredVariables[t];

        if (null == _this34.accumulations[n]) {
          var _e79 = !1;

          _this34.accumulations[n] = {
            originalName: "".concat(t, "/momentum"),
            variable: Yn(function () {
              return pr(s).variable(_e79);
            })
          };
        }

        var r = _this34.accumulations[n].variable,
            a = Array.isArray(e) ? e[n].tensor : e[t];
        null != a && Yn(function () {
          var e;
          var t = es(ss(_this34.m, r), a);
          e = es(ss(_this34.c, _this34.useNesterov ? es(a, ss(t, _this34.m)) : t), s), r.assign(t), s.assign(e);
        });
      }), this.incrementIterations();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.m.dispose(), null != this.accumulations && Jn(this.accumulations.map(function (e) {
        return e.variable;
      }));
    }
  }, {
    key: "setMomentum",
    value: function setMomentum(e) {
      this.momentum = e;
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee41() {
        return _regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                _context41.next = 2;
                return this.saveIterations();

              case 2:
                _context41.t0 = _context41.sent;
                return _context41.abrupt("return", [_context41.t0].concat(this.accumulations.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));

              case 4:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function getWeights() {
        return _getWeights7.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee42(e) {
        return _regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return this.extractIterations(e);

              case 2:
                e = _context42.sent;
                this.accumulations = e.map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(!1)
                  };
                });

              case 4:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function setWeights(_x39) {
        return _setWeights7.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate,
        momentum: this.momentum,
        useNesterov: this.useNesterov
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate, t.momentum, t.useNesterov);
    }
  }]);

  return ko;
}(yo);

ko.className = "Momentum", qn(ko);

var wo = /*#__PURE__*/function (_fo6) {
  "use strict";

  _inherits(wo, _fo6);

  var _super9 = _createSuper(wo);

  function wo(e) {
    var _this35;

    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

    _classCallCheck(this, wo);

    if (_this35 = _super9.call(this), _this35.learningRate = e, _this35.decay = t, _this35.momentum = n, _this35.epsilon = s, _this35.accumulatedMeanSquares = [], _this35.accumulatedMoments = [], _this35.accumulatedMeanGrads = [], _this35.centered = r, null == s && (_this35.epsilon = wt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    return _possibleConstructorReturn(_this35);
  }

  _createClass(wo, [{
    key: "applyGradients",
    value: function applyGradients(e) {
      var _this36 = this;

      (Array.isArray(e) ? e.map(function (e) {
        return e.name;
      }) : Object.keys(e)).forEach(function (t, n) {
        var s = wt.registeredVariables[t],
            r = !1;
        null == _this36.accumulatedMeanSquares[n] && (_this36.accumulatedMeanSquares[n] = {
          originalName: "".concat(t, "/rms"),
          variable: Yn(function () {
            return pr(s).variable(r);
          })
        }), null == _this36.accumulatedMoments[n] && (_this36.accumulatedMoments[n] = {
          originalName: "".concat(t, "/momentum"),
          variable: Yn(function () {
            return pr(s).variable(r);
          })
        }), null == _this36.accumulatedMeanGrads[n] && _this36.centered && (_this36.accumulatedMeanGrads[n] = {
          originalName: "".concat(t, "/mg"),
          variable: Yn(function () {
            return pr(s).variable(r);
          })
        });
        var a = Array.isArray(e) ? e[n].tensor : e[t];
        if (null == a) return;
        var i = _this36.accumulatedMeanSquares[n].variable,
            o = _this36.accumulatedMoments[n].variable;
        Yn(function () {
          var e = es(ss(i, _this36.decay), ss(ga(a), 1 - _this36.decay));

          if (_this36.centered) {
            var _t78 = _this36.accumulatedMeanGrads[n].variable,
                _r33 = es(ss(_t78, _this36.decay), ss(a, 1 - _this36.decay)),
                _l8 = ns(ss(a, _this36.learningRate), ui(Vr(e, es(ga(_r33), _this36.epsilon)))),
                _u5 = es(ss(o, _this36.momentum), _l8);

            i.assign(e), _t78.assign(_r33), o.assign(_u5);

            var _c4 = Vr(s, _u5);

            s.assign(_c4);
          } else {
            var _e80 = es(ss(i, _this36.decay), ss(ga(a), 1 - _this36.decay)),
                _t79 = es(ss(o, _this36.momentum), ns(ss(a, _this36.learningRate), ui(es(_e80, _this36.epsilon))));

            i.assign(_e80), o.assign(_t79);

            var _n42 = Vr(s, _t79);

            s.assign(_n42);
          }
        });
      }), this.incrementIterations();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      null != this.accumulatedMeanSquares && Jn(this.accumulatedMeanSquares.map(function (e) {
        return e.variable;
      })), null != this.accumulatedMeanGrads && this.centered && Jn(this.accumulatedMeanGrads.map(function (e) {
        return e.variable;
      })), null != this.accumulatedMoments && Jn(this.accumulatedMoments.map(function (e) {
        return e.variable;
      }));
    }
  }, {
    key: "getWeights",
    value: function () {
      var _getWeights8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee43() {
        var e;
        return _regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                e = [].concat(_toConsumableArray(this.accumulatedMeanSquares), _toConsumableArray(this.accumulatedMoments));
                this.centered && e.push.apply(e, _toConsumableArray(this.accumulatedMeanGrads));
                _context43.next = 4;
                return this.saveIterations();

              case 4:
                _context43.t0 = _context43.sent;
                return _context43.abrupt("return", [_context43.t0].concat(e.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));

              case 6:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));

      function getWeights() {
        return _getWeights8.apply(this, arguments);
      }

      return getWeights;
    }()
  }, {
    key: "setWeights",
    value: function () {
      var _setWeights8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee44(e) {
        var t, n;
        return _regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                _context44.next = 2;
                return this.extractIterations(e);

              case 2:
                e = _context44.sent;
                t = this.centered ? e.length / 3 : e.length / 2, n = !1;
                this.accumulatedMeanSquares = e.slice(0, t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                  };
                }), this.accumulatedMoments = e.slice(t, 2 * t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                  };
                }), this.centered && (this.accumulatedMeanGrads = e.slice(2 * t, 3 * t).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                  };
                }));

              case 5:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this);
      }));

      function setWeights(_x40) {
        return _setWeights8.apply(this, arguments);
      }

      return setWeights;
    }()
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        learningRate: this.learningRate,
        decay: this.decay,
        momentum: this.momentum,
        epsilon: this.epsilon,
        centered: this.centered
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
    }
  }]);

  return wo;
}(fo);

wo.className = "RMSProp", qn(wo);

var vo = /*#__PURE__*/function () {
  "use strict";

  function vo() {
    _classCallCheck(this, vo);
  }

  _createClass(vo, null, [{
    key: "sgd",
    value: function sgd(e) {
      return new yo(e);
    }
  }, {
    key: "momentum",
    value: function momentum(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      return new ko(e, t, n);
    }
  }, {
    key: "rmsprop",
    value: function rmsprop(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      return new wo(e, t, n, s, r);
    }
  }, {
    key: "adam",
    value: function adam() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .001;
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .999;
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      return new bo(e, t, n, s);
    }
  }, {
    key: "adadelta",
    value: function adadelta() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .001;
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .95;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return new go(e, t, n);
    }
  }, {
    key: "adamax",
    value: function adamax() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : .002;
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .9;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .999;
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      return new xo(e, t, n, s, r);
    }
  }, {
    key: "adagrad",
    value: function adagrad(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .1;
      return new mo(e, t);
    }
  }]);

  return vo;
}();

var Io = {
  sgd: vo.sgd,
  momentum: vo.momentum,
  adadelta: vo.adadelta,
  adagrad: vo.adagrad,
  rmsprop: vo.rmsprop,
  adamax: vo.adamax,
  adam: vo.adam
},
    $o = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function (e) {
  return e();
};

function No() {
  return new Promise(function (e) {
    return $o(function () {
      return e();
    });
  });
}

function Co(e, t) {
  var n = e[0].length;
  e.forEach(function (e, t) {
    l(e.length === n, function () {
      return "Error in concat".concat(n, "D: rank of tensors[").concat(t, "] must be the same as the rank of the rest (").concat(n, ")");
    });
  }), l(t >= 0 && t < n, function () {
    return "Error in concat".concat(n, "D: axis must be between 0 and ").concat(n - 1, ".");
  });
  var s = e[0];
  e.forEach(function (e, r) {
    for (var _a22 = 0; _a22 < n; _a22++) {
      l(_a22 === t || e[_a22] === s[_a22], function () {
        return "Error in concat".concat(n, "D: Shape of tensors[").concat(r, "] (").concat(e, ") does not match the shape of the rest (").concat(s, ") along the non-concatenated axis ").concat(r, ".");
      });
    }
  });
}

function So(e, t) {
  var n = e[0].slice();

  for (var _s42 = 1; _s42 < e.length; _s42++) {
    n[t] += e[_s42][t];
  }

  return n;
}

function To(e) {
  return e <= 30 ? e : R(e, Math.floor(Math.sqrt(e)));
}

function Eo(e, t, n) {
  return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])];
}

function Ro(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = [];
  if (s) r = r.concat(t.slice(0)), r.push(e[0] / n), r = r.concat(e.slice(1));else {
    r = r.concat(e[0]);
    var _n43 = t.length;

    for (var _s43 = 0; _s43 < _n43; ++_s43) {
      r = r.concat([e[_s43 + 1] / t[_s43], t[_s43]]);
    }

    r = r.concat(e.slice(_n43 + 1));
  }
  return r;
}

function Ao(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
  var s = [];

  if (n) {
    s.push(t);

    for (var _n44 = t + 1; _n44 < e; ++_n44) {
      _n44 <= 2 * t ? (s.push(_n44), s.push(_n44 - (t + 1))) : s.push(_n44);
    }
  } else {
    var _n45 = [],
        _r34 = [];

    for (var _s44 = 1; _s44 < e; ++_s44) {
      _s44 >= 2 * t + 1 || _s44 % 2 == 1 ? _r34.push(_s44) : _n45.push(_s44);
    }

    s.push.apply(s, _n45), s.push(0), s.push.apply(s, _r34);
  }

  return s;
}

function Fo(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = [];
  r.push(s ? e[0] / n : e[0] * n);

  for (var _n46 = 1; _n46 < e.length; ++_n46) {
    r.push(_n46 <= t.length ? s ? t[_n46 - 1] * e[_n46] : e[_n46] / t[_n46 - 1] : e[_n46]);
  }

  return r;
}

function Do(e, t) {
  var n = [0];

  for (var _s45 = 0; _s45 < t; ++_s45) {
    n.push(e[_s45][0]);
  }

  return n;
}

function _o(e, t, n) {
  var s = e.slice(0, 1);

  for (var _r35 = 0; _r35 < n; ++_r35) {
    s.push(e[_r35 + 1] - t[_r35][0] - t[_r35][1]);
  }

  return s;
}

function Oo() {
  var _console;

  V().getBool("IS_TEST") || (_console = console).warn.apply(_console, arguments);
}

function Mo(e, t) {
  if (e.length !== t.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:".concat(e.length, ", imag: ").concat(t.length, "."));
  var n = new Float32Array(2 * e.length);

  for (var _s46 = 0; _s46 < n.length; _s46 += 2) {
    n[_s46] = e[_s46 / 2], n[_s46 + 1] = t[_s46 / 2];
  }

  return n;
}

function Lo(e) {
  var t = new Float32Array(e.length / 2),
      n = new Float32Array(e.length / 2);

  for (var _s47 = 0; _s47 < e.length; _s47 += 2) {
    t[_s47 / 2] = e[_s47], n[_s47 / 2] = e[_s47 + 1];
  }

  return {
    real: t,
    imag: n
  };
}

function zo(e) {
  var t = Math.ceil(e.length / 4),
      n = new Float32Array(t),
      s = new Float32Array(t);

  for (var _t80 = 0; _t80 < e.length; _t80 += 4) {
    n[Math.floor(_t80 / 4)] = e[_t80], s[Math.floor(_t80 / 4)] = e[_t80 + 1];
  }

  return {
    real: n,
    imag: s
  };
}

function Bo(e) {
  var t = Math.floor(e.length / 4),
      n = new Float32Array(t),
      s = new Float32Array(t);

  for (var _t81 = 2; _t81 < e.length; _t81 += 4) {
    n[Math.floor(_t81 / 4)] = e[_t81], s[Math.floor(_t81 / 4)] = e[_t81 + 1];
  }

  return {
    real: n,
    imag: s
  };
}

function Po(e, t) {
  return {
    real: e[2 * t],
    imag: e[2 * t + 1]
  };
}

function Wo(e, t, n, s) {
  e[2 * s] = t, e[2 * s + 1] = n;
}

function Uo(e, t) {
  var n = new Float32Array(e / 2),
      s = new Float32Array(e / 2);

  for (var _r36 = 0; _r36 < Math.ceil(e / 2); _r36++) {
    var _a23 = (t ? 2 : -2) * Math.PI * (_r36 / e);

    n[_r36] = Math.cos(_a23), s[_r36] = Math.sin(_a23);
  }

  return {
    real: n,
    imag: s
  };
}

function Vo(e, t, n) {
  var s = (n ? 2 : -2) * Math.PI * (e / t);
  return {
    real: Math.cos(s),
    imag: Math.sin(s)
  };
}

var Go = /->/g;

function Ho(e, t) {
  var n = ((e = e.replace(/\s/g, "")).length - e.replace(Go, "").length) / "->".length;
  if (n < 1) throw new Error("Equations without an arrow are not supported.");
  if (n > 1) throw new Error('Equation must contain exactly one arrow ("->").');

  var _e$split3 = e.split("->"),
      _e$split4 = _slicedToArray(_e$split3, 2),
      s = _e$split4[0],
      r = _e$split4[1];

  l(-1 === s.indexOf("..."), function () {
    return 'The ellipsis notation ("...") is not supported yet.';
  });
  var a = s.split(","),
      i = a.length;
  if (t !== i) throw new Error("Expected ".concat(i, " input tensors, received ").concat(t));
  if (i > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
  var o = [];

  var _loop9 = function _loop9(_e81) {
    var t = r[_e81];
    if (!a.some(function (e) {
      return -1 !== e.indexOf(t);
    })) throw new Error("Output subscripts contain the label ".concat(t, " not present in the input subscripts."));
    -1 === o.indexOf(t) && o.push(t);
  };

  for (var _e81 = 0; _e81 < r.length; ++_e81) {
    _loop9(_e81);
  }

  for (var _e82 = 0; _e82 < s.length; ++_e82) {
    var _t82 = s[_e82];
    -1 === o.indexOf(_t82) && "," !== _t82 && o.push(_t82);
  }

  var u = new Array(a.length);

  for (var _e83 = 0; _e83 < i; ++_e83) {
    if (new Set(a[_e83].split("")).size !== a[_e83].length) throw new Error("Found duplicate axes in input component ".concat(a[_e83], ". Support for duplicate axes in input is not implemented yet."));
    u[_e83] = [];

    for (var _t83 = 0; _t83 < a[_e83].length; ++_t83) {
      u[_e83].push(o.indexOf(a[_e83][_t83]));
    }
  }

  var c = o.length,
      h = [];

  for (var _e84 = r.length; _e84 < c; ++_e84) {
    h.push(_e84);
  }

  return {
    allDims: o,
    summedDims: h,
    idDims: u
  };
}

function jo(e, t) {
  var n = new Array(e);
  n.fill(-1);

  for (var _e85 = 0; _e85 < t.length; ++_e85) {
    n[t[_e85]] = _e85;
  }

  var s = [];

  for (var _t84 = 0; _t84 < e; ++_t84) {
    -1 === n[_t84] && s.push(_t84);
  }

  return n = n.filter(function (e) {
    return -1 !== e;
  }), {
    permutationIndices: n,
    expandDims: s
  };
}

function qo(e, t, n) {
  var s = new Array(e);

  var _loop10 = function _loop10(_e86) {
    var r = n[_e86].shape;

    var _loop11 = function _loop11(_n47) {
      void 0 === s[t[_e86][_n47]] ? s[t[_e86][_n47]] = r[_n47] : l(s[t[_e86][_n47]] === r[_n47], function () {
        return "Expected dimension ".concat(s[t[_e86][_n47]], " at axis ").concat(_n47, " of input shaped ").concat(JSON.stringify(r), ", but got dimension ").concat(r[_n47]);
      });
    };

    for (var _n47 = 0; _n47 < t[_e86].length; ++_n47) {
      _loop11(_n47);
    }
  };

  for (var _e86 = 0; _e86 < n.length; ++_e86) {
    _loop10(_e86);
  }
}

function Ko(e, t) {
  var n = e,
      s = [];
  var r = 0;
  0 === e.length && n.push(-1), r = e.length + 1;

  for (var _e87 = 0; _e87 < r; ++_e87) {
    s.push([]);
  }

  var a = [];

  for (var _e88 = 0; _e88 < n.length; ++_e88) {
    var _r37 = Yo(t, n[_e88]);

    var _iterator8 = _createForOfIteratorHelper(_r37),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _t85 = _step8.value;
        -1 === a.indexOf(_t85) && (s[_e88].push(_t85), a.push(_t85));
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
  }

  return {
    path: n,
    steps: s
  };
}

function Xo(e) {
  return e.every(function (e, t) {
    return e === t;
  });
}

function Yo(e, t) {
  var n = [];

  for (var _s48 = 0; _s48 < e.length; ++_s48) {
    0 !== e[_s48].length && -1 === e[_s48].indexOf(t) && -1 !== t || n.push(_s48);
  }

  return n;
}

function Jo(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = [];
  if ("number" == typeof t) l(e.shape[n] % t == 0, function () {
    return "Number of splits must evenly divide the axis.";
  }), s = new Array(t).fill(e.shape[n] / t);else {
    l(t.reduce(function (e, t) {
      return -1 === t && (e += 1), e;
    }, 0) <= 1, function () {
      return "There should be only one negative value in split array.";
    });

    var _r38 = t.indexOf(-1);

    if (-1 !== _r38) {
      var _s49 = t.reduce(function (e, t) {
        return t > 0 ? e + t : e;
      });

      t[_r38] = e.shape[n] - _s49;
    }

    l(e.shape[n] === t.reduce(function (e, t) {
      return e + t;
    }), function () {
      return "The sum of sizes must match the size of the axis dimension.";
    }), s = t;
  }
  return s;
}

function Zo(e, t) {
  var n,
      s = !1;

  for (e <= 30 ? (n = e, s = !0) : n = R(e, Math.floor(Math.sqrt(e))); !s;) {
    n > t || n === e ? s = !0 : n = R(e, n + 1);
  }

  return n;
}

function Qo(e, t, n) {
  var s = [],
      r = e.length;

  for (var _a24 = 0; _a24 < r; _a24++) {
    s.push(_a24 !== t ? e[_a24] : n);
  }

  return s;
}

function el(e, t, n, s) {
  var r = t.shape.length,
      a = e.shape.length;
  if (0 !== s && (s < -r || s > r)) throw new Error("Expect batchDims in the range of [-".concat(r, ", ").concat(r, "], but got ").concat(s));
  if (s < 0 && (s += r), s > a) throw new Error("batchDims (".concat(s, ") must be less than rank(x) (\n    ").concat(a, ")."));
  if (n < s) throw new Error("batchDims (".concat(s, ") must be less than or equal to axis (").concat(n, ")."));

  for (var _n48 = 0; _n48 < s; ++_n48) {
    if (e.shape[_n48] !== t.shape[_n48]) throw new Error("x.shape[".concat(_n48, "]: ").concat(e.shape[_n48], " should be equal to indices.shape[").concat(_n48, "]: ").concat(t.shape[_n48], "."));
  }

  var i = e.shape[n],
      o = [];
  var l = 1,
      u = 1,
      c = 1;

  for (var _t86 = 0; _t86 < s; ++_t86) {
    o.push(e.shape[_t86]), l *= e.shape[_t86];
  }

  for (var _t87 = s; _t87 < n; _t87++) {
    o.push(e.shape[_t87]), u *= e.shape[_t87];
  }

  for (var _e89 = s; _e89 < r; _e89++) {
    o.push(t.shape[_e89]);
  }

  for (var _t88 = n + 1; _t88 < a; _t88++) {
    o.push(e.shape[_t88]), c *= e.shape[_t88];
  }

  return {
    batchSize: l,
    sliceSize: c,
    outerSize: u,
    dimSize: i,
    outputShape: o
  };
}

function tl(e) {
  try {
    return e.map(function (e) {
      return He(e);
    });
  } catch (e) {
    throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(e));
  }
}

function nl(e) {
  return e.map(function (e) {
    return Ge(e);
  });
}

var sl = {
  __proto__: null,
  slice_util: Gn,
  segment_util: {
    __proto__: null,
    segOpComputeOptimalWindowSize: Zo,
    computeOutShape: Qo,
    collectGatherOpShapeInfo: el
  },
  fromUint8ToStringArray: tl,
  fromStringArrayToUint8: nl,
  upcastType: dt,
  axesAreInnerMostDims: jr,
  combineLocations: qr,
  computeOutAndReduceShapes: Kr,
  expandShapeToKeepDim: Xr,
  assertAxesAreInnerMostDims: Yr,
  getAxesPermutation: Jr,
  getUndoAxesPermutation: Zr,
  getInnerMostAxes: Qr,
  getBroadcastDims: lr,
  getReductionAxes: ur,
  assertAndGetBroadcastShape: cr,
  assertParamsConsistent: Co,
  computeOutShape: So,
  computeDilation2DInfo: ms,
  computePool2DInfo: bs,
  computePool3DInfo: xs,
  computeConv2DInfo: ys,
  computeConv3DInfo: ks,
  computeDefaultPad: ws,
  tupleValuesAreOne: Cs,
  eitherStridesOrDilationsAreOne: Ss,
  convertConv2DDataFormat: Ts,
  getFusedDyActivation: Ei,
  getFusedBiasGradient: Ri,
  applyActivation: Ai,
  shouldFuse: Fi,
  PARALLELIZE_THRESHOLD: 30,
  computeOptimalWindowSize: To,
  getImageCenter: Eo,
  getReshaped: Ro,
  getPermuted: Ao,
  getReshapedPermuted: Fo,
  getSliceBeginCoords: Do,
  getSliceSize: _o,
  prepareAndValidate: Nn,
  validateUpdateShape: Cn,
  validateInput: function validateInput(e, t, n) {
    if (t.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ".concat(t.rank, "."));
    if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ".concat(e.rank, "."));
    if ("int32" !== t.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));
    if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));

    if (0 === n.length) {
      if (0 === t.size) throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));
      if (0 === e.size) throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape));
    }

    Cn(n, t, e);
  },
  calculateShapes: Sn,
  SELU_SCALEALPHA: 1.7580993408473768,
  SELU_SCALE: 1.0507009873554805,
  ERF_P: .3275911,
  ERF_A1: .254829592,
  ERF_A2: -.284496736,
  ERF_A3: 1.421413741,
  ERF_A4: -1.453152027,
  ERF_A5: 1.061405429,
  warn: Oo,
  log: function log() {
    var _console2;

    V().getBool("IS_TEST") || (_console2 = console).log.apply(_console2, arguments);
  },
  mergeRealAndImagArrays: Mo,
  splitRealAndImagArrays: Lo,
  complexWithEvenIndex: zo,
  complexWithOddIndex: Bo,
  getComplexWithIndex: Po,
  assignToTypedArray: Wo,
  exponents: Uo,
  exponent: Vo,
  decodeEinsumEquation: Ho,
  getEinsumPermutation: jo,
  checkEinsumDimSizes: qo,
  getEinsumComputePath: Ko,
  isIdentityPermutation: Xo,
  prepareSplitSize: Jo
};
var rl = {
  kernelName: "Abs",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t89 = _slicedToArray(t, 1),
        n = _t89[0];

    return {
      x: function x() {
        return ss(e, pi(pn(n, "float32"), -1));
      }
    };
  }
},
    al = {
  kernelName: "Acos",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t90 = _slicedToArray(t, 1),
        n = _t90[0];

    return {
      x: function x() {
        var t = ga(pn(n, "float32")),
            s = ui(Vr(qa(1), t));
        return Br(ns(e, s));
      }
    };
  }
},
    il = {
  kernelName: "Acosh",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t91 = _slicedToArray(t, 1),
        n = _t91[0];

    return {
      x: function x() {
        var t = ui(Vr(ga(pn(n, "float32")), 1));
        return ns(e, t);
      }
    };
  }
},
    ol = {
  kernelName: "Add",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t92 = _slicedToArray(t, 2),
        n = _t92[0],
        s = _t92[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = e;
        var s = ur(n.shape, r);
        return s.length > 0 && (t = Gr(t, s)), Es(t, n.shape);
      },
      b: function b() {
        var t = e;
        var n = ur(s.shape, r);
        return n.length > 0 && (t = Gr(t, n)), Es(t, s.shape);
      }
    };
  }
},
    ll = {
  kernelName: "ArgMax",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t93 = _slicedToArray(t, 1),
        n = _t93[0];

    return {
      x: function x() {
        return pr(n);
      }
    };
  }
},
    ul = {
  kernelName: "ArgMin",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t94 = _slicedToArray(t, 1),
        n = _t94[0];

    return {
      x: function x() {
        return pr(n);
      }
    };
  }
},
    cl = {
  kernelName: "Asin",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t95 = _slicedToArray(t, 1),
        n = _t95[0];

    return {
      x: function x() {
        return ns(e, ui(Vr(qa(1), ga(pn(n, "float32")))));
      }
    };
  }
},
    hl = {
  kernelName: "Asinh",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t96 = _slicedToArray(t, 1),
        n = _t96[0];

    return {
      x: function x() {
        var t = ui(es(qa(1), ga(pn(n, "float32"))));
        return ns(e, t);
      }
    };
  }
},
    dl = {
  kernelName: "Atan2",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t97 = _slicedToArray(t, 2),
        n = _t97[0],
        s = _t97[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = es(ga(n), ga(s));
        var a = ss(e, ns(s, t));
        var i = ur(n.shape, r);
        return i.length > 0 && (a = Gr(a, i)), Es(a, n.shape);
      },
      b: function b() {
        var t = es(ga(n), ga(s));
        var a = Br(ss(e, ns(n, t)));
        var i = ur(s.shape, r);
        return i.length > 0 && (a = Gr(a, i)), Es(a, s.shape);
      }
    };
  }
},
    pl = {
  kernelName: "Atan",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t98 = _slicedToArray(t, 1),
        n = _t98[0];

    return {
      x: function x() {
        return ns(e, es(ga(pn(n, "float32")), 1));
      }
    };
  }
},
    fl = {
  kernelName: "Atanh",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t99 = _slicedToArray(t, 1),
        n = _t99[0];

    return {
      x: function x() {
        return ns(e, Vr(qa(1), ga(pn(n, "float32"))));
      }
    };
  }
},
    gl = At({
  avgPool3dGrad_: function avgPool3dGrad_(e, t, n, s, r, a) {
    var i = Et(e, "dy", "avgPool3dGrad"),
        o = Et(t, "input", "avgPool3dGrad");
    var u = i,
        c = o,
        h = !1;
    4 === o.rank && (h = !0, u = Es(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]]), c = Es(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), l(5 === u.rank, function () {
      return "Error in avgPool3dGrad: dy must be rank 5 but got rank ".concat(u.rank, ".");
    }), l(5 === c.rank, function () {
      return "Error in avgPool3dGrad: input must be rank 5 but got rank ".concat(c.rank, ".");
    }), null != a && l(f(r), function () {
      return "Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ".concat(a, " but got pad ").concat(r, ".");
    });
    var d = wt.runKernel("AvgPool3DGrad", {
      dy: u,
      input: c
    }, {
      filterSize: n,
      strides: s,
      pad: r,
      dimRoundingMode: a
    });
    return h ? Es(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d;
  }
}),
    ml = {
  kernelName: "AvgPool3D",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t100 = _slicedToArray(t, 1),
        s = _t100[0],
        r = n.filterSize,
        a = n.strides,
        i = n.pad,
        o = n.dimRoundingMode;

    return {
      x: function x() {
        return gl(e, s, r, a, i, o);
      }
    };
  }
},
    bl = At({
  avgPoolGrad_: function avgPoolGrad_(e, t, n, s, r) {
    var a = Et(e, "dy", "avgPoolGrad"),
        i = Et(t, "input", "avgPoolGrad");
    l(i.rank === a.rank, function () {
      return "Rank of input (".concat(i.rank, ") does not match rank of dy (").concat(a.rank, ")");
    });
    var o = i,
        u = a,
        c = !1;
    3 === i.rank && (c = !0, o = Es(i, [1, i.shape[0], i.shape[1], i.shape[2]]), u = Es(a, [1, a.shape[0], a.shape[1], a.shape[2]])), l(4 === u.rank, function () {
      return "Error in avgPoolGrad: dy must be rank 4 but got rank ".concat(u.rank, ".");
    }), l(4 === o.rank, function () {
      return "Error in avgPoolGrad: input must be rank 4 but got rank ".concat(o.rank, ".");
    });
    var h = wt.runKernel("AvgPoolGrad", {
      dy: u,
      input: o
    }, {
      filterSize: n,
      strides: s,
      pad: r
    });
    return c ? Es(h, [h.shape[1], h.shape[2], h.shape[3]]) : h;
  }
}),
    xl = {
  kernelName: "AvgPool",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t101 = _slicedToArray(t, 1),
        s = _t101[0],
        r = n.filterSize,
        a = n.strides,
        i = n.pad;

    return {
      x: function x() {
        return bl(e, s, r, a, i);
      }
    };
  }
},
    yl = {
  kernelName: "BatchMatMul",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t, n) {
    var _t102 = _slicedToArray(t, 2),
        s = _t102[0],
        r = _t102[1],
        a = n.transposeA,
        i = n.transposeB;

    return a || i ? !a && i ? {
      a: function a() {
        return vn(e, r, !1, !1);
      },
      b: function b() {
        return vn(e, s, !0, !1);
      }
    } : a && !i ? {
      a: function a() {
        return vn(r, e, !1, !0);
      },
      b: function b() {
        return vn(s, e, !1, !1);
      }
    } : {
      a: function a() {
        return vn(r, e, !0, !0);
      },
      b: function b() {
        return vn(e, s, !0, !0);
      }
    } : {
      a: function a() {
        return vn(e, r, !1, !0);
      },
      b: function b() {
        return vn(s, e, !0, !1);
      }
    };
  }
},
    kl = {
  kernelName: "BatchToSpaceND",
  gradFunc: function gradFunc(e, t, n) {
    var s = n.blockShape,
        r = n.crops;
    return {
      x: function x() {
        return ka(e, s, r);
      }
    };
  }
},
    wl = {
  kernelName: "BroadcastTo",
  gradFunc: function gradFunc(e, t, n) {
    var s = n.inputShape,
        r = n.shape,
        a = Array.from(r);

    for (var _e90 = s.length - 1; _e90 >= 0; _e90--) {
      if (s[_e90] === r[_e90]) a[_e90] = 1;else if (1 !== s[_e90]) throw new Error("broadcastTo(): [".concat(s, "] cannot be broadcast to [").concat(r, "]."));
    }

    var i = [];

    for (var _e91 = 0; _e91 < a.length; _e91++) {
      a[_e91] > 1 && i.push(_e91);
    }

    return {
      x: function x() {
        return Gr(e, i, !0);
      }
    };
  }
},
    vl = {
  kernelName: "Ceil",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
},
    Il = {
  kernelName: "ClipByValue",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t103 = _slicedToArray(t, 1),
        s = _t103[0],
        r = n.clipValueMin,
        a = n.clipValueMax;

    return {
      x: function x() {
        return dr(ta(Sr(s, r), _r(s, a)), e, pr(e));
      }
    };
  }
},
    $l = {
  kernelName: "ComplexAbs",
  inputsToSave: ["x"],
  gradFunc: rl.gradFunc
},
    Nl = {
  kernelName: "Concat",
  saveAllInputs: !0,
  gradFunc: function gradFunc(e, t, n) {
    var s = t.map(function (e) {
      return e.shape;
    }),
        r = n.axis,
        a = y(r, t[0].shape)[0],
        i = s.map(function (e) {
      return e[a];
    });
    return oi(e, i, a).map(function (e) {
      return function () {
        return e;
      };
    });
  }
},
    Cl = {
  kernelName: "Conv2D",
  inputsToSave: ["x", "filter"],
  gradFunc: function gradFunc(e, t, n) {
    var _t104 = _slicedToArray(t, 2),
        s = _t104[0],
        r = _t104[1],
        a = n.dilations,
        i = n.strides,
        o = n.pad,
        u = n.dataFormat;

    return l(Cs(a), function () {
      return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(a, "'");
    }), {
      x: function x() {
        return Js(s.shape, e, r, i, o, u);
      },
      filter: function filter() {
        return Ti(s, e, r.shape, i, o, u);
      }
    };
  }
},
    Sl = {
  kernelName: "Conv2DBackpropInput",
  inputsToSave: ["dy", "filter"],
  gradFunc: function gradFunc(e, t, n) {
    var _t105 = _slicedToArray(t, 2),
        s = _t105[0],
        r = _t105[1],
        a = n.strides,
        i = n.pad,
        o = n.dataFormat,
        l = n.dimRoundingMode;

    return {
      dy: function dy() {
        return Xs(e, r, a, i, o, 1, l);
      },
      filter: function filter() {
        return Ti(e, s, r.shape, a, i, o, l);
      }
    };
  }
},
    Tl = At({
  conv3DBackpropFilter_: function conv3DBackpropFilter_(e, t, n, s, r) {
    var a = e;
    4 === e.rank && (a = Es(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
    var i = t;
    return 4 === i.rank && (i = Es(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), l(5 === a.rank, function () {
      return "Error in conv3dDerFilter: input must be rank 5, but got shape ".concat(a.shape, ".");
    }), l(5 === i.rank, function () {
      return "Error in conv3dDerFilter: dy must be rank 5, but got shape ".concat(i.shape, ".");
    }), l(5 === n.length, function () {
      return "Error in conv3dDerFilter: filterShape must be length 5, but got ".concat(n, ".");
    }), l(a.shape[4] === n[3], function () {
      return "Error in conv3dDerFilter: depth of input ".concat(a.shape[4], ") must match input depth in filter (").concat(n[3], ".");
    }), l(i.shape[4] === n[4], function () {
      return "Error in conv3dDerFilter: depth of dy (".concat(i.shape[4], ") must match output depth for filter (").concat(n[4], ").");
    }), wt.runKernel("Conv3DBackpropFilterV2", {
      x: a,
      dy: i
    }, {
      strides: s,
      pad: r,
      filterShape: n
    });
  }
}),
    El = {
  kernelName: "Conv3D",
  inputsToSave: ["x", "filter"],
  gradFunc: function gradFunc(e, t, n) {
    var s = n.dilations,
        r = n.strides,
        a = n.pad;
    l(Cs(s), function () {
      return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '".concat(s, "'");
    });

    var _t106 = _slicedToArray(t, 2),
        i = _t106[0],
        o = _t106[1];

    return {
      x: function x() {
        return er(i.shape, e, o, r, a);
      },
      filter: function filter() {
        return Tl(i, e, o.shape, r, a);
      }
    };
  }
},
    Rl = {
  kernelName: "Cos",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t107 = _slicedToArray(t, 1),
        n = _t107[0];

    return {
      x: function x() {
        return ss(Br(Ja(pn(n, "float32"))), e);
      }
    };
  }
},
    Al = {
  kernelName: "Cosh",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t108 = _slicedToArray(t, 1),
        n = _t108[0];

    return {
      x: function x() {
        return ss(Za(pn(n, "float32")), e);
      }
    };
  }
},
    Fl = {
  kernelName: "Cumsum",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t109 = _slicedToArray(t, 1),
        s = _t109[0],
        r = n.axis,
        a = n.exclusive,
        i = n.reverse;

    return {
      x: function x() {
        var t = Jr([r], s.rank);
        var n = rr(e, r, a, !i);
        return null != t && (n = $n(n, t)), n;
      }
    };
  }
},
    Dl = {
  kernelName: "DepthwiseConv2dNative",
  inputsToSave: ["x", "filter"],
  gradFunc: function gradFunc(e, t, n) {
    var s = n.dilations,
        r = n.strides,
        a = n.pad,
        i = n.dimRoundingMode,
        o = null == s ? [1, 1] : s;
    l(Cs(o), function () {
      return "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '".concat(o, "'");
    });

    var _t110 = _slicedToArray(t, 2),
        u = _t110[0],
        c = _t110[1];

    return l(4 === u.rank, function () {
      return "Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ".concat(u.rank, ".");
    }), l(4 === c.rank, function () {
      return "Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ".concat(c.rank, ".");
    }), l(u.shape[3] === c.shape[2], function () {
      return "Error in gradient of depthwiseConv2d: number of input channels (".concat(u.shape[3], ") must match the inChannels dimension in filter ").concat(c.shape[2], ".");
    }), l(Ss(r, o), function () {
      return "Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ".concat(r, " and dilations '").concat(o, "'.");
    }), null != i && l(f(a), function () {
      return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".");
    }), {
      x: function x() {
        return Oi(u.shape, e, c, r, a, s, i);
      },
      filter: function filter() {
        return _i(u, e, c.shape, r, a, s, i);
      }
    };
  }
},
    _l = {
  kernelName: "Dilation2D",
  inputsToSave: ["x", "filter"],
  gradFunc: function gradFunc(e, t, n) {
    var _t111 = _slicedToArray(t, 2),
        s = _t111[0],
        r = _t111[1],
        a = {
      x: s,
      filter: r,
      dy: e
    },
        i = {
      x: s,
      filter: r,
      dy: e
    };

    return {
      x: function x() {
        return wt.runKernel("Dilation2DBackpropInput", a, n);
      },
      filter: function filter() {
        return wt.runKernel("Dilation2DBackpropFilter", i, n);
      }
    };
  }
},
    Ol = {
  kernelName: "Elu",
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t) {
    var _t112 = _slicedToArray(t, 1),
        n = _t112[0],
        s = {
      dy: e,
      y: n
    };

    return {
      x: function x() {
        return wt.runKernel("EluGrad", s);
      }
    };
  }
},
    Ml = {
  kernelName: "Erf",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t113 = _slicedToArray(t, 1),
        n = _t113[0],
        s = ss(xr(Br(ga(n))), 2 / Math.sqrt(Math.PI));

    return {
      x: function x() {
        return ss(e, s);
      }
    };
  }
},
    Ll = {
  kernelName: "Exp",
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t) {
    var _t114 = _slicedToArray(t, 1),
        n = _t114[0];

    return {
      x: function x() {
        return ss(e, n);
      }
    };
  }
},
    zl = {
  kernelName: "ExpandDims",
  inputsToSave: ["input"],
  gradFunc: function gradFunc(e, t) {
    var _t115 = _slicedToArray(t, 1),
        n = _t115[0];

    return {
      input: function input() {
        return Es(e, n.shape);
      }
    };
  }
},
    Bl = {
  kernelName: "Expm1",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t116 = _slicedToArray(t, 1),
        n = _t116[0];

    return {
      x: function x() {
        return ss(e, xr(n));
      }
    };
  }
},
    Pl = {
  kernelName: "Floor",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
},
    Wl = {
  kernelName: "FloorDiv",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t117 = _slicedToArray(t, 2),
        n = _t117[0],
        s = _t117[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = ns(e, pn(s, "float32")),
            a = ur(n.shape, r);
        return a.length > 0 ? Es(Gr(t, a), n.shape) : t;
      },
      b: function b() {
        var t = ss(e, pn(n, "float32"));
        var a = ur(s.shape, r);
        a.length > 0 && (t = Es(Gr(t, a), s.shape));
        var i = ga(s);
        return Br(ns(t, pn(i, "float32")));
      }
    };
  }
},
    Ul = {
  kernelName: "FusedBatchNorm",
  inputsToSave: ["x", "mean", "variance", "scale"],
  gradFunc: function gradFunc(e, t, n) {
    var s = n.varianceEpsilon,
        _t118 = _slicedToArray(t, 4),
        r = _t118[0],
        a = _t118[1],
        i = _t118[2],
        o = _t118[3],
        l = null == o ? qa(1) : o,
        u = ur(a.shape, r.shape),
        c = [];

    if (1 === a.rank) {
      for (var _e92 = 0; _e92 < r.shape.length - 1; ++_e92) {
        c.push(r.shape[_e92]);
      }

      c.push(1);
    }

    var h = Vr(r, a),
        d = ss(e, l),
        p = ja(es(i, qa(s))),
        f = ss(ss(ss(p, p), p), qa(-.5));
    return {
      x: function x() {
        return Es(ss(ss(e, 1 === a.rank ? wr(Es(p, [1, 1, 1, a.shape[0]]), c) : p), l), r.shape);
      },
      mean: function mean() {
        var e = ss(ss(p, qa(-1)), d);
        return 1 === a.rank && (e = Gr(e, u)), Es(e, a.shape);
      },
      variance: function variance() {
        var e = ss(ss(f, h), d);
        return 1 === a.rank && (e = Gr(e, u)), Es(e, a.shape);
      },
      scale: function scale() {
        var t = ss(h, p);
        var n = ss(e, t);
        return 1 === a.rank && (n = Gr(n, u)), Es(n, a.shape);
      },
      offset: function offset() {
        var t = e;
        return 1 === a.rank && (t = Gr(t, u)), Es(t, a.shape);
      }
    };
  }
},
    Vl = {
  kernelName: "GatherV2",
  inputsToSave: ["x", "indices"],
  gradFunc: function gradFunc(e, t, n) {
    var _t119 = _slicedToArray(t, 2),
        s = _t119[0],
        r = _t119[1],
        a = n.axis,
        i = y(a, s.shape)[0];

    return {
      x: function x() {
        var t = s.shape,
            n = r.size,
            o = t.slice(0, i),
            l = o.length,
            u = t.slice(a, t.length).slice(1),
            c = u.length,
            h = Gl(0, l),
            d = Gl(l + 1, l + 1 + c),
            p = Hl([o, [n], u]),
            f = Es(e, p),
            g = Es(r, [n]),
            m = Hl([[l], h, d]),
            b = $n(f, m);
        var x = wi(b, g, s.shape[i]);
        var y = Zr(m);
        return x = $n(x, y), x;
      },
      indices: function indices() {
        return r;
      }
    };
  }
};

function Gl(e, t) {
  var n = [];

  for (var _s50 = e; _s50 < t; ++_s50) {
    n.push(_s50);
  }

  return n;
}

function Hl(e) {
  var t = [];

  for (var _n49 = 0; _n49 < e.length; ++_n49) {
    for (var _s51 = 0; _s51 < e[_n49].length; ++_s51) {
      t.push(e[_n49][_s51]);
    }
  }

  return t;
}

var jl = {
  kernelName: "GreaterEqual",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t120 = _slicedToArray(t, 2),
        n = _t120[0],
        s = _t120[1];

    return {
      a: function a() {
        return pr(n);
      },
      b: function b() {
        return pr(s);
      }
    };
  }
},
    ql = {
  kernelName: "Identity",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pn(e, "float32");
      }
    };
  }
},
    Kl = {
  kernelName: "IsFinite",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
},
    Xl = {
  kernelName: "IsInf",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
},
    Yl = {
  kernelName: "IsNan",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
},
    Jl = {
  kernelName: "LeakyRelu",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t121 = _slicedToArray(t, 1),
        s = _t121[0],
        r = n.alpha,
        a = Cr(s, 0);

    return {
      x: function x() {
        return dr(a, e, ss(e, r));
      }
    };
  }
},
    Zl = {
  kernelName: "Log1p",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t122 = _slicedToArray(t, 1),
        n = _t122[0];

    return {
      x: function x() {
        return ns(e, es(n, 1));
      }
    };
  }
},
    Ql = {
  kernelName: "Log",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t123 = _slicedToArray(t, 1),
        n = _t123[0];

    return {
      x: function x() {
        return ns(e, pn(n, "float32"));
      }
    };
  }
},
    eu = {
  kernelName: "LogSoftmax",
  inputsToSave: [],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var _t124 = _slicedToArray(t, 1),
        s = _t124[0],
        r = n.axis;

    return {
      logits: function logits() {
        var t = xr(s);
        return Vr(e, ss(Gr(e, r, !0), t));
      }
    };
  }
},
    tu = At({
  localResponseNormalizationBackprop_: function localResponseNormalizationBackprop_(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : .5;
    return wt.runKernel("LRNGrad", {
      x: e,
      y: t,
      dy: n
    }, {
      depthRadius: s,
      bias: r,
      alpha: a,
      beta: i
    });
  }
}),
    nu = {
  kernelName: "LRN",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var _t125 = _slicedToArray(t, 2),
        s = _t125[0],
        r = _t125[1],
        a = n.depthRadius,
        i = n.bias,
        o = n.alpha,
        l = n.beta;

    return {
      x: function x() {
        return tu(s, r, e, a, i, o, l);
      }
    };
  }
};

function su(e, t, n, s) {
  return t.rank < n.rank && (t = Es(t, Xr(t.shape, s))), e.rank < n.rank && (e = Es(e, Xr(e.shape, s))), {
    x: function x() {
      return ss(e, pn(hr(n, t), e.dtype));
    }
  };
}

var ru = {
  kernelName: "Max",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var s = n,
        r = s.reductionIndices,
        a = t[0],
        i = su(e, t[1], a, y(r, a.shape));
    return {
      x: function x() {
        return i.x();
      }
    };
  }
},
    au = {
  kernelName: "Maximum",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t126 = _slicedToArray(t, 2),
        n = _t126[0],
        s = _t126[1];

    return {
      a: function a() {
        return ss(e, pn(Sr(n, s), "float32"));
      },
      b: function b() {
        return ss(e, pn(Dr(n, s), "float32"));
      }
    };
  }
},
    iu = At({
  maxPool3dGrad_: function maxPool3dGrad_(e, t, n, s, r, a, i) {
    var o = Et(e, "dy", "maxPool3dGrad"),
        u = Et(t, "input", "maxPool3dGrad"),
        c = Et(n, "output", "maxPool3dGrad");
    var h = o,
        d = u,
        p = c,
        g = !1;
    4 === u.rank && (g = !0, h = Es(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), d = Es(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), p = Es(c, [1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]])), l(5 === h.rank, function () {
      return "Error in maxPool3dGrad: dy must be rank 5 but got rank ".concat(h.rank, ".");
    }), l(5 === d.rank, function () {
      return "Error in maxPool3dGrad: input must be rank 5 but got rank ".concat(d.rank, ".");
    }), l(5 === p.rank, function () {
      return "Error in maxPool3dGrad: output must be rank 5 but got rank ".concat(p.rank, ".");
    }), null != i && l(f(a), function () {
      return "Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".");
    });
    var m = wt.runKernel("MaxPool3DGrad", {
      dy: h,
      input: d,
      output: p
    }, {
      filterSize: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    });
    return g ? Es(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m;
  }
}),
    ou = {
  kernelName: "MaxPool3D",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var _t127 = _slicedToArray(t, 2),
        s = _t127[0],
        r = _t127[1],
        a = n.filterSize,
        i = n.strides,
        o = n.pad,
        l = n.dimRoundingMode;

    return {
      x: function x() {
        return iu(e, s, r, a, i, o, l);
      }
    };
  }
},
    lu = At({
  maxPoolGrad_: function maxPoolGrad_(e, t, n, s, r, a, i) {
    var o = Et(e, "dy", "maxPoolGrad"),
        u = Et(t, "input", "maxPoolGrad"),
        c = Et(n, "output", "maxPoolGrad");
    return l(u.rank === o.rank, function () {
      return "Rank of input (".concat(u.rank, ") does not match rank of dy (").concat(o.rank, ")");
    }), l(4 === o.rank, function () {
      return "Error in maxPoolGrad: dy must be rank 4 but got rank ".concat(o.rank, ".");
    }), l(4 === u.rank, function () {
      return "Error in maxPoolGrad: input must be rank 4 but got rank ".concat(u.rank, ".");
    }), null != i && l(f(a), function () {
      return "Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ".concat(i, " but got pad ").concat(a, ".");
    }), wt.runKernel("MaxPoolGrad", {
      dy: o,
      input: u,
      output: c
    }, {
      filterSize: s,
      strides: r,
      pad: a,
      dimRoundingMode: i
    });
  }
}),
    uu = {
  kernelName: "PadV2",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var s = t[0],
        r = n.paddings,
        a = r.map(function (e) {
      return e[0];
    });
    return {
      x: function x() {
        return _s(e, a, s.shape);
      }
    };
  }
},
    cu = {
  kernelName: "SpaceToBatchND",
  gradFunc: function gradFunc(e, t, n) {
    var s = n.blockShape,
        r = n.paddings;
    return {
      x: function x() {
        return Ms(e, s, r);
      }
    };
  }
},
    hu = {
  kernelName: "SplitV",
  gradFunc: function gradFunc(e, t, n) {
    var s = n.axis;
    return {
      x: function x() {
        return Fs(e, s);
      }
    };
  }
},
    du = [rl, al, il, ol, {
  kernelName: "AddN",
  saveAllInputs: !0,
  gradFunc: function gradFunc(e, t) {
    var n = {};
    return t.forEach(function (t, s) {
      n[s] = function () {
        return e.clone();
      };
    }), n;
  }
}, ll, ul, cl, hl, dl, pl, fl, ml, xl, yl, kl, wl, {
  kernelName: "Cast",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return e.clone();
      }
    };
  }
}, vl, Il, $l, Nl, Sl, Cl, El, Rl, Al, Fl, Dl, _l, {
  kernelName: "RealDiv",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t128 = _slicedToArray(t, 2),
        n = _t128[0],
        s = _t128[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = ns(e, pn(s, "float32")),
            a = ur(n.shape, r);
        return a.length > 0 ? Es(Gr(t, a), n.shape) : t;
      },
      b: function b() {
        var t = ss(e, pn(n, "float32"));
        var a = ur(s.shape, r);
        a.length > 0 && (t = Es(Gr(t, a), s.shape));
        var i = ga(s);
        return Br(ns(t, pn(i, "float32")));
      }
    };
  }
}, Ol, Ml, Ll, zl, Bl, Wl, Pl, Ul, Vl, jl, ql, Kl, Xl, Yl, Jl, Zl, Ql, eu, nu, ru, ru, au, ou, {
  kernelName: "MaxPool",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var _t129 = _slicedToArray(t, 2),
        s = _t129[0],
        r = _t129[1],
        a = n.filterSize,
        i = n.strides,
        o = n.pad;

    return {
      x: function x() {
        return lu(e, s, r, a, i, o);
      }
    };
  }
}, {
  kernelName: "Mean",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t130 = _slicedToArray(t, 1),
        s = _t130[0],
        r = n.axis,
        a = y(r, s.shape),
        i = d(Kr(s.shape, a)[1]);

    return {
      x: function x() {
        var t = s.shape.slice();
        a.forEach(function (e) {
          t[e] = 1;
        });
        var n = Es(e, t);
        return ns(ss(n, ca(s.shape, "float32")), i);
      }
    };
  }
}, {
  kernelName: "Min",
  inputsToSave: ["x"],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var s = n,
        r = s.axis,
        _t131 = _slicedToArray(t, 2),
        a = _t131[0],
        i = _t131[1],
        o = su(e, i, a, y(r, a.shape));

    return {
      x: function x() {
        return o.x();
      }
    };
  }
}, {
  kernelName: "Minimum",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t132 = _slicedToArray(t, 2),
        n = _t132[0],
        s = _t132[1];

    return {
      a: function a() {
        return ss(e, pn(_r(n, s), "float32"));
      },
      b: function b() {
        return ss(e, pn(Cr(n, s), "float32"));
      }
    };
  }
}, {
  kernelName: "MirrorPad",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var s = t[0],
        r = n.paddings,
        a = r.map(function (e) {
      return e[0];
    });
    return {
      x: function x() {
        return _s(e, a, s.shape);
      }
    };
  }
}, {
  kernelName: "Mod",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t133 = _slicedToArray(t, 2),
        n = _t133[0],
        s = _t133[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = ur(n.shape, r);
        return t.length > 0 ? Es(Gr(e, t), n.shape) : e;
      },
      b: function b() {
        var t = ss(e, Br($r(ns(n, s)))),
            a = ur(s.shape, r);
        return a.length > 0 ? Es(Gr(t, a), s.shape) : t;
      }
    };
  }
}, {
  kernelName: "Multiply",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t134 = _slicedToArray(t, 2),
        n = _t134[0],
        s = _t134[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = ss(e, pn(s, "float32")),
            a = ur(n.shape, r);
        return a.length > 0 ? Es(Gr(t, a), n.shape) : t;
      },
      b: function b() {
        var t = ss(e, pn(n, "float32")),
            a = ur(s.shape, r);
        return a.length > 0 ? Es(Gr(t, a), s.shape) : t;
      }
    };
  }
}, {
  kernelName: "Neg",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return Br(e);
      }
    };
  }
}, {
  kernelName: "OneHot",
  inputsToSave: ["indices"],
  gradFunc: function gradFunc(e, t) {
    var n = t[0];
    return {
      indices: function indices() {
        return ua(n.shape, "float32");
      }
    };
  }
}, {
  kernelName: "OnesLike",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
}, {
  kernelName: "Pack",
  saveAllInputs: !0,
  gradFunc: function gradFunc(e, t, n) {
    var s = n.axis;
    return vi(e, s).map(function (e) {
      return function () {
        return e;
      };
    });
  }
}, uu, uu, {
  kernelName: "Pow",
  inputsToSave: ["a", "b"],
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t) {
    var _t135 = _slicedToArray(t, 3),
        n = _t135[0],
        s = _t135[1],
        r = _t135[2],
        _a25 = n,
        i = s,
        o = cr(_a25.shape, i.shape);

    return {
      a: function a() {
        var t = pn(i, "float32");
        var n = ss(e, ss(t, va(_a25, Vr(t, qa(1)))));
        var s = ur(_a25.shape, o);
        return s.length > 0 && (n = Gr(n, s)), Es(n, _a25.shape);
      },
      b: function b() {
        var t = Cr(_a25, 0),
            n = dr(t, Mr(_a25), pr(_a25));
        var s = ss(e, ss(r, n));
        var l = ur(i.shape, o);
        return l.length > 0 && (s = Gr(s, l)), Es(s, i.shape);
      }
    };
  }
}, {
  kernelName: "Prelu",
  inputsToSave: ["x", "alpha"],
  gradFunc: function gradFunc(e, t) {
    var _t136 = _slicedToArray(t, 2),
        n = _t136[0],
        s = _t136[1],
        r = Cr(n, 0);

    return {
      x: function x() {
        return dr(r, e, ss(e, s));
      },
      alpha: function alpha() {
        var t = dr(r, pr(e), ss(e, n));
        var a = ur(s.shape, e.shape);
        return a.length > 0 && (t = Gr(t, a)), Es(t, s.shape);
      }
    };
  }
}, {
  kernelName: "Reciprocal",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t137 = _slicedToArray(t, 1),
        n = _t137[0];

    return {
      x: function x() {
        return ns(e, Br(ga(n)));
      }
    };
  }
}, {
  kernelName: "Relu6",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t138 = _slicedToArray(t, 1),
        n = _t138[0],
        s = ss(_r(n, 6), pi(n));

    return {
      x: function x() {
        return ss(e, pn(s, "float32"));
      }
    };
  }
}, {
  kernelName: "Relu",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t139 = _slicedToArray(t, 1),
        n = _t139[0];

    return {
      x: function x() {
        return ss(e, pn(pi(n), "float32"));
      }
    };
  }
}, {
  kernelName: "Reshape",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t140 = _slicedToArray(t, 1),
        n = _t140[0];

    return {
      x: function x() {
        return Es(e, n.shape);
      }
    };
  }
}, {
  kernelName: "ResizeBilinear",
  inputsToSave: ["images"],
  gradFunc: function gradFunc(e, t, n) {
    var _t141 = _slicedToArray(t, 1),
        s = _t141[0],
        r = {
      dy: e,
      images: s
    };

    return {
      images: function images() {
        return wt.runKernel("ResizeBilinearGrad", r, n);
      }
    };
  }
}, {
  kernelName: "ResizeNearestNeighbor",
  inputsToSave: ["images"],
  gradFunc: function gradFunc(e, t, n) {
    var _t142 = _slicedToArray(t, 1),
        s = _t142[0],
        r = {
      dy: e,
      images: s
    };

    return {
      images: function images() {
        return wt.runKernel("ResizeNearestNeighborGrad", r, n);
      }
    };
  }
}, {
  kernelName: "Reverse",
  gradFunc: function gradFunc(e, t, n) {
    var s = n.dims,
        r = y(s, e.shape);
    return {
      x: function x() {
        return Ga(e, r);
      }
    };
  }
}, {
  kernelName: "Round",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
}, {
  kernelName: "Rsqrt",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t143 = _slicedToArray(t, 1),
        n = _t143[0];

    return {
      x: function x() {
        return Br(ns(e, ss(va(n, 1.5), 2)));
      }
    };
  }
}, {
  kernelName: "Select",
  inputsToSave: ["condition"],
  gradFunc: function gradFunc(_e93, t) {
    var _t144 = _slicedToArray(t, 1),
        n = _t144[0];

    return {
      condition: function condition() {
        return pn(pr(n), "float32");
      },
      t: function t() {
        return ss(_e93, pn(n, _e93.dtype));
      },
      e: function e() {
        return ss(_e93, pn(na(n), _e93.dtype));
      }
    };
  }
}, {
  kernelName: "Selu",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t145 = _slicedToArray(t, 1),
        n = _t145[0];

    return {
      x: function x() {
        var t = Cr(n, qa(0)),
            s = qa(1.7580993408473768),
            r = qa(1.0507009873554805),
            a = ss(e, r),
            i = ss(ss(e, s), xr(pn(n, "float32")));
        return dr(t, a, i);
      }
    };
  }
}, {
  kernelName: "Sigmoid",
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t) {
    var _t146 = _slicedToArray(t, 1),
        n = _t146[0];

    return {
      x: function x() {
        return ss(e, ss(n, Vr(qa(1), n)));
      }
    };
  }
}, {
  kernelName: "Sign",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
}, {
  kernelName: "Sin",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t147 = _slicedToArray(t, 1),
        n = _t147[0];

    return {
      x: function x() {
        return ss(nr(pn(n, "float32")), e);
      }
    };
  }
}, {
  kernelName: "Sinh",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t148 = _slicedToArray(t, 1),
        n = _t148[0];

    return {
      x: function x() {
        return ss(sr(pn(n, "float32")), e);
      }
    };
  }
}, {
  kernelName: "Slice",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t149 = _slicedToArray(t, 1),
        s = _t149[0],
        r = n.begin,
        a = n.size,
        i = s.shape,
        _Un = Un(s, r, a),
        _Un2 = _slicedToArray(_Un, 2),
        o = _Un2[0],
        l = _Un2[1],
        u = [];

    for (var _t150 = 0; _t150 < e.rank; _t150++) {
      u.push([o[_t150], i[_t150] - o[_t150] - l[_t150]]);
    }

    return {
      x: function x() {
        return ya(e, u);
      }
    };
  }
}, {
  kernelName: "Softmax",
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t, n) {
    var _t151 = _slicedToArray(t, 1),
        s = _t151[0],
        r = n.dim,
        a = ss(e, s);

    return {
      logits: function logits() {
        return Vr(a, ss(Gr(a, [r], !0), s));
      }
    };
  }
}, {
  kernelName: "Softplus",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t152 = _slicedToArray(t, 1),
        n = _t152[0];

    return {
      x: function x() {
        return ss(e, Ds(n));
      }
    };
  }
}, cu, cu, hu, hu, {
  kernelName: "Sqrt",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t153 = _slicedToArray(t, 1),
        n = _t153[0];

    return {
      x: function x() {
        return ns(e, ss(ui(pn(n, "float32")), 2));
      }
    };
  }
}, {
  kernelName: "SquaredDifference",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t154 = _slicedToArray(t, 2),
        n = _t154[0],
        s = _t154[1],
        r = qa(2);

    return {
      a: function a() {
        return ss(e, ss(r, Vr(n, s)));
      },
      b: function b() {
        return ss(e, ss(r, Vr(s, n)));
      }
    };
  }
}, {
  kernelName: "Square",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t155 = _slicedToArray(t, 1),
        n = _t155[0];

    return {
      x: function x() {
        return ss(e, ss(pn(n, "float32"), 2));
      }
    };
  }
}, {
  kernelName: "Step",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
}, {
  kernelName: "Sub",
  inputsToSave: ["a", "b"],
  gradFunc: function gradFunc(e, t) {
    var _t156 = _slicedToArray(t, 2),
        n = _t156[0],
        s = _t156[1],
        r = cr(n.shape, s.shape);

    return {
      a: function a() {
        var t = e;
        var s = ur(n.shape, r);
        return s.length > 0 && (t = Gr(t, s)), Es(t, n.shape);
      },
      b: function b() {
        var t = e;
        var n = ur(s.shape, r);
        return n.length > 0 && (t = Gr(t, n)), Es(Br(t), s.shape);
      }
    };
  }
}, {
  kernelName: "Sum",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t157 = _slicedToArray(t, 1),
        s = _t157[0],
        r = s.shape.slice(),
        a = n.axis;

    y(a, s.shape).forEach(function (e) {
      r[e] = 1;
    });
    var i = Es(e, r),
        o = ss(i, ca(s.shape, "float32"));
    return {
      x: function x() {
        return o;
      }
    };
  }
}, {
  kernelName: "Tan",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t) {
    var _t158 = _slicedToArray(t, 1),
        n = _t158[0];

    return {
      x: function x() {
        return ns(e, ga(nr(n)));
      }
    };
  }
}, {
  kernelName: "Tanh",
  outputsToSave: [!0],
  gradFunc: function gradFunc(e, t) {
    var _t159 = _slicedToArray(t, 1),
        n = _t159[0];

    return {
      x: function x() {
        return ss(Vr(qa(1), ga(n)), e);
      }
    };
  }
}, {
  kernelName: "Tile",
  inputsToSave: ["x"],
  gradFunc: function gradFunc(e, t, n) {
    var _t160 = _slicedToArray(t, 1),
        s = _t160[0],
        r = n.reps;

    return {
      x: function x() {
        var t = pr(s);
        if (1 === s.rank) for (var _n50 = 0; _n50 < r[0]; ++_n50) {
          t = es(t, _s(e, [_n50 * s.shape[0]], [s.shape[0]]));
        } else if (2 === s.rank) for (var _n51 = 0; _n51 < r[0]; ++_n51) {
          for (var _a26 = 0; _a26 < r[1]; ++_a26) {
            t = es(t, _s(e, [_n51 * s.shape[0], _a26 * s.shape[1]], [s.shape[0], s.shape[1]]));
          }
        } else if (3 === s.rank) for (var _n52 = 0; _n52 < r[0]; ++_n52) {
          for (var _a27 = 0; _a27 < r[1]; ++_a27) {
            for (var _i18 = 0; _i18 < r[2]; ++_i18) {
              t = es(t, _s(e, [_n52 * s.shape[0], _a27 * s.shape[1], _i18 * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
            }
          }
        } else {
          if (4 !== s.rank) throw new Error("Gradient for tile operation is not implemented for rank-".concat(s.rank, " tensors yet."));

          for (var _n53 = 0; _n53 < r[0]; ++_n53) {
            for (var _a28 = 0; _a28 < r[1]; ++_a28) {
              for (var _i19 = 0; _i19 < r[2]; ++_i19) {
                for (var _o14 = 0; _o14 < r[3]; ++_o14) {
                  t = es(t, _s(e, [_n53 * s.shape[0], _a28 * s.shape[1], _i19 * s.shape[2], _o14 * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]));
                }
              }
            }
          }
        }
        return t;
      }
    };
  }
}, {
  kernelName: "Transpose",
  gradFunc: function gradFunc(e, t, n) {
    var s = n,
        r = s.perm,
        a = Zr(r);
    return {
      x: function x() {
        return $n(e, a);
      }
    };
  }
}, {
  kernelName: "Unpack",
  gradFunc: function gradFunc(e, t, n) {
    var s = n,
        r = s.axis;
    return {
      value: function value() {
        return di(e, r);
      }
    };
  }
}, {
  kernelName: "UnsortedSegmentSum",
  inputsToSave: ["segmentIds"],
  gradFunc: function gradFunc(e, t) {
    var _t161 = _slicedToArray(t, 1),
        n = _t161[0];

    return {
      x: function x() {
        return function (e, t) {
          var n = oa(t, pr(t)),
              s = Nr(e, n);
          var r = Sr(t, qa(0, "int32"));
          var a = s.rank - r.rank;

          for (var _e94 = 0; _e94 < a; ++_e94) {
            r = yr(r, _e94 + 1);
          }

          r = ta(r, ca(s.shape, "bool"));
          var i = pr(s);
          return dr(r, s, i);
        }(e, n);
      }
    };
  }
}, {
  kernelName: "ZerosLike",
  gradFunc: function gradFunc(e) {
    return {
      x: function x() {
        return pr(e);
      }
    };
  }
}];

for (var _i20 = 0, _du = du; _i20 < _du.length; _i20++) {
  var _e95 = _du[_i20];
  ee(_e95);
}

var pu;

function fu() {
  return null == pu && (pu = wt.backend.epsilon()), pu;
}

rt().prototype.abs = function () {
  return this.throwIfDisposed(), rs(this);
}, rt().prototype.acos = function () {
  return this.throwIfDisposed(), as(this);
}, rt().prototype.acosh = function () {
  return this.throwIfDisposed(), is(this);
}, rt().prototype.add = function (e) {
  return this.throwIfDisposed(), es(this, e);
}, rt().prototype.all = function (e, t) {
  return this.throwIfDisposed(), os(this, e, t);
}, rt().prototype.any = function (e, t) {
  return this.throwIfDisposed(), ls(this, e, t);
}, rt().prototype.argMax = function (e) {
  return this.throwIfDisposed(), us(this, e);
}, rt().prototype.argMin = function (e) {
  return this.throwIfDisposed(), cs(this, e);
}, rt().prototype.asScalar = function () {
  return this.throwIfDisposed(), l(1 === this.size, function () {
    return "The array must have only 1 element.";
  }), Es(this, []);
}, rt().prototype.asType = function (e) {
  return this.throwIfDisposed(), pn(this, e);
}, rt().prototype.as1D = function () {
  return this.throwIfDisposed(), Es(this, [this.size]);
}, rt().prototype.as2D = function (e, t) {
  return this.throwIfDisposed(), Es(this, [e, t]);
}, rt().prototype.as3D = function (e, t, n) {
  return this.throwIfDisposed(), Es(this, [e, t, n]);
}, rt().prototype.as4D = function (e, t, n, s) {
  return this.throwIfDisposed(), Es(this, [e, t, n, s]);
}, rt().prototype.as5D = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Es(this, [e, t, n, s, r]);
}, rt().prototype.asin = function () {
  return this.throwIfDisposed(), hs(this);
}, rt().prototype.asinh = function () {
  return this.throwIfDisposed(), ds(this);
}, rt().prototype.atan = function () {
  return this.throwIfDisposed(), ps(this);
}, rt().prototype.atan2 = function (e) {
  return this.throwIfDisposed(), fs(this, e);
}, rt().prototype.atanh = function () {
  return this.throwIfDisposed(), gs(this);
}, rt().prototype.avgPool = function (e, t, n, s) {
  return this.throwIfDisposed(), Rs(this, e, t, n, s);
}, rt().prototype.batchToSpaceND = function (e, t) {
  return this.throwIfDisposed(), Ms(this, e, t);
}, rt().prototype.batchNorm = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Ls(this, e, t, n, s, r);
}, rt().prototype.broadcastTo = function (e) {
  return this.throwIfDisposed(), Us(this, e);
}, rt().prototype.cast = function (e) {
  return this.throwIfDisposed(), pn(this, e);
}, rt().prototype.ceil = function () {
  return this.throwIfDisposed(), Vs(this);
}, rt().prototype.clipByValue = function (e, t) {
  return this.throwIfDisposed(), Gs(this, e, t);
}, rt().prototype.concat = function (e, t) {
  return this.throwIfDisposed(), e instanceof st && (e = [e]), Fs([this].concat(_toConsumableArray(e)), t);
}, rt().prototype.conv1d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Ys(this, e, t, n, s, r, a);
}, rt().prototype.conv2dTranspose = function (e, t, n, s, r) {
  return this.throwIfDisposed(), Zs(this, e, t, n, s, r);
}, rt().prototype.conv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Xs(this, e, t, n, s, r, a);
}, rt().prototype.cos = function () {
  return this.throwIfDisposed(), nr(this);
}, rt().prototype.cosh = function () {
  return this.throwIfDisposed(), sr(this);
}, rt().prototype.cumsum = function (e, t, n) {
  return this.throwIfDisposed(), rr(this, e, t, n);
}, rt().prototype.depthToSpace = function (e, t) {
  return this.throwIfDisposed(), ar(this, e, t);
}, rt().prototype.depthwiseConv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), ir(this, e, t, n, s, r, a);
}, rt().prototype.dilation2d = function (e, t, n, s, r) {
  return this.throwIfDisposed(), or(this, e, t, n, s, r);
}, rt().prototype.divNoNan = function (e) {
  return this.throwIfDisposed(), fr(this, e);
}, rt().prototype.div = function (e) {
  return this.throwIfDisposed(), ns(this, e);
}, rt().prototype.dot = function (e) {
  return this.throwIfDisposed(), gr(this, e);
}, rt().prototype.elu = function () {
  return this.throwIfDisposed(), mr(this);
}, rt().prototype.equal = function (e) {
  return this.throwIfDisposed(), hr(this, e);
}, rt().prototype.erf = function () {
  return this.throwIfDisposed(), br(this);
}, rt().prototype.exp = function () {
  return this.throwIfDisposed(), xr(this);
}, rt().prototype.expandDims = function (e) {
  return this.throwIfDisposed(), yr(this, e);
}, rt().prototype.expm1 = function () {
  return this.throwIfDisposed(), kr(this);
}, rt().prototype.fft = function () {
  return this.throwIfDisposed(), ri(this);
}, rt().prototype.flatten = function () {
  return this.throwIfDisposed(), Es(this, [this.size]);
}, rt().prototype.floor = function () {
  return this.throwIfDisposed(), $r(this);
}, rt().prototype.floorDiv = function (e) {
  return this.throwIfDisposed(), ts(this, e);
}, rt().prototype.gather = function (e, t) {
  return this.throwIfDisposed(), Nr(this, e, t);
}, rt().prototype.greaterEqual = function (e) {
  return this.throwIfDisposed(), Sr(this, e);
}, rt().prototype.greater = function (e) {
  return this.throwIfDisposed(), Cr(this, e);
}, rt().prototype.ifft = function () {
  return this.throwIfDisposed(), ai(this);
}, rt().prototype.irfft = function () {
  return this.throwIfDisposed(), ii(this);
}, rt().prototype.isFinite = function () {
  return this.throwIfDisposed(), Er(this);
}, rt().prototype.isInf = function () {
  return this.throwIfDisposed(), Rr(this);
}, rt().prototype.isNaN = function () {
  return this.throwIfDisposed(), Ar(this);
}, rt().prototype.leakyRelu = function (e) {
  return this.throwIfDisposed(), Fr(this, e);
}, rt().prototype.lessEqual = function (e) {
  return this.throwIfDisposed(), _r(this, e);
}, rt().prototype.less = function (e) {
  return this.throwIfDisposed(), Dr(this, e);
}, rt().prototype.localResponseNormalization = function (e, t, n, s) {
  return this.throwIfDisposed(), Or(this, e, t, n, s);
}, rt().prototype.logSigmoid = function () {
  return this.throwIfDisposed(), Wr(this);
}, rt().prototype.logSoftmax = function (e) {
  return this.throwIfDisposed(), Hr(this, e);
}, rt().prototype.logSumExp = function (e, t) {
  return this.throwIfDisposed(), ea(this, e, t);
}, rt().prototype.log = function () {
  return this.throwIfDisposed(), Mr(this);
}, rt().prototype.log1p = function () {
  return this.throwIfDisposed(), Lr(this);
}, rt().prototype.logicalAnd = function (e) {
  return this.throwIfDisposed(), ta(this, e);
}, rt().prototype.logicalNot = function () {
  return this.throwIfDisposed(), na(this);
}, rt().prototype.logicalOr = function (e) {
  return this.throwIfDisposed(), sa(this, e);
}, rt().prototype.logicalXor = function (e) {
  return this.throwIfDisposed(), ra(this, e);
}, rt().prototype.matMul = function (e, t, n) {
  return this.throwIfDisposed(), vn(this, e, t, n);
}, rt().prototype.maxPool = function (e, t, n, s) {
  return this.throwIfDisposed(), aa(this, e, t, n, s);
}, rt().prototype.max = function (e, t) {
  return this.throwIfDisposed(), Ur(this, e, t);
}, rt().prototype.maximum = function (e) {
  return this.throwIfDisposed(), oa(this, e);
}, rt().prototype.mean = function (e, t) {
  return this.throwIfDisposed(), la(this, e, t);
}, rt().prototype.min = function (e, t) {
  return this.throwIfDisposed(), ha(this, e, t);
}, rt().prototype.minimum = function (e) {
  return this.throwIfDisposed(), da(this, e);
}, rt().prototype.mirrorPad = function (e, t) {
  return this.throwIfDisposed(), pa(this, e, t);
}, rt().prototype.mod = function (e) {
  return this.throwIfDisposed(), fa(this, e);
}, rt().prototype.mul = function (e) {
  return this.throwIfDisposed(), ss(this, e);
}, rt().prototype.neg = function () {
  return this.throwIfDisposed(), Br(this);
}, rt().prototype.norm = function (e, t, n) {
  return this.throwIfDisposed(), Ni(this, e, t, n);
}, rt().prototype.notEqual = function (e) {
  return this.throwIfDisposed(), ba(this, e);
}, rt().prototype.oneHot = function (e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return this.throwIfDisposed(), In(this, e, t, n);
}, rt().prototype.onesLike = function () {
  return this.throwIfDisposed(), xa(this);
}, rt().prototype.pad = function (e, t) {
  return this.throwIfDisposed(), ya(this, e, t);
}, rt().prototype.pool = function (e, t, n, s, r) {
  return this.throwIfDisposed(), wa(this, e, t, n, s, r);
}, rt().prototype.pow = function (e) {
  return this.throwIfDisposed(), va(this, e);
}, rt().prototype.prelu = function (e) {
  return this.throwIfDisposed(), Ia(this, e);
}, rt().prototype.prod = function (e, t) {
  return this.throwIfDisposed(), $a(this, e, t);
}, rt().prototype.reciprocal = function () {
  return this.throwIfDisposed(), Wa(this);
}, rt().prototype.relu = function () {
  return this.throwIfDisposed(), Ua(this);
}, rt().prototype.relu6 = function () {
  return this.throwIfDisposed(), Va(this);
}, rt().prototype.reshapeAs = function (e) {
  return this.throwIfDisposed(), Es(this, e.shape);
}, rt().prototype.reshape = function (e) {
  return this.throwIfDisposed(), Es(this, e);
}, rt().prototype.resizeBilinear = function (e, t, n) {
  return this.throwIfDisposed(), to(this, e, t, n);
}, rt().prototype.resizeNearestNeighbor = function (e, t, n) {
  return this.throwIfDisposed(), no(this, e, t, n);
}, rt().prototype.reverse = function (e) {
  return this.throwIfDisposed(), Ga(this, e);
}, rt().prototype.rfft = function () {
  return this.throwIfDisposed(), li(this);
}, rt().prototype.round = function () {
  return this.throwIfDisposed(), Ha(this);
}, rt().prototype.rsqrt = function () {
  return this.throwIfDisposed(), ja(this);
}, rt().prototype.selu = function () {
  return this.throwIfDisposed(), Ka(this);
}, rt().prototype.separableConv2d = function (e, t, n, s, r, a) {
  return this.throwIfDisposed(), Xa(this, e, t, n, s, r, a);
}, rt().prototype.sigmoid = function () {
  return this.throwIfDisposed(), Ds(this);
}, rt().prototype.sign = function () {
  return this.throwIfDisposed(), Ya(this);
}, rt().prototype.sin = function () {
  return this.throwIfDisposed(), Ja(this);
}, rt().prototype.sinh = function () {
  return this.throwIfDisposed(), Za(this);
}, rt().prototype.slice = function (e, t) {
  return this.throwIfDisposed(), _s(this, e, t);
}, rt().prototype.softmax = function (e) {
  return this.throwIfDisposed(), si(this, e);
}, rt().prototype.softplus = function () {
  return this.throwIfDisposed(), Pr(this);
}, rt().prototype.spaceToBatchND = function (e, t) {
  return this.throwIfDisposed(), ka(this, e, t);
}, rt().prototype.split = function (e, t) {
  return this.throwIfDisposed(), oi(this, e, t);
}, rt().prototype.sqrt = function () {
  return this.throwIfDisposed(), ui(this);
}, rt().prototype.square = function () {
  return this.throwIfDisposed(), ga(this);
}, rt().prototype.squaredDifference = function (e) {
  return this.throwIfDisposed(), ci(this, e);
}, rt().prototype.squeeze = function (e) {
  return this.throwIfDisposed(), hi(this, e);
}, rt().prototype.stack = function (e, t) {
  this.throwIfDisposed();
  var n = e instanceof st ? [this, e] : [this].concat(_toConsumableArray(e));
  return di(n, t);
}, rt().prototype.step = function (e) {
  return this.throwIfDisposed(), pi(this, e);
}, rt().prototype.stridedSlice = function (e, t, n, s, r, a, i, o) {
  return this.throwIfDisposed(), fi(this, e, t, n, s, r, a, i, o);
}, rt().prototype.sub = function (e) {
  return this.throwIfDisposed(), Vr(this, e);
}, rt().prototype.sum = function (e, t) {
  return this.throwIfDisposed(), Gr(this, e, t);
}, rt().prototype.tan = function () {
  return this.throwIfDisposed(), gi(this);
}, rt().prototype.tanh = function () {
  return this.throwIfDisposed(), Os(this);
}, rt().prototype.tile = function (e) {
  return this.throwIfDisposed(), wr(this, e);
}, rt().prototype.toBool = function () {
  return this.throwIfDisposed(), pn(this, "bool");
}, rt().prototype.toFloat = function () {
  return this.throwIfDisposed(), pn(this, "float32");
}, rt().prototype.toInt = function () {
  return this.throwIfDisposed(), pn(this, "int32");
}, rt().prototype.topk = function (e, t) {
  return this.throwIfDisposed(), xi(this, e, t);
}, rt().prototype.transpose = function (e) {
  return this.throwIfDisposed(), $n(this, e);
}, rt().prototype.unique = function (e) {
  return this.throwIfDisposed(), ki(this, e);
}, rt().prototype.unsortedSegmentSum = function (e, t) {
  return this.throwIfDisposed(), wi(this, e, t);
}, rt().prototype.unstack = function (e) {
  return this.throwIfDisposed(), vi(this, e);
}, rt().prototype.where = function (e, t) {
  return this.throwIfDisposed(), dr(e, this, t);
}, rt().prototype.zerosLike = function () {
  return this.throwIfDisposed(), pr(this);
};

var gu = /*#__PURE__*/function (_Error) {
  "use strict";

  _inherits(gu, _Error);

  var _super10 = _createSuper(gu);

  function gu(e) {
    var _this37;

    _classCallCheck(this, gu);

    _this37 = _super10.call(this, e), Object.setPrototypeOf(_assertThisInitialized(_this37), gu.prototype);
    return _this37;
  }

  return gu;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var mu = /*#__PURE__*/function (_Error2) {
  "use strict";

  _inherits(mu, _Error2);

  var _super11 = _createSuper(mu);

  function mu(e) {
    var _this38;

    _classCallCheck(this, mu);

    _this38 = _super11.call(this, e), Object.setPrototypeOf(_assertThisInitialized(_this38), mu.prototype);
    return _this38;
  }

  return mu;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var bu = /*#__PURE__*/function (_Error3) {
  "use strict";

  _inherits(bu, _Error3);

  var _super12 = _createSuper(bu);

  function bu(e) {
    var _this39;

    _classCallCheck(this, bu);

    _this39 = _super12.call(this, e), Object.setPrototypeOf(_assertThisInitialized(_this39), bu.prototype);
    return _this39;
  }

  return bu;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var xu = /*#__PURE__*/function (_Error4) {
  "use strict";

  _inherits(xu, _Error4);

  var _super13 = _createSuper(xu);

  function xu(e) {
    var _this40;

    _classCallCheck(this, xu);

    _this40 = _super13.call(this, e), Object.setPrototypeOf(_assertThisInitialized(_this40), xu.prototype);
    return _this40;
  }

  return xu;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var yu = /*#__PURE__*/function (_Error5) {
  "use strict";

  _inherits(yu, _Error5);

  var _super14 = _createSuper(yu);

  function yu(e) {
    var _this41;

    _classCallCheck(this, yu);

    _this41 = _super14.call(this, e), Object.setPrototypeOf(_assertThisInitialized(_this41), yu.prototype);
    return _this41;
  }

  return yu;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function ku(e, t) {
  if (Array.isArray(e)) {
    var _n54 = [];

    for (var _s52 = 0; _s52 < t; _s52++) {
      _n54 = _n54.concat(e);
    }

    return _n54;
  }

  {
    var _n55 = new Array(t);

    return _n55.fill(e), _n55;
  }
}

function wu(e, t) {
  if (!e) throw new yu(t);
}

function vu(e, t) {
  var n = 0;

  var _iterator9 = _createForOfIteratorHelper(e),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _s53 = _step9.value;
      _s53 === t && n++;
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return n;
}

function Iu(e) {
  return 1 === e.length ? e[0] : e;
}

function $u(e) {
  return Array.isArray(e) ? e : [e];
}

function Nu(e) {
  var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  return "_" !== t[0] ? t : "private" + t;
}

function Cu(e) {
  return e.length <= 1 || -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, function (e, t) {
    return t.toUpperCase();
  });
}

var Su = {};

function Tu(e) {
  if (null == e) return null;
  var t = {};
  return t.className = e.getClassName(), t.config = e.getConfig(), t;
}

function Eu(e) {
  if (null != e && "object" == typeof e) if (Array.isArray(e)) e.forEach(function (e) {
    return Eu(e);
  });else {
    var t = Object.keys(e);

    for (var _i21 = 0, _t162 = t; _i21 < _t162.length; _i21++) {
      var _n56 = _t162[_i21];
      var _t163 = e[_n56];
      null != _t163 && "object" == typeof _t163 && (Array.isArray(_t163) || "ndarray" !== _t163.type || "number" != typeof _t163.value ? Eu(_t163) : e[_n56] = _t163.value);
    }
  }
}

function Ru(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "object";
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

  if ("string" == typeof e) {
    var _r39 = e;

    var _a29;

    if (_r39 in n) _a29 = n[_r39];else if (_r39 in Su) _a29 = Su[_r39];else if (_a29 = t[_r39], null == _a29) throw new bu("Unknown ".concat(s, ": ").concat(e, ". This may be due to one of the following reasons:\n1. The ").concat(s, " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(s, " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));
    return _a29;
  }

  {
    var _n$_i, _n$_i2, _Su$className, _Su$className2, _t$_i, _t$_i2;

    var _a30 = e;
    if (null == _a30.className || null == _a30.config) throw new bu("".concat(s, ": Improper config format: ").concat(JSON.stringify(_a30), ".\n'className' and 'config' must set."));
    var _i22 = _a30.className;

    var _o15, _l9;

    if (_i22 in n ? (_n$_i = n[_i22], _n$_i2 = _slicedToArray(_n$_i, 2), _o15 = _n$_i2[0], _l9 = _n$_i2[1], _n$_i) : _i22 in Su ? (_Su$className = Su.className, _Su$className2 = _slicedToArray(_Su$className, 2), _o15 = _Su$className2[0], _l9 = _Su$className2[1], _Su$className) : _i22 in t && (_t$_i = t[_i22], _t$_i2 = _slicedToArray(_t$_i, 2), _o15 = _t$_i2[0], _l9 = _t$_i2[1], _t$_i), null == _o15) throw new bu("Unknown ".concat(s, ": ").concat(_i22, ". This may be due to one of the following reasons:\n1. The ").concat(s, " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ").concat(s, " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass()."));

    if (null != _l9) {
      var _e96 = {};

      for (var _i23 = 0, _Object$keys = Object.keys(Su); _i23 < _Object$keys.length; _i23++) {
        var _t165 = _Object$keys[_i23];
        _e96[_t165] = Su[_t165];
      }

      for (var _i24 = 0, _Object$keys2 = Object.keys(n); _i24 < _Object$keys2.length; _i24++) {
        var _t166 = _Object$keys2[_i24];
        _e96[_t166] = n[_t166];
      }

      _a30.config.customObjects = _e96;

      var _t164 = Object.assign({}, Su);

      for (var _i25 = 0, _Object$keys3 = Object.keys(n); _i25 < _Object$keys3.length; _i25++) {
        var _e97 = _Object$keys3[_i25];
        Su[_e97] = n[_e97];
      }

      Eu(_a30.config);

      var _s54 = _l9(_o15, _a30.config, n, r);

      return Su = Object.assign({}, _t164), _s54;
    }

    {
      var _e98 = Object.assign({}, Su);

      for (var _i26 = 0, _Object$keys4 = Object.keys(n); _i26 < _Object$keys4.length; _i26++) {
        var _e99 = _Object$keys4[_i26];
        Su[_e99] = n[_e99];
      }

      var _t167 = new _o15(_a30.config);

      return Su = Object.assign({}, _e98), _t167;
    }
  }
}

function Au(e, t) {
  return -1 * function (e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }(e, t);
}

function Fu(e) {
  if (null == e) return e;
  var t = [];

  var _iterator10 = _createForOfIteratorHelper(e),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _n57 = _step10.value;
      -1 === t.indexOf(_n57) && t.push(_n57);
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return t;
}

function Du(e) {
  if (null == e) throw new bu("Invalid value in obj: ".concat(JSON.stringify(e)));

  for (var t in e) {
    if (e.hasOwnProperty(t)) return !1;
  }

  return !0;
}

function _u(e, t, n) {
  if (null != n && e.indexOf(n) < 0) throw new bu("".concat(n, " is not a valid ").concat(t, ".  Valid values are ").concat(e, " or null/undefined."));
}

function Ou(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
  return wu(n >= 0), wu(s >= n), Array.isArray(e) && e.length >= n && e.length <= s && e.every(function (e) {
    return typeof e === t;
  });
}

function Mu(e, t) {
  Array.isArray(e) ? (l(e.length > 0, function () {
    return "".concat(t, " is unexpectedly an empty array.");
  }), e.forEach(function (e, n) {
    return Mu(e, "element ".concat(n + 1, " of ").concat(t));
  })) : l(Number.isInteger(e) && e > 0, function () {
    return "Expected ".concat(t, " to be a positive integer, but got ").concat(Lu(e), ".");
  });
}

function Lu(e) {
  return null === e ? "null" : Array.isArray(e) ? "[" + e.map(function (e) {
    return Lu(e);
  }).join(",") + "]" : "string" == typeof e ? "\"".concat(e, "\"") : "".concat(e);
}

function zu(e) {
  return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
}

function Bu(e, t) {
  return Yn(function () {
    return ui(Gr(ss(e, e), t, !0));
  });
}

var Pu = /*#__PURE__*/function (_Hn2) {
  "use strict";

  _inherits(Pu, _Hn2);

  var _super15 = _createSuper(Pu);

  function Pu() {
    _classCallCheck(this, Pu);

    return _super15.apply(this, arguments);
  }

  _createClass(Pu, [{
    key: "getConfig",
    value: function getConfig() {
      return {};
    }
  }]);

  return Pu;
}(Hn);

var Wu = /*#__PURE__*/function (_Pu) {
  "use strict";

  _inherits(Wu, _Pu);

  var _super16 = _createSuper(Wu);

  function Wu(e) {
    var _this42;

    _classCallCheck(this, Wu);

    _this42 = _super16.call(this), _this42.defaultMaxValue = 2, _this42.defaultAxis = 0, _this42.maxValue = null != e.maxValue ? e.maxValue : _this42.defaultMaxValue, _this42.axis = null != e.axis ? e.axis : _this42.defaultAxis;
    return _this42;
  }

  _createClass(Wu, [{
    key: "apply",
    value: function apply(e) {
      var _this43 = this;

      return Yn(function () {
        var t = Bu(e, _this43.axis),
            n = Gs(t, 0, _this43.maxValue);
        return ss(e, ns(n, es(fu(), t)));
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        maxValue: this.maxValue,
        axis: this.axis
      };
    }
  }]);

  return Wu;
}(Pu);

Wu.className = "MaxNorm", qn(Wu);

var Uu = /*#__PURE__*/function (_Pu2) {
  "use strict";

  _inherits(Uu, _Pu2);

  var _super17 = _createSuper(Uu);

  function Uu(e) {
    var _this44;

    _classCallCheck(this, Uu);

    _this44 = _super17.call(this), _this44.defaultAxis = 0, _this44.axis = null != e.axis ? e.axis : _this44.defaultAxis;
    return _this44;
  }

  _createClass(Uu, [{
    key: "apply",
    value: function apply(e) {
      var _this45 = this;

      return Yn(function () {
        return ns(e, es(fu(), Bu(e, _this45.axis)));
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        axis: this.axis
      };
    }
  }]);

  return Uu;
}(Pu);

Uu.className = "UnitNorm", qn(Uu);

var Vu = /*#__PURE__*/function (_Pu3) {
  "use strict";

  _inherits(Vu, _Pu3);

  var _super18 = _createSuper(Vu);

  function Vu() {
    _classCallCheck(this, Vu);

    return _super18.apply(this, arguments);
  }

  _createClass(Vu, [{
    key: "apply",
    value: function apply(e) {
      return Ua(e);
    }
  }]);

  return Vu;
}(Pu);

Vu.className = "NonNeg", qn(Vu);

var Gu = /*#__PURE__*/function (_Pu4) {
  "use strict";

  _inherits(Gu, _Pu4);

  var _super19 = _createSuper(Gu);

  function Gu(e) {
    var _this46;

    _classCallCheck(this, Gu);

    _this46 = _super19.call(this), _this46.defaultMinValue = 0, _this46.defaultMaxValue = 1, _this46.defaultRate = 1, _this46.defaultAxis = 0, _this46.minValue = null != e.minValue ? e.minValue : _this46.defaultMinValue, _this46.maxValue = null != e.maxValue ? e.maxValue : _this46.defaultMaxValue, _this46.rate = null != e.rate ? e.rate : _this46.defaultRate, _this46.axis = null != e.axis ? e.axis : _this46.defaultAxis;
    return _this46;
  }

  _createClass(Gu, [{
    key: "apply",
    value: function apply(e) {
      var _this47 = this;

      return Yn(function () {
        var t = Bu(e, _this47.axis),
            n = es(ss(_this47.rate, Gs(t, _this47.minValue, _this47.maxValue)), ss(1 - _this47.rate, t));
        return ss(e, ns(n, es(fu(), t)));
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        minValue: this.minValue,
        maxValue: this.maxValue,
        rate: this.rate,
        axis: this.axis
      };
    }
  }]);

  return Gu;
}(Pu);

Gu.className = "MinMaxNorm", qn(Gu);
var Hu = {
  maxNorm: "MaxNorm",
  minMaxNorm: "MinMaxNorm",
  nonNeg: "NonNeg",
  unitNorm: "UnitNorm"
};

function ju(e) {
  return Tu(e);
}

function qu(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "constraint");
}

function Ku(e) {
  return null == e ? null : "string" == typeof e ? qu({
    className: e in Hu ? Hu[e] : e,
    config: {}
  }) : e instanceof Pu ? e : qu(e);
}

var Xu = ["channelsFirst", "channelsLast"],
    Yu = ["nearest", "bilinear"],
    Ju = ["valid", "same", "causal"],
    Zu = ["max", "avg"],
    Qu = ["sum", "mul", "concat", "ave"],
    ec = new Map();

function tc(e) {
  _u(Xu, "DataFormat", e);
}

function nc(e) {
  _u(Ju, "PaddingMode", e);
}

function sc(e) {
  _u(Zu, "PoolMode", e);
}

var rc = [];

function ac(e, t) {
  rc.push(e);

  try {
    var _e100 = t();

    return rc.pop(), _e100;
  } catch (e) {
    throw rc.pop(), e;
  }
}

function ic(e) {
  if (!uc(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  return (0 === rc.length ? "" : rc.join("/") + "/") + e;
}

function oc(e) {
  if (!uc(e)) throw new Error("Not a valid tensor name: '" + e + "'");
  ec.has(e) || ec.set(e, 0);
  var t = ec.get(e);

  if (ec.set(e, ec.get(e) + 1), t > 0) {
    var _n58 = "".concat(e, "_").concat(t);

    return ec.set(_n58, 1), _n58;
  }

  return e;
}

var lc = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

function uc(e) {
  return !!e.match(lc);
}

function cc(e, t, n) {
  null == t && (t = 0), null == n && (n = e.length);
  var s = 1;

  for (var _r40 = t; _r40 < n; ++_r40) {
    s *= e[_r40];
  }

  return s;
}

function hc(e) {
  if (0 === e.length) return Number.NaN;
  var t = Number.POSITIVE_INFINITY;

  for (var _n59 = 0; _n59 < e.length; _n59++) {
    var _s55 = e[_n59];
    _s55 < t && (t = _s55);
  }

  return t;
}

function dc(e) {
  if (0 === e.length) return Number.NaN;
  var t = Number.NEGATIVE_INFINITY;

  for (var _n60 = 0; _n60 < e.length; _n60++) {
    var _s56 = e[_n60];
    _s56 > t && (t = _s56);
  }

  return t;
}

function pc(e, t) {
  if (t < e) throw new bu("end (".concat(t, ") < begin (").concat(e, ") is forbidden."));
  var n = [];

  for (var _s57 = e; _s57 < t; ++_s57) {
    n.push(_s57);
  }

  return n;
}

function fc(e, t) {
  return pn(e, t);
}

function gc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  var n = e.shape.slice();
  return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), Es(e, n);
}

function mc(e, t, n) {
  return Yn(function () {
    switch (e.rank) {
      case 1:
        return Qa(e, t, n);

      case 2:
        return ei(e, [t, 0], [n, e.shape[1]]);

      case 3:
        return ti(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);

      case 4:
        return ni(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);

      case 5:
        return _s(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);

      case 6:
        return _s(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);

      default:
        throw new bu("sliceAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function bc(e, t, n) {
  return Yn(function () {
    switch (e.rank) {
      case 1:
        return Qa(e, t, n);

      case 2:
        return ei(e, [0, t], [e.shape[0], n]);

      case 3:
        return ti(e, [0, 0, t], [e.shape[0], e.shape[1], n]);

      case 4:
        return ni(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);

      default:
        throw new bu("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function xc(e, t, n, s) {
  return Yn(function () {
    switch (e.rank) {
      case 1:
        return Qa(e, t, n);

      case 2:
        switch (s) {
          case 1:
            return mc(e, t, n);

          case 2:
            return bc(e, t, n);

          default:
            throw new bu("The axis is not within the rank of the tensor ".concat(s));
        }

      case 3:
        switch (s) {
          case 1:
            return mc(e, t, n);

          case 2:
            return ti(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);

          case 3:
            return bc(e, t, n);

          default:
            throw new bu("The axis is not within the rank of the tensor ".concat(s));
        }

      case 4:
        switch (s) {
          case 1:
            return mc(e, t, n);

          case 2:
            return ni(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);

          case 3:
            return ni(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);

          case 4:
            return bc(e, t, n);

          default:
            throw new bu("The axis is not within the rank of the tensor ".concat(s));
        }

      default:
        throw new bu("sliceAlongLastAxis() received an unsupported tensor rank: ".concat(e.rank));
    }
  });
}

function yc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  var n;
  return t < 0 && (n = e[0].rank, t = 0 !== n ? n : 0), t === e[0].rank && (t = -1), Fs(e, t);
}

function kc(e, t) {
  switch (e.rank) {
    case 1:
      return Hs([e, t]);

    case 2:
      return js([e, t], 0);

    case 3:
      return qs([e, t], 0);

    case 4:
      return Ks([e, t], 0);

    default:
      throw new bu("concatAlongFirstAxis() received an unsupported tensor rank: ".concat(e.rank));
  }
}

function wc(e, t) {
  if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new bu("The length of input n (".concat(t.length, ") does not match the number of dimensions in input x (").concat(e.rank, ")"));
  return wr(e, t);
}

function vc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var s = arguments.length > 3 ? arguments[3] : undefined;
  var r = arguments.length > 4 ? arguments[4] : undefined;
  return La(e, t, n, s, r);
}

function Ic(e, t, n, s) {
  if (e.rank < 2 || t.rank < 2) throw new xu("dot requires both inputs to be rank >= 2 but got x shape = ".concat(e.shape, " and y shape = ").concat(t.shape));
  if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) throw new xu("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ".concat(e.shape, " and  y shape = ").concat(t.shape));
  if (2 === e.rank && 2 === t.rank) return Mi({
    a: e,
    b: t,
    transposeA: !1,
    transposeB: !1,
    bias: s ? Cc(e.rank, s, "channelsLast") : null,
    activation: n
  });
  {
    var _r41 = e.shape.slice(),
        _a31 = _r41.pop();

    e = Es(e, [-1, _a31]);

    var _i27 = t.shape.slice(),
        _o16 = _i27.pop(),
        _l10 = _i27.pop(),
        _u6 = [].concat(_toConsumableArray(_i27), [_o16]),
        _c5 = Array.from({
      length: t.rank
    }, function (e, n) {
      return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n;
    });

    t = Es($n(t, _c5), [_l10, -1]);

    var _h4 = [].concat(_toConsumableArray(_r41), _toConsumableArray(_u6));

    return Es(Mi({
      a: e,
      b: t,
      transposeA: !1,
      transposeB: !1,
      bias: s ? Cc(e.rank, s, "channelsLast") : null,
      activation: n
    }), _h4);
  }
}

function $c(e, t, n) {
  return Yn(function () {
    return t = Array.isArray(t) ? mi(t, "int32") : pn(t, "int32"), Nr(e, t, n);
  });
}

function Nc(e) {
  return ss(e, e);
}

function Cc(e, t, n) {
  var s = t.shape;
  if (1 !== t.rank && t.rank !== e) throw new bu("Unexpected bias dimensions: ".concat(t.rank, "; expected it to be 1 or ").concat(e));

  if (5 === e) {
    if ("channelsFirst" === n) return Es(t, 1 === s.length ? [1, s[0], 1, 1, 1] : [1, s[3], s[0], s[1], s[2]]);
    if ("channelsLast" === n) return Es(t, 1 === s.length ? [1, 1, 1, 1, s[0]] : [1].concat(s));
  } else if (4 === e) {
    if ("channelsFirst" === n) return Es(t, 1 === s.length ? [1, s[0], 1, 1] : [1, s[2], s[0], s[1]]);
    if ("channelsLast" === n) return Es(t, 1 === s.length ? [1, 1, 1, s[0]] : [1].concat(s));
  } else if (3 === e) {
    if ("channelsFirst" === n) return Es(t, 1 === s.length ? [1, s[0], 1] : [1, s[1], s[0]]);
    if ("channelsLast" === n) return Es(t, 1 === s.length ? [1, 1, s[0]] : [1].concat(s));
  } else if (e < 3) return t;

  throw new bu("Unsupported input rank by biasAdd: ".concat(t.rank));
}

function Sc(e, t, n) {
  return Yn(function () {
    return null == n && (n = "channelsLast"), tc(n), es(e, Cc(e.rank, t, n));
  });
}

function Tc(e, t, n, s) {
  return Yn(function () {
    return Ci(e, t, n, s);
  });
}

function Ec(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return n ? e() : t();
}

var Rc = ["fanIn", "fanOut", "fanAvg"],
    Ac = ["normal", "uniform", "truncatedNormal"];

var Fc = /*#__PURE__*/function (_Hn3) {
  "use strict";

  _inherits(Fc, _Hn3);

  var _super20 = _createSuper(Fc);

  function Fc() {
    _classCallCheck(this, Fc);

    return _super20.apply(this, arguments);
  }

  _createClass(Fc, [{
    key: "fromConfigUsesCustomObjects",
    value: function fromConfigUsesCustomObjects() {
      return !1;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {};
    }
  }]);

  return Fc;
}(Hn);

var Dc = /*#__PURE__*/function (_Fc) {
  "use strict";

  _inherits(Dc, _Fc);

  var _super21 = _createSuper(Dc);

  function Dc() {
    _classCallCheck(this, Dc);

    return _super21.apply(this, arguments);
  }

  _createClass(Dc, [{
    key: "apply",
    value: function apply(e, t) {
      return ua(e, t);
    }
  }]);

  return Dc;
}(Fc);

Dc.className = "Zeros", qn(Dc);

var _c = /*#__PURE__*/function (_Fc2) {
  "use strict";

  _inherits(_c, _Fc2);

  var _super22 = _createSuper(_c);

  function _c() {
    _classCallCheck(this, _c);

    return _super22.apply(this, arguments);
  }

  _createClass(_c, [{
    key: "apply",
    value: function apply(e, t) {
      return ca(e, t);
    }
  }]);

  return _c;
}(Fc);

_c.className = "Ones", qn(_c);

var Oc = /*#__PURE__*/function (_Fc3) {
  "use strict";

  _inherits(Oc, _Fc3);

  var _super23 = _createSuper(Oc);

  function Oc(e) {
    var _this48;

    _classCallCheck(this, Oc);

    if (_this48 = _super23.call(this), "object" != typeof e) throw new bu("Expected argument of type ConstantConfig but got ".concat(e));
    if (void 0 === e.value) throw new bu("config must have value set but got ".concat(e));
    _this48.value = e.value;
    return _possibleConstructorReturn(_this48);
  }

  _createClass(Oc, [{
    key: "apply",
    value: function apply(e, t) {
      var _this49 = this;

      return Yn(function () {
        return ss(qa(_this49.value), ca(e, t));
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        value: this.value
      };
    }
  }]);

  return Oc;
}(Fc);

Oc.className = "Constant", qn(Oc);

var Mc = /*#__PURE__*/function (_Fc4) {
  "use strict";

  _inherits(Mc, _Fc4);

  var _super24 = _createSuper(Mc);

  function Mc(e) {
    var _this50;

    _classCallCheck(this, Mc);

    _this50 = _super24.call(this), _this50.DEFAULT_MINVAL = -.05, _this50.DEFAULT_MAXVAL = .05, _this50.minval = e.minval || _this50.DEFAULT_MINVAL, _this50.maxval = e.maxval || _this50.DEFAULT_MAXVAL, _this50.seed = e.seed;
    return _this50;
  }

  _createClass(Mc, [{
    key: "apply",
    value: function apply(e, t) {
      return za(e, this.minval, this.maxval, t);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        minval: this.minval,
        maxval: this.maxval,
        seed: this.seed
      };
    }
  }]);

  return Mc;
}(Fc);

Mc.className = "RandomUniform", qn(Mc);

var Lc = /*#__PURE__*/function (_Fc5) {
  "use strict";

  _inherits(Lc, _Fc5);

  var _super25 = _createSuper(Lc);

  function Lc(e) {
    var _this51;

    _classCallCheck(this, Lc);

    _this51 = _super25.call(this), _this51.DEFAULT_MEAN = 0, _this51.DEFAULT_STDDEV = .05, _this51.mean = e.mean || _this51.DEFAULT_MEAN, _this51.stddev = e.stddev || _this51.DEFAULT_STDDEV, _this51.seed = e.seed;
    return _this51;
  }

  _createClass(Lc, [{
    key: "apply",
    value: function apply(e, t) {
      if ("float32" !== (t = t || "float32") && "int32" !== t) throw new xu("randomNormal does not support dType ".concat(t, "."));
      return vc(e, this.mean, this.stddev, t, this.seed);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      };
    }
  }]);

  return Lc;
}(Fc);

Lc.className = "RandomNormal", qn(Lc);

var zc = /*#__PURE__*/function (_Fc6) {
  "use strict";

  _inherits(zc, _Fc6);

  var _super26 = _createSuper(zc);

  function zc(e) {
    var _this52;

    _classCallCheck(this, zc);

    _this52 = _super26.call(this), _this52.DEFAULT_MEAN = 0, _this52.DEFAULT_STDDEV = .05, _this52.mean = e.mean || _this52.DEFAULT_MEAN, _this52.stddev = e.stddev || _this52.DEFAULT_STDDEV, _this52.seed = e.seed;
    return _this52;
  }

  _createClass(zc, [{
    key: "apply",
    value: function apply(e, t) {
      if ("float32" !== (t = t || "float32") && "int32" !== t) throw new xu("truncatedNormal does not support dType ".concat(t, "."));
      return yi(e, this.mean, this.stddev, t, this.seed);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      };
    }
  }]);

  return zc;
}(Fc);

zc.className = "TruncatedNormal", qn(zc);

var Bc = /*#__PURE__*/function (_Fc7) {
  "use strict";

  _inherits(Bc, _Fc7);

  var _super27 = _createSuper(Bc);

  function Bc(e) {
    var _this53;

    _classCallCheck(this, Bc);

    _this53 = _super27.call(this), _this53.gain = null != e.gain ? e.gain : 1;
    return _this53;
  }

  _createClass(Bc, [{
    key: "apply",
    value: function apply(e, t) {
      var _this54 = this;

      return Yn(function () {
        if (2 !== e.length || e[0] !== e[1]) throw new bu("Identity matrix initializer can only be used for 2D square matrices.");
        return ss(_this54.gain, vr(e[0]));
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        gain: this.gain
      };
    }
  }]);

  return Bc;
}(Fc);

Bc.className = "Identity", qn(Bc);

var Pc = /*#__PURE__*/function (_Fc8) {
  "use strict";

  _inherits(Pc, _Fc8);

  var _super28 = _createSuper(Pc);

  function Pc(e) {
    var _this55;

    _classCallCheck(this, Pc);

    if (_this55 = _super28.call(this), e.scale < 0) throw new bu("scale must be a positive float. Got: ".concat(e.scale));
    _this55.scale = null == e.scale ? 1 : e.scale, _this55.mode = null == e.mode ? "fanIn" : e.mode, _u(Rc, "FanMode", _this55.mode), _this55.distribution = null == e.distribution ? "normal" : e.distribution, _u(Ac, "Distribution", _this55.distribution), _this55.seed = e.seed;
    return _possibleConstructorReturn(_this55);
  }

  _createClass(Pc, [{
    key: "apply",
    value: function apply(e, t) {
      var n = function (e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "channelsLast";
        var n, s;
        if (tc(t), 2 === e.length) n = e[0], s = e[1];else if (-1 !== [3, 4, 5].indexOf(e.length)) {
          if ("channelsFirst" === t) {
            var _t168 = cc(e, 2);

            n = e[1] * _t168, s = e[0] * _t168;
          } else if ("channelsLast" === t) {
            var _t169 = cc(e, 0, e.length - 2);

            n = e[e.length - 2] * _t169, s = e[e.length - 1] * _t169;
          }
        } else {
          var _t170 = cc(e);

          n = Math.sqrt(_t170), s = Math.sqrt(_t170);
        }
        return [n, s];
      }(e),
          s = n[0],
          r = n[1];

      var a = this.scale;

      if (a /= "fanIn" === this.mode ? Math.max(1, s) : "fanOut" === this.mode ? Math.max(1, r) : Math.max(1, (s + r) / 2), "normal" === this.distribution) {
        var _n61 = Math.sqrt(a);

        if ("float32" !== (t = t || "float32") && "int32" !== t) throw new xu("".concat(this.getClassName(), " does not support dType ").concat(t, "."));
        return yi(e, 0, _n61, t, this.seed);
      }

      {
        var _n62 = Math.sqrt(3 * a);

        return za(e, -_n62, _n62, t);
      }
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        scale: this.scale,
        mode: this.mode,
        distribution: this.distribution,
        seed: this.seed
      };
    }
  }]);

  return Pc;
}(Fc);

Pc.className = "VarianceScaling", qn(Pc);

var Wc = /*#__PURE__*/function (_Pc) {
  "use strict";

  _inherits(Wc, _Pc);

  var _super29 = _createSuper(Wc);

  function Wc(e) {
    _classCallCheck(this, Wc);

    return _super29.call(this, {
      scale: 1,
      mode: "fanAvg",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  _createClass(Wc, [{
    key: "getClassName",
    value: function getClassName() {
      return Pc.className;
    }
  }]);

  return Wc;
}(Pc);

Wc.className = "GlorotUniform", qn(Wc);

var Uc = /*#__PURE__*/function (_Pc2) {
  "use strict";

  _inherits(Uc, _Pc2);

  var _super30 = _createSuper(Uc);

  function Uc(e) {
    _classCallCheck(this, Uc);

    return _super30.call(this, {
      scale: 1,
      mode: "fanAvg",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  _createClass(Uc, [{
    key: "getClassName",
    value: function getClassName() {
      return Pc.className;
    }
  }]);

  return Uc;
}(Pc);

Uc.className = "GlorotNormal", qn(Uc);

var Vc = /*#__PURE__*/function (_Pc3) {
  "use strict";

  _inherits(Vc, _Pc3);

  var _super31 = _createSuper(Vc);

  function Vc(e) {
    _classCallCheck(this, Vc);

    return _super31.call(this, {
      scale: 2,
      mode: "fanIn",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  _createClass(Vc, [{
    key: "getClassName",
    value: function getClassName() {
      return Pc.className;
    }
  }]);

  return Vc;
}(Pc);

Vc.className = "HeNormal", qn(Vc);

var Gc = /*#__PURE__*/function (_Pc4) {
  "use strict";

  _inherits(Gc, _Pc4);

  var _super32 = _createSuper(Gc);

  function Gc(e) {
    _classCallCheck(this, Gc);

    return _super32.call(this, {
      scale: 2,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  _createClass(Gc, [{
    key: "getClassName",
    value: function getClassName() {
      return Pc.className;
    }
  }]);

  return Gc;
}(Pc);

Gc.className = "HeUniform", qn(Gc);

var Hc = /*#__PURE__*/function (_Pc5) {
  "use strict";

  _inherits(Hc, _Pc5);

  var _super33 = _createSuper(Hc);

  function Hc(e) {
    _classCallCheck(this, Hc);

    return _super33.call(this, {
      scale: 1,
      mode: "fanIn",
      distribution: "normal",
      seed: null == e ? null : e.seed
    });
  }

  _createClass(Hc, [{
    key: "getClassName",
    value: function getClassName() {
      return Pc.className;
    }
  }]);

  return Hc;
}(Pc);

Hc.className = "LeCunNormal", qn(Hc);

var jc = /*#__PURE__*/function (_Pc6) {
  "use strict";

  _inherits(jc, _Pc6);

  var _super34 = _createSuper(jc);

  function jc(e) {
    _classCallCheck(this, jc);

    return _super34.call(this, {
      scale: 1,
      mode: "fanIn",
      distribution: "uniform",
      seed: null == e ? null : e.seed
    });
  }

  _createClass(jc, [{
    key: "getClassName",
    value: function getClassName() {
      return Pc.className;
    }
  }]);

  return jc;
}(Pc);

jc.className = "LeCunNormal", qn(jc);

var qc = /*#__PURE__*/function (_Fc9) {
  "use strict";

  _inherits(qc, _Fc9);

  var _super35 = _createSuper(qc);

  function qc(e) {
    var _this56;

    _classCallCheck(this, qc);

    if (_this56 = _super35.call(this), _this56.DEFAULT_GAIN = 1, _this56.gain = null == e.gain ? _this56.DEFAULT_GAIN : e.gain, _this56.seed = e.seed, null != _this56.seed) throw new xu("Random seed is not implemented for Orthogonal Initializer yet.");
    return _possibleConstructorReturn(_this56);
  }

  _createClass(qc, [{
    key: "apply",
    value: function apply(e, t) {
      var _this57 = this;

      return Yn(function () {
        if (e.length < 2) throw new xu("Shape must be at least 2D.");
        e[0] * e[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (".concat(e[0] * e[1], ") elements: Slowness may result."));
        var t = vc(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32");
        var n = po.gramSchmidt(t);
        return e[0] > e[1] && (n = $n(n)), ss(_this57.gain, n);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        gain: this.gain,
        seed: this.seed
      };
    }
  }]);

  return qc;
}(Fc);

qc.className = "Orthogonal", qn(qc);
var Kc = {
  constant: "Constant",
  glorotNormal: "GlorotNormal",
  glorotUniform: "GlorotUniform",
  heNormal: "HeNormal",
  heUniform: "HeUniform",
  identity: "Identity",
  leCunNormal: "LeCunNormal",
  leCunUniform: "LeCunUniform",
  ones: "Ones",
  orthogonal: "Orthogonal",
  randomNormal: "RandomNormal",
  randomUniform: "RandomUniform",
  truncatedNormal: "TruncatedNormal",
  varianceScaling: "VarianceScaling",
  zeros: "Zeros"
};

function Xc(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "initializer");
}

function Yc(e) {
  return Tu(e);
}

function Jc(e) {
  if ("string" == typeof e) {
    var t = e in Kc ? Kc[e] : e;
    if ("GlorotNormal" === t) return new Uc();
    if ("GlorotUniform" === t) return new Wc();
    if ("HeNormal" === t) return new Vc();
    if ("HeUniform" === t) return new Gc();
    if ("LeCunNormal" === t) return new Hc();
    if ("LeCunUniform" === t) return new jc();
    {
      var _e101 = {};
      return _e101.className = t, _e101.config = {}, Xc(_e101);
    }
  }

  return e instanceof Fc ? e : Xc(e);
}

var Zc = 0;

function Qc() {
  return Zc++;
}

var eh = {};

function th() {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  return e in eh || (eh[e] = 0), eh[e] += 1, e + eh[e].toString();
}

function nh(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}

function sh(e) {
  return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e];
}

function rh(e) {
  var t;

  if (Array.isArray(e)) {
    if (1 !== e.length) throw new bu("Expected Tensor length to be 1; got ".concat(e.length));
    t = e[0];
  } else t = e;

  return t;
}

function ah(e) {
  if (Array.isArray(e) && Array.isArray(e[0])) {
    if (1 === e.length) return (e = e)[0];
    throw new bu("Expected exactly 1 Shape; got ".concat(e.length));
  }

  return e;
}

function ih(e) {
  var t = 0;

  var _iterator11 = _createForOfIteratorHelper(e),
      _step11;

  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var _n63 = _step11.value;
      t += 0 === _n63.shape.length ? 1 : _n63.shape.reduce(function (e, t) {
        return e * t;
      });
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }

  return t;
}

var oh = /*#__PURE__*/function () {
  "use strict";

  function oh(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "float32";
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Variable";
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, oh);

    this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = Qc(), this.originalName = ic(n = null == n ? "Variable" : n), this.name = oc(this.originalName), this.trainable_ = s, this.constraint = r, this.val = function (e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = arguments.length > 2 ? arguments[2] : undefined;
      var s = arguments.length > 3 ? arguments[3] : undefined;
      return wt.makeVariable(e, t, n, s);
    }(e, this.trainable_, this.name, this.dtype);
  }

  _createClass(oh, [{
    key: "read",
    value: function read() {
      return this.assertNotDisposed(), this.val;
    }
  }, {
    key: "write",
    value: function write(e) {
      return this.assertNotDisposed(), function (e, t) {
        if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
      }(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.assertNotDisposed(), this.val.dispose();
    }
  }, {
    key: "assertNotDisposed",
    value: function assertNotDisposed() {
      if (this.val.isDisposed) throw new Error("LayersVariable ".concat(this.name, " is already disposed."));
    }
  }, {
    key: "trainable",
    get: function get() {
      return this.trainable_;
    },
    set: function set(e) {
      this.trainable_ = e, this.val.trainable = e;
    }
  }]);

  return oh;
}();

function lh(e) {
  return e.map(function (e) {
    return e.read();
  });
}

function uh(e) {
  e.forEach(function (e) {
    e[0].write(e[1]);
  });
}

var ch = function ch(e) {
  "use strict";

  _classCallCheck(this, ch);

  this.dtype = e.dtype, this.shape = e.shape, this.ndim = null != e.shape ? e.shape.length : e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
};

var hh = function hh(e, t, n, s, r, a, i) {
  "use strict";

  _classCallCheck(this, hh);

  this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = s, this.callArgs = r, this.outputTensorIndex = i, this.id = Qc(), null != a && (this.originalName = ic(a), this.name = oc(this.originalName)), this.rank = t.length;
};

var dh = 0;

var ph = /*#__PURE__*/function () {
  "use strict";

  function ph(e, t) {
    _classCallCheck(this, ph);

    this.callArgs = t, this.id = dh++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;

    var _iterator12 = _createForOfIteratorHelper(e.inboundLayers),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var _t171 = _step12.value;
        null != _t171 && _t171.outboundNodes.push(this);
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    e.outboundLayer.inboundNodes.push(this);
  }

  _createClass(ph, [{
    key: "getConfig",
    value: function getConfig() {
      var e = [];

      var _iterator13 = _createForOfIteratorHelper(this.inboundLayers),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var t = _step13.value;
          e.push(null != t ? t.name : null);
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }

      return {
        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
        inboundLayers: e,
        nodeIndices: this.nodeIndices,
        tensorIndices: this.tensorIndices
      };
    }
  }]);

  return ph;
}();

var fh = 0;

var gh = /*#__PURE__*/function (_Hn4) {
  "use strict";

  _inherits(gh, _Hn4);

  var _super36 = _createSuper(gh);

  function gh() {
    var _this58;

    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, gh);

    _this58 = _super36.call(this), _this58._callHook = null, _this58._addedWeightNames = [], _this58._stateful = !1, _this58.id = fh++, _this58.activityRegularizer = null, _this58.inputSpec = null, _this58.supportsMasking = !1, _this58._trainableWeights = [], _this58._nonTrainableWeights = [], _this58._losses = [], _this58._updates = [], _this58._built = !1, _this58.inboundNodes = [], _this58.outboundNodes = [];
    var t = e.name;

    if (!t) {
      var _e102 = _this58.getClassName();

      t = Nu(_e102) + "_" + th(_e102);
    }

    if (_this58.name = t, _this58.trainable_ = null == e.trainable || e.trainable, null != e.inputShape || null != e.batchInputShape) {
      var _t172;

      if (null != e.batchInputShape) _t172 = e.batchInputShape;else if (null != e.inputShape) {
        var _n65 = null;
        null != e.batchSize && (_n65 = e.batchSize), _t172 = [_n65].concat(e.inputShape);
      }
      _this58.batchInputShape = _t172;
      var _n64 = e.dtype;
      null == _n64 && (_n64 = e.inputDType), null == _n64 && (_n64 = "float32"), _this58.dtype = _n64;
    }

    _this58.initialWeights = null != e.weights ? e.weights : null, _this58._refCount = null, _this58.fastWeightInitDuringBuild = !1;
    return _this58;
  }

  _createClass(gh, [{
    key: "getNodeAtIndex",
    value: function getNodeAtIndex(e, t) {
      if (0 === this.inboundNodes.length) throw new mu("The layer has never been called and thus has no defined ".concat(t, "."));
      if (this.inboundNodes.length <= e) throw new bu("Asked to get ".concat(t, " at node ").concat(e, ", but the layer has only ").concat(this.inboundNodes.length, " inbound nodes."));
      return this.inboundNodes[e];
    }
  }, {
    key: "getInputAt",
    value: function getInputAt(e) {
      return Iu(this.getNodeAtIndex(e, "input").inputTensors);
    }
  }, {
    key: "getOutputAt",
    value: function getOutputAt(e) {
      return Iu(this.getNodeAtIndex(e, "output").outputTensors);
    }
  }, {
    key: "input",
    get: function get() {
      if (this.inboundNodes.length > 1) throw new gu("Layer ".concat(this.name, " has multiple inbound nodes, hence the notion of \"layer input\" is ill-defined. Use `getInputAt(nodeIndex)` instead."));
      if (0 === this.inboundNodes.length) throw new gu("Layer ".concat(this.name, " is not connected, no input to return."));
      return Iu(this.getNodeAtIndex(0, "input").inputTensors);
    }
  }, {
    key: "output",
    get: function get() {
      if (0 === this.inboundNodes.length) throw new gu("Layer ".concat(this.name, " has no inbound nodes."));
      if (this.inboundNodes.length > 1) throw new gu("Layer ".concat(this.name, " has multiple inbound nodes, hence the notion of \"layer output\" is ill-defined. Use `getOutputAt(nodeIndex)` instead."));
      return Iu(this.getNodeAtIndex(0, "output").outputTensors);
    }
  }, {
    key: "losses",
    get: function get() {
      return this._losses;
    }
  }, {
    key: "calculateLosses",
    value: function calculateLosses() {
      return this.losses.map(function (e) {
        return e();
      });
    }
  }, {
    key: "updates",
    get: function get() {
      return this._updates;
    }
  }, {
    key: "built",
    get: function get() {
      return this._built;
    },
    set: function set(e) {
      this._built = e;
    }
  }, {
    key: "trainable",
    get: function get() {
      return this.trainable_;
    },
    set: function set(e) {
      this._trainableWeights.forEach(function (t) {
        return t.trainable = e;
      }), this.trainable_ = e;
    }
  }, {
    key: "trainableWeights",
    get: function get() {
      return this.trainable_ ? this._trainableWeights.filter(function (e) {
        return e.trainable;
      }) : [];
    },
    set: function set(e) {
      this._trainableWeights = e;
    }
  }, {
    key: "nonTrainableWeights",
    get: function get() {
      return this.trainable ? this._trainableWeights.filter(function (e) {
        return !e.trainable;
      }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    },
    set: function set(e) {
      this._nonTrainableWeights = e;
    }
  }, {
    key: "weights",
    get: function get() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
  }, {
    key: "stateful",
    get: function get() {
      return this._stateful;
    }
  }, {
    key: "resetStates",
    value: function resetStates() {
      if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }
  }, {
    key: "assertInputCompatibility",
    value: function assertInputCompatibility(e) {
      if (e = $u(e), null == this.inputSpec || 0 === this.inputSpec.length) return;
      var t = $u(this.inputSpec);
      if (e.length !== t.length) throw new bu("Layer ".concat(this.name, " expects ").concat(t.length, " inputs, but it received ").concat(e.length, " input tensors. Input received: ").concat(e));

      for (var _n66 = 0; _n66 < e.length; _n66++) {
        var _s58 = e[_n66],
            _r42 = t[_n66];
        if (null == _r42) continue;
        var _a32 = _s58.rank;
        if (null != _r42.ndim && _a32 !== _r42.ndim) throw new bu("Input ".concat(_n66, " is incompatible with layer ").concat(this.name, ": expected ndim=").concat(_r42.ndim, ", found ndim=").concat(_a32));
        if (null != _r42.maxNDim && _a32 > _r42.maxNDim) throw new bu("Input ".concat(_n66, " is incompatible with layer ").concat(this.name, ": expected max_ndim=").concat(_r42.maxNDim, ", found ndim=").concat(_a32));
        if (null != _r42.minNDim && _a32 < _r42.minNDim) throw new bu("Input ".concat(_n66, " is incompatible with layer ").concat(this.name, ": expected min_ndim=").concat(_r42.minNDim, ", found ndim=").concat(_a32, "."));
        if (null != _r42.dtype && _s58.dtype !== _r42.dtype) throw new bu("Input ".concat(_n66, " is incompatible with layer ").concat(this.name, " : expected dtype=").concat(_r42.dtype, ", found dtype=").concat(_s58.dtype, "."));

        if (_r42.axes) {
          var _e103 = _s58.shape;

          for (var _t173 in _r42.axes) {
            var _s59 = Number(_t173),
                _a33 = _r42.axes[_t173],
                _i28 = _s59 >= 0 ? _e103[_s59] : _e103[_e103.length + _s59];

            if (null != _a33 && -1 === [_a33, null].indexOf(_i28)) throw new bu("Input ".concat(_n66, " is incompatible with layer ").concat(this.name, ": expected axis ").concat(_s59, " of input shape to have value ").concat(_a33, " but got shape ").concat(_e103, "."));
          }
        }

        if (null != _r42.shape) for (var _e104 = 0; _e104 < _r42.shape.length; ++_e104) {
          var _t174 = _r42.shape[_e104],
              _a34 = _s58.shape[_e104];
          if (null != _t174 && null != _a34 && _t174 !== _a34) throw new bu("Input ".concat(_n66, " is incompatible with layer ").concat(this.name, ": expected shape=").concat(_r42.shape, ", found shape=").concat(_s58.shape, "."));
        }
      }
    }
  }, {
    key: "call",
    value: function call(e, t) {
      return e;
    }
  }, {
    key: "invokeCallHook",
    value: function invokeCallHook(e, t) {
      null != this._callHook && this._callHook(e, t);
    }
  }, {
    key: "setCallHook",
    value: function setCallHook(e) {
      this._callHook = e;
    }
  }, {
    key: "clearCallHook",
    value: function clearCallHook() {
      this._callHook = null;
    }
  }, {
    key: "apply",
    value: function apply(e, t) {
      var _this59 = this;

      t = t || {}, this.assertNotDisposed();
      var n = $u(e);
      var s = !0;

      var _iterator14 = _createForOfIteratorHelper(n),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var _e106 = _step14.value;

          if (!(_e106 instanceof hh)) {
            s = !1;
            break;
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }

      var r = !0;

      var _iterator15 = _createForOfIteratorHelper(n),
          _step15;

      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var _e107 = _step15.value;

          if (_e107 instanceof hh) {
            r = !1;
            break;
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }

      if (s === r) throw new bu("Arguments to apply() must be all SymbolicTensors or all Tensors");
      return ac(this.name, function () {
        if (!_this59.built) {
          _this59.assertInputCompatibility(e);

          var _t175 = [];

          var _iterator16 = _createForOfIteratorHelper($u(e)),
              _step16;

          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var _n67 = _step16.value;

              _t175.push(_n67.shape);
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }

          _this59.build(Iu(_t175)), _this59.built = !0, _this59.initialWeights && _this59.setWeights(_this59.initialWeights), null === _this59._refCount && r && (_this59._refCount = 1);
        }

        if (_this59.assertInputCompatibility(e), r) {
          var _s60 = _this59.call(e, t);

          var _r43 = $u(_s60),
              _a35 = [];

          var _iterator17 = _createForOfIteratorHelper(_r43),
              _step17;

          try {
            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
              var _e105 = _step17.value;
              -1 !== n.indexOf(_e105) && (_e105 = _e105.clone()), _a35.push(_e105);
            }
          } catch (err) {
            _iterator17.e(err);
          } finally {
            _iterator17.f();
          }

          if (_s60 = Iu(_a35), null != _this59.activityRegularizer) throw new xu("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return _s60;
        }

        {
          var _n68 = function (e) {
            e = $u(e);
            var t = [];

            var _iterator18 = _createForOfIteratorHelper(e),
                _step18;

            try {
              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                var _n69 = _step18.value;
                t.push(_n69.shape);
              }
            } catch (err) {
              _iterator18.e(err);
            } finally {
              _iterator18.f();
            }

            return Iu(t);
          }(e),
              _s61 = _this59.computeOutputShape(_n68);

          var _r44;

          var _a36 = "float32";
          if (_this59.warnOnIncompatibleInputShape(Array.isArray(e) ? _n68[0] : _n68), _r44 = null != _s61 && _s61.length > 0 && Array.isArray(_s61[0]) ? _s61.map(function (n, s) {
            return new hh(_a36, n, _this59, $u(e), t, _this59.name, s);
          }) : new hh(_a36, _s61, _this59, $u(e), t, _this59.name), _this59.addInboundNode(e, _r44, null, null, _n68, _s61, t), _this59._refCount++, null != _this59.activityRegularizer) throw new xu("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return _r44;
        }
      });
    }
  }, {
    key: "warnOnIncompatibleInputShape",
    value: function warnOnIncompatibleInputShape(e) {
      if (null != this.batchInputShape) if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: ".concat(JSON.stringify(e), ") does not match that of the batchInputShape (").concat(JSON.stringify(this.batchInputShape), ") of the layer ").concat(this.name));else {
        var t = !1;
        this.batchInputShape.forEach(function (n, s) {
          null != n && null != e[s] && e[s] !== n && (t = !0);
        }), t && console.warn("The shape of the input tensor (".concat(JSON.stringify(e), ") does not match the expectation of layer ").concat(this.name, ": ").concat(JSON.stringify(this.batchInputShape)));
      }
    }
  }, {
    key: "outputShape",
    get: function get() {
      if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new gu("The layer ".concat(this.name, " has never been called and thus has no defined output shape."));
      var e = [];

      var _iterator19 = _createForOfIteratorHelper(this.inboundNodes),
          _step19;

      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var t = _step19.value;

          var _n70 = JSON.stringify(t.outputShapes);

          -1 === e.indexOf(_n70) && e.push(_n70);
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }

      if (1 === e.length) {
        var _e108 = this.inboundNodes[0].outputShapes;
        return Array.isArray(_e108) && Array.isArray(_e108[0]) && 1 === _e108.length ? _e108[0] : _e108;
      }

      throw new gu("The layer ".concat(this.name, " has multiple inbound nodes with different output shapes. Hence the notion of \"output shape\" is ill-defined for the layer."));
    }
  }, {
    key: "countParams",
    value: function countParams() {
      if (!this.built) throw new mu("You tried to call countParams() on ".concat(this.name, ", but the layer is not built yet. Build it first by calling build(batchInputShape)."));
      return ih(this.weights);
    }
  }, {
    key: "build",
    value: function build(e) {
      this.built = !0;
    }
  }, {
    key: "getWeights",
    value: function getWeights() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
      return lh(e ? this.trainableWeights : this.weights);
    }
  }, {
    key: "setWeights",
    value: function setWeights(e) {
      var _this60 = this;

      Yn(function () {
        var t = _this60.weights;
        if (t.length !== e.length) throw new bu("You called setWeights(weights) on layer \"".concat(_this60.name, "\" with a weight list of length ").concat(e.length, ", but the layer was expecting ").concat(t.length, " weights. Provided weights: ").concat(e, "..."));
        if (0 === t.length) return;
        var n = [],
            s = lh(t);

        for (var _r45 = 0; _r45 < s.length; ++_r45) {
          var _a37 = s[_r45],
              _i29 = t[_r45],
              _o17 = e[_r45];
          if (!p(_a37.shape, _o17.shape)) throw new bu("Layer weight shape ".concat(_a37.shape, " not compatible with provided weight shape ").concat(_o17.shape));
          n.push([_i29, _o17]);
        }

        uh(n);
      });
    }
  }, {
    key: "addWeight",
    value: function addWeight(e, t, n, s, r, a, i) {
      if (-1 !== this._addedWeightNames.indexOf(e)) throw new bu("Duplicate weight name ".concat(e, " for layer ").concat(this.name));
      this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (s = Jc("zeros"));
      var o = s.apply(t, n),
          l = new oh(o, n, e, a, i);
      return o.dispose(), null != r && this.addLoss(function () {
        return r.apply(l.read());
      }), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l;
    }
  }, {
    key: "setFastWeightInitDuringBuild",
    value: function setFastWeightInitDuringBuild(e) {
      this.fastWeightInitDuringBuild = e;
    }
  }, {
    key: "addLoss",
    value: function addLoss(e) {
      var _this$losses;

      null == e || Array.isArray(e) && 0 === e.length || (e = $u(e), null != this._losses && (_this$losses = this.losses).push.apply(_this$losses, _toConsumableArray(e)));
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var _this61 = this;

      if (!this.supportsMasking) {
        if (null != t) {
          if (!Array.isArray(t)) throw new TypeError("Layer ".concat(this.name, " does not support masking, but was passed an inputMask."));
          t.forEach(function (e) {
            if (null != e) throw new TypeError("Layer ".concat(_this61.name, " does not support masking, but was passed an inputMask."));
          });
        }

        return null;
      }

      return t;
    }
  }, {
    key: "addInboundNode",
    value: function addInboundNode(e, t, n, s, r, a) {
      var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var o = $u(e);
      t = $u(t), n = $u(n), s = $u(s), r = sh(r), a = sh(a);
      var l = [],
          u = [],
          c = [];

      var _iterator20 = _createForOfIteratorHelper(o),
          _step20;

      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
          var _e110 = _step20.value;
          l.push(_e110.sourceLayer), u.push(_e110.nodeIndex), c.push(_e110.tensorIndex);
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }

      new ph({
        outboundLayer: this,
        inboundLayers: l,
        nodeIndices: u,
        tensorIndices: c,
        inputTensors: o,
        outputTensors: t,
        inputMasks: n,
        outputMasks: s,
        inputShapes: r,
        outputShapes: a
      }, i);

      for (var _e109 = 0; _e109 < t.length; _e109++) {
        t[_e109].sourceLayer = this, t[_e109].nodeIndex = this.inboundNodes.length - 1, t[_e109].tensorIndex = _e109;
      }
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        name: this.name,
        trainable: this.trainable
      };
      return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e;
    }
  }, {
    key: "disposeWeights",
    value: function disposeWeights() {
      return this.weights.forEach(function (e) {
        return e.dispose();
      }), this.weights.length;
    }
  }, {
    key: "assertNotDisposed",
    value: function assertNotDisposed() {
      if (0 === this._refCount) throw new Error("Layer '".concat(this.name, "' is already disposed."));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (!this.built) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been built yet."));
      if (null === this._refCount) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been used yet."));
      this.assertNotDisposed();
      var e = 0;
      return 0 == --this._refCount && (e = this.disposeWeights()), {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: e
      };
    }
  }], [{
    key: "nodeKey",
    value: function nodeKey(e, t) {
      return e.name + "_ib-" + t.toString();
    }
  }]);

  return gh;
}(Hn);

function mh(e, t, n) {
  if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
  {
    var _e111 = t.inboundNodes[n];
    if (0 === _e111.inboundLayers.length) return _e111.inputTensors;
    {
      var _t176 = [];

      for (var _n71 = 0; _n71 < _e111.inboundLayers.length; _n71++) {
        var _s62 = mh(_e111.inputTensors[_n71], _e111.inboundLayers[_n71], _e111.nodeIndices[_n71]);

        var _iterator21 = _createForOfIteratorHelper(_s62),
            _step21;

        try {
          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
            var _e112 = _step21.value;
            -1 === _t176.indexOf(_e112) && _t176.push(_e112);
          }
        } catch (err) {
          _iterator21.e(err);
        } finally {
          _iterator21.f();
        }
      }

      return _t176;
    }
  }
}

var bh = /*#__PURE__*/function (_gh) {
  "use strict";

  _inherits(bh, _gh);

  var _super37 = _createSuper(bh);

  function bh(e) {
    var _this62;

    _classCallCheck(this, bh);

    if (_this62 = _super37.call(this, {
      dtype: e.dtype,
      name: null != e.name ? e.name : th("input").toString()
    }), null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), _this62.trainable = !1, _this62.built = !0, _this62.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new bu("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
    var t = e.batchInputShape;

    if (null == t) {
      if (null == e.inputShape) throw new bu("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
      t = [e.batchSize].concat(e.inputShape);
    } else if (null != e.batchSize) throw new bu("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");

    var n = e.dtype || "float32";
    _this62.batchInputShape = t, _this62.dtype = n, _this62.inputSpec = [{
      shape: t
    }];
    var s = new hh(_this62.dtype, _this62.batchInputShape, _assertThisInitialized(_this62), [], {}, _this62.name);
    s.nodeIndex = 0, s.tensorIndex = 0, new ph({
      outboundLayer: _assertThisInitialized(_this62),
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: [s],
      outputTensors: [s],
      inputMasks: [null],
      outputMasks: [null],
      inputShapes: [t],
      outputShapes: [t]
    });
    return _possibleConstructorReturn(_this62);
  }

  _createClass(bh, [{
    key: "apply",
    value: function apply(e, t) {
      throw new bu("Cannot pass any input to an InputLayer's apply() method. InputLayer name: ".concat(this.name));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      return {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: 0
      };
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        batchInputShape: this.batchInputShape,
        dtype: this.dtype,
        sparse: this.sparse,
        name: this.name
      };
    }
  }]);

  return bh;
}(gh);

function xh(_x41) {
  return _xh.apply(this, arguments);
}

function _xh() {
  _xh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee99(e) {
    var t, n, s, _r177, a, _e540, _r178, _t481;

    return _regeneratorRuntime.wrap(function _callee99$(_context102) {
      while (1) {
        switch (_context102.prev = _context102.next) {
          case 0:
            if (!(null == e)) {
              _context102.next = 2;
              break;
            }

            return _context102.abrupt("return");

          case 2:
            t = [], n = [], s = [];

            for (_r177 in e) {
              a = e[_r177];

              if ("number" != typeof a) {
                _e540 = a;
                t.push(_e540.data()), n.push(_r177), s.push(_e540);
              }
            }

            if (!(t.length > 0)) {
              _context102.next = 10;
              break;
            }

            _context102.next = 7;
            return Promise.all(t);

          case 7:
            _r178 = _context102.sent;

            for (_t481 = 0; _t481 < _r178.length; ++_t481) {
              e[n[_t481]] = _r178[_t481][0];
            }

            Jn(s);

          case 10:
          case "end":
            return _context102.stop();
        }
      }
    }, _callee99);
  }));
  return _xh.apply(this, arguments);
}

function yh(e) {
  if (null != e) for (var t in e) {
    var _n72 = e[t];
    "number" != typeof _n72 && _n72.dispose();
  }
}

var kh;
bh.className = "InputLayer", qn(bh), function (e) {
  e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE";
}(kh || (kh = {}));

var wh = /*#__PURE__*/function () {
  "use strict";

  function wh() {
    _classCallCheck(this, wh);

    this.validationData = null;
  }

  _createClass(wh, [{
    key: "setParams",
    value: function setParams(e) {
      this.params = e;
    }
  }, {
    key: "onEpochBegin",
    value: function () {
      var _onEpochBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee45(e, t) {
        return _regeneratorRuntime.wrap(function _callee45$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee45);
      }));

      function onEpochBegin(_x42, _x43) {
        return _onEpochBegin.apply(this, arguments);
      }

      return onEpochBegin;
    }()
  }, {
    key: "onEpochEnd",
    value: function () {
      var _onEpochEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee46(e, t) {
        return _regeneratorRuntime.wrap(function _callee46$(_context46) {
          while (1) {
            switch (_context46.prev = _context46.next) {
              case 0:
              case "end":
                return _context46.stop();
            }
          }
        }, _callee46);
      }));

      function onEpochEnd(_x44, _x45) {
        return _onEpochEnd.apply(this, arguments);
      }

      return onEpochEnd;
    }()
  }, {
    key: "onBatchBegin",
    value: function () {
      var _onBatchBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee47(e, t) {
        return _regeneratorRuntime.wrap(function _callee47$(_context47) {
          while (1) {
            switch (_context47.prev = _context47.next) {
              case 0:
              case "end":
                return _context47.stop();
            }
          }
        }, _callee47);
      }));

      function onBatchBegin(_x46, _x47) {
        return _onBatchBegin.apply(this, arguments);
      }

      return onBatchBegin;
    }()
  }, {
    key: "onBatchEnd",
    value: function () {
      var _onBatchEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee48(e, t) {
        return _regeneratorRuntime.wrap(function _callee48$(_context48) {
          while (1) {
            switch (_context48.prev = _context48.next) {
              case 0:
              case "end":
                return _context48.stop();
            }
          }
        }, _callee48);
      }));

      function onBatchEnd(_x48, _x49) {
        return _onBatchEnd.apply(this, arguments);
      }

      return onBatchEnd;
    }()
  }, {
    key: "onTrainBegin",
    value: function () {
      var _onTrainBegin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee49(e) {
        return _regeneratorRuntime.wrap(function _callee49$(_context49) {
          while (1) {
            switch (_context49.prev = _context49.next) {
              case 0:
              case "end":
                return _context49.stop();
            }
          }
        }, _callee49);
      }));

      function onTrainBegin(_x50) {
        return _onTrainBegin.apply(this, arguments);
      }

      return onTrainBegin;
    }()
  }, {
    key: "onTrainEnd",
    value: function () {
      var _onTrainEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee50(e) {
        return _regeneratorRuntime.wrap(function _callee50$(_context50) {
          while (1) {
            switch (_context50.prev = _context50.next) {
              case 0:
              case "end":
                return _context50.stop();
            }
          }
        }, _callee50);
      }));

      function onTrainEnd(_x51) {
        return _onTrainEnd.apply(this, arguments);
      }

      return onTrainEnd;
    }()
  }, {
    key: "setModel",
    value: function setModel(e) {}
  }]);

  return wh;
}();

var vh = /*#__PURE__*/function () {
  "use strict";

  function vh(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    _classCallCheck(this, vh);

    null == e && (e = []), this.callbacks = e, this.queueLength = t;
  }

  _createClass(vh, [{
    key: "append",
    value: function append(e) {
      this.callbacks.push(e);
    }
  }, {
    key: "setParams",
    value: function setParams(e) {
      var _iterator22 = _createForOfIteratorHelper(this.callbacks),
          _step22;

      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var t = _step22.value;
          t.setParams(e);
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
    }
  }, {
    key: "setModel",
    value: function setModel(e) {
      var _iterator23 = _createForOfIteratorHelper(this.callbacks),
          _step23;

      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var t = _step23.value;
          t.setModel(e);
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    }
  }, {
    key: "onEpochBegin",
    value: function () {
      var _onEpochBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee51(e, t) {
        var _iterator24, _step24, _n73;

        return _regeneratorRuntime.wrap(function _callee51$(_context51) {
          while (1) {
            switch (_context51.prev = _context51.next) {
              case 0:
                null == t && (t = {});
                _iterator24 = _createForOfIteratorHelper(this.callbacks);
                _context51.prev = 2;

                _iterator24.s();

              case 4:
                if ((_step24 = _iterator24.n()).done) {
                  _context51.next = 10;
                  break;
                }

                _n73 = _step24.value;
                _context51.next = 8;
                return _n73.onEpochBegin(e, t);

              case 8:
                _context51.next = 4;
                break;

              case 10:
                _context51.next = 15;
                break;

              case 12:
                _context51.prev = 12;
                _context51.t0 = _context51["catch"](2);

                _iterator24.e(_context51.t0);

              case 15:
                _context51.prev = 15;

                _iterator24.f();

                return _context51.finish(15);

              case 18:
              case "end":
                return _context51.stop();
            }
          }
        }, _callee51, this, [[2, 12, 15, 18]]);
      }));

      function onEpochBegin(_x52, _x53) {
        return _onEpochBegin2.apply(this, arguments);
      }

      return onEpochBegin;
    }()
  }, {
    key: "onEpochEnd",
    value: function () {
      var _onEpochEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee52(e, t) {
        var _iterator25, _step25, _n74;

        return _regeneratorRuntime.wrap(function _callee52$(_context52) {
          while (1) {
            switch (_context52.prev = _context52.next) {
              case 0:
                null == t && (t = {});
                _iterator25 = _createForOfIteratorHelper(this.callbacks);
                _context52.prev = 2;

                _iterator25.s();

              case 4:
                if ((_step25 = _iterator25.n()).done) {
                  _context52.next = 10;
                  break;
                }

                _n74 = _step25.value;
                _context52.next = 8;
                return _n74.onEpochEnd(e, t);

              case 8:
                _context52.next = 4;
                break;

              case 10:
                _context52.next = 15;
                break;

              case 12:
                _context52.prev = 12;
                _context52.t0 = _context52["catch"](2);

                _iterator25.e(_context52.t0);

              case 15:
                _context52.prev = 15;

                _iterator25.f();

                return _context52.finish(15);

              case 18:
              case "end":
                return _context52.stop();
            }
          }
        }, _callee52, this, [[2, 12, 15, 18]]);
      }));

      function onEpochEnd(_x54, _x55) {
        return _onEpochEnd2.apply(this, arguments);
      }

      return onEpochEnd;
    }()
  }, {
    key: "onBatchBegin",
    value: function () {
      var _onBatchBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee53(e, t) {
        var _iterator26, _step26, _n75;

        return _regeneratorRuntime.wrap(function _callee53$(_context53) {
          while (1) {
            switch (_context53.prev = _context53.next) {
              case 0:
                null == t && (t = {});
                _iterator26 = _createForOfIteratorHelper(this.callbacks);
                _context53.prev = 2;

                _iterator26.s();

              case 4:
                if ((_step26 = _iterator26.n()).done) {
                  _context53.next = 10;
                  break;
                }

                _n75 = _step26.value;
                _context53.next = 8;
                return _n75.onBatchBegin(e, t);

              case 8:
                _context53.next = 4;
                break;

              case 10:
                _context53.next = 15;
                break;

              case 12:
                _context53.prev = 12;
                _context53.t0 = _context53["catch"](2);

                _iterator26.e(_context53.t0);

              case 15:
                _context53.prev = 15;

                _iterator26.f();

                return _context53.finish(15);

              case 18:
              case "end":
                return _context53.stop();
            }
          }
        }, _callee53, this, [[2, 12, 15, 18]]);
      }));

      function onBatchBegin(_x56, _x57) {
        return _onBatchBegin2.apply(this, arguments);
      }

      return onBatchBegin;
    }()
  }, {
    key: "onBatchEnd",
    value: function () {
      var _onBatchEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee54(e, t) {
        var _iterator27, _step27, _n76;

        return _regeneratorRuntime.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                null == t && (t = {});
                _iterator27 = _createForOfIteratorHelper(this.callbacks);
                _context54.prev = 2;

                _iterator27.s();

              case 4:
                if ((_step27 = _iterator27.n()).done) {
                  _context54.next = 10;
                  break;
                }

                _n76 = _step27.value;
                _context54.next = 8;
                return _n76.onBatchEnd(e, t);

              case 8:
                _context54.next = 4;
                break;

              case 10:
                _context54.next = 15;
                break;

              case 12:
                _context54.prev = 12;
                _context54.t0 = _context54["catch"](2);

                _iterator27.e(_context54.t0);

              case 15:
                _context54.prev = 15;

                _iterator27.f();

                return _context54.finish(15);

              case 18:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54, this, [[2, 12, 15, 18]]);
      }));

      function onBatchEnd(_x58, _x59) {
        return _onBatchEnd2.apply(this, arguments);
      }

      return onBatchEnd;
    }()
  }, {
    key: "onTrainBegin",
    value: function () {
      var _onTrainBegin2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee55(e) {
        var _iterator28, _step28, t;

        return _regeneratorRuntime.wrap(function _callee55$(_context55) {
          while (1) {
            switch (_context55.prev = _context55.next) {
              case 0:
                null == e && (e = {});
                _iterator28 = _createForOfIteratorHelper(this.callbacks);
                _context55.prev = 2;

                _iterator28.s();

              case 4:
                if ((_step28 = _iterator28.n()).done) {
                  _context55.next = 10;
                  break;
                }

                t = _step28.value;
                _context55.next = 8;
                return t.onTrainBegin(e);

              case 8:
                _context55.next = 4;
                break;

              case 10:
                _context55.next = 15;
                break;

              case 12:
                _context55.prev = 12;
                _context55.t0 = _context55["catch"](2);

                _iterator28.e(_context55.t0);

              case 15:
                _context55.prev = 15;

                _iterator28.f();

                return _context55.finish(15);

              case 18:
              case "end":
                return _context55.stop();
            }
          }
        }, _callee55, this, [[2, 12, 15, 18]]);
      }));

      function onTrainBegin(_x60) {
        return _onTrainBegin2.apply(this, arguments);
      }

      return onTrainBegin;
    }()
  }, {
    key: "onTrainEnd",
    value: function () {
      var _onTrainEnd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee56(e) {
        var _iterator29, _step29, t;

        return _regeneratorRuntime.wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                null == e && (e = {});
                _iterator29 = _createForOfIteratorHelper(this.callbacks);
                _context56.prev = 2;

                _iterator29.s();

              case 4:
                if ((_step29 = _iterator29.n()).done) {
                  _context56.next = 10;
                  break;
                }

                t = _step29.value;
                _context56.next = 8;
                return t.onTrainEnd(e);

              case 8:
                _context56.next = 4;
                break;

              case 10:
                _context56.next = 15;
                break;

              case 12:
                _context56.prev = 12;
                _context56.t0 = _context56["catch"](2);

                _iterator29.e(_context56.t0);

              case 15:
                _context56.prev = 15;

                _iterator29.f();

                return _context56.finish(15);

              case 18:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56, this, [[2, 12, 15, 18]]);
      }));

      function onTrainEnd(_x61) {
        return _onTrainEnd2.apply(this, arguments);
      }

      return onTrainEnd;
    }()
  }]);

  return vh;
}();

var Ih = /*#__PURE__*/function (_wh) {
  "use strict";

  _inherits(Ih, _wh);

  var _super38 = _createSuper(Ih);

  function Ih() {
    _classCallCheck(this, Ih);

    return _super38.call(this);
  }

  _createClass(Ih, [{
    key: "onEpochBegin",
    value: function () {
      var _onEpochBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee57(e) {
        return _regeneratorRuntime.wrap(function _callee57$(_context57) {
          while (1) {
            switch (_context57.prev = _context57.next) {
              case 0:
                this.seen = 0, this.totals = {};

              case 1:
              case "end":
                return _context57.stop();
            }
          }
        }, _callee57, this);
      }));

      function onEpochBegin(_x62) {
        return _onEpochBegin3.apply(this, arguments);
      }

      return onEpochBegin;
    }()
  }, {
    key: "onBatchEnd",
    value: function () {
      var _onBatchEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee58(e, t) {
        var _this63 = this;

        var n, _loop12, _e113;

        return _regeneratorRuntime.wrap(function _callee58$(_context58) {
          while (1) {
            switch (_context58.prev = _context58.next) {
              case 0:
                null == t && (t = {});
                n = null == t.size ? 0 : t.size;
                this.seen += n;

                _loop12 = function _loop12(_e113) {
                  var s = t[_e113];
                  if ("number" == typeof s) _this63.totals.hasOwnProperty(_e113) || (_this63.totals[_e113] = 0), _this63.totals[_e113] = _this63.totals[_e113] + s * n;else {
                    var _t177;

                    _e113 in _this63.totals ? _t177 = _this63.totals[_e113] : _this63.totals[_e113] = 0;

                    var _r46 = Yn(function () {
                      return es(_this63.totals[_e113], ss(s, n));
                    });

                    _this63.totals[_e113] = _r46, null != _t177 && _t177.dispose();
                  }
                };

                for (_e113 in t) {
                  _loop12(_e113);
                }

              case 5:
              case "end":
                return _context58.stop();
            }
          }
        }, _callee58, this);
      }));

      function onBatchEnd(_x63, _x64) {
        return _onBatchEnd3.apply(this, arguments);
      }

      return onBatchEnd;
    }()
  }, {
    key: "onEpochEnd",
    value: function () {
      var _onEpochEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee59(e, t) {
        var _this64 = this;

        var _iterator30, _step30, _loop13;

        return _regeneratorRuntime.wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                if (null != t) {
                  _iterator30 = _createForOfIteratorHelper(this.params.metrics);

                  try {
                    _loop13 = function _loop13() {
                      var e = _step30.value;
                      null != _this64.totals[e] && ("number" == typeof _this64.totals[e] ? t[e] = _this64.totals[e] / _this64.seen : Yn(function () {
                        var n = ss(ns(1, _this64.seen), _this64.totals[e]);
                        t[e] = n, _this64.totals[e].dispose(), Zn(t[e]);
                      }));
                    };

                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                      _loop13();
                    }
                  } catch (err) {
                    _iterator30.e(err);
                  } finally {
                    _iterator30.f();
                  }
                }

              case 1:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59, this);
      }));

      function onEpochEnd(_x65, _x66) {
        return _onEpochEnd3.apply(this, arguments);
      }

      return onEpochEnd;
    }()
  }]);

  return Ih;
}(wh);

var $h = /*#__PURE__*/function (_wh2) {
  "use strict";

  _inherits($h, _wh2);

  var _super39 = _createSuper($h);

  function $h() {
    _classCallCheck(this, $h);

    return _super39.apply(this, arguments);
  }

  _createClass($h, [{
    key: "onTrainBegin",
    value: function () {
      var _onTrainBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee60(e) {
        return _regeneratorRuntime.wrap(function _callee60$(_context60) {
          while (1) {
            switch (_context60.prev = _context60.next) {
              case 0:
                this.epoch = [], this.history = {};

              case 1:
              case "end":
                return _context60.stop();
            }
          }
        }, _callee60, this);
      }));

      function onTrainBegin(_x67) {
        return _onTrainBegin3.apply(this, arguments);
      }

      return onTrainBegin;
    }()
  }, {
    key: "onEpochEnd",
    value: function () {
      var _onEpochEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee61(e, t) {
        var _e114;

        return _regeneratorRuntime.wrap(function _callee61$(_context61) {
          while (1) {
            switch (_context61.prev = _context61.next) {
              case 0:
                null == t && (t = {}), this.epoch.push(e);

                for (_e114 in t) {
                  null == this.history[_e114] && (this.history[_e114] = []), this.history[_e114].push(t[_e114]);
                }

              case 2:
              case "end":
                return _context61.stop();
            }
          }
        }, _callee61, this);
      }));

      function onEpochEnd(_x68, _x69) {
        return _onEpochEnd4.apply(this, arguments);
      }

      return onEpochEnd;
    }()
  }, {
    key: "syncData",
    value: function () {
      var _syncData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee62() {
        var e, t, n, _s63, _r47, _a38, s, _e115;

        return _regeneratorRuntime.wrap(function _callee62$(_context62) {
          while (1) {
            switch (_context62.prev = _context62.next) {
              case 0:
                e = [], t = [], n = [];

                for (_s63 in this.history) {
                  _r47 = this.history[_s63];

                  for (_a38 = 0; _a38 < _r47.length; ++_a38) {
                    "number" != typeof _r47[_a38] && (e.push(_r47[_a38].data()), t.push(_s63), n.push(_a38));
                  }
                }

                _context62.next = 4;
                return Promise.all(e);

              case 4:
                s = _context62.sent;

                for (_e115 = 0; _e115 < s.length; ++_e115) {
                  this.history[t[_e115]][n[_e115]].dispose(), this.history[t[_e115]][n[_e115]] = s[_e115][0];
                }

              case 6:
              case "end":
                return _context62.stop();
            }
          }
        }, _callee62, this);
      }));

      function syncData() {
        return _syncData.apply(this, arguments);
      }

      return syncData;
    }()
  }]);

  return $h;
}(wh);

var Nh = /*#__PURE__*/function (_wh3) {
  "use strict";

  _inherits(Nh, _wh3);

  var _super40 = _createSuper(Nh);

  function Nh(e, t) {
    var _this65;

    _classCallCheck(this, Nh);

    if (_this65 = _super40.call(this), _this65.currentEpoch = 0, _this65.yieldEvery = t || "auto", "auto" === _this65.yieldEvery && (_this65.yieldEvery = 125), "never" === _this65.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
    S(_this65.yieldEvery) && (_this65.maybeWait = function (e, t) {
      var n,
          s = Ve();
      return function () {
        var a = Ve();
        return a - s < t || (s = a, n = e.apply(void 0, arguments)), n;
      };
    }(_this65.maybeWait.bind(_assertThisInitialized(_this65)), _this65.yieldEvery)), _this65.trainBegin = e.onTrainBegin, _this65.trainEnd = e.onTrainEnd, _this65.epochBegin = e.onEpochBegin, _this65.epochEnd = e.onEpochEnd, _this65.batchBegin = e.onBatchBegin, _this65.batchEnd = e.onBatchEnd, _this65.yield = e.onYield;
    return _possibleConstructorReturn(_this65);
  }

  _createClass(Nh, [{
    key: "maybeWait",
    value: function () {
      var _maybeWait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee63(e, t, n) {
        var s;
        return _regeneratorRuntime.wrap(function _callee63$(_context63) {
          while (1) {
            switch (_context63.prev = _context63.next) {
              case 0:
                s = [];
                _context63.t0 = null != this.yield;

                if (!_context63.t0) {
                  _context63.next = 6;
                  break;
                }

                _context63.next = 5;
                return xh(n);

              case 5:
                s.push(this.yield(e, t, n));

              case 6:
                s.push(No());
                _context63.next = 9;
                return Promise.all(s);

              case 9:
              case "end":
                return _context63.stop();
            }
          }
        }, _callee63, this);
      }));

      function maybeWait(_x70, _x71, _x72) {
        return _maybeWait.apply(this, arguments);
      }

      return maybeWait;
    }()
  }, {
    key: "onEpochBegin",
    value: function () {
      var _onEpochBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee64(e, t) {
        return _regeneratorRuntime.wrap(function _callee64$(_context64) {
          while (1) {
            switch (_context64.prev = _context64.next) {
              case 0:
                this.currentEpoch = e;
                _context64.t0 = null != this.epochBegin;

                if (!_context64.t0) {
                  _context64.next = 7;
                  break;
                }

                _context64.next = 5;
                return xh(t);

              case 5:
                _context64.next = 7;
                return this.epochBegin(e, t);

              case 7:
              case "end":
                return _context64.stop();
            }
          }
        }, _callee64, this);
      }));

      function onEpochBegin(_x73, _x74) {
        return _onEpochBegin4.apply(this, arguments);
      }

      return onEpochBegin;
    }()
  }, {
    key: "onEpochEnd",
    value: function () {
      var _onEpochEnd5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee65(e, t) {
        var n;
        return _regeneratorRuntime.wrap(function _callee65$(_context65) {
          while (1) {
            switch (_context65.prev = _context65.next) {
              case 0:
                n = [];
                _context65.t0 = null != this.epochEnd;

                if (!_context65.t0) {
                  _context65.next = 6;
                  break;
                }

                _context65.next = 5;
                return xh(t);

              case 5:
                n.push(this.epochEnd(e, t));

              case 6:
                "epoch" === this.yieldEvery && n.push(No());
                _context65.next = 9;
                return Promise.all(n);

              case 9:
              case "end":
                return _context65.stop();
            }
          }
        }, _callee65, this);
      }));

      function onEpochEnd(_x75, _x76) {
        return _onEpochEnd5.apply(this, arguments);
      }

      return onEpochEnd;
    }()
  }, {
    key: "onBatchBegin",
    value: function () {
      var _onBatchBegin3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee66(e, t) {
        return _regeneratorRuntime.wrap(function _callee66$(_context66) {
          while (1) {
            switch (_context66.prev = _context66.next) {
              case 0:
                _context66.t0 = null != this.batchBegin;

                if (!_context66.t0) {
                  _context66.next = 6;
                  break;
                }

                _context66.next = 4;
                return xh(t);

              case 4:
                _context66.next = 6;
                return this.batchBegin(e, t);

              case 6:
              case "end":
                return _context66.stop();
            }
          }
        }, _callee66, this);
      }));

      function onBatchBegin(_x77, _x78) {
        return _onBatchBegin3.apply(this, arguments);
      }

      return onBatchBegin;
    }()
  }, {
    key: "onBatchEnd",
    value: function () {
      var _onBatchEnd4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee67(e, t) {
        var n;
        return _regeneratorRuntime.wrap(function _callee67$(_context67) {
          while (1) {
            switch (_context67.prev = _context67.next) {
              case 0:
                n = [];
                _context67.t0 = null != this.batchEnd;

                if (!_context67.t0) {
                  _context67.next = 6;
                  break;
                }

                _context67.next = 5;
                return xh(t);

              case 5:
                n.push(this.batchEnd(e, t));

              case 6:
                "batch" === this.yieldEvery ? n.push(No()) : S(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, e, t));
                _context67.next = 9;
                return Promise.all(n);

              case 9:
              case "end":
                return _context67.stop();
            }
          }
        }, _callee67, this);
      }));

      function onBatchEnd(_x79, _x80) {
        return _onBatchEnd4.apply(this, arguments);
      }

      return onBatchEnd;
    }()
  }, {
    key: "onTrainBegin",
    value: function () {
      var _onTrainBegin4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee68(e) {
        return _regeneratorRuntime.wrap(function _callee68$(_context68) {
          while (1) {
            switch (_context68.prev = _context68.next) {
              case 0:
                _context68.t0 = null != this.trainBegin;

                if (!_context68.t0) {
                  _context68.next = 6;
                  break;
                }

                _context68.next = 4;
                return xh(e);

              case 4:
                _context68.next = 6;
                return this.trainBegin(e);

              case 6:
              case "end":
                return _context68.stop();
            }
          }
        }, _callee68, this);
      }));

      function onTrainBegin(_x81) {
        return _onTrainBegin4.apply(this, arguments);
      }

      return onTrainBegin;
    }()
  }, {
    key: "onTrainEnd",
    value: function () {
      var _onTrainEnd3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee69(e) {
        return _regeneratorRuntime.wrap(function _callee69$(_context69) {
          while (1) {
            switch (_context69.prev = _context69.next) {
              case 0:
                _context69.t0 = null != this.trainEnd;

                if (!_context69.t0) {
                  _context69.next = 6;
                  break;
                }

                _context69.next = 4;
                return xh(e);

              case 4:
                _context69.next = 6;
                return this.trainEnd(e);

              case 6:
              case "end":
                return _context69.stop();
            }
          }
        }, _callee69, this);
      }));

      function onTrainEnd(_x82) {
        return _onTrainEnd3.apply(this, arguments);
      }

      return onTrainEnd;
    }()
  }]);

  return Nh;
}(wh);

function Ch(e, t) {
  return null == e && (e = {}), e instanceof wh ? [e] : Array.isArray(e) && e[0] instanceof wh ? e : $u(e).map(function (e) {
    return new Nh(e, t);
  });
}

var Sh = /*#__PURE__*/function () {
  "use strict";

  function Sh() {
    _classCallCheck(this, Sh);
  }

  _createClass(Sh, null, [{
    key: "registerCallbackConstructor",
    value: function registerCallbackConstructor(e, t) {
      l(e >= 0 && Number.isInteger(e), function () {
        return "Verbosity level is expected to be an integer >= 0, but got ".concat(e);
      }), Sh.checkForDuplicate(t), null == Sh.constructors[e] && (Sh.constructors[e] = []), Sh.constructors[e].push(t);
    }
  }, {
    key: "checkForDuplicate",
    value: function checkForDuplicate(e) {
      for (var t in Sh.constructors) {
        Sh.constructors[+t].forEach(function (t) {
          if (t === e) throw new bu("Duplicate callback constructor.");
        });
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      Sh.constructors = {};
    }
  }, {
    key: "createCallbacks",
    value: function createCallbacks(e) {
      var t = [];

      for (var _n77 in Sh.constructors) {
        var _s64 = +_n77;

        e >= _s64 && t.push.apply(t, _toConsumableArray(Sh.constructors[_s64]));
      }

      return t.map(function (e) {
        return new e();
      });
    }
  }]);

  return Sh;
}();

function Th(e, t, n, s, r, a, i, o, l) {
  var u = new $h(),
      c = [new Ih()].concat(_toConsumableArray(Sh.createCallbacks(t)));
  null != e && c.push.apply(c, _toConsumableArray(e)), c.push(u);
  var h = new vh(c);
  return h.setParams({
    epochs: n,
    initialEpoch: s,
    samples: r,
    steps: a,
    batchSize: i,
    verbose: t,
    doValidation: o,
    metrics: l
  }), {
    callbackList: h,
    history: u
  };
}

function Eh(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Ru(e, jn.getMap().classNameMap, t, "layer", n);
}

function Rh(e, t) {
  return Yn(function () {
    "float32" !== e.dtype && (e = pn(e, "float32"));
    var n = Gr(Nc(e), t, !0),
        s = Ir(n.shape, fu()),
        r = ui(oa(n, s));
    return ns(e, r);
  });
}

function Ah(e, t) {
  return Yn(function () {
    return la(Nc(Vr(t, e)), -1);
  });
}

function Fh(e, t) {
  return Yn(function () {
    return la(rs(Vr(t, e)), -1);
  });
}

function Dh(e, t) {
  return Yn(function () {
    var n = Vr(e, t),
        s = Gs(rs(e), fu(), Number.MAX_VALUE),
        r = rs(ns(n, s));
    return ss(100, la(r, -1));
  });
}

function _h(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Yn(function () {
    if (n) t = si(t);else {
      var _e116 = Gr(t, t.shape.length - 1, !0);

      t = ns(t, _e116);
    }
    return t = Gs(t, fu(), 1 - fu()), Br(Gr(ss(pn(e, "float32"), Mr(t)), t.shape.length - 1));
  });
}

function Oh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  return Yn(function () {
    var s = pn($r(function (e) {
      var t = [cc(e.shape)];
      return Es(e, t);
    }(e)), "int32"),
        r = (t = Gs(t, fu(), 1 - fu())).shape;
    return _h(Es(In(s, r[r.length - 1]), r), t, n);
  });
}

function Mh(e, t) {
  return Yn(function () {
    var n;
    return n = Gs(t, fu(), 1 - fu()), n = Mr(ns(n, Vr(1, n))), la(function (e, t) {
      if (!p(e.shape, t.shape)) throw new bu("logits and labels must have the same shape, but got shapes ".concat(JSON.stringify(e.shape), " and ").concat(JSON.stringify(t.shape)));
      return Yn(function () {
        var n = Ua(t),
            s = Br(rs(t));
        return es(Vr(n, ss(t, e)), Lr(xr(s)));
      });
    }(e, n), -1);
  });
}

function Lh(e, t) {
  return Yn(function () {
    var n = Rh(e, -1),
        s = Rh(t, -1),
        r = ss(n, s);
    return Br(Gr(r, -1));
  });
}

Sh.constructors = {};
var zh = {
  meanSquaredError: Ah,
  meanAbsoluteError: Fh,
  meanAbsolutePercentageError: Dh,
  meanSquaredLogarithmicError: function meanSquaredLogarithmicError(e, t) {
    return Yn(function () {
      var n = Gs(t, fu(), Number.MAX_VALUE),
          s = Mr(es(1, n)),
          r = Gs(e, fu(), Number.MAX_VALUE),
          a = Mr(es(1, r));
      return la(Nc(Vr(s, a)), -1);
    });
  },
  squaredHinge: function squaredHinge(e, t) {
    return Yn(function () {
      var n = oa(0, Vr(1, ss(e, t)));
      return la(Nc(n), -1);
    });
  },
  hinge: function hinge(e, t) {
    return Yn(function () {
      var n = oa(0, Vr(1, ss(e, t)));
      return la(n, -1);
    });
  },
  categoricalHinge: function categoricalHinge(e, t) {
    return Yn(function () {
      var n = Gr(ss(e, t), -1),
          s = Ur(ss(Vr(1, e), t), -1);
      return oa(0, es(1, Vr(s, n)));
    });
  },
  logcosh: function logcosh(e, t) {
    return Yn(function () {
      var n = Math.log(2),
          s = Vr(t, e),
          r = Vr(es(s, Pr(ss(-2, s))), n);
      return la(r, -1);
    });
  },
  categoricalCrossentropy: _h,
  sparseCategoricalCrossentropy: Oh,
  binaryCrossentropy: Mh,
  kullbackLeiblerDivergence: function kullbackLeiblerDivergence(e, t) {
    return Yn(function () {
      var n = Gs(e, fu(), 1),
          s = Gs(t, fu(), 1);
      return Gr(ss(e, Mr(ns(n, s))), -1);
    });
  },
  poisson: function poisson(e, t) {
    return Yn(function () {
      var n = Mr(es(fu(), t));
      return la(Vr(t, ss(e, n)), -1);
    });
  },
  cosineProximity: Lh
};

function Bh(e) {
  if ("string" == typeof e) {
    if (e in zh) return zh[e];
    var t = "Unknown loss ".concat(e);
    throw e.toLowerCase().includes("softmaxcrossentropy") && (t = "Unknown loss ".concat(e, ". Use \"categoricalCrossentropy\" as the string name for tf.losses.softmaxCrossEntropy")), new bu(t);
  }

  return e;
}

function Ph(e, t) {
  return Yn(function () {
    var n = ss(.5, xa(t)),
        s = fc(Cr(t, n), e.dtype);
    return la(hr(e, s), -1);
  });
}

function Wh(e, t) {
  return Yn(function () {
    return fc(hr(us(e, -1), us(t, -1)), "float32");
  });
}

function Uh(e, t) {
  return Mh(e, t);
}

function Vh(e, t) {
  return e.rank === t.rank && (e = hi(e, [e.rank - 1])), (t = us(t, -1)).dtype !== e.dtype && (t = pn(t, e.dtype)), pn(hr(e, t), "float32");
}

var Gh = _h,
    Hh = Oh,
    jh = {
  binaryAccuracy: Ph,
  categoricalAccuracy: Wh,
  precision: function precision(e, t) {
    return Yn(function () {
      var n = function (e, t) {
        return Yn(function () {
          return pn(Gr(ta(hr(e, 1), hr(t, 1))), "float32");
        });
      }(e, t),
          s = function (e, t) {
        return Yn(function () {
          return pn(Gr(ta(hr(e, 0), hr(t, 1))), "float32");
        });
      }(e, t),
          r = es(n, s);

      return pn(dr(Cr(r, 0), ns(n, r), 0), "float32");
    });
  },
  categoricalCrossentropy: Gh,
  sparseCategoricalCrossentropy: Hh,
  mse: Ah,
  MSE: Ah,
  mae: Fh,
  MAE: Fh,
  mape: Dh,
  MAPE: Dh,
  cosine: Lh
};

function qh(e) {
  if ("string" == typeof e && e in jh) return jh[e];
  if ("string" != typeof e && null != e) return e;
  throw new bu("Unknown metric ".concat(e));
}

function Kh(e) {
  if (wu(null !== e, "Unknown LossOrMetricFn ".concat(e)), "string" == typeof e) return e;
  {
    var t;

    for (var _i30 = 0, _Object$keys5 = Object.keys(zh); _i30 < _Object$keys5.length; _i30++) {
      var _n78 = _Object$keys5[_i30];

      if (zh[_n78] === e) {
        t = _n78;
        break;
      }
    }

    if (void 0 !== t) return t;

    for (var _i31 = 0, _Object$keys6 = Object.keys(jh); _i31 < _Object$keys6.length; _i31++) {
      var _n79 = _Object$keys6[_i31];

      if (jh[_n79] === e) {
        t = _n79;
        break;
      }
    }

    return void 0 !== t ? t : e.name;
  }
}

function Xh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  if (null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !Yh(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");

  if (n) {
    var _n80 = JSON.stringify(e);

    _n80.length > 1048576 && console.warn("User-defined metadata of model \"".concat(t, "\" is too large in size (length=").concat(_n80.length, " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576."));
  }
}

function Yh(e) {
  if (null === e) return !0;

  if ("object" == typeof e) {
    if (Object.getPrototypeOf(e) === Object.prototype) {
      var t = Object.keys(e);

      for (var _i32 = 0, _t178 = t; _i32 < _t178.length; _i32++) {
        var _n81 = _t178[_i32];
        if ("string" != typeof _n81) return !1;
        if (!Yh(e[_n81])) return !1;
      }

      return !0;
    }

    if (Array.isArray(e)) {
      var _iterator31 = _createForOfIteratorHelper(e),
          _step31;

      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var _t179 = _step31.value;
          if (!Yh(_t179)) return !1;
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }

      return !0;
    }

    return !1;
  }

  {
    var _t180 = typeof e;

    return "string" === _t180 || "number" === _t180 || "boolean" === _t180;
  }
}

function Jh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
  var s = "";

  for (var _n82 = 0; _n82 < e.length; ++_n82) {
    _n82 > 0 && (s = s.slice(0, s.length - 1) + " "), s += e[_n82], s = s.slice(0, t[_n82]), s += " ".repeat(t[_n82] - s.length);
  }

  n(s);
}

function Zh(e, t, n) {
  var s;

  try {
    s = JSON.stringify(e.outputShape);
  } catch (e) {
    s = "multiple";
  }

  Jh(["".concat(e.name, " (").concat(e.getClassName(), ")"), s, e.countParams().toString()], t, n);
}

function Qh(e, t, n, s) {
  var r;

  try {
    r = JSON.stringify(e.outputShape);
  } catch (e) {
    r = "multiple";
  }

  var a = [];

  var _iterator32 = _createForOfIteratorHelper(e.inboundNodes),
      _step32;

  try {
    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
      var _t181 = _step32.value;
      if (!(null != n && n.length > 0 && -1 === n.indexOf(_t181))) for (var _e118 = 0; _e118 < _t181.inboundLayers.length; ++_e118) {
        a.push("".concat(_t181.inboundLayers[_e118].name, "[").concat(_t181.nodeIndices[_e118], "][").concat(_t181.tensorIndices[_e118], "]"));
      }
    }
  } catch (err) {
    _iterator32.e(err);
  } finally {
    _iterator32.f();
  }

  var i = e.name,
      o = e.getClassName(),
      l = 0 === a.length ? "" : a[0];
  Jh(["".concat(i, " (").concat(o, ")"), r, e.countParams().toString(), l], t, s);

  for (var _e117 = 1; _e117 < a.length; ++_e117) {
    Jh(["", "", "", a[_e117]], t, s);
  }
}

function ed(e, t, n) {
  return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
}

function td(e, t) {
  if (null === e) return null;
  if ("string" == typeof e) return Cu(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    var _n83 = [],
        _s65 = e.length;

    for (var _r48 = 0; _r48 < _s65; ++_r48) {
      var _s66 = e[_r48];
      ed(t, _r48, _s66) ? _n83.push(_s66) : _n83.push(td(_s66, t));
    }

    return _n83;
  }

  {
    var _t182 = {};

    for (var _i33 = 0, _Object$keys7 = Object.keys(e); _i33 < _Object$keys7.length; _i33++) {
      var _n84 = _Object$keys7[_i33];
      var _s67 = e[_n84];
      if ("name" === _n84 && "string" == typeof _s67) _t182[_n84] = _s67;else {
        var _e119 = Cu(_n84);

        _t182[_e119] = td(_s67, _e119);
      }
    }

    return _t182;
  }
}

function nd(e, t) {
  if (null == e) return null;
  if ("string" == typeof e) return Nu(e);
  if ("number" == typeof e || "boolean" == typeof e) return e;

  if (e instanceof Array) {
    var _n85 = [],
        _s68 = e.length;

    for (var _r49 = 0; _r49 < _s68; ++_r49) {
      var _s69 = e[_r49];
      ed(t, _r49, _s69) ? _n85.push(_s69) : _n85.push(nd(_s69, t));
    }

    return _n85;
  }

  {
    var _t183 = {};

    for (var _i34 = 0, _Object$keys8 = Object.keys(e); _i34 < _Object$keys8.length; _i34++) {
      var _n86 = _Object$keys8[_i34];
      var _s70 = e[_n86];
      _t183[Nu(_n86)] = "name" !== _n86 && "className" !== _n86 || "string" != typeof _s70 ? nd(_s70, _n86) : _s70;
    }

    return _t183;
  }
}

var sd = /*#__PURE__*/function () {
  "use strict";

  function sd(e) {
    _classCallCheck(this, sd);

    if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof sd) for (var t in e.id2Value) {
      this.id2Value[t] = e.id2Value[t], t in e.id2Mask && (this.id2Mask[t] = e.id2Mask[t]);
    } else {
      if (null == e) return;

      var _iterator33 = _createForOfIteratorHelper(e),
          _step33;

      try {
        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
          var _t184 = _step33.value;
          this.add(_t184.key, _t184.value);
        }
      } catch (err) {
        _iterator33.e(err);
      } finally {
        _iterator33.f();
      }
    }
  }

  _createClass(sd, [{
    key: "add",
    value: function add(e, t, n) {
      if (null != this.id2Value[e.id]) throw new bu("Duplicate key: name=".concat(e.name, ", id=").concat(e.id));
      return this.id2Value[e.id] = function (e, t) {
        if (null == e.dtype || e.dtype === t.dtype) return t;

        try {
          return pn(t, e.dtype);
        } catch (n) {
          throw new bu("The dtype of the feed (".concat(t.dtype, ") can not be cast to the dtype of the key '").concat(e.name, "' (").concat(e.dtype, ")."));
        }
      }(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this;
    }
  }, {
    key: "addFeed",
    value: function addFeed(e) {
      this.add(e.key, e.value);
    }
  }, {
    key: "hasKey",
    value: function hasKey(e) {
      return null != this.id2Value[e.id];
    }
  }, {
    key: "names",
    value: function names() {
      return Object.keys(this.name2Id);
    }
  }, {
    key: "getValue",
    value: function getValue(e) {
      if (e instanceof hh) {
        if (null == this.id2Value[e.id]) throw new bu("Nonexistent key: ".concat(e.name));
        return this.id2Value[e.id];
      }

      {
        var t = this.name2Id[e];
        if (null == t) throw new bu("Feed dict has no SymbolicTensor name: ".concat(e));
        return this.id2Value[t];
      }
    }
  }, {
    key: "getMask",
    value: function getMask(e) {
      if (e instanceof hh) {
        if (null == this.id2Value[e.id]) throw new bu("Nonexistent key: ".concat(e.name));
        return this.id2Mask[e.id];
      }

      {
        var t = this.name2Id[e];
        if (null == t) throw new bu("Feed dict has no SymbolicTensor name: ".concat(e));
        return this.id2Mask[t];
      }
    }
  }, {
    key: "disposeMasks",
    value: function disposeMasks() {
      null != this.id2Mask && Jn(this.id2Mask);
    }
  }]);

  return sd;
}();

var rd = {},
    ad = {};

function id(e, t, n, s) {
  var r = null != n && n.training,
      a = Array.isArray(e),
      i = a ? e : [e],
      o = i.map(function (e) {
    return e.name;
  }),
      u = [],
      c = t.names();

  var _iterator34 = _createForOfIteratorHelper(o),
      _step34;

  try {
    for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
      var _e127 = _step34.value;
      -1 !== c.indexOf(_e127) ? u.push(t.getValue(_e127)) : u.push(null);
    }
  } catch (err) {
    _iterator34.e(err);
  } finally {
    _iterator34.f();
  }

  null != s && (s.maxNumTensors = -Infinity, s.minNumTensors = Infinity);
  var h = o.join(",") + "|" + t.names().join(",");
  var d, p;

  if (null == rd[h]) {
    var _e120 = function (e, t) {
      l(null != e && e.length > 0, function () {
        return "Expected at least one fetch, got none";
      });
      var n = [],
          s = {};

      if (1 === e.length) {
        var _r50 = ld(e[0], t);

        n = _r50.sorted, s = _r50.recipientMap;
      } else {
        var _r51 = new Set();

        var _iterator35 = _createForOfIteratorHelper(e),
            _step35;

        try {
          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
            var _a39 = _step35.value;

            var _ld = ld(_a39, t),
                _e121 = _ld.sorted,
                _i35 = _ld.recipientMap;

            var _iterator36 = _createForOfIteratorHelper(_e121),
                _step36;

            try {
              for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                var _t185 = _step36.value;
                _r51.has(_t185.name) || (n.push(_t185), _r51.add(_t185.name));
              }
            } catch (err) {
              _iterator36.e(err);
            } finally {
              _iterator36.f();
            }

            var _loop14 = function _loop14(_e122) {
              null == s[_e122] && (s[_e122] = new Set()), _i35[_e122].forEach(function (t) {
                return s[_e122].add(t);
              });
            };

            for (var _e122 in _i35) {
              _loop14(_e122);
            }
          }
        } catch (err) {
          _iterator35.e(err);
        } finally {
          _iterator35.f();
        }
      }

      return {
        sorted: n,
        recipientCounts: od(s)
      };
    }(i, t);

    d = _e120.sorted, p = _e120.recipientCounts, rd[h] = d, ad[h] = p;
  }

  d = rd[h], p = {}, r || Object.assign(p, ad[h]);
  var f = new sd(t);

  for (var _e123 = 0; _e123 < d.length; ++_e123) {
    if (null != s) {
      var _e124 = Xn().numTensors;
      _e124 > s.maxNumTensors && (s.maxNumTensors = _e124), _e124 < s.minNumTensors && (s.minNumTensors = _e124);
    }

    var _a40 = d[_e123],
        _i36 = _a40.sourceLayer;
    if (_i36 instanceof bh) continue;
    var _l11 = [],
        _c6 = [],
        _h5 = [];

    var _g5 = !1;

    var _iterator37 = _createForOfIteratorHelper(_a40.inputs),
        _step37;

    try {
      for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
        var _e126 = _step37.value;

        var _n87 = f.getValue(_e126),
            _s71 = f.getMask(_e126);

        _l11.push(_n87), _c6.push(_s71), null != _s71 && (_g5 = !0), r || (p[_e126.name]--, 0 !== p[_e126.name] || t.hasKey(_e126) || -1 !== o.indexOf(_e126.name) || _n87.isDisposed || !0 === _e126.sourceLayer.stateful || _h5.push(_n87));
      }
    } catch (err) {
      _iterator37.e(err);
    } finally {
      _iterator37.f();
    }

    _g5 && ((n = n || {}).mask = _c6[0]);

    var _m4 = $u(_i36.apply(_l11, n));

    var _b4 = null;
    _i36.supportsMasking && (_b4 = _i36.computeMask(_l11, _c6));

    var _x83 = ud(_a40),
        _y4 = Array.isArray(_x83) ? _x83 : [_x83];

    for (var _e125 = 0; _e125 < _y4.length; ++_e125) {
      f.hasKey(_y4[_e125]) || f.add(_y4[_e125], _m4[_e125], Array.isArray(_b4) ? _b4[0] : _b4);

      var _t186 = o.indexOf(_y4[_e125].name);

      -1 !== _t186 && (u[_t186] = _m4[_e125]);
    }

    r || Jn(_h5);
  }

  return f.disposeMasks(), a ? u : u[0];
}

function od(e) {
  var t = {};

  for (var _n88 in e) {
    t[_n88] = e[_n88].size;
  }

  return t;
}

function ld(e, t) {
  var n = new Set(),
      s = [],
      r = {};

  var _iterator38 = _createForOfIteratorHelper(t.names()),
      _step38;

  try {
    for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
      var _e129 = _step38.value;
      n.add(_e129);
    }
  } catch (err) {
    _iterator38.e(err);
  } finally {
    _iterator38.f();
  }

  var a = [],
      i = [];

  for (a.push(e); a.length > 0;) {
    var _e128 = a[a.length - 1];

    if (n.has(_e128.name)) {
      a.pop();
      continue;
    }

    var _t187 = i[i.length - 1] === a.length - 1;

    if (0 === _e128.inputs.length || _t187) a.pop(), s.push(_e128), n.add(_e128.name), _t187 && i.pop();else {
      i.push(a.length - 1);

      var _iterator39 = _createForOfIteratorHelper(_e128.inputs),
          _step39;

      try {
        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
          var _t188 = _step39.value;
          null == r[_t188.name] && (r[_t188.name] = new Set()), r[_t188.name].add(_e128.name), n.has(_t188.name) || a.push(_t188);
        }
      } catch (err) {
        _iterator39.e(err);
      } finally {
        _iterator39.f();
      }
    }
  }

  return {
    sorted: s,
    recipientMap: r
  };
}

function ud(e) {
  var t;
  if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;else {
    var _n89 = null;

    for (var _t189 = 0; _t189 < e.sourceLayer.inboundNodes.length; ++_t189) {
      var _iterator40 = _createForOfIteratorHelper(e.sourceLayer.inboundNodes[_t189].outputTensors),
          _step40;

      try {
        for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
          var _s72 = _step40.value;

          if (_s72.id === e.id) {
            _n89 = _t189;
            break;
          }
        }
      } catch (err) {
        _iterator40.e(err);
      } finally {
        _iterator40.f();
      }
    }

    t = e.sourceLayer.getOutputAt(_n89);
  }
  return t;
}

var cd = /*#__PURE__*/function (_gh2) {
  "use strict";

  _inherits(cd, _gh2);

  var _super41 = _createSuper(cd);

  function cd(e) {
    var _this66;

    _classCallCheck(this, cd);

    if (_this66 = _super41.call(this, {}), _this66.containerNodes = new Set(), _this66.name = e.name, null == _this66.name) {
      var _e130 = _this66.getClassName().toLowerCase();

      _this66.name = th(_e130);
    }

    if (_this66.supportsMasking = !1, _this66.trainable_ = !0, _this66.inputs = Array.isArray(e.inputs) ? e.inputs.slice() : [e.inputs], _this66.outputs = Array.isArray(e.outputs) ? e.outputs.slice() : [e.outputs], Fu(_this66.inputs).length !== _this66.inputs.length) throw new bu("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ".concat(_this66.inputs.map(function (e) {
      return e.name;
    })));
    Fu(_this66.outputs).length !== _this66.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ".concat(_this66.outputs.map(function (e) {
      return e.name;
    }))), _this66.inputLayers = [], _this66.inputLayersNodeIndices = [], _this66.inputLayersTensorIndices = [], _this66.outputLayers = [], _this66.outputLayersNodeIndices = [], _this66.outputLayersTensorIndices = [], _this66.layers = [], _this66.internalContainerRefs = [];

    var _iterator41 = _createForOfIteratorHelper(_this66.outputs),
        _step41;

    try {
      for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
        var _e134 = _step41.value;
        var _t192 = _e134.nodeIndex,
            _n91 = _e134.tensorIndex;
        _this66.outputLayers.push(_e134.sourceLayer), _this66.outputLayersNodeIndices.push(_t192), _this66.outputLayersTensorIndices.push(_n91);
      }
    } catch (err) {
      _iterator41.e(err);
    } finally {
      _iterator41.f();
    }

    var _iterator42 = _createForOfIteratorHelper(_this66.inputs),
        _step42;

    try {
      for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
        var _e135 = _step42.value;
        var _t193 = _e135.sourceLayer,
            _n92 = _e135.nodeIndex,
            _s74 = _e135.tensorIndex;
        wu(0 === _n92, "input layer has >1 nodes"), wu(0 === _s74, "input layer has >1 tensors"), _this66.inputLayers.push(_t193), _this66.inputLayersNodeIndices.push(_n92), _this66.inputLayersTensorIndices.push(_s74);
      }
    } catch (err) {
      _iterator42.e(err);
    } finally {
      _iterator42.f();
    }

    _this66.inputNames = [], _this66.outputNames = [], _this66.feedInputShapes = [], _this66.feedInputNames = [], _this66.feedOutputNames = [];

    for (var _t190 = 0; _t190 < _this66.inputLayers.length; _t190++) {
      var _n90 = _this66.inputLayers[_t190];
      if (!(_n90 instanceof bh)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: ".concat(e.inputs, ". Input ").concat(_t190, " (0-based) originates from layer type ").concat(_n90.getClassName(), "."));
      _this66.inputNames.push(_n90.name), _this66.feedInputShapes.push(_n90.batchInputShape), _this66.feedInputNames.push(_n90.name);
    }

    var _iterator43 = _createForOfIteratorHelper(_this66.outputLayers),
        _step43;

    try {
      for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
        var _e136 = _step43.value;

        _this66.outputNames.push(_e136.name);
      }
    } catch (err) {
      _iterator43.e(err);
    } finally {
      _iterator43.f();
    }

    _this66.internalInputShapes = _this66.inputs.map(function (e) {
      return e.shape;
    }), _this66.internalOutputShapes = _this66.outputs.map(function (e) {
      return e.shape;
    });

    var t = {},
        n = {},
        s = {},
        r = {},
        a = {},
        i = [],
        o = function o(e, t, n, s, r, l) {
      null != s && null != r && null != l || (s = e.sourceLayer, r = e.nodeIndex, l = e.tensorIndex);
      var u = s.inboundNodes[r];
      if (-1 !== n.indexOf(u)) throw new mu("The tensor ".concat(e.name, " at layer \"").concat(s.name, "\" is part of a cycle."));
      if (-1 !== t.indexOf(u)) return;
      _this66.containerNodes.add(cd.nodeKey(s, r)), s.id in a || (a[s.id] = Object.keys(a).length), -1 === n.indexOf(u) && n.push(u);
      var c = u.inboundLayers.length;

      for (var _e131 = 0; _e131 < c; _e131++) {
        o(u.inputTensors[_e131], t, n, u.inboundLayers[_e131], u.nodeIndices[_e131], u.tensorIndices[_e131]);
      }

      for (t.push(u); n.indexOf(u) >= 0;) {
        n.splice(n.indexOf(u), 1);
      }

      i.push(u);
    },
        l = [],
        u = [];

    var _iterator44 = _createForOfIteratorHelper(_this66.outputs),
        _step44;

    try {
      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
        var _e137 = _step44.value;
        o(_e137, l, u);
      }
    } catch (err) {
      _iterator44.e(err);
    } finally {
      _iterator44.f();
    }

    var c = i.slice().reverse();

    var _iterator45 = _createForOfIteratorHelper(c),
        _step45;

    try {
      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
        var _e138 = _step45.value;
        n[_e138.id] = _e138, _e138.id in t || (t[_e138.id] = 0);
        var _a41 = t[_e138.id];
        _a41 = Math.max(_a41, null == s[_e138.outboundLayer.id] ? 0 : s[_e138.outboundLayer.id]), s[_e138.outboundLayer.id] = _a41, r[_e138.outboundLayer.id] = _e138.outboundLayer, t[_e138.id] = _a41;

        for (var _s75 = 0; _s75 < _e138.inboundLayers.length; _s75++) {
          var _r52 = _e138.inboundLayers[_s75].inboundNodes[_e138.nodeIndices[_s75]];
          t[_r52.id] = Math.max(_a41 + 1, null == t[_r52.id] ? 0 : t[_r52.id]), n[_r52.id] = _r52;
        }
      }
    } catch (err) {
      _iterator45.e(err);
    } finally {
      _iterator45.f();
    }

    var h = {};

    for (var _e132 in t) {
      var _s73 = t[_e132];
      _s73 in h || (h[_s73] = []), h[_s73].push(n[_e132]);
    }

    var d = {};

    for (var _e133 in s) {
      var _t191 = s[_e133];
      _t191 in d || (d[_t191] = []), d[_t191].push(r[_e133]);
    }

    var p = Object.keys(d).map(function (e) {
      return parseInt(e, 10);
    }).sort(Au);
    _this66.layers = [];

    var _iterator46 = _createForOfIteratorHelper(p),
        _step46;

    try {
      for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
        var _e139 = _step46.value;
        var _t194 = d[_e139];

        _t194.sort(function (e, t) {
          var n = a[e.id],
              s = a[t.id];
          return n < s ? -1 : n > s ? 1 : 0;
        });

        var _iterator49 = _createForOfIteratorHelper(_t194),
            _step49;

        try {
          for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
            var _e140 = _step49.value;
            _e140 instanceof cd && _this66.internalContainerRefs.push(_e140), _this66.layers.push(_e140);
          }
        } catch (err) {
          _iterator49.e(err);
        } finally {
          _iterator49.f();
        }
      }
    } catch (err) {
      _iterator46.e(err);
    } finally {
      _iterator46.f();
    }

    _this66.layersByDepth = d, p = Object.keys(h).map(function (e) {
      return parseInt(e, 10);
    }).sort(Au);

    var f = _this66.inputs.slice(),
        g = [];

    var _iterator47 = _createForOfIteratorHelper(p),
        _step47;

    try {
      for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
        var _e141 = _step47.value;

        var _iterator50 = _createForOfIteratorHelper(h[_e141]),
            _step50;

        try {
          for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
            var _t195 = _step50.value;
            var _e142 = _t195.outboundLayer;

            if (null != _e142) {
              var _iterator51 = _createForOfIteratorHelper(_t195.inputTensors),
                  _step51;

              try {
                for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
                  var _n93 = _step51.value;
                  if (-1 === f.indexOf(_n93)) throw new mu("Graph disconnected: cannot obtain value for tensor ".concat(_n93, " at layer \"").concat(_e142.name, "\". The following previous layers were accessed without issue: ").concat(g));
                }
              } catch (err) {
                _iterator51.e(err);
              } finally {
                _iterator51.f();
              }

              var _iterator52 = _createForOfIteratorHelper(_t195.outputTensors),
                  _step52;

              try {
                for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
                  var _e143 = _step52.value;
                  f.push(_e143);
                }
              } catch (err) {
                _iterator52.e(err);
              } finally {
                _iterator52.f();
              }

              g.push(_e142.name);
            }
          }
        } catch (err) {
          _iterator50.e(err);
        } finally {
          _iterator50.f();
        }
      }
    } catch (err) {
      _iterator47.e(err);
    } finally {
      _iterator47.f();
    }

    _this66.nodesByDepth = h;

    var m = _this66.layers.map(function (e) {
      return e.name;
    });

    var _iterator48 = _createForOfIteratorHelper(m),
        _step48;

    try {
      var _loop15 = function _loop15() {
        var e = _step48.value;
        var t = m.filter(function (t) {
          return t === e;
        }).length;
        if (1 !== t) throw new mu("The name \"".concat(e, "\" is used ").concat(t, " times in the model. All layer names should be unique. Layer names: ") + JSON.stringify(m));
      };

      for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
        _loop15();
      }
    } catch (err) {
      _iterator48.e(err);
    } finally {
      _iterator48.f();
    }

    _this66.outboundNodes = [], _this66.inboundNodes = [], new ph({
      outboundLayer: _assertThisInitialized(_this66),
      inboundLayers: [],
      nodeIndices: [],
      tensorIndices: [],
      inputTensors: _this66.inputs,
      outputTensors: _this66.outputs,
      inputMasks: _this66.inputs.map(function (e) {
        return null;
      }),
      outputMasks: _this66.outputs.map(function (e) {
        return null;
      }),
      inputShapes: _this66.inputs.map(function (e) {
        return e.shape;
      }),
      outputShapes: _this66.outputs.map(function (e) {
        return e.shape;
      })
    }), _this66.built = !0, _this66._refCount = 1;
    return _possibleConstructorReturn(_this66);
  }

  _createClass(cd, [{
    key: "assertNotDisposed",
    value: function assertNotDisposed() {
      if (0 === this._refCount) throw new Error("Container '".concat(this.name, "' is already disposed."));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.assertNotDisposed();
      var e = {
        refCountAfterDispose: null,
        numDisposedVariables: 0
      };

      if (0 == --this._refCount) {
        var _iterator53 = _createForOfIteratorHelper(this.layers),
            _step53;

        try {
          for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
            var t = _step53.value;
            e.numDisposedVariables += t.dispose().numDisposedVariables;
          }
        } catch (err) {
          _iterator53.e(err);
        } finally {
          _iterator53.f();
        }

        var _iterator54 = _createForOfIteratorHelper(this.internalContainerRefs),
            _step54;

        try {
          for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
            var _t196 = _step54.value;
            e.numDisposedVariables += _t196.dispose().numDisposedVariables;
          }
        } catch (err) {
          _iterator54.e(err);
        } finally {
          _iterator54.f();
        }
      }

      return e.refCountAfterDispose = this._refCount, e;
    }
  }, {
    key: "trainable",
    get: function get() {
      return this.trainable_;
    },
    set: function set(e) {
      this.layers.forEach(function (t) {
        t._trainableWeights.forEach(function (t) {
          return t.trainable = e;
        });
      }), this.trainable_ = e;
    }
  }, {
    key: "trainableWeights",
    get: function get() {
      if (this._trainableWeights.length > 0) throw new bu("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable) return [];
      var e = [];

      var _iterator55 = _createForOfIteratorHelper(this.layers),
          _step55;

      try {
        for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
          var t = _step55.value;
          e = e.concat(t.trainableWeights);
        }
      } catch (err) {
        _iterator55.e(err);
      } finally {
        _iterator55.f();
      }

      return e;
    }
  }, {
    key: "nonTrainableWeights",
    get: function get() {
      var e = [];

      var _iterator56 = _createForOfIteratorHelper(this.layers),
          _step56;

      try {
        for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
          var _t197 = _step56.value;
          e.push.apply(e, _toConsumableArray(_t197.nonTrainableWeights));
        }
      } catch (err) {
        _iterator56.e(err);
      } finally {
        _iterator56.f();
      }

      if (!this.trainable) {
        var t = [];

        var _iterator57 = _createForOfIteratorHelper(this.layers),
            _step57;

        try {
          for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
            var _e144 = _step57.value;
            t.push.apply(t, _toConsumableArray(_e144.trainableWeights));
          }
        } catch (err) {
          _iterator57.e(err);
        } finally {
          _iterator57.f();
        }

        return t.concat(e);
      }

      return e;
    }
  }, {
    key: "weights",
    get: function get() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
  }, {
    key: "loadWeights",
    value: function loadWeights(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = {};
      var s = 0;

      var _iterator58 = _createForOfIteratorHelper(this.layers),
          _step58;

      try {
        for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
          var _e147 = _step58.value;

          var _iterator59 = _createForOfIteratorHelper(_e147.weights),
              _step59;

          try {
            for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
              var _t199 = _step59.value;
              if (null != n[_t199.originalName]) throw new bu("Duplicate weight name: ".concat(_t199.originalName));
              n[_t199.originalName] = _t199, s++;
            }
          } catch (err) {
            _iterator59.e(err);
          } finally {
            _iterator59.f();
          }
        }
      } catch (err) {
        _iterator58.e(err);
      } finally {
        _iterator58.f();
      }

      var r = [];

      for (var _s76 in e) {
        var _a42 = _s76;

        if (null == n[_s76]) {
          var _e145 = _s76.split("/");

          _a42 = _e145.slice(0, -2).concat([_e145[_e145.length - 1]]).join("/");
        }

        if (null != n[_a42]) r.push([n[_a42], e[_s76]]);else if (t) throw new bu("Provided weight data has no target variable: ".concat(_s76));
        delete n[_a42];
      }

      if (t) {
        var _e146 = [];

        for (var _t198 in n) {
          _e146.push(_t198);
        }

        if (_e146.length > 0) throw new bu("".concat(_e146.length, " of ").concat(s, " weights are not set: ").concat(_e146));
      }

      uh(r);
    }
  }, {
    key: "updatedConfig",
    value: function updatedConfig() {
      var e = this.getConfig(),
          t = {};
      return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers 3.8.0", t.backend = "TensorFlow.js", t;
    }
  }, {
    key: "toJSON",
    value: function toJSON(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var n = nd(this.updatedConfig());
      return t ? JSON.stringify(n) : n;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this67 = this;

      return Yn(function () {
        e = $u(e);
        var n = new sd();

        for (var _t200 = 0; _t200 < _this67.inputs.length; ++_t200) {
          n.add(_this67.inputs[_t200], e[_t200]);
        }

        return id(_this67.outputs, n, t);
      });
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var _this68 = this;

      return Yn(function () {
        var n;
        return e = $u(e), n = null == t ? ku(null, e.length) : $u(t), _this68.runInternalGraph(e, n)[1];
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = sh(e);
      if (t.length !== this.inputLayers.length) throw new bu("Invalid inputShape argument ".concat(e, ": model has ").concat(this.inputLayers.length, " tensor inputs."));
      var n = {};

      for (var _e148 = 0; _e148 < t.length; _e148++) {
        n[this.inputLayers[_e148].name + "_0_0"] = t[_e148];
      }

      var s = Object.keys(this.nodesByDepth).map(function (e) {
        return parseInt(e, 10);
      }).sort(Au);

      if (s.length > 1) {
        var _iterator60 = _createForOfIteratorHelper(s),
            _step60;

        try {
          for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
            var _e149 = _step60.value;
            var _t201 = this.nodesByDepth[_e149];

            var _iterator61 = _createForOfIteratorHelper(_t201),
                _step61;

            try {
              for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
                var _e150 = _step61.value;
                var _t202 = _e150.outboundLayer;
                if (-1 !== this.inputLayers.map(function (e) {
                  return e.id;
                }).indexOf(_t202.id)) continue;
                var _s77 = [];

                for (var _t203 = 0; _t203 < _e150.inboundLayers.length; _t203++) {
                  _s77.push(n["".concat(_e150.inboundLayers[_t203].name, "_").concat(_e150.nodeIndices[_t203], "_").concat(_e150.tensorIndices[_t203])]);
                }

                var _r53 = sh(_t202.computeOutputShape(Iu(_s77))),
                    _a43 = _t202.inboundNodes.indexOf(_e150);

                for (var _e151 = 0; _e151 < _r53.length; _e151++) {
                  n["".concat(_t202.name, "_").concat(_a43, "_").concat(_e151)] = _r53[_e151];
                }
              }
            } catch (err) {
              _iterator61.e(err);
            } finally {
              _iterator61.f();
            }
          }
        } catch (err) {
          _iterator60.e(err);
        } finally {
          _iterator60.f();
        }
      }

      var r = [],
          a = [];

      for (var _e152 = 0; _e152 < this.outputLayers.length; _e152++) {
        a.push("".concat(this.outputLayers[_e152].name, "_").concat(this.outputLayersNodeIndices[_e152], "_").concat(this.outputLayersTensorIndices[_e152]));
      }

      for (var _e153 = 0; _e153 < a.length; _e153++) {
        var _t204 = a[_e153];
        wu(_t204 in n), r.push(n[_t204]);
      }

      return Iu(r);
    }
  }, {
    key: "runInternalGraph",
    value: function runInternalGraph(e, t) {
      null == t && (t = ku(null, e.length));
      var n = {};

      for (var _s78 = 0; _s78 < this.inputs.length; ++_s78) {
        n[this.inputs[_s78].id] = [e[_s78], t[_s78]];
      }

      var s = Object.keys(this.nodesByDepth).map(function (e) {
        return parseInt(e, 10);
      }).sort(Au);

      var _iterator62 = _createForOfIteratorHelper(s),
          _step62;

      try {
        for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
          var _e154 = _step62.value;
          var _t205 = this.nodesByDepth[_e154];

          var _iterator64 = _createForOfIteratorHelper(_t205),
              _step64;

          try {
            for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {
              var _e155 = _step64.value;

              var _t206 = _e155.outboundLayer,
                  _s79 = _e155.inputTensors,
                  _r54 = _e155.outputTensors,
                  _a44 = new Array();

              var _iterator65 = _createForOfIteratorHelper(_s79),
                  _step65;

              try {
                for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
                  var _e158 = _step65.value;
                  _e158.id in n && _a44.push(n[_e158.id]);
                }
              } catch (err) {
                _iterator65.e(err);
              } finally {
                _iterator65.f();
              }

              if (_a44.length === _s79.length) {
                var _s80 = void 0,
                    _i37 = void 0,
                    _o18 = void 0,
                    _l12 = void 0,
                    _u7 = {};

                if (null != _e155.callArgs && (_u7 = _e155.callArgs), 1 === _a44.length) {
                  var _a44$ = _slicedToArray(_a44[0], 2),
                      _e156 = _a44$[0],
                      _n94 = _a44$[1];

                  null == _u7.mask && (_u7.mask = _n94), _o18 = $u(_t206.call(_e156, _u7)), _l12 = $u(_t206.computeMask(_e156, _n94)), _s80 = [_e156], _i37 = [_n94];
                } else _s80 = _a44.map(function (e) {
                  return e[0];
                }), _i37 = _a44.map(function (e) {
                  return e[1];
                }), null == _u7.mask && (_u7.mask = _i37), _o18 = $u(_t206.call(_s80, _u7)), _l12 = $u(_t206.computeMask(_s80, _i37));

                if (_t206.activityRegularizer) throw new xu("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");

                for (var _e157 = 0; _e157 < _r54.length; ++_e157) {
                  n[_r54[_e157].id] = [_o18[_e157], _l12[_e157]];
                }
              }
            }
          } catch (err) {
            _iterator64.e(err);
          } finally {
            _iterator64.f();
          }
        }
      } catch (err) {
        _iterator62.e(err);
      } finally {
        _iterator62.f();
      }

      var r = [],
          a = [],
          i = [];

      var _iterator63 = _createForOfIteratorHelper(this.outputs),
          _step63;

      try {
        for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
          var _e159 = _step63.value;
          wu(_e159.id in n, "Could not compute output ".concat(_e159.name, " : ").concat(_e159.id));

          var _n$_e159$id = _slicedToArray(n[_e159.id], 2),
              _t207 = _n$_e159$id[0],
              _s81 = _n$_e159$id[1];

          i.push(_t207.shape), r.push(_t207), a.push(_s81);
        }
      } catch (err) {
        _iterator63.e(err);
      } finally {
        _iterator63.f();
      }

      return [r, a, i];
    }
  }, {
    key: "buildNodeConversionMap",
    value: function buildNodeConversionMap(e) {
      var t = {};
      var n;

      var _iterator66 = _createForOfIteratorHelper(this.layers),
          _step66;

      try {
        for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
          var _e160 = _step66.value;
          n = _e160 instanceof cd ? 1 : 0;

          for (var _s82 = 0; _s82 < _e160.inboundNodes.length; _s82++) {
            var _r55 = cd.nodeKey(_e160, _s82);

            this.containerNodes.has(_r55) && (t[_r55] = n, n += 1);
          }
        }
      } catch (err) {
        _iterator66.e(err);
      } finally {
        _iterator66.f();
      }

      return t;
    }
  }, {
    key: "getLayer",
    value: function getLayer(e, t) {
      if (null != t) {
        if (this.layers.length <= t) throw new bu("Was asked to retrieve layer at index ".concat(t, ", but model only has ").concat(this.layers.length, " layer(s)."));
        return this.layers[t];
      }

      if (null == e) throw new bu("Provide either a layer name or layer index");

      var _iterator67 = _createForOfIteratorHelper(this.layers),
          _step67;

      try {
        for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {
          var _t208 = _step67.value;
          if (_t208.name === e) return _t208;
        }
      } catch (err) {
        _iterator67.e(err);
      } finally {
        _iterator67.f();
      }

      throw new bu("No such layer: ".concat(e));
    }
  }, {
    key: "calculateLosses",
    value: function calculateLosses() {
      var _this69 = this;

      return Yn(function () {
        var e = [];

        var _iterator68 = _createForOfIteratorHelper(_this69.layers),
            _step68;

        try {
          for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {
            var t = _step68.value;

            for (var _n95 = 0; _n95 < t.inboundNodes.length; ++_n95) {
              var _s83 = cd.nodeKey(t, _n95);

              _this69.containerNodes.has(_s83) && e.push.apply(e, _toConsumableArray(t.calculateLosses()));
            }
          }
        } catch (err) {
          _iterator68.e(err);
        } finally {
          _iterator68.f();
        }

        return e;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        name: this.name
      },
          t = this.buildNodeConversionMap(this.layers),
          n = [];

      var _iterator69 = _createForOfIteratorHelper(this.layers),
          _step69;

      try {
        for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {
          var _e163 = _step69.value;

          var _s85 = _e163.getClassName(),
              _r57 = _e163.getConfig(),
              _a47 = [];

          for (var _n98 = 0; _n98 < _e163.inboundNodes.length; _n98++) {
            var _s86 = _e163.inboundNodes[_n98],
                _r58 = cd.nodeKey(_e163, _n98);

            var _i39 = {};

            if (this.containerNodes.has(_r58)) {
              if (_s86.callArgs) try {
                JSON.stringify(_s86.callArgs), _i39 = _s86.callArgs;
              } catch (t) {
                console.warn("Layer ".concat(_e163.name, " was passed non-serializable keyword arguments: ").concat(_s86.callArgs, ". They will not be included in the serialized model (and thus will be missing at deserialization time).")), _i39 = {};
              }

              if (_s86.inboundLayers.length > 0) {
                var _e164 = [];

                for (var _n99 = 0; _n99 < _s86.inboundLayers.length; _n99++) {
                  var _r59 = _s86.inboundLayers[_n99],
                      _a48 = _s86.tensorIndices[_n99];
                  var _o19 = t[cd.nodeKey(_r59, _s86.nodeIndices[_n99])];
                  null == _o19 && (_o19 = 0), _e164.push([_r59.name, _o19, _a48, _i39]);
                }

                _a47.push(_e164);
              }
            }
          }

          var _i38 = {};
          _i38.name = _e163.name, _i38.className = _s85, _i38.config = _r57, _i38.inboundNodes = _a47, n.push(_i38);
        }
      } catch (err) {
        _iterator69.e(err);
      } finally {
        _iterator69.f();
      }

      e.layers = n;
      var s = [];

      for (var _e161 = 0; _e161 < this.inputLayers.length; _e161++) {
        var _n96 = this.inputLayers[_e161],
            _r56 = cd.nodeKey(_n96, this.inputLayersNodeIndices[_e161]);

        if (!this.containerNodes.has(_r56)) continue;
        var _a45 = t[_r56];
        null == _a45 && (_a45 = 0), s.push([_n96.name, _a45, this.inputLayersTensorIndices[_e161]]);
      }

      e.inputLayers = s;
      var r = [];

      for (var _e162 = 0; _e162 < this.outputLayers.length; _e162++) {
        var _n97 = this.outputLayers[_e162],
            _s84 = cd.nodeKey(_n97, this.outputLayersNodeIndices[_e162]);

        if (!this.containerNodes.has(_s84)) continue;
        var _a46 = t[_s84];
        null == _a46 && (_a46 = 0), r.push([_n97.name, _a46, this.outputLayersTensorIndices[_e162]]);
      }

      return e.outputLayers = r, e;
    }
  }, {
    key: "stateful",
    get: function get() {
      if (this._stateful) throw new bu("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");

      var _iterator70 = _createForOfIteratorHelper(this.layers),
          _step70;

      try {
        for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
          var _e165 = _step70.value;
          if (_e165.stateful) return !0;
        }
      } catch (err) {
        _iterator70.e(err);
      } finally {
        _iterator70.f();
      }

      return !1;
    }
  }, {
    key: "resetStates",
    value: function resetStates() {
      var _this70 = this;

      Yn(function () {
        _this70.layers.forEach(function (e) {
          e.stateful && e.resetStates();
        });
      });
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      var r = {},
          a = {};

      function i(e, t) {
        e.name in a ? a[e.name].push(t) : a[e.name] = [t];
      }

      function o(e, t) {
        var n = [];
        var s;

        var _iterator71 = _createForOfIteratorHelper(t),
            _step71;

        try {
          for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
            var _a49 = _step71.value;
            var _o20 = _a49[0],
                _l13 = _a49[1],
                _u8 = _a49[2];
            if (s = null == _a49[3] ? {} : _a49[3], !(_o20 in r)) return void i(e, t);
            var _c7 = r[_o20];
            if (_c7.inboundNodes.length <= _l13) return void i(e, t);
            n.push(_c7.inboundNodes[_l13].outputTensors[_u8]);
          }
        } catch (err) {
          _iterator71.e(err);
        } finally {
          _iterator71.f();
        }

        n.length > 0 && e.apply(Iu(n), s);
      }

      function l(e) {
        var n = e.name,
            a = Eh(e, null != t.customObjects ? t.customObjects : {});
        a.setFastWeightInitDuringBuild(s), r[n] = a, e.inboundNodes.forEach(function (e) {
          if (!(e instanceof Array)) throw new bu("Corrupted configuration, expected array for nodeData: ".concat(e));
          i(a, e);
        });
      }

      var u = t.name,
          c = t.layers;

      var _iterator72 = _createForOfIteratorHelper(c),
          _step72;

      try {
        for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {
          var _e168 = _step72.value;
          l(_e168);
        }
      } catch (err) {
        _iterator72.e(err);
      } finally {
        _iterator72.f();
      }

      for (; !Du(a);) {
        var _iterator73 = _createForOfIteratorHelper(c),
            _step73;

        try {
          for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {
            var _e166 = _step73.value;
            var _t209 = r[_e166.name];

            if (_t209.name in a) {
              var _e167 = a[_t209.name];
              delete a[_t209.name];

              var _iterator74 = _createForOfIteratorHelper(_e167),
                  _step74;

              try {
                for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {
                  var _n100 = _step74.value;
                  o(_t209, _n100);
                }
              } catch (err) {
                _iterator74.e(err);
              } finally {
                _iterator74.f();
              }
            }
          }
        } catch (err) {
          _iterator73.e(err);
        } finally {
          _iterator73.f();
        }
      }

      var h = [],
          d = [],
          p = t.inputLayers;

      var _iterator75 = _createForOfIteratorHelper(p),
          _step75;

      try {
        for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
          var _e169 = _step75.value;
          var _t210 = _e169[0],
              _n101 = _e169[1],
              _s87 = _e169[2];
          wu(_t210 in r), h.push(r[_t210].inboundNodes[_n101].outputTensors[_s87]);
        }
      } catch (err) {
        _iterator75.e(err);
      } finally {
        _iterator75.f();
      }

      var f = t.outputLayers;

      var _iterator76 = _createForOfIteratorHelper(f),
          _step76;

      try {
        for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
          var _e170 = _step76.value;
          var _t211 = _e170[0],
              _n102 = _e170[1],
              _s88 = _e170[2];
          wu(_t211 in r), d.push(r[_t211].inboundNodes[_n102].outputTensors[_s88]);
        }
      } catch (err) {
        _iterator76.e(err);
      } finally {
        _iterator76.f();
      }

      return new e({
        inputs: h,
        outputs: d,
        name: u
      });
    }
  }]);

  return cd;
}(gh);

function hd(e, t) {
  return function (e, t, n) {
    var s = t.length;
    if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
      return null;
    });
    if (1 === s) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];

    if (Array.isArray(e)) {
      if (e.length !== s) throw new Error("Provided classWeight is an array of ".concat(e.length, " element(s), but the model has ").concat(s, " outputs. Make sure a set of weights is provided for each model output."));
      return e;
    }

    if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
      var _n103 = [];
      return t.forEach(function (t) {
        _n103.push(t in e ? e[t] : null);
      }), _n103;
    }

    throw new Error("The model has multiple (".concat(s, ") outputs, so classWeight must be either an array with ").concat(s, " elements or an object with ").concat(t, " keys. Provided classWeight not understood: ").concat(JSON.stringify(e)));
  }(e, t);
}

function dd(_x84, _x85, _x86, _x87) {
  return _dd.apply(this, arguments);
}

function _dd() {
  _dd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee100(e, t, n, s) {
    var _t482, _s247, _r179;

    return _regeneratorRuntime.wrap(function _callee100$(_context103) {
      while (1) {
        switch (_context103.prev = _context103.next) {
          case 0:
            if (!(null != t || null != s)) {
              _context103.next = 2;
              break;
            }

            throw new Error("Support sampleWeight is not implemented yet");

          case 2:
            if (!(null != n)) {
              _context103.next = 12;
              break;
            }

            _t482 = Yn(function () {
              if (1 === e.shape.length) return fn(e);

              if (2 === e.shape.length) {
                if (e.shape[1] > 1) return us(e, 1);
                if (1 === e.shape[1]) return Es(e, [e.shape[0]]);
                throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1], ") during handling of class weights. The size is expected to be >= 1."));
              }

              throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank, ") during handling of class weights. The rank is expected to be 1 or 2."));
            });
            _context103.t0 = Array;
            _context103.next = 7;
            return _t482.data();

          case 7:
            _context103.t1 = _context103.sent;
            _s247 = _context103.t0.from.call(_context103.t0, _context103.t1);
            Jn(_t482);
            _r179 = [];
            return _context103.abrupt("return", (_s247.forEach(function (e) {
              if (null == n[e]) throw new Error("classWeight must contain all classes in the training data. The class ".concat(e, " exists in the data but not in classWeight"));

              _r179.push(n[e]);
            }), mi(_r179, "float32")));

          case 12:
            return _context103.abrupt("return", null);

          case 13:
          case "end":
            return _context103.stop();
        }
      }
    }, _callee100);
  }));
  return _dd.apply(this, arguments);
}

function pd(e, t) {
  return ss(e, t);
}

function fd(e, t) {
  var n, s;
  n = t.xs, s = t.ys, l(null != n && null != s, function () {
    return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ".concat(t);
  });
  var r = gd("input", e.inputNames, n),
      a = gd("output", e.outputNames, s),
      i = r[0].shape[0];
  l(r.length === e.inputs.length, function () {
    return "LayersModel has ".concat(e.inputs.length, " inputs, but the dataset provides ").concat(r.length, " inputs.  (Expected input keys: ").concat(JSON.stringify(e.inputNames), ")");
  }), l(a.length === e.outputs.length, function () {
    return "LayersModel has ".concat(e.outputs.length, " outputs, but the dataset provides ").concat(a.length, " outputs.  (Expected output keys: ").concat(JSON.stringify(e.outputNames), ")");
  });

  var _loop16 = function _loop16(_t212) {
    l(r[_t212].shape[0] === i, function () {
      return "Batch size mismatch: input ".concat(e.inputNames[_t212], " has ").concat(r[_t212].shape[0], "; expected  ").concat(i, " based on input ").concat(e.inputNames[0], ".");
    });
  };

  for (var _t212 = 0; _t212 < r.length; _t212++) {
    _loop16(_t212);
  }

  var _loop17 = function _loop17(_t213) {
    l(a[_t213].shape[0] === i, function () {
      return "Batch size mismatch: output ".concat(e.outputNames[_t213], " has ").concat(a[_t213].shape[0], "; expected  ").concat(i, " based on input ").concat(e.inputNames[0], ".");
    });
  };

  for (var _t213 = 0; _t213 < a.length; _t213++) {
    _loop17(_t213);
  }

  return {
    xs: r,
    ys: a
  };
}

function gd(e, t, n) {
  if (n instanceof st) return [n];
  if (Array.isArray(n)) return l(n.length === t.length, function () {
    return "Received an array of ".concat(n.length, " Tensors, but expected ").concat(t.length, " to match the ").concat(e, " keys ").concat(t, ".");
  }), n;
  {
    var _s89 = [];

    var _iterator77 = _createForOfIteratorHelper(t),
        _step77;

    try {
      for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {
        var _r60 = _step77.value;
        if (null == n[_r60]) throw new bu("The feature data generated by the dataset lacks the required ".concat(e, " key '").concat(_r60, "'."));

        _s89.push(n[_r60]);
      }
    } catch (err) {
      _iterator77.e(err);
    } finally {
      _iterator77.f();
    }

    return _s89;
  }
}

function md(e) {
  return "function" == typeof e.iterator;
}

function bd(e) {
  l(e > 0 && Number.isInteger(e), function () {
    return "batchSize is required to be a positive integer, but got ".concat(e);
  });
}

function xd(e, t, n) {
  return null == e ? [null] : Array.isArray(e) ? e.map(function (e) {
    return mc(e, t, n - t);
  }) : mc(e, t, n - t);
}

function yd(e, t) {
  return Yn(function () {
    return null == e ? null : Array.isArray(e) ? e.map(function (e) {
      return yd(e, t);
    }) : $c(e, "int32" === t.dtype ? t : pn(t, "int32"));
  });
}

function kd(e, t) {
  var n = [];
  var s = 0,
      r = null;

  for (; s < e;) {
    r = s + t, r >= e && (r = e), n.push([s, r]), s = r;
  }

  return n;
}

function wd(e) {
  var t = [];
  e instanceof st && (e = [e]);

  for (var _n104 = 0; _n104 < e.length; ++_n104) {
    var _s90 = e[_n104];
    if (1 === _s90.rank) t.push(gc(_s90, 1));else {
      if (0 === _s90.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      t.push(_s90);
    }
  }

  return t;
}

function vd(e, t) {
  if (null == e) return;
  var n = [];
  if (t instanceof st) n.push(t.id);else if (Array.isArray(t)) t.forEach(function (e) {
    return n.push(e.id);
  });else if (null != t) for (var _e171 in t) {
    n.push(t[_e171].id);
  }
  var s = [];
  if (e instanceof st) -1 === n.indexOf(e.id) && s.push(e);else if (Array.isArray(e)) e.forEach(function (e) {
    -1 === n.indexOf(e.id) && s.push(e);
  });else if (null != e) for (var _t214 in e) {
    var _r61 = e[_t214];
    -1 === n.indexOf(_r61.id) && s.push(_r61);
  }
  s.forEach(function (e) {
    e.isDisposed || e.dispose();
  });
}

function Id(e) {
  return Array.isArray(e);
}

function $d(e) {
  return !function (e) {
    return e instanceof st;
  }(e) && !Id(e);
}

function Nd(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";

  if (null == t || 0 === t.length) {
    if (null != e) {
      var _t215 = !1;

      if (Id(e) && e.length > 0) _t215 = !0;else if ($d(e)) {
        for (var _n105 in e) {
          if (e.hasOwnProperty(_n105)) {
            _t215 = !0;
            break;
          }
        }
      } else _t215 = !0;
      if (_t215) throw new bu("Error when checking model ".concat(r, " expected no data, but got ").concat(e));
    }

    return [];
  }

  if (null == e) return t.map(function (e) {
    return null;
  });
  var a;

  if ($d(e)) {
    e = e, a = [];

    var _iterator78 = _createForOfIteratorHelper(t),
        _step78;

    try {
      for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
        var _n106 = _step78.value;
        if (null == e[_n106]) throw new bu("No data provided for \"".concat(_n106, "\". Need data for each key in: ").concat(t));
        a.push(e[_n106]);
      }
    } catch (err) {
      _iterator78.e(err);
    } finally {
      _iterator78.f();
    }
  } else if (Id(e)) {
    if ((e = e).length !== t.length) throw new bu("Error when checking model ".concat(r, ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ").concat(t.length, " Tensor(s), but instead got the following list of Tensor(s): ").concat(e));
    a = e;
  } else {
    if (e = e, t.length > 1) throw new bu("The model ".concat(r, " expects ").concat(t.length, " Tensor(s), but only received one Tensor. Found: Tensor with shape ").concat(e.shape));
    a = [e];
  }

  if (a = wd(a), null != n) for (var _e172 = 0; _e172 < t.length; ++_e172) {
    if (null == n[_e172]) continue;
    var _i40 = a[_e172];
    if (_i40.shape.length !== n[_e172].length) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e172], " to have ").concat(n[_e172].length, " dimension(s). but got array with shape ").concat(_i40.shape));

    for (var _a50 = 0; _a50 < n[_e172].length; ++_a50) {
      if (0 === _a50 && !s) continue;
      var _o21 = _i40.shape[_a50],
          _l14 = n[_e172][_a50];
      if (null != _l14 && _l14 >= 0 && _o21 !== _l14) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e172], " to have shape [").concat(n[_e172], "], but got array with shape [").concat(_i40.shape, "]."));
    }
  }
  return a;
}

function Cd(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
  var a;

  if (Array.isArray(e)) {
    if (e.length !== t.length) throw new bu("Error when checking model ".concat(r, ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ").concat(t.length, " Tensor(s), but instead got ").concat(e.length, " Tensors(s)."));
    a = e;
  } else {
    if (t.length > 1) throw new bu("The model expects ".concat(t.length, " ").concat(r, " Tensors, but only received one Tensor. Found: array with shape ").concat(JSON.stringify(e.shape), "."));
    a = [e];
  }

  if (null != n) for (var _e173 = 0; _e173 < t.length; ++_e173) {
    if (null == n[_e173]) continue;
    var _i41 = a[_e173];
    if (_i41.shape.length !== n[_e173].length) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e173], " to have ").concat(n[_e173].length, " dimension(s), but got array with shape ").concat(JSON.stringify(_i41.shape)));

    for (var _a51 = 0; _a51 < n[_e173].length; ++_a51) {
      if (0 === _a51 && !s) continue;
      var _o22 = _i41.shape[_a51],
          _l15 = n[_e173][_a51];
      if (null != _l15 && _l15 !== _o22) throw new bu("Error when checking ".concat(r, ": expected ").concat(t[_e173], " to have shape ").concat(JSON.stringify(n[_e173]), " but got array with shape ").concat(JSON.stringify(_i41.shape), "."));
    }
  }
}

var Sd = /*#__PURE__*/function (_cd) {
  "use strict";

  _inherits(Sd, _cd);

  var _super42 = _createSuper(Sd);

  function Sd(e) {
    var _this71;

    _classCallCheck(this, Sd);

    _this71 = _super42.call(this, e), _this71.isTraining = !1;
    return _this71;
  }

  _createClass(Sd, [{
    key: "summary",
    value: function summary(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
      if (!this.built) throw new bu("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
      !function (e, t, n) {
        var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;

        var r = function (e) {
          var t = !0;
          var n = [],
              s = [];

          for (var _t216 in e.nodesByDepth) {
            n.push(e.nodesByDepth[_t216]);
          }

          for (var _i42 = 0, _n107 = n; _i42 < _n107.length; _i42++) {
            var _e174 = _n107[_i42];

            if (_e174.length > 1 || 1 === _e174.length && _e174[0].inboundLayers.length > 1) {
              t = !1;
              break;
            }

            s.push.apply(s, _toConsumableArray(_e174));
          }

          if (t) {
            var _iterator79 = _createForOfIteratorHelper(e.layers),
                _step79;

            try {
              for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
                var _n108 = _step79.value;

                var _e175 = !1;

                var _iterator80 = _createForOfIteratorHelper(_n108.inboundNodes),
                    _step80;

                try {
                  for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {
                    var _r62 = _step80.value;

                    if (-1 !== s.indexOf(_r62)) {
                      if (_e175) {
                        t = !1;
                        break;
                      }

                      _e175 = !0;
                    }
                  }
                } catch (err) {
                  _iterator80.e(err);
                } finally {
                  _iterator80.f();
                }

                if (!t) break;
              }
            } catch (err) {
              _iterator79.e(err);
            } finally {
              _iterator79.f();
            }
          }

          return t;
        }(e),
            a = ["Layer (type)", "Output shape", "Param #"];

        var i;

        if (r ? (t = t || 65, n = n || [.45, .85, 1]) : (t = t || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(function (e) {
          return Math.floor(t * e);
        })), !r) {
          a.push("Receives inputs"), i = [];

          for (var _t217 in e.nodesByDepth) {
            var _i43;

            (_i43 = i).push.apply(_i43, _toConsumableArray(e.nodesByDepth[_t217]));
          }
        }

        s("_".repeat(t)), Jh(a, n, s), s("=".repeat(t));
        var o = e.layers;

        for (var _e176 = 0; _e176 < o.length; ++_e176) {
          r ? Zh(o[_e176], n, s) : Qh(o[_e176], n, i, s), s((_e176 === o.length - 1 ? "=" : "_").repeat(t));
        }

        e.checkTrainableWeightsConsistency();

        var l = function (e) {
          var t;
          return t = ih(null != e.collectedTrainableWeights ? e.collectedTrainableWeights : e.trainableWeights), t;
        }(e),
            u = ih(e.nonTrainableWeights);

        s("Total params: ".concat(l + u)), s("Trainable params: ".concat(l)), s("Non-trainable params: ".concat(u)), s("_".repeat(t));
      }(this, e, t, n);
    }
  }, {
    key: "compile",
    value: function compile(e) {
      var _this72 = this;

      if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = function (e) {
        var t = {
          Adagrad: function Adagrad() {
            return Io.adagrad(.01);
          },
          Adadelta: function Adadelta() {
            return Io.adadelta(1, .95, fu());
          },
          Adam: function Adam() {
            return Io.adam(.001, .9, .999, fu());
          },
          Adamax: function Adamax() {
            return Io.adamax(.002, .9, .999, fu(), 0);
          },
          RMSProp: function RMSProp() {
            return Io.rmsprop(.001, .9, 0, fu());
          },
          SGD: function SGD() {
            return Io.sgd(.01);
          }
        };
        if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
        throw new bu("Unknown Optimizer ".concat(e));
      }(e.optimizer), this.isOptimizerOwned = !0;else {
        if (!(e.optimizer instanceof fo)) throw new bu("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1;
      }
      var t = [];
      if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss) {
        if (Array.isArray(e.loss)) {
          if (e.loss.length !== this.outputs.length) throw new bu("When passing an Array as loss, it should have one entry per model output. The model has ".concat(this.outputs.length, " output(s), but you passed loss=").concat(e.loss, "."));
          t = e.loss.map(function (e) {
            return Bh(e);
          });
        } else {
          var _n109 = Bh(e.loss);

          this.outputs.forEach(function (e) {
            t.push(_n109);
          });
        }
      } else {
        e.loss = e.loss;

        for (var _t218 in e.loss) {
          if (-1 === this.outputNames.indexOf(_t218)) throw new bu("Unknown entry in loss dictionary: \"".concat(_t218, "\". Only expected the following keys: ").concat(this.outputNames));
        }

        var _iterator81 = _createForOfIteratorHelper(this.outputNames),
            _step81;

        try {
          for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
            var _n110 = _step81.value;
            null == e.loss[_n110] && console.warn("Output \"".concat(_n110, "\" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ").concat(_n110, " during training")), t.push(Bh(e.loss[_n110]));
          }
        } catch (err) {
          _iterator81.e(err);
        } finally {
          _iterator81.f();
        }
      }
      this.lossFunctions = t, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];

      for (var _e177 = 0; _e177 < this.outputs.length; ++_e177) {
        var _t219 = this.internalOutputShapes[_e177];
        this.feedOutputNames.push(this.outputNames[_e177]), this.feedOutputShapes.push(_t219), this.feedLossFns.push(this.lossFunctions[_e177]);
      }

      var n = [];
      this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], ac("loss", function () {
        for (var _e178 = 0; _e178 < _this72.outputs.length; ++_e178) {
          if (-1 !== n.indexOf(_e178)) continue;
          var _t220 = _this72.lossFunctions[_e178];
          _this72.outputs.length > 1 && (_this72.metricsTensors.push([_t220, _e178]), _this72.metricsNames.push(_this72.outputNames[_e178] + "_loss"));
        }
      });

      var s = function (e, t) {
        if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function (e) {
          return [];
        });
        var n;
        if ("string" == typeof e || "function" == typeof e) n = [e];else {
          if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ".concat(e));
          n = e;
        }
        if (Array.isArray(n)) return t.map(function (e) {
          return n;
        });
        {
          var _e179 = [];

          var _iterator82 = _createForOfIteratorHelper(t),
              _step82;

          try {
            for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {
              var _s91 = _step82.value;

              var _t221 = n.hasOwnProperty(_s91) ? n[_s91] : [];

              Array.isArray(_t221) || (_t221 = [_t221]), _e179.push(_t221);
            }
          } catch (err) {
            _iterator82.e(err);
          } finally {
            _iterator82.f();
          }

          return _e179;
        }
      }(e.metrics, this.outputNames),
          r = function r(e, t, n) {
        _this72.outputNames.length > 1 && (t = _this72.outputNames[e] + "_" + t), _this72.metricsNames.push(t), _this72.metricsTensors.push([n, e]);
      };

      ac("metric", function () {
        var _loop18 = function _loop18(_e180) {
          -1 === n.indexOf(_e180) && function (t) {
            var n, s, a;

            var _iterator83 = _createForOfIteratorHelper(t),
                _step83;

            try {
              for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
                var _i44 = _step83.value;

                if ("string" == typeof _i44 && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(_i44)) {
                  var _t223 = _this72.internalOutputShapes[_e180];

                  var _r63 = void 0;

                  1 === _t223[_t223.length - 1] || _this72.lossFunctions[_e180] === Mh ? -1 !== ["accuracy", "acc"].indexOf(_i44) ? s = Ph : -1 !== ["crossentropy", "ce"].indexOf(_i44) && (s = Uh) : _this72.lossFunctions[_e180] === Oh ? -1 !== ["accuracy", "acc"].indexOf(_i44) ? s = Vh : -1 !== ["crossentropy", "ce"].indexOf(_i44) && (s = Hh) : -1 !== ["accuracy", "acc"].indexOf(_i44) ? s = Wh : -1 !== ["crossentropy", "ce"].indexOf(_i44) && (s = Gh), -1 !== ["accuracy", "acc"].indexOf(_i44) ? _r63 = "acc" : -1 !== ["crossentropy", "ce"].indexOf(_i44) && (_r63 = "ce"), a = s, n = "" + _r63;
                } else {
                  var _e181 = qh(_i44);

                  a = _e181, n = "" + Kh(_i44);
                }

                var _t222 = void 0;

                ac(n, function () {
                  _t222 = a;
                }), r(_e180, n, _t222);
              }
            } catch (err) {
              _iterator83.e(err);
            } finally {
              _iterator83.f();
            }
          }(s[_e180]);
        };

        for (var _e180 = 0; _e180 < _this72.outputs.length; ++_e180) {
          _loop18(_e180);
        }
      }), this.collectedTrainableWeights = this.trainableWeights;
    }
  }, {
    key: "checkTrainableWeightsConsistency",
    value: function checkTrainableWeightsConsistency() {
      null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }
  }, {
    key: "evaluate",
    value: function evaluate(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var s = null == n.batchSize ? 32 : n.batchSize;
      bd(s);
      var r = this.standardizeUserDataXY(e, t, !0, s);

      try {
        var _a52 = r[0].concat(r[1]);

        return this.makeTestFunction(), Iu(this.testLoop(this.testFunction, _a52, s, n.verbose, n.steps));
      } finally {
        vd(r[0], e), vd(r[1], t);
      }
    }
  }, {
    key: "evaluateDataset",
    value: function () {
      var _evaluateDataset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee71(e, t) {
        return _regeneratorRuntime.wrap(function _callee71$(_context72) {
          while (1) {
            switch (_context72.prev = _context72.next) {
              case 0:
                return _context72.abrupt("return", (this.makeTestFunction(), function () {
                  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee70(e, t, n) {
                    var s, r, a, i, o, u, _loop19, _ret, _e182, _t224;

                    return _regeneratorRuntime.wrap(function _callee70$(_context71) {
                      while (1) {
                        switch (_context71.prev = _context71.next) {
                          case 0:
                            s = null != (n = n || {}).batches, r = e.testFunction;
                            a = [];

                            if (!(n.verbose > 0)) {
                              _context71.next = 4;
                              break;
                            }

                            throw new xu("Verbose mode is not implemented yet.");

                          case 4:
                            l(!s || n.batches > 0 && Number.isInteger(n.batches), function () {
                              return "Test loop expects `batches` to be a positive integer, but received ".concat(JSON.stringify(n.batches));
                            });

                            if (!("function" == typeof t.next)) {
                              _context71.next = 9;
                              break;
                            }

                            _context71.t0 = t;
                            _context71.next = 12;
                            break;

                          case 9:
                            _context71.next = 11;
                            return t.iterator();

                          case 11:
                            _context71.t0 = _context71.sent;

                          case 12:
                            i = _context71.t0;
                            o = 0, u = 0;
                            _loop19 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop19() {
                              var t;
                              return _regeneratorRuntime.wrap(function _loop19$(_context70) {
                                while (1) {
                                  switch (_context70.prev = _context70.next) {
                                    case 0:
                                      _context70.next = 2;
                                      return i.next();

                                    case 2:
                                      t = _context70.sent;

                                      if (!(a = Yn(function () {
                                        if (t.value) {
                                          (function () {
                                            var _fd = fd(e, t.value),
                                                n = _fd.xs,
                                                s = _fd.ys,
                                                i = n.concat(s),
                                                l = Yn(function () {
                                              return r(i);
                                            });

                                            if (Jn(i), 0 === u) for (var _e183 = 0; _e183 < l.length; ++_e183) {
                                              a.push(qa(0));
                                            }
                                            var c = i[0].shape[0];

                                            var _loop20 = function _loop20(_e184) {
                                              var t = l[_e184],
                                                  n = a[_e184];
                                              a[_e184] = Yn(function () {
                                                return es(a[_e184], ss(c, t));
                                              }), u > 0 && Jn(n);
                                            };

                                            for (var _e184 = 0; _e184 < l.length; ++_e184) {
                                              _loop20(_e184);
                                            }

                                            Jn(l), o += c, ++u;
                                          })();
                                        }

                                        return a;
                                      }), t.done)) {
                                        _context70.next = 6;
                                        break;
                                      }

                                      s && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, ".concat(n.batches, " batches). You may need to use the repeat() function when building your dataset."));
                                      return _context70.abrupt("return", "break");

                                    case 6:
                                    case "end":
                                      return _context70.stop();
                                  }
                                }
                              }, _loop19);
                            });

                          case 15:
                            if (!(!s || u < n.batches)) {
                              _context71.next = 22;
                              break;
                            }

                            return _context71.delegateYield(_loop19(), "t1", 17);

                          case 17:
                            _ret = _context71.t1;

                            if (!(_ret === "break")) {
                              _context71.next = 20;
                              break;
                            }

                            return _context71.abrupt("break", 22);

                          case 20:
                            _context71.next = 15;
                            break;

                          case 22:
                            for (_e182 = 0; _e182 < a.length; ++_e182) {
                              _t224 = a[_e182];
                              a[_e182] = ns(a[_e182], o), Jn(_t224);
                            }

                            return _context71.abrupt("return", Iu(a));

                          case 24:
                          case "end":
                            return _context71.stop();
                        }
                      }
                    }, _callee70);
                  }));

                  return function (_x90, _x91, _x92) {
                    return _ref13.apply(this, arguments);
                  };
                }()(this, e, t)));

              case 1:
              case "end":
                return _context72.stop();
            }
          }
        }, _callee71, this);
      }));

      function evaluateDataset(_x88, _x89) {
        return _evaluateDataset.apply(this, arguments);
      }

      return evaluateDataset;
    }()
  }, {
    key: "checkNumSamples",
    value: function checkNumSamples(e, t, n) {
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "steps";
      var r;

      if (null != n) {
        if (r = null, null != t) throw new bu("If ".concat(s, " is set, batchSize must be null or undefined.Got batchSize = ").concat(t));
      } else {
        if (null == e) throw new bu("Either the input data should have a defined shape, or ".concat(s, " shoud be specified."));
        r = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
      }

      return r;
    }
  }, {
    key: "execute",
    value: function execute(e, t) {
      if (Array.isArray(t) && 0 === t.length) throw new bu("`outputs` is an empty Array, which is not allowed.");
      var n = Array.isArray(t),
          s = this.retrieveSymbolicTensors(n ? t : [t]),
          r = new sd();

      if (e instanceof st && (e = [e]), Array.isArray(e)) {
        if (e.length !== this.inputs.length) throw new bu("The number of inputs provided (".concat(e.length, ") does not match the number of inputs of this model (").concat(this.inputs.length, ")."));

        for (var _t225 = 0; _t225 < this.inputs.length; ++_t225) {
          r.add(this.inputs[_t225], e[_t225]);
        }
      } else {
        var _iterator84 = _createForOfIteratorHelper(this.inputs),
            _step84;

        try {
          for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
            var _t226 = _step84.value;
            var _n111 = e[_t226.name];
            if (null == _n111) throw new bu("No value is provided for the model's input ".concat(_t226.name));
            r.add(_t226, _n111);
          }
        } catch (err) {
          _iterator84.e(err);
        } finally {
          _iterator84.f();
        }
      }

      var a = id(s, r);
      return n ? a : a[0];
    }
  }, {
    key: "retrieveSymbolicTensors",
    value: function retrieveSymbolicTensors(e) {
      var t = ku(null, e.length);
      var n = e.length;

      var _iterator85 = _createForOfIteratorHelper(this.layers),
          _step85;

      try {
        for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
          var _s92 = _step85.value;

          var _r64 = Array.isArray(_s92.output) ? _s92.output : [_s92.output],
              _a53 = _r64.map(function (e) {
            return e.name;
          });

          for (var _s93 = 0; _s93 < e.length; ++_s93) {
            var _i45 = _a53.indexOf(e[_s93]);

            if (-1 !== _i45 && (t[_s93] = _r64[_i45], n--), 0 === n) break;
          }

          if (0 === n) break;
        }
      } catch (err) {
        _iterator85.e(err);
      } finally {
        _iterator85.f();
      }

      if (n > 0) {
        var _n112 = [];
        throw t.forEach(function (t, s) {
          null == t && _n112.push(e[s]);
        }), new bu("Cannot find SymbolicTensors for output name(s): ".concat(JSON.stringify(_n112)));
      }

      return t;
    }
  }, {
    key: "predictLoop",
    value: function predictLoop(e) {
      var _this73 = this;

      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      return Yn(function () {
        var s = _this73.checkNumSamples(e);

        if (n) throw new xu("Verbose predictLoop() is not implemented yet.");

        var r = kd(s, t),
            a = _this73.outputs.map(function (e) {
          return [];
        });

        var _loop21 = function _loop21(_t227) {
          Yn(function () {
            var n = xd(e, r[_t227][0], r[_t227][1]),
                s = [];
            if (Array.isArray(n)) for (var _e185 = 0; _e185 < n.length; ++_e185) {
              s.push({
                key: _this73.inputs[_e185],
                value: n[_e185]
              });
            } else s.push({
              key: _this73.inputs[0],
              value: n
            });
            var a = new sd(s);
            return id(_this73.outputs, a);
          }).forEach(function (e, t) {
            return a[t].push(e);
          });
        };

        for (var _t227 = 0; _t227 < r.length; ++_t227) {
          _loop21(_t227);
        }

        return Iu(a.map(function (e) {
          return Fs(e, 0);
        }));
      });
    }
  }, {
    key: "predict",
    value: function predict(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var n = wd(e);
      Cd(n, this.inputNames, this.feedInputShapes, !1);

      try {
        var _s94 = null == t.batchSize ? 32 : t.batchSize;

        return bd(_s94), this.predictLoop(n, _s94);
      } finally {
        vd(n, e);
      }
    }
  }, {
    key: "predictOnBatch",
    value: function predictOnBatch(e) {
      Cd(e, this.inputNames, this.feedInputShapes, !0);
      var t = (Array.isArray(e) ? e[0] : e).shape[0];
      return this.predictLoop(e, t);
    }
  }, {
    key: "standardizeUserDataXY",
    value: function standardizeUserDataXY(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      var s = arguments.length > 3 ? arguments[3] : undefined;
      if (null == this.optimizer_) throw new mu("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      var r = [];

      for (var _e186 = 0; _e186 < this.feedOutputShapes.length; ++_e186) {
        var _t228 = this.feedOutputShapes[_e186];
        r.push(this.feedLossFns[_e186] === Oh ? _t228.slice(0, _t228.length - 1).concat([1]) : _t228);
      }

      if (function (e, t, n) {
        var s = Fu(e.map(function (e) {
          return e.shape[0];
        }));
        s.sort();
        var r = Fu(t.map(function (e) {
          return e.shape[0];
        }));
        if (r.sort(), s.length > 1) throw new bu("All input Tensors (x) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(e.map(function (e) {
          return e.shape;
        }))));
        if (r.length > 1) throw new bu("All target Tensors (y) should have the same number of samples. Got array shapes: ".concat(JSON.stringify(t.map(function (e) {
          return e.shape;
        }))));
        if (s.length > 0 && r.length > 0 && !p(s, r)) throw new bu("Input Tensors should have the same number of samples as target Tensors. Found ".concat(s[0], " input sample(s) and ").concat(r[0], " target sample(s)."));
      }(e = Nd(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = Nd(t, this.feedOutputNames, r, !1, "target")), function (e, t, n) {
        var s = [Ah, Mh, _h];

        for (var _r65 = 0; _r65 < e.length; ++_r65) {
          var _a54 = e[_r65],
              _i46 = t[_r65],
              _o23 = n[_r65];

          if (null != _i46) {
            if (_i46 === _h && 1 === _a54.shape[_a54.shape.length - 1]) throw new bu("You are passing a target array of shape ".concat(_a54.shape, " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes]."));

            if (-1 !== s.indexOf(_i46)) {
              var _e187 = _a54.shape.slice(1),
                  _t229 = _o23.slice(1);

              for (var _n113 = 0; _n113 < _e187.length; ++_n113) {
                var _s95 = _e187[_n113],
                    _r66 = _t229[_n113];
                if (null != _r66 && _s95 !== _r66) throw new bu("A target Tensor with shape ".concat(_a54.shape, " was passed for an output of shape ").concat(_o23, ", while using a loss function that expects targets to have the same shape as the output."));
              }
            }
          }
        }
      }(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != s && s > 0 && e[0].shape[0] % s != 0) throw new bu("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ".concat(s, ". Found: ").concat(e[0].shape[0], " sample(s)."));
      return [e, t];
    }
  }, {
    key: "standardizeUserData",
    value: function () {
      var _standardizeUserData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee72(e, t, n, s) {
        var r,
            a,
            _this$standardizeUser,
            _this$standardizeUser2,
            i,
            o,
            l,
            _e188,
            _t230,
            _args73 = arguments;

        return _regeneratorRuntime.wrap(function _callee72$(_context73) {
          while (1) {
            switch (_context73.prev = _context73.next) {
              case 0:
                r = _args73.length > 4 && _args73[4] !== undefined ? _args73[4] : !0;
                a = _args73.length > 5 ? _args73[5] : undefined;
                _this$standardizeUser = this.standardizeUserDataXY(e, t, r, a), _this$standardizeUser2 = _slicedToArray(_this$standardizeUser, 2), i = _this$standardizeUser2[0], o = _this$standardizeUser2[1];

                if (!(null != n)) {
                  _context73.next = 5;
                  break;
                }

                throw new Error("sample weight is not supported yet.");

              case 5:
                l = null;

                if (!(null != s)) {
                  _context73.next = 19;
                  break;
                }

                _e188 = hd(s, this.outputNames);
                l = [];
                _t230 = 0;

              case 10:
                if (!(_t230 < _e188.length)) {
                  _context73.next = 19;
                  break;
                }

                _context73.t0 = l;
                _context73.next = 14;
                return dd(o[_t230], null, _e188[_t230]);

              case 14:
                _context73.t1 = _context73.sent;

                _context73.t0.push.call(_context73.t0, _context73.t1);

              case 16:
                ++_t230;
                _context73.next = 10;
                break;

              case 19:
                return _context73.abrupt("return", [i, o, l]);

              case 20:
              case "end":
                return _context73.stop();
            }
          }
        }, _callee72, this);
      }));

      function standardizeUserData(_x93, _x94, _x95, _x96) {
        return _standardizeUserData.apply(this, arguments);
      }

      return standardizeUserData;
    }()
  }, {
    key: "testLoop",
    value: function testLoop(e, t, n) {
      var _this74 = this;

      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var r = arguments.length > 4 ? arguments[4] : undefined;
      return Yn(function () {
        var a = _this74.checkNumSamples(t, n, r, "steps"),
            i = [];

        if (s > 0) throw new xu("Verbose mode is not implemented yet.");
        if (null != r) throw new xu("steps mode in testLoop() is not implemented yet");
        {
          var _s96 = kd(a, n),
              _r67 = mi(pc(0, a));

          for (var _n114 = 0; _n114 < _s96.length; ++_n114) {
            var _a55 = _s96[_n114][0],
                _o24 = _s96[_n114][1],
                _l16 = mc(_r67, _a55, _o24 - _a55),
                _u9 = yd(t, _l16),
                _c8 = e(_u9);

            if (0 === _n114) for (var _e189 = 0; _e189 < _c8.length; ++_e189) {
              i.push(qa(0));
            }

            for (var _e190 = 0; _e190 < _c8.length; ++_e190) {
              i[_e190] = es(i[_e190], ss(_o24 - _a55, _c8[_e190]));
            }
          }

          for (var _e191 = 0; _e191 < i.length; ++_e191) {
            i[_e191] = ns(i[_e191], a);
          }
        }
        return i;
      });
    }
  }, {
    key: "getDedupedMetricsNames",
    value: function getDedupedMetricsNames() {
      var e = this.metricsNames,
          t = [];

      for (var _n115 = 0; _n115 < e.length; ++_n115) {
        var _s97 = e[_n115];
        var _r68 = _s97;
        vu(e, _s97) > 1 && (_r68 += "_".concat(vu(e.slice(0, _n115), _s97))), t.push(_r68);
      }

      return t;
    }
  }, {
    key: "makeTrainFunction",
    value: function makeTrainFunction() {
      var _this75 = this;

      return function (e) {
        var t = [],
            n = e.slice(0, _this75.inputs.length),
            s = e.slice(_this75.inputs.length, _this75.inputs.length + _this75.outputs.length),
            r = e.slice(_this75.inputs.length + _this75.outputs.length, _this75.inputs.length + 2 * _this75.outputs.length),
            a = [],
            i = _this75.collectedTrainableWeights.map(function (e) {
          return e.read();
        });

        return [_this75.optimizer_.minimize(function () {
          var e = [];

          for (var _t231 = 0; _t231 < _this75.inputs.length; ++_t231) {
            e.push({
              key: _this75.inputs[_t231],
              value: n[_t231]
            });
          }

          var i = new sd(e),
              o = id(_this75.outputs, i, {
            training: !0
          });
          var l;

          for (var _e192 = 0; _e192 < _this75.lossFunctions.length; ++_e192) {
            var _n116 = (0, _this75.lossFunctions[_e192])(s[_e192], o[_e192]);

            null != r[_e192] && (_n116 = pd(_n116, r[_e192]));

            var _a56 = la(_n116);

            t.push(_a56), l = 0 === _e192 ? _n116 : es(l, _n116);
          }

          for (var _e193 = 0; _e193 < _this75.metricsTensors.length; ++_e193) {
            var _n117 = void 0;

            if (_this75.outputs.length > 1 && _e193 < _this75.outputs.length) _n117 = t[_e193];else {
              var _t232 = _this75.metricsTensors[_e193][1];
              _n117 = la((0, _this75.metricsTensors[_e193][0])(s[_t232], o[_t232]));
            }
            Zn(_n117), a.push(_n117);
          }

          return l = la(l), _this75.calculateLosses().forEach(function (e) {
            l = es(l, e);
          }), l;
        }, !0, i)].concat(a);
      };
    }
  }, {
    key: "makeTestFunction",
    value: function makeTestFunction() {
      var _this76 = this;

      this.testFunction = function (e) {
        return Yn(function () {
          var t = [];
          var n;
          var s = e.slice(0, _this76.inputs.length),
              r = e.slice(_this76.inputs.length, _this76.inputs.length + _this76.outputs.length),
              a = [];

          for (var _e194 = 0; _e194 < _this76.inputs.length; ++_e194) {
            a.push({
              key: _this76.inputs[_e194],
              value: s[_e194]
            });
          }

          var i = new sd(a),
              o = id(_this76.outputs, i);

          for (var _e195 = 0; _e195 < _this76.lossFunctions.length; ++_e195) {
            var _s98 = la((0, _this76.lossFunctions[_e195])(r[_e195], o[_e195]));

            n = 0 === _e195 ? _s98 : es(n, _s98), t.push(n);
          }

          for (var _e196 = 0; _e196 < _this76.metricsTensors.length; ++_e196) {
            var _n118 = _this76.metricsTensors[_e196][1],
                _s99 = la((0, _this76.metricsTensors[_e196][0])(r[_n118], o[_n118]));

            t.push(_s99);
          }

          return t;
        });
      };
    }
  }, {
    key: "fit",
    value: function () {
      var _fit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee76(e, t) {
        var n,
            _args79 = arguments;
        return _regeneratorRuntime.wrap(function _callee76$(_context79) {
          while (1) {
            switch (_context79.prev = _context79.next) {
              case 0:
                n = _args79.length > 2 && _args79[2] !== undefined ? _args79[2] : {};
                return _context79.abrupt("return", function () {
                  var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee75(e, t, n) {
                    var s,
                        a,
                        i,
                        o,
                        l,
                        u,
                        c,
                        h,
                        _d5,
                        _p5,
                        _f4,
                        _g6,
                        _m5,
                        _t233,
                        _n119,
                        _e197,
                        _t234,
                        _b5,
                        _x102,
                        _y5,
                        _k3,
                        _w2,
                        _v2,
                        _args78 = arguments;

                    return _regeneratorRuntime.wrap(function _callee75$(_context78) {
                      while (1) {
                        switch (_context78.prev = _context78.next) {
                          case 0:
                            s = _args78.length > 3 && _args78[3] !== undefined ? _args78[3] : {};

                            if (!e.isTraining) {
                              _context78.next = 3;
                              break;
                            }

                            throw new Error("Cannot start training because another fit() call is ongoing.");

                          case 3:
                            e.isTraining = !0;
                            _context78.prev = 4;
                            _d5 = null == s.batchSize ? 32 : s.batchSize;
                            bd(_d5);
                            _p5 = !1;
                            _context78.next = 10;
                            return e.standardizeUserData(t, n, s.sampleWeight, s.classWeight, _p5, _d5);

                          case 10:
                            _f4 = _context78.sent;
                            a = _f4[0], i = _f4[1], h = _f4[2];
                            _m5 = !1;

                            if (!(null != s.validationData && s.validationData.length > 0)) {
                              _context78.next = 24;
                              break;
                            }

                            if (!(_m5 = !0, 2 !== s.validationData.length)) {
                              _context78.next = 16;
                              break;
                            }

                            throw 3 === s.validationData.length ? new xu("validationData including sample weights is not supported yet.") : new bu("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ".concat(s.validationData, " is invalid."));

                          case 16:
                            o = s.validationData[0], l = s.validationData[1];
                            _t233 = !0;
                            _context78.next = 20;
                            return e.standardizeUserData(o, l, null, null, _t233, _d5);

                          case 20:
                            _n119 = _context78.sent;
                            u = _n119[0], c = _n119[1], _g6 = u.concat(c);
                            _context78.next = 25;
                            break;

                          case 24:
                            if (null != s.validationSplit && s.validationSplit > 0 && s.validationSplit < 1) {
                              _m5 = !0;
                              _e197 = Math.floor(a[0].shape[0] * (1 - s.validationSplit)), _t234 = a[0].shape[0];
                              u = xd(a, _e197, _t234), a = xd(a, 0, _e197), c = xd(i, _e197, _t234), i = xd(i, 0, _e197), _g6 = u.concat(c);
                            } else null != s.validationSteps && (_m5 = !0);

                          case 25:
                            _b5 = a.concat(i).concat(h);
                            e.checkTrainableWeightsConsistency();
                            _x102 = e.makeTrainFunction(), _y5 = e.getDedupedMetricsNames();
                            _m5 ? (e.makeTestFunction(), _k3 = e.testFunction, _w2 = _y5.slice().concat(_y5.map(function (e) {
                              return "val_" + e;
                            }))) : (_k3 = null, _g6 = [], _w2 = _y5.slice());
                            _v2 = Ch(s.callbacks, s.yieldEvery);
                            _context78.next = 32;
                            return function () {
                              var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee74(e, t, n, s, a, i, o, l, u, c, h, d, p, f, g) {
                                var m, b, x, _Th, y, k, _loop22, _o25, _ret2;

                                return _regeneratorRuntime.wrap(function _callee74$(_context77) {
                                  while (1) {
                                    switch (_context77.prev = _context77.next) {
                                      case 0:
                                        null == a && (a = 32), null == i && (i = 1), null == h && (h = !0), null == p && (p = 0);
                                        m = !1;
                                        null != u && null != c && (m = !0);
                                        b = e.checkNumSamples(n, a, null, "steps_per_epoch");
                                        null != b && (x = pc(0, b)), null == o && (o = 1);
                                        _Th = Th(l, o, i, p, b, null, a, m, d), y = _Th.callbackList, k = _Th.history;
                                        y.setModel(e);
                                        e.history = k;
                                        _context77.next = 10;
                                        return y.onTrainBegin();

                                      case 10:
                                        e.stopTraining_ = !1;
                                        _loop22 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop22(_o25) {
                                          var i;
                                          return _regeneratorRuntime.wrap(function _loop22$(_context76) {
                                            while (1) {
                                              switch (_context76.prev = _context76.next) {
                                                case 0:
                                                  _context76.next = 2;
                                                  return y.onEpochBegin(_o25);

                                                case 2:
                                                  i = {};
                                                  return _context76.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee73() {
                                                    var o, l, _loop23, _r69, _ret3;

                                                    return _regeneratorRuntime.wrap(function _callee73$(_context75) {
                                                      while (1) {
                                                        switch (_context75.prev = _context75.next) {
                                                          case 0:
                                                            if (!("batch" === h)) {
                                                              _context75.next = 2;
                                                              break;
                                                            }

                                                            throw new xu("batch shuffling is not implemneted yet");

                                                          case 2:
                                                            h && r(x);
                                                            o = mi(x), l = kd(b, a);
                                                            _loop23 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop23(_r69) {
                                                              var h;
                                                              return _regeneratorRuntime.wrap(function _loop23$(_context74) {
                                                                while (1) {
                                                                  switch (_context74.prev = _context74.next) {
                                                                    case 0:
                                                                      h = {};
                                                                      _context74.next = 3;
                                                                      return y.onBatchBegin(_r69, h);

                                                                    case 3:
                                                                      Yn(function () {
                                                                        var d = l[_r69][0],
                                                                            p = l[_r69][1],
                                                                            f = mc(o, d, p - d);
                                                                        h.batch = _r69, h.size = p - d;
                                                                        var g = yd(n, f),
                                                                            b = t(g);

                                                                        for (var _e198 = 0; _e198 < s.length; ++_e198) {
                                                                          var _t235 = b[_e198];
                                                                          h[s[_e198]] = _t235, Zn(_t235);
                                                                        }

                                                                        if (_r69 === l.length - 1 && m) {
                                                                          var _t236 = e.testLoop(u, c, a);

                                                                          for (var _e199 = 0; _e199 < s.length; ++_e199) {
                                                                            var _n120 = s[_e199],
                                                                                _r70 = _t236[_e199];
                                                                            Zn(_r70), i["val_" + _n120] = _r70;
                                                                          }
                                                                        }
                                                                      });
                                                                      _context74.next = 6;
                                                                      return y.onBatchEnd(_r69, h);

                                                                    case 6:
                                                                      yh(h);

                                                                      if (!e.stopTraining_) {
                                                                        _context74.next = 9;
                                                                        break;
                                                                      }

                                                                      return _context74.abrupt("return", "break");

                                                                    case 9:
                                                                    case "end":
                                                                      return _context74.stop();
                                                                  }
                                                                }
                                                              }, _loop23);
                                                            });
                                                            _r69 = 0;

                                                          case 6:
                                                            if (!(_r69 < l.length)) {
                                                              _context75.next = 14;
                                                              break;
                                                            }

                                                            return _context75.delegateYield(_loop23(_r69), "t0", 8);

                                                          case 8:
                                                            _ret3 = _context75.t0;

                                                            if (!(_ret3 === "break")) {
                                                              _context75.next = 11;
                                                              break;
                                                            }

                                                            return _context75.abrupt("break", 14);

                                                          case 11:
                                                            ++_r69;
                                                            _context75.next = 6;
                                                            break;

                                                          case 14:
                                                            o.dispose();

                                                          case 15:
                                                          case "end":
                                                            return _context75.stop();
                                                        }
                                                      }
                                                    }, _callee73);
                                                  })(), "t0", 4);

                                                case 4:
                                                  _context76.next = 6;
                                                  return y.onEpochEnd(_o25, i);

                                                case 6:
                                                  if (!e.stopTraining_) {
                                                    _context76.next = 8;
                                                    break;
                                                  }

                                                  return _context76.abrupt("return", "break");

                                                case 8:
                                                case "end":
                                                  return _context76.stop();
                                              }
                                            }
                                          }, _loop22);
                                        });
                                        _o25 = p;

                                      case 13:
                                        if (!(_o25 < i)) {
                                          _context77.next = 21;
                                          break;
                                        }

                                        return _context77.delegateYield(_loop22(_o25), "t0", 15);

                                      case 15:
                                        _ret2 = _context77.t0;

                                        if (!(_ret2 === "break")) {
                                          _context77.next = 18;
                                          break;
                                        }

                                        return _context77.abrupt("break", 21);

                                      case 18:
                                        ++_o25;
                                        _context77.next = 13;
                                        break;

                                      case 21:
                                        _context77.next = 23;
                                        return y.onTrainEnd();

                                      case 23:
                                        _context77.next = 25;
                                        return e.history.syncData();

                                      case 25:
                                        return _context77.abrupt("return", e.history);

                                      case 26:
                                      case "end":
                                        return _context77.stop();
                                    }
                                  }
                                }, _callee74);
                              }));

                              return function (_x103, _x104, _x105, _x106, _x107, _x108, _x109, _x110, _x111, _x112, _x113, _x114, _x115, _x116, _x117) {
                                return _ref15.apply(this, arguments);
                              };
                            }()(e, _x102, _b5, _y5, _d5, s.epochs, s.verbose, _v2, _k3, _g6, s.shuffle, _w2, s.initialEpoch);

                          case 32:
                            return _context78.abrupt("return", _context78.sent);

                          case 33:
                            _context78.prev = 33;
                            e.isTraining = !1, vd(a, t), vd(i, n), vd(u, o), vd(c, l), null != h && Jn(h);
                            return _context78.finish(33);

                          case 36:
                          case "end":
                            return _context78.stop();
                        }
                      }
                    }, _callee75, null, [[4,, 33, 36]]);
                  }));

                  return function (_x99, _x100, _x101) {
                    return _ref14.apply(this, arguments);
                  };
                }()(this, e, t, n));

              case 2:
              case "end":
                return _context79.stop();
            }
          }
        }, _callee76, this);
      }));

      function fit(_x97, _x98) {
        return _fit.apply(this, arguments);
      }

      return fit;
    }()
  }, {
    key: "fitDataset",
    value: function () {
      var _fitDataset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee78(e, t) {
        return _regeneratorRuntime.wrap(function _callee78$(_context81) {
          while (1) {
            switch (_context81.prev = _context81.next) {
              case 0:
                return _context81.abrupt("return", function () {
                  var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee77(e, t, n) {
                    var s, _r71, a, i, _e200, o, u, c, h, _d6, _Th2, _p6, _f5, _g7, _m6, _l17, _c9, _h6, _t237, _fd2, _s100, _r72, _a57, _i47, _t238, _e201, _l18, _d7, _e202, _t239, _t240, _n121;

                    return _regeneratorRuntime.wrap(function _callee77$(_context80) {
                      while (1) {
                        switch (_context80.prev = _context80.next) {
                          case 0:
                            s = null != n.batchesPerEpoch;

                            if (!(l(null != e.optimizer, function () {
                              return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
                            }), l(null != n, function () {
                              return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
                            }), l(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), function () {
                              return "For fitDataset(), config.epochs is expected to be a positive integer, but got ".concat(n.epochs);
                            }), l(!s || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), function () {
                              return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ".concat(n.batchesPerEpoch);
                            }), l(null == n.validationSplit, function () {
                              return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
                            }), e.isTraining)) {
                              _context80.next = 3;
                              break;
                            }

                            throw new Error("Cannot start training because another fit() call is ongoing.");

                          case 3:
                            e.isTraining = !0;
                            _context80.prev = 4;
                            _r71 = null != n.validationData;
                            if (_r71) if (md(n.validationData)) l(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), function () {
                              return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ".concat(n.validationBatches);
                            });else {
                              _e200 = function (e) {
                                if (3 === e.length) throw new xu("Validation with sample weights is not implemented yet.");
                                return {
                                  xs: e[0],
                                  ys: e[1]
                                };
                              }(n.validationData);

                              a = _e200.xs, i = _e200.ys;
                            }
                            o = e.makeTrainFunction(), u = e.getDedupedMetricsNames();
                            c = _r71 ? u.slice().concat(u.map(function (e) {
                              return "val_" + e;
                            })) : u.slice();
                            h = Ch(n.callbacks, n.yieldEvery), _d6 = null == n.verbose ? 1 : n.verbose, _Th2 = Th(h, _d6, n.epochs, null, null, function (e, t) {
                              var n = null;
                              return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n;
                            }(t, n), null, _r71, c), _p6 = _Th2.callbackList, _f5 = _Th2.history;

                            _p6.setModel(e);

                            e.history = _f5;
                            _context80.next = 14;
                            return _p6.onTrainBegin();

                          case 14:
                            e.stopTraining_ = !1;
                            _g7 = null == n.initialEpoch ? 0 : n.initialEpoch;
                            _context80.next = 18;
                            return t.iterator();

                          case 18:
                            _m6 = _context80.sent;

                          case 19:
                            if (!(_g7 < n.epochs)) {
                              _context80.next = 89;
                              break;
                            }

                            _l17 = {};
                            _context80.next = 23;
                            return _p6.onEpochBegin(_g7);

                          case 23:
                            _c9 = 0, _h6 = 0;
                            _context80.t0 = s;

                            if (_context80.t0) {
                              _context80.next = 29;
                              break;
                            }

                            _context80.next = 28;
                            return t.iterator();

                          case 28:
                            _m6 = _context80.sent;

                          case 29:
                            if (!(!s || _c9 < n.batchesPerEpoch)) {
                              _context80.next = 82;
                              break;
                            }

                            _context80.next = 32;
                            return _m6.next();

                          case 32:
                            _t237 = _context80.sent;

                            if (!(s && _t237.done)) {
                              _context80.next = 36;
                              break;
                            }

                            console.warn("You provided `batchesPerEpoch` as ".concat(n.batchesPerEpoch, ", but your dataset iterator ran out of data after ").concat(_c9, " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, ") + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset.");
                            return _context80.abrupt("break", 82);

                          case 36:
                            if (!(null != _t237.value)) {
                              _context80.next = 63;
                              break;
                            }

                            _fd2 = fd(e, _t237.value), _s100 = _fd2.xs, _r72 = _fd2.ys, _a57 = {};
                            _a57.batch = _h6;
                            _a57.size = _s100[0].shape[0];
                            _context80.next = 42;
                            return _p6.onBatchBegin(_h6, _a57);

                          case 42:
                            _i47 = [];

                            if (!(null != n.classWeight)) {
                              _context80.next = 55;
                              break;
                            }

                            _t238 = hd(n.classWeight, e.outputNames);
                            _e201 = 0;

                          case 46:
                            if (!(_e201 < _t238.length)) {
                              _context80.next = 55;
                              break;
                            }

                            _context80.t1 = _i47;
                            _context80.next = 50;
                            return dd(_r72[_e201], null, _t238[_e201]);

                          case 50:
                            _context80.t2 = _context80.sent;

                            _context80.t1.push.call(_context80.t1, _context80.t2);

                          case 52:
                            ++_e201;
                            _context80.next = 46;
                            break;

                          case 55:
                            _l18 = _s100.concat(_r72).concat(_i47), _d7 = o(_l18);
                            Jn(_l18);

                            for (_e202 = 0; _e202 < u.length; ++_e202) {
                              _t239 = _d7[_e202];
                              _a57[u[_e202]] = _t239, Zn(_t239);
                            }

                            _context80.next = 60;
                            return _p6.onBatchEnd(_h6, _a57);

                          case 60:
                            yh(_a57);
                            _h6++;
                            _c9++;

                          case 63:
                            if (!(s ? _c9 >= n.batchesPerEpoch : _t237.done)) {
                              _context80.next = 78;
                              break;
                            }

                            if (!_r71) {
                              _context80.next = 77;
                              break;
                            }

                            _t240 = void 0;

                            if (!md(n.validationData)) {
                              _context80.next = 74;
                              break;
                            }

                            _context80.t4 = $u;
                            _context80.next = 70;
                            return e.evaluateDataset(n.validationData, {
                              batches: n.validationBatches
                            });

                          case 70:
                            _context80.t5 = _context80.sent;
                            _context80.t3 = (0, _context80.t4)(_context80.t5);
                            _context80.next = 75;
                            break;

                          case 74:
                            _context80.t3 = $u(e.evaluate(a, i, {
                              batchSize: null == n.validationBatchSize ? 32 : n.validationBatchSize,
                              verbose: 0
                            }));

                          case 75:
                            _t240 = _context80.t3;

                            for (_n121 = 0; _n121 < e.metricsNames.length; ++_n121) {
                              _l17["val_".concat(e.metricsNames[_n121])] = _t240[_n121];
                            }

                          case 77:
                            return _context80.abrupt("break", 82);

                          case 78:
                            if (!e.stopTraining_) {
                              _context80.next = 80;
                              break;
                            }

                            return _context80.abrupt("break", 82);

                          case 80:
                            _context80.next = 29;
                            break;

                          case 82:
                            _context80.next = 84;
                            return _p6.onEpochEnd(_g7, _l17);

                          case 84:
                            _g7++;

                            if (!e.stopTraining_) {
                              _context80.next = 87;
                              break;
                            }

                            return _context80.abrupt("break", 89);

                          case 87:
                            _context80.next = 19;
                            break;

                          case 89:
                            _context80.next = 91;
                            return _p6.onTrainEnd();

                          case 91:
                            _context80.next = 93;
                            return e.history.syncData();

                          case 93:
                            return _context80.abrupt("return", e.history);

                          case 94:
                            _context80.prev = 94;
                            e.isTraining = !1;
                            return _context80.finish(94);

                          case 97:
                          case "end":
                            return _context80.stop();
                        }
                      }
                    }, _callee77, null, [[4,, 94, 97]]);
                  }));

                  return function (_x120, _x121, _x122) {
                    return _ref16.apply(this, arguments);
                  };
                }()(this, e, t));

              case 1:
              case "end":
                return _context81.stop();
            }
          }
        }, _callee78, this);
      }));

      function fitDataset(_x118, _x119) {
        return _fitDataset.apply(this, arguments);
      }

      return fitDataset;
    }()
  }, {
    key: "trainOnBatch",
    value: function () {
      var _trainOnBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee79(e, t) {
        var n, s, r, a, i, _iterator86, _step86, _e203, _t241;

        return _regeneratorRuntime.wrap(function _callee79$(_context82) {
          while (1) {
            switch (_context82.prev = _context82.next) {
              case 0:
                _context82.next = 2;
                return this.standardizeUserData(e, t);

              case 2:
                n = _context82.sent;
                s = n[0];
                r = n[1];
                a = this.makeTrainFunction()(s.concat(r));
                i = [];
                _iterator86 = _createForOfIteratorHelper(a);
                _context82.prev = 8;

                _iterator86.s();

              case 10:
                if ((_step86 = _iterator86.n()).done) {
                  _context82.next = 18;
                  break;
                }

                _e203 = _step86.value;
                _context82.next = 14;
                return _e203.data();

              case 14:
                _t241 = _context82.sent;
                i.push(_t241[0]);

              case 16:
                _context82.next = 10;
                break;

              case 18:
                _context82.next = 23;
                break;

              case 20:
                _context82.prev = 20;
                _context82.t0 = _context82["catch"](8);

                _iterator86.e(_context82.t0);

              case 23:
                _context82.prev = 23;

                _iterator86.f();

                return _context82.finish(23);

              case 26:
                return _context82.abrupt("return", (Jn(a), Iu(i)));

              case 27:
              case "end":
                return _context82.stop();
            }
          }
        }, _callee79, this, [[8, 20, 23, 26]]);
      }));

      function trainOnBatch(_x123, _x124) {
        return _trainOnBatch.apply(this, arguments);
      }

      return trainOnBatch;
    }()
  }, {
    key: "getNamedWeights",
    value: function getNamedWeights(e) {
      var t = [],
          n = null != e && e.trainableOnly,
          s = n ? this.trainableWeights : this.weights,
          r = this.getWeights(n);

      for (var _e204 = 0; _e204 < s.length; ++_e204) {
        n && !s[_e204].trainable || t.push({
          name: s[_e204].originalName,
          tensor: r[_e204]
        });
      }

      return t;
    }
  }, {
    key: "stopTraining",
    get: function get() {
      return this.stopTraining_;
    },
    set: function set(e) {
      this.stopTraining_ = e;
    }
  }, {
    key: "optimizer",
    get: function get() {
      return this.optimizer_;
    },
    set: function set(e) {
      this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var e = _get(_getPrototypeOf(Sd.prototype), "dispose", this).call(this);

      if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
        var t = Xn().numTensors;
        this.optimizer_.dispose(), e.numDisposedVariables += t - Xn().numTensors;
      }

      return e;
    }
  }, {
    key: "getLossIdentifiers",
    value: function getLossIdentifiers() {
      var e;
      if ("string" == typeof this.loss) e = Nu(this.loss);else if (Array.isArray(this.loss)) {
        var _iterator87 = _createForOfIteratorHelper(this.loss),
            _step87;

        try {
          for (_iterator87.s(); !(_step87 = _iterator87.n()).done;) {
            var _e205 = _step87.value;
            if ("string" != typeof _e205) throw new Error("Serialization of non-string loss is not supported.");
          }
        } catch (err) {
          _iterator87.e(err);
        } finally {
          _iterator87.f();
        }

        e = this.loss.map(function (e) {
          return Nu(e);
        });
      } else {
        var t = Object.keys(this.loss);
        e = {};
        var _n122 = this.loss;

        for (var _i48 = 0, _t242 = t; _i48 < _t242.length; _i48++) {
          var _s101 = _t242[_i48];
          if ("string" != typeof _n122[_s101]) throw new Error("Serialization of non-string loss is not supported.");
          e[_s101] = Nu(_n122[_s101]);
        }
      }
      return e;
    }
  }, {
    key: "getMetricIdentifiers",
    value: function getMetricIdentifiers() {
      if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [Nu(Kh(this.metrics))];
      if (Array.isArray(this.metrics)) return this.metrics.map(function (e) {
        return Nu(Kh(e));
      });
      {
        var _e206 = {};

        for (var t in this.metrics) {
          _e206[t] = Nu(Kh(this.metrics[t]));
        }

        return _e206;
      }
    }
  }, {
    key: "getTrainingConfig",
    value: function getTrainingConfig() {
      return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
          class_name: this.optimizer.getClassName(),
          config: this.optimizer.getConfig()
        }
      };
    }
  }, {
    key: "loadTrainingConfig",
    value: function loadTrainingConfig(e) {
      if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
      if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
      if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
      var t = Eh(td(e.optimizer_config));
      var n, s;
      if ("string" == typeof e.loss) n = Cu(e.loss);else if (Array.isArray(e.loss)) n = e.loss.map(function (e) {
        return Cu(e);
      });else if (null != e.loss) {
        n = {};

        for (var _t243 in e.loss) {
          n[_t243] = Cu(e.loss[_t243]);
        }
      }
      if (Array.isArray(e.metrics)) s = e.metrics.map(function (e) {
        return Cu(e);
      });else if (null != e.metrics) {
        s = {};

        for (var _t244 in e.metrics) {
          s[_t244] = Cu(e.metrics[_t244]);
        }
      }
      this.compile({
        loss: n,
        metrics: s,
        optimizer: t
      });
    }
  }, {
    key: "save",
    value: function () {
      var _save5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee80(e, t) {
        var _t245, n, s, _n$specs, _e207, _yield$Mt, _t246, _r73;

        return _regeneratorRuntime.wrap(function _callee80$(_context83) {
          while (1) {
            switch (_context83.prev = _context83.next) {
              case 0:
                if (!("string" == typeof e)) {
                  _context83.next = 7;
                  break;
                }

                _t245 = Gt.getSaveHandlers(e);

                if (!(0 === _t245.length)) {
                  _context83.next = 4;
                  break;
                }

                throw new bu("Cannot find any save handlers for URL '".concat(e, "'"));

              case 4:
                if (!(_t245.length > 1)) {
                  _context83.next = 6;
                  break;
                }

                throw new bu("Found more than one (".concat(_t245.length, ") save handlers for URL '").concat(e, "'"));

              case 6:
                e = _t245[0];

              case 7:
                if (!(null == e.save)) {
                  _context83.next = 9;
                  break;
                }

                throw new bu("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");

              case 9:
                _context83.next = 11;
                return Mt(this.getNamedWeights(t));

              case 11:
                n = _context83.sent;
                s = {
                  modelTopology: this.toJSON(null, !1),
                  format: "layers-model",
                  generatedBy: "TensorFlow.js tfjs-layers v3.8.0",
                  convertedBy: null
                };

                if (!(null != t && t.includeOptimizer && null != this.optimizer)) {
                  _context83.next = 27;
                  break;
                }

                s.trainingConfig = this.getTrainingConfig();
                _e207 = "optimizer";
                _context83.t0 = Mt;
                _context83.next = 19;
                return this.optimizer.getWeights();

              case 19:
                _context83.t1 = _context83.sent;
                _context83.t2 = _e207;
                _context83.next = 23;
                return (0, _context83.t0)(_context83.t1, _context83.t2);

              case 23:
                _yield$Mt = _context83.sent;
                _t246 = _yield$Mt.data;
                _r73 = _yield$Mt.specs;
                (_n$specs = n.specs).push.apply(_n$specs, _toConsumableArray(_r73)), n.data = Pt([n.data, _t246]);

              case 27:
                return _context83.abrupt("return", (null != this.userDefinedMetadata && (Xh(this.userDefinedMetadata, this.name, !0), s.userDefinedMetadata = this.userDefinedMetadata), s.weightData = n.data, s.weightSpecs = n.specs, e.save(s)));

              case 28:
              case "end":
                return _context83.stop();
            }
          }
        }, _callee80, this);
      }));

      function save(_x125, _x126) {
        return _save5.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: "setUserDefinedMetadata",
    value: function setUserDefinedMetadata(e) {
      Xh(e, this.name), this.userDefinedMetadata = e;
    }
  }, {
    key: "getUserDefinedMetadata",
    value: function getUserDefinedMetadata() {
      return this.userDefinedMetadata;
    }
  }]);

  return Sd;
}(cd);

Sd.className = "Model", qn(Sd);

var Td = /*#__PURE__*/function (_Sd) {
  "use strict";

  _inherits(Td, _Sd);

  var _super43 = _createSuper(Td);

  function Td() {
    _classCallCheck(this, Td);

    return _super43.apply(this, arguments);
  }

  return Td;
}(Sd);

Td.className = "Functional", qn(Td);

var Ed = /*#__PURE__*/function (_Sd2) {
  "use strict";

  _inherits(Ed, _Sd2);

  var _super44 = _createSuper(Ed);

  function Ed(e) {
    var _this77;

    _classCallCheck(this, Ed);

    if (_this77 = _super44.call(this, {
      inputs: [],
      outputs: []
    }), e = e || {}, _this77.trainable = !0, _this77.built = !1, _this77.name = null != e.name ? e.name : th("sequential_"), null != e.layers) {
      var _iterator88 = _createForOfIteratorHelper(e.layers),
          _step88;

      try {
        for (_iterator88.s(); !(_step88 = _iterator88.n()).done;) {
          var t = _step88.value;

          _this77.add(t);
        }
      } catch (err) {
        _iterator88.e(err);
      } finally {
        _iterator88.f();
      }
    }

    return _possibleConstructorReturn(_this77);
  }

  _createClass(Ed, [{
    key: "checkShape",
    value: function checkShape(e) {
      if (e.inboundNodes[0].outputTensors[0].shape.some(function (e) {
        return e < 0;
      })) throw new bu("Negative dimension size caused by adding layer ".concat(e.name, " with input shape [").concat(e.inboundNodes[0].inputTensors[0].shape, "]"));
    }
  }, {
    key: "add",
    value: function add(e) {
      var t = e instanceof Ed || e instanceof Sd;
      var n;

      if (t) {
        if (n = e, 1 !== n.outputs.length) throw new bu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        if (1 !== n.inputs.length) throw new bu("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
      }

      if (0 === this.outputs.length) {
        if (0 === e.inboundNodes.length) {
          if (null == e.batchInputShape) throw new bu("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");

          var _t247 = function (e) {
            if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
            if (null != e.batchShape && null != e.shape) throw new bu("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
            var t = e.batchShape;
            null != e.shape && null == t && (t = [null].concat(e.shape));
            var n = e.dtype;
            return null == n && (n = "float32"), new bh({
              batchInputShape: t,
              name: e.name,
              dtype: n,
              sparse: e.sparse
            }).inboundNodes[0].outputTensors[0];
          }({
            batchShape: e.batchInputShape,
            dtype: e.dtype,
            name: e.name + "_input"
          });

          e.apply(_t247);
        }

        if (t) this.outputs = n.outputs, this.inputs = n.inputs;else {
          if (1 !== e.inboundNodes.length) throw new bu("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ".concat(e.name, " which has ").concat(e.inboundNodes.length, " pre-existing inbound connections."));
          if (1 !== e.inboundNodes[0].outputTensors.length) throw new bu("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = mh(this.outputs[0]);
        }
        this.inboundNodes = [], new ph({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: ku(null, this.inputs.length),
          outputMasks: [null],
          inputShapes: this.inputs.map(function (e) {
            return e.shape;
          }),
          outputShapes: this.outputs[0].shape
        });
      } else {
        var _t248 = e.apply(this.outputs[0]);

        if (Array.isArray(_t248)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [_t248], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }

      this.layers.push(e), this.built = !1;
    }
  }, {
    key: "pop",
    value: function pop() {
      if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];else {
        var _e208 = this.layers.length - 1;

        this.layers[_e208].outboundNodes = [], this.outputs = [this.layers[_e208].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
    }
  }, {
    key: "call",
    value: function call(e, t) {
      return null == this.model && this.build(), this.model.call(e, t);
    }
  }, {
    key: "build",
    value: function build(e) {
      if (ah(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new Sd({
        inputs: this.inputs,
        outputs: this.outputs[0],
        name: this.name + "_model"
      }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
    }
  }, {
    key: "countParams",
    value: function countParams() {
      return this.built || this.build(), _get(_getPrototypeOf(Ed.prototype), "countParams", this).call(this);
    }
  }, {
    key: "summary",
    value: function summary(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : console.log;
      this.built || this.build(), _get(_getPrototypeOf(Ed.prototype), "summary", this).call(this, e, t, n);
    }
  }, {
    key: "setWeights",
    value: function setWeights(e) {
      null == this.model && this.build(), this.model.setWeights(e);
    }
  }, {
    key: "evaluate",
    value: function evaluate(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!this.built) throw new mu("The model needs to be compiled before being used.");
      return this.model.evaluate(e, t, n);
    }
  }, {
    key: "evaluateDataset",
    value: function () {
      var _evaluateDataset2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee81(e, t) {
        return _regeneratorRuntime.wrap(function _callee81$(_context84) {
          while (1) {
            switch (_context84.prev = _context84.next) {
              case 0:
                if (this.built) {
                  _context84.next = 2;
                  break;
                }

                throw new mu("The model needs to be compiled before being used.");

              case 2:
                return _context84.abrupt("return", this.model.evaluateDataset(e, t));

              case 3:
              case "end":
                return _context84.stop();
            }
          }
        }, _callee81, this);
      }));

      function evaluateDataset(_x127, _x128) {
        return _evaluateDataset2.apply(this, arguments);
      }

      return evaluateDataset;
    }()
  }, {
    key: "predict",
    value: function predict(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return null == this.model && this.build(), this.model.predict(e, t);
    }
  }, {
    key: "predictOnBatch",
    value: function predictOnBatch(e) {
      return null == this.model && this.build(), this.model.predictOnBatch(e);
    }
  }, {
    key: "compile",
    value: function compile(e) {
      this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
    }
  }, {
    key: "optimizer",
    get: function get() {
      return null == this.model ? void 0 : this.model.optimizer;
    },
    set: function set(e) {
      this.model.optimizer = e;
    }
  }, {
    key: "fit",
    value: function () {
      var _fit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee82(e, t) {
        var n,
            _args85 = arguments;
        return _regeneratorRuntime.wrap(function _callee82$(_context85) {
          while (1) {
            switch (_context85.prev = _context85.next) {
              case 0:
                n = _args85.length > 2 && _args85[2] !== undefined ? _args85[2] : {};

                if (this.built) {
                  _context85.next = 3;
                  break;
                }

                throw new mu("The model needs to be compiled before being used.");

              case 3:
                return _context85.abrupt("return", this.model.fit(e, t, n));

              case 4:
              case "end":
                return _context85.stop();
            }
          }
        }, _callee82, this);
      }));

      function fit(_x129, _x130) {
        return _fit2.apply(this, arguments);
      }

      return fit;
    }()
  }, {
    key: "fitDataset",
    value: function () {
      var _fitDataset2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee83(e, t) {
        return _regeneratorRuntime.wrap(function _callee83$(_context86) {
          while (1) {
            switch (_context86.prev = _context86.next) {
              case 0:
                if (this.built) {
                  _context86.next = 2;
                  break;
                }

                throw new mu("The model needs to be compiled before being used.");

              case 2:
                return _context86.abrupt("return", this.model.fitDataset(e, t));

              case 3:
              case "end":
                return _context86.stop();
            }
          }
        }, _callee83, this);
      }));

      function fitDataset(_x131, _x132) {
        return _fitDataset2.apply(this, arguments);
      }

      return fitDataset;
    }()
  }, {
    key: "trainOnBatch",
    value: function () {
      var _trainOnBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee84(e, t) {
        return _regeneratorRuntime.wrap(function _callee84$(_context87) {
          while (1) {
            switch (_context87.prev = _context87.next) {
              case 0:
                return _context87.abrupt("return", this.model.trainOnBatch(e, t));

              case 1:
              case "end":
                return _context87.stop();
            }
          }
        }, _callee84, this);
      }));

      function trainOnBatch(_x133, _x134) {
        return _trainOnBatch2.apply(this, arguments);
      }

      return trainOnBatch;
    }()
  }, {
    key: "stopTraining",
    get: function get() {
      if (null == this.model) throw new bu("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    },
    set: function set(e) {
      if (null == this.model) throw new bu("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = [];

      var _iterator89 = _createForOfIteratorHelper(this.layers),
          _step89;

      try {
        for (_iterator89.s(); !(_step89 = _iterator89.n()).done;) {
          var t = _step89.value;
          var _n123 = {};
          _n123.className = t.getClassName(), _n123.config = t.getConfig(), e.push(_n123);
        }
      } catch (err) {
        _iterator89.e(err);
      } finally {
        _iterator89.f();
      }

      return {
        name: this.name,
        layers: e
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      var r,
          a = {};

      if (t instanceof Array) {
        if (null == t[0].className || "Merge" === t[0].className) throw new bu("Legacy serialization format not supported yet.");
        r = t;
      } else l(null != t.layers, function () {
        return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
      }), r = t.layers, delete t.layers, a = t;

      var i = new e(a);
      if (!(i instanceof Ed)) throw new xu("Sequential.fromConfig called on non-Sequential input: ".concat(i));

      var _iterator90 = _createForOfIteratorHelper(r),
          _step90;

      try {
        for (_iterator90.s(); !(_step90 = _iterator90.n()).done;) {
          var _e209 = _step90.value;

          var _t249 = Eh(_e209, void 0, s);

          s && _t249.setFastWeightInitDuringBuild(!0), i.add(_t249);
        }
      } catch (err) {
        _iterator90.e(err);
      } finally {
        _iterator90.f();
      }

      return i;
    }
  }]);

  return Ed;
}(Sd);

Ed.className = "Sequential", qn(Ed);

var Rd = /*#__PURE__*/function (_Hn5) {
  "use strict";

  _inherits(Rd, _Hn5);

  var _super45 = _createSuper(Rd);

  function Rd() {
    _classCallCheck(this, Rd);

    return _super45.apply(this, arguments);
  }

  _createClass(Rd, [{
    key: "getConfig",
    value: function getConfig() {
      return {};
    }
  }]);

  return Rd;
}(Hn);

var Ad = /*#__PURE__*/function (_Rd) {
  "use strict";

  _inherits(Ad, _Rd);

  var _super46 = _createSuper(Ad);

  function Ad() {
    _classCallCheck(this, Ad);

    return _super46.apply(this, arguments);
  }

  _createClass(Ad, [{
    key: "apply",
    value: function apply(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return function (e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        if (1 !== t) throw new xu("Support for alpha values other than 1 (".concat(t, ") is not implemented yet."));
        return mr(e);
      }(e, t);
    }
  }]);

  return Ad;
}(Rd);

Ad.className = "elu", qn(Ad);

var Fd = /*#__PURE__*/function (_Rd2) {
  "use strict";

  _inherits(Fd, _Rd2);

  var _super47 = _createSuper(Fd);

  function Fd() {
    _classCallCheck(this, Fd);

    return _super47.apply(this, arguments);
  }

  _createClass(Fd, [{
    key: "apply",
    value: function apply(e) {
      return Ka(e);
    }
  }]);

  return Fd;
}(Rd);

Fd.className = "selu", qn(Fd);

var Dd = /*#__PURE__*/function (_Rd3) {
  "use strict";

  _inherits(Dd, _Rd3);

  var _super48 = _createSuper(Dd);

  function Dd() {
    _classCallCheck(this, Dd);

    return _super48.apply(this, arguments);
  }

  _createClass(Dd, [{
    key: "apply",
    value: function apply(e) {
      return Ua(e);
    }
  }]);

  return Dd;
}(Rd);

Dd.className = "relu", qn(Dd);

var _d = /*#__PURE__*/function (_Rd4) {
  "use strict";

  _inherits(_d, _Rd4);

  var _super49 = _createSuper(_d);

  function _d() {
    _classCallCheck(this, _d);

    return _super49.apply(this, arguments);
  }

  _createClass(_d, [{
    key: "apply",
    value: function apply(e) {
      return Yn(function () {
        return da(6, Ua(e));
      });
    }
  }]);

  return _d;
}(Rd);

_d.className = "relu6", qn(_d);

var Od = /*#__PURE__*/function (_Rd5) {
  "use strict";

  _inherits(Od, _Rd5);

  var _super50 = _createSuper(Od);

  function Od() {
    _classCallCheck(this, Od);

    return _super50.apply(this, arguments);
  }

  _createClass(Od, [{
    key: "apply",
    value: function apply(e) {
      return e;
    }
  }]);

  return Od;
}(Rd);

Od.className = "linear", qn(Od);

var Md = /*#__PURE__*/function (_Rd6) {
  "use strict";

  _inherits(Md, _Rd6);

  var _super51 = _createSuper(Md);

  function Md() {
    _classCallCheck(this, Md);

    return _super51.apply(this, arguments);
  }

  _createClass(Md, [{
    key: "apply",
    value: function apply(e) {
      return Ds(e);
    }
  }]);

  return Md;
}(Rd);

Md.className = "sigmoid", qn(Md);

var Ld = /*#__PURE__*/function (_Rd7) {
  "use strict";

  _inherits(Ld, _Rd7);

  var _super52 = _createSuper(Ld);

  function Ld() {
    _classCallCheck(this, Ld);

    return _super52.apply(this, arguments);
  }

  _createClass(Ld, [{
    key: "apply",
    value: function apply(e) {
      return function (e) {
        return Yn(function () {
          var t = es(.5, ss(.2, e));
          return Gs(t, 0, 1);
        });
      }(e);
    }
  }]);

  return Ld;
}(Rd);

Ld.className = "hardSigmoid", qn(Ld);

var zd = /*#__PURE__*/function (_Rd8) {
  "use strict";

  _inherits(zd, _Rd8);

  var _super53 = _createSuper(zd);

  function zd() {
    _classCallCheck(this, zd);

    return _super53.apply(this, arguments);
  }

  _createClass(zd, [{
    key: "apply",
    value: function apply(e) {
      return Pr(e);
    }
  }]);

  return zd;
}(Rd);

zd.className = "softplus", qn(zd);

var Bd = /*#__PURE__*/function (_Rd9) {
  "use strict";

  _inherits(Bd, _Rd9);

  var _super54 = _createSuper(Bd);

  function Bd() {
    _classCallCheck(this, Bd);

    return _super54.apply(this, arguments);
  }

  _createClass(Bd, [{
    key: "apply",
    value: function apply(e) {
      return function (e) {
        return Yn(function () {
          return ns(e, es(rs(e), 1));
        });
      }(e);
    }
  }]);

  return Bd;
}(Rd);

Bd.className = "softsign", qn(Bd);

var Pd = /*#__PURE__*/function (_Rd10) {
  "use strict";

  _inherits(Pd, _Rd10);

  var _super55 = _createSuper(Pd);

  function Pd() {
    _classCallCheck(this, Pd);

    return _super55.apply(this, arguments);
  }

  _createClass(Pd, [{
    key: "apply",
    value: function apply(e) {
      return Os(e);
    }
  }]);

  return Pd;
}(Rd);

Pd.className = "tanh", qn(Pd);

var Wd = /*#__PURE__*/function (_Rd11) {
  "use strict";

  _inherits(Wd, _Rd11);

  var _super56 = _createSuper(Wd);

  function Wd() {
    _classCallCheck(this, Wd);

    return _super56.apply(this, arguments);
  }

  _createClass(Wd, [{
    key: "apply",
    value: function apply(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      return si(e, t);
    }
  }]);

  return Wd;
}(Rd);

Wd.className = "softmax", qn(Wd);

var Ud = /*#__PURE__*/function (_Rd12) {
  "use strict";

  _inherits(Ud, _Rd12);

  var _super57 = _createSuper(Ud);

  function Ud() {
    _classCallCheck(this, Ud);

    return _super57.apply(this, arguments);
  }

  _createClass(Ud, [{
    key: "apply",
    value: function apply(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      return Hr(e, t);
    }
  }]);

  return Ud;
}(Rd);

Ud.className = "logSoftmax", qn(Ud);

var Vd = /*#__PURE__*/function (_Rd13) {
  "use strict";

  _inherits(Vd, _Rd13);

  var _super58 = _createSuper(Vd);

  function Vd() {
    _classCallCheck(this, Vd);

    return _super58.apply(this, arguments);
  }

  _createClass(Vd, [{
    key: "apply",
    value: function apply(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return Yn(function () {
        return ss(Ds(ss(e, t)), e);
      });
    }
  }]);

  return Vd;
}(Rd);

Vd.className = "swish", qn(Vd);

var Gd = /*#__PURE__*/function (_Rd14) {
  "use strict";

  _inherits(Gd, _Rd14);

  var _super59 = _createSuper(Gd);

  function Gd() {
    _classCallCheck(this, Gd);

    return _super59.apply(this, arguments);
  }

  _createClass(Gd, [{
    key: "apply",
    value: function apply(e) {
      return Yn(function () {
        return ss(e, Os(Pr(e)));
      });
    }
  }]);

  return Gd;
}(Rd);

function Hd(e) {
  return e.getClassName();
}

function jd(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "activation");
}

function qd(e) {
  if (null == e) return jd({
    className: "linear",
    config: {}
  });

  if ("string" == typeof e) {
    var t = {};
    return t.className = e, t.config = {}, jd(t);
  }

  return e instanceof Rd ? e : jd(e);
}

Gd.className = "mish", qn(Gd);

var Kd = /*#__PURE__*/function (_Hn6) {
  "use strict";

  _inherits(Kd, _Hn6);

  var _super60 = _createSuper(Kd);

  function Kd() {
    _classCallCheck(this, Kd);

    return _super60.apply(this, arguments);
  }

  return Kd;
}(Hn);

var Xd = /*#__PURE__*/function (_Kd) {
  "use strict";

  _inherits(Xd, _Kd);

  var _super61 = _createSuper(Xd);

  function Xd(e) {
    var _this78;

    _classCallCheck(this, Xd);

    _this78 = _super61.call(this), function (e) {
      if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: ".concat(e));
    }(e), _this78.l1 = null == e || null == e.l1 ? .01 : e.l1, _this78.l2 = null == e || null == e.l2 ? .01 : e.l2, _this78.hasL1 = 0 !== _this78.l1, _this78.hasL2 = 0 !== _this78.l2;
    return _this78;
  }

  _createClass(Xd, [{
    key: "apply",
    value: function apply(e) {
      var _this79 = this;

      return Yn(function () {
        var t = ua([1]);
        return _this79.hasL1 && (t = es(t, Gr(ss(_this79.l1, rs(e))))), _this79.hasL2 && (t = es(t, Gr(ss(_this79.l2, Nc(e))))), Es(t, []);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      return {
        l1: this.l1,
        l2: this.l2
      };
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e({
        l1: t.l1,
        l2: t.l2
      });
    }
  }]);

  return Xd;
}(Kd);

Xd.className = "L1L2", qn(Xd);
var Yd = {
  l1l2: "L1L2"
};

function Jd(e) {
  return Tu(e);
}

function Zd(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Ru(e, jn.getMap().classNameMap, t, "regularizer");
}

function Qd(e) {
  return null == e ? null : "string" == typeof e ? Zd({
    className: e in Yd ? Yd[e] : e,
    config: {}
  }) : e instanceof Kd ? e : Zd(e);
}

var ep = /*#__PURE__*/function (_gh3) {
  "use strict";

  _inherits(ep, _gh3);

  var _super62 = _createSuper(ep);

  function ep(e) {
    var _this80;

    _classCallCheck(this, ep);

    _this80 = _super62.call(this, null == e ? {} : e), _this80.supportsMasking = !0, null != e && (_this80.maxValue = e.maxValue);
    return _this80;
  }

  _createClass(ep, [{
    key: "call",
    value: function call(e, t) {
      e = rh(e);
      var n = Ua(e);
      return null != this.maxValue && (n = Gs(n, 0, this.maxValue)), n;
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        maxValue: this.maxValue
      },
          t = _get(_getPrototypeOf(ep.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return ep;
}(gh);

ep.className = "ReLU", qn(ep);

var tp = /*#__PURE__*/function (_gh4) {
  "use strict";

  _inherits(tp, _gh4);

  var _super63 = _createSuper(tp);

  function tp(e) {
    var _this81;

    _classCallCheck(this, tp);

    _this81 = _super63.call(this, null == e ? {} : e), _this81.DEFAULT_ALPHA = .3, null == e && (e = {}), _this81.alpha = null == e.alpha ? _this81.DEFAULT_ALPHA : e.alpha;
    return _this81;
  }

  _createClass(tp, [{
    key: "call",
    value: function call(e, t) {
      var n = rh(e);
      return Fr(n, this.alpha);
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        alpha: this.alpha
      },
          t = _get(_getPrototypeOf(tp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return tp;
}(gh);

tp.className = "LeakyReLU", qn(tp);

var np = /*#__PURE__*/function (_gh5) {
  "use strict";

  _inherits(np, _gh5);

  var _super64 = _createSuper(np);

  function np(e) {
    var _this82;

    _classCallCheck(this, np);

    if (_this82 = _super64.call(this, null == e ? {} : e), _this82.DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), _this82.supportsMasking = !0, _this82.alphaInitializer = Jc(e.alphaInitializer || _this82.DEFAULT_ALPHA_INITIALIZER), _this82.alphaRegularizer = Qd(e.alphaRegularizer), _this82.alphaConstraint = Ku(e.alphaConstraint), null == e.sharedAxes) _this82.sharedAxes = null;else if (Array.isArray(e.sharedAxes)) _this82.sharedAxes = e.sharedAxes;else {
      if ("number" != typeof e.sharedAxes) throw new bu("Expected sharedAxes to be a number or an array of numbers, but got ".concat(e.sharedAxes));
      _this82.sharedAxes = [e.sharedAxes];
    }
    return _possibleConstructorReturn(_this82);
  }

  _createClass(np, [{
    key: "build",
    value: function build(e) {
      var t = (e = ah(e)).slice(1);

      if (null != this.sharedAxes) {
        var _iterator91 = _createForOfIteratorHelper(this.sharedAxes),
            _step91;

        try {
          for (_iterator91.s(); !(_step91 = _iterator91.n()).done;) {
            var _e210 = _step91.value;
            t[_e210 - 1] = 1;
          }
        } catch (err) {
          _iterator91.e(err);
        } finally {
          _iterator91.f();
        }
      }

      this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
      var n = {};
      if (null != this.sharedAxes) for (var _t250 = 1; _t250 < e.length; ++_t250) {
        n[_t250] = e[_t250];
      }
      this.inputSpec = [new ch({
        ndim: e.length,
        axes: n
      })], this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      return e = rh(e), Ia(e, this.alpha.read());
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        alphaInitializer: Yc(this.alphaInitializer),
        alphaRegularizer: Jd(this.alphaRegularizer),
        alphaConstraint: ju(this.alphaConstraint),
        sharedAxes: this.sharedAxes
      },
          t = _get(_getPrototypeOf(np.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return np;
}(gh);

np.className = "PReLU", qn(np);

var sp = /*#__PURE__*/function (_gh6) {
  "use strict";

  _inherits(sp, _gh6);

  var _super65 = _createSuper(sp);

  function sp(e) {
    var _this83;

    _classCallCheck(this, sp);

    if (_this83 = _super65.call(this, null == e ? {} : e), _this83.DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== _this83.DEFAULT_ALPHA) throw new xu("Non-default alpha value (".concat(e.alpha, ") is not supported by the ELU layer yet."));
    _this83.alpha = null == e.alpha ? _this83.DEFAULT_ALPHA : e.alpha;
    return _possibleConstructorReturn(_this83);
  }

  _createClass(sp, [{
    key: "call",
    value: function call(e, t) {
      var n = rh(e);
      return mr(n);
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        alpha: this.alpha
      },
          t = _get(_getPrototypeOf(sp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return sp;
}(gh);

sp.className = "ELU", qn(sp);

var rp = /*#__PURE__*/function (_gh7) {
  "use strict";

  _inherits(rp, _gh7);

  var _super66 = _createSuper(rp);

  function rp(e) {
    var _this84;

    _classCallCheck(this, rp);

    _this84 = _super66.call(this, null == e ? {} : e), _this84.DEFAULT_THETA = 1, null == e && (e = {}), _this84.theta = null == e.theta ? _this84.DEFAULT_THETA : e.theta;
    return _this84;
  }

  _createClass(rp, [{
    key: "call",
    value: function call(e, t) {
      var n = rh(e);
      return ss(n, pn(Cr(n, this.theta), "float32"));
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        theta: this.theta
      },
          t = _get(_getPrototypeOf(rp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return rp;
}(gh);

rp.className = "ThresholdedReLU", qn(rp);

var ap = /*#__PURE__*/function (_gh8) {
  "use strict";

  _inherits(ap, _gh8);

  var _super67 = _createSuper(ap);

  function ap(e) {
    var _this85;

    _classCallCheck(this, ap);

    _this85 = _super67.call(this, null == e ? {} : e), _this85.DEFAULT_AXIS = 1, null == e && (e = {}), _this85.softmax = new Wd().apply, _this85.axis = null == e.axis ? _this85.DEFAULT_AXIS : e.axis;
    return _this85;
  }

  _createClass(ap, [{
    key: "call",
    value: function call(e, t) {
      var n = rh(e);
      return this.softmax(n, this.axis);
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        axis: this.axis
      },
          t = _get(_getPrototypeOf(ap.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return ap;
}(gh);

function ip(e, t, n) {
  if ("number" == typeof e) return ku(e, t);
  if (e.length !== t) throw new bu("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers. Received: ").concat(e.length, " elements."));

  for (var _r74 = 0; _r74 < t; ++_r74) {
    var a = e[_r74];
    if ((s = a) !== parseInt(s.toString(), 10)) throw new bu("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers. Received: ").concat(JSON.stringify(e), " including a non-integer number ").concat(a));
  }

  return e;
  var s;
}

function op(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
  if (null == e) return e;
  var a;
  return a = "same" === n ? e : e - (t + (t - 1) * (r - 1)) + 1, Math.floor((a + s - 1) / s);
}

function lp(e, t, n, s) {
  if (null == e) return null;
  if ("valid" === s) e = e * t + dc([n - t, 0]);else {
    if ("same" !== s) throw new bu("Unsupport padding mode: ".concat(s, "."));
    e *= t;
  }
  return e;
}

function up(e, t) {
  return Yn(function () {
    return tc(t), "channelsFirst" === t ? $n(e, [0, 2, 3, 1]) : e;
  });
}

function cp(e, t) {
  return Yn(function () {
    return tc(t), "channelsFirst" === t ? $n(e, [0, 2, 3, 4, 1]) : e;
  });
}

function hp(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1];
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
  var a = arguments.length > 5 ? arguments[5] : undefined;
  var i = arguments.length > 6 ? arguments[6] : undefined;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
  return Yn(function () {
    if (null == a && (a = "channelsLast"), tc(a), 3 !== e.rank && 4 !== e.rank) throw new bu("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ".concat(e.rank, "."));
    if (3 !== t.rank && 4 !== t.rank) throw new bu("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ".concat(e.rank, "."));
    var l = up(e, a);
    if ("causal" === r) throw new xu("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
    return l = Di({
      x: l,
      filter: t,
      strides: s,
      pad: "same" === r ? "same" : "valid",
      dilations: i,
      dataFormat: "NHWC",
      bias: n,
      activation: o
    }), "channelsFirst" === a && (l = $n(l, [0, 3, 1, 2])), l;
  });
}

ap.className = "Softmax", qn(ap);

var dp = /*#__PURE__*/function (_gh9) {
  "use strict";

  _inherits(dp, _gh9);

  var _super68 = _createSuper(dp);

  function dp(e, t) {
    var _this86;

    _classCallCheck(this, dp);

    if (_this86 = _super68.call(this, t), _this86.bias = null, _this86.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", _this86.DEFAULT_BIAS_INITIALIZER = "zeros", dp.verifyArgs(t), _this86.rank = e, Mu(_this86.rank, "rank"), 1 !== _this86.rank && 2 !== _this86.rank && 3 !== _this86.rank) throw new xu("Convolution layer for rank other than 1, 2, or 3 (".concat(_this86.rank, ") is not implemented yet."));
    if (_this86.kernelSize = ip(t.kernelSize, e, "kernelSize"), _this86.strides = ip(null == t.strides ? 1 : t.strides, e, "strides"), _this86.padding = null == t.padding ? "valid" : t.padding, nc(_this86.padding), _this86.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, tc(_this86.dataFormat), _this86.activation = qd(t.activation), _this86.useBias = null == t.useBias || t.useBias, _this86.biasInitializer = Jc(t.biasInitializer || _this86.DEFAULT_BIAS_INITIALIZER), _this86.biasConstraint = Ku(t.biasConstraint), _this86.biasRegularizer = Qd(t.biasRegularizer), _this86.activityRegularizer = Qd(t.activityRegularizer), _this86.dilationRate = ip(null == t.dilationRate ? 1 : t.dilationRate, e, "dilationRate"), 1 === _this86.rank && Array.isArray(_this86.dilationRate) && 1 !== _this86.dilationRate.length) throw new bu("dilationRate must be a number or an array of a single number for 1D convolution, but received ".concat(JSON.stringify(_this86.dilationRate)));

    if (2 === _this86.rank) {
      if ("number" == typeof _this86.dilationRate) _this86.dilationRate = [_this86.dilationRate, _this86.dilationRate];else if (2 !== _this86.dilationRate.length) throw new bu("dilationRate must be a number or array of two numbers for 2D convolution, but received ".concat(JSON.stringify(_this86.dilationRate)));
    } else if (3 === _this86.rank) if ("number" == typeof _this86.dilationRate) _this86.dilationRate = [_this86.dilationRate, _this86.dilationRate, _this86.dilationRate];else if (3 !== _this86.dilationRate.length) throw new bu("dilationRate must be a number or array of three numbers for 3D convolution, but received ".concat(JSON.stringify(_this86.dilationRate)));

    return _possibleConstructorReturn(_this86);
  }

  _createClass(dp, [{
    key: "getConfig",
    value: function getConfig() {
      var e = {
        kernelSize: this.kernelSize,
        strides: this.strides,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        activation: Hd(this.activation),
        useBias: this.useBias,
        biasInitializer: Yc(this.biasInitializer),
        biasRegularizer: Jd(this.biasRegularizer),
        activityRegularizer: Jd(this.activityRegularizer),
        biasConstraint: ju(this.biasConstraint)
      },
          t = _get(_getPrototypeOf(dp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }], [{
    key: "verifyArgs",
    value: function verifyArgs(e) {
      if (wu("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !Ou(e.kernelSize, "number", 1, 3)) throw new bu("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize), "."));
    }
  }]);

  return dp;
}(gh);

var pp = /*#__PURE__*/function (_dp) {
  "use strict";

  _inherits(pp, _dp);

  var _super69 = _createSuper(pp);

  function pp(e, t) {
    var _this87;

    _classCallCheck(this, pp);

    _this87 = _super69.call(this, e, t), _this87.kernel = null, pp.verifyArgs(t), _this87.filters = t.filters, Mu(_this87.filters, "filters"), _this87.kernelInitializer = Jc(t.kernelInitializer || _this87.DEFAULT_KERNEL_INITIALIZER), _this87.kernelConstraint = Ku(t.kernelConstraint), _this87.kernelRegularizer = Qd(t.kernelRegularizer);
    return _this87;
  }

  _createClass(pp, [{
    key: "build",
    value: function build(e) {
      e = ah(e);
      var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
      if (null == e[t]) throw new bu("The channel dimension of the input should be defined. Found ".concat(e[t]));
      var n = e[t],
          s = this.kernelSize.concat([n, this.filters]);
      this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
        ndim: this.rank + 2,
        axes: _defineProperty({}, t, n)
      }], this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this88 = this;

      return Yn(function () {
        var t;
        e = rh(e);
        var n = null == _this88.bias ? null : _this88.bias.read(),
            s = zu(_this88.activation.getClassName());
        if (null != s && 2 === _this88.rank) t = hp(e, _this88.kernel.read(), n, _this88.strides, _this88.padding, _this88.dataFormat, _this88.dilationRate, s);else {
          if (1 === _this88.rank) t = function (e, t, n) {
            var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
            var a = arguments.length > 5 ? arguments[5] : undefined;
            var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
            return Yn(function () {
              if (null == a && (a = "channelsLast"), tc(a), 3 !== e.shape.length) throw new bu("The input of a conv1dWithBias operation should be 3, but is ".concat(e.shape.length, " instead."));
              if (3 !== t.shape.length) throw new bu("The kernel for a conv1dWithBias operation should be 3, but is ".concat(t.shape.length, " instead"));
              if (null != n && 1 !== n.shape.length) throw new bu("The bias for a conv1dWithBias operation should be 1, but is ".concat(t.shape.length, " instead"));
              if ("channelsFirst" === a && (e = $n(e, [0, 2, 1])), "causal" === r) throw new xu("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
              var o = Ys(e, t, s, "same" === r ? "same" : "valid", "NWC", i);
              return null != n && (o = Sc(o, n)), o;
            });
          }(e, _this88.kernel.read(), n, _this88.strides[0], _this88.padding, _this88.dataFormat, _this88.dilationRate[0]);else if (2 === _this88.rank) t = hp(e, _this88.kernel.read(), n, _this88.strides, _this88.padding, _this88.dataFormat, _this88.dilationRate);else {
            if (3 !== _this88.rank) throw new xu("convolutions greater than 3D are not implemented yet.");

            t = function (e, t, n) {
              var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1, 1];
              var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "valid";
              var a = arguments.length > 5 ? arguments[5] : undefined;
              var i = arguments.length > 6 ? arguments[6] : undefined;
              return Yn(function () {
                if (null == a && (a = "channelsLast"), tc(a), 4 !== e.rank && 5 !== e.rank) throw new bu("conv3dWithBias expects input to be of rank 4 or 5, but received ".concat(e.rank, "."));
                if (4 !== t.rank && 5 !== t.rank) throw new bu("conv3dWithBias expects kernel to be of rank 4 or 5, but received ".concat(e.rank, "."));
                var o = cp(e, a);
                if ("causal" === r) throw new xu("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
                return o = Qs(o, t, s, "same" === r ? "same" : "valid", "NDHWC", i), null != n && (o = Sc(o, n)), "channelsFirst" === a && (o = $n(o, [0, 4, 1, 2, 3])), o;
              });
            }(e, _this88.kernel.read(), n, _this88.strides, _this88.padding, _this88.dataFormat, _this88.dilationRate);
          }
          null != _this88.activation && (t = _this88.activation.apply(t));
        }
        return t;
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      e = ah(e);
      var t = [],
          n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2);

      for (var _e211 = 0; _e211 < n.length; ++_e211) {
        var _s102 = op(n[_e211], this.kernelSize[_e211], this.padding, this.strides[_e211], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[_e211]);

        t.push(_s102);
      }

      var s = [e[0]];
      return "channelsLast" === this.dataFormat ? (s = s.concat(t), s.push(this.filters)) : (s.push(this.filters), s = s.concat(t)), s;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        filters: this.filters,
        kernelInitializer: Yc(this.kernelInitializer),
        kernelRegularizer: Jd(this.kernelRegularizer),
        kernelConstraint: ju(this.kernelConstraint)
      },
          t = _get(_getPrototypeOf(pp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }], [{
    key: "verifyArgs",
    value: function verifyArgs(e) {
      if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new bu("Convolution layer expected config.filters to be a 'number' > 0 but got ".concat(JSON.stringify(e.filters)));
    }
  }]);

  return pp;
}(dp);

var fp = /*#__PURE__*/function (_pp) {
  "use strict";

  _inherits(fp, _pp);

  var _super70 = _createSuper(fp);

  function fp(e) {
    var _this89;

    _classCallCheck(this, fp);

    _this89 = _super70.call(this, 2, e), fp.verifyArgs(e);
    return _this89;
  }

  _createClass(fp, [{
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(fp.prototype), "getConfig", this).call(this);

      return delete e.rank, e;
    }
  }], [{
    key: "verifyArgs",
    value: function verifyArgs(e) {
      if ("number" != typeof e.kernelSize && !Ou(e.kernelSize, "number", 1, 2)) throw new bu("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize), "."));
    }
  }]);

  return fp;
}(pp);

fp.className = "Conv2D", qn(fp);

var gp = /*#__PURE__*/function (_pp2) {
  "use strict";

  _inherits(gp, _pp2);

  var _super71 = _createSuper(gp);

  function gp(e) {
    var _this90;

    _classCallCheck(this, gp);

    _this90 = _super71.call(this, 3, e), gp.verifyArgs(e);
    return _this90;
  }

  _createClass(gp, [{
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(gp.prototype), "getConfig", this).call(this);

      return delete e.rank, e;
    }
  }], [{
    key: "verifyArgs",
    value: function verifyArgs(e) {
      if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new bu("Conv3D expects config.kernelSize to be number or [number, number, number], but received ".concat(JSON.stringify(e.kernelSize), "."));
    }
  }]);

  return gp;
}(pp);

gp.className = "Conv3D", qn(gp);

var mp = /*#__PURE__*/function (_fp) {
  "use strict";

  _inherits(mp, _fp);

  var _super72 = _createSuper(mp);

  function mp(e) {
    var _this91;

    _classCallCheck(this, mp);

    if (_this91 = _super72.call(this, e), _this91.inputSpec = [new ch({
      ndim: 4
    })], "same" !== _this91.padding && "valid" !== _this91.padding) throw new bu("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(_this91.padding));
    return _possibleConstructorReturn(_this91);
  }

  _createClass(mp, [{
    key: "build",
    value: function build(e) {
      if (4 !== (e = ah(e)).length) throw new bu("Input should have rank 4; Received input shape: " + JSON.stringify(e));
      var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
      if (null == e[t]) throw new bu("The channel dimension of the inputs should be defined. Found `None`.");
      var n = e[t],
          s = this.kernelSize.concat([this.filters, n]);
      this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new ch({
        ndim: 4,
        axes: _defineProperty({}, t, n)
      })], this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this92 = this;

      return Yn(function () {
        var t = rh(e);
        if (4 !== t.shape.length) throw new bu("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));
        var n = t.shape;
        var s, r;
        "channelsFirst" === _this92.dataFormat ? (s = 2, r = 3) : (s = 1, r = 2);
        var a = n[r],
            i = _this92.kernelSize[1],
            o = _this92.strides[1],
            l = [n[0], lp(n[s], _this92.strides[0], _this92.kernelSize[0], _this92.padding), lp(a, o, i, _this92.padding), _this92.filters];
        "channelsLast" !== _this92.dataFormat && (t = $n(t, [0, 2, 3, 1]));
        var u = Zs(t, _this92.kernel.read(), l, _this92.strides, _this92.padding);
        return "channelsLast" !== _this92.dataFormat && (u = $n(u, [0, 3, 1, 2])), null != _this92.bias && (u = Sc(u, _this92.bias.read(), _this92.dataFormat)), null != _this92.activation && (u = _this92.activation.apply(u)), u;
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = (e = ah(e)).slice();
      var n, s, r;
      "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3) : (n = 3, s = 1, r = 2);
      var a = this.kernelSize[0],
          i = this.kernelSize[1],
          o = this.strides[0],
          l = this.strides[1];
      return t[n] = this.filters, t[s] = lp(t[s], o, a, this.padding), t[r] = lp(t[r], l, i, this.padding), t;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(mp.prototype), "getConfig", this).call(this);

      return delete e.dilationRate, e;
    }
  }]);

  return mp;
}(fp);

mp.className = "Conv2DTranspose", qn(mp);

var bp = /*#__PURE__*/function (_gp) {
  "use strict";

  _inherits(bp, _gp);

  var _super73 = _createSuper(bp);

  function bp(e) {
    var _this93;

    _classCallCheck(this, bp);

    if (_this93 = _super73.call(this, e), _this93.inputSpec = [new ch({
      ndim: 5
    })], "same" !== _this93.padding && "valid" !== _this93.padding) throw new bu("Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ".concat(_this93.padding));
    return _possibleConstructorReturn(_this93);
  }

  _createClass(bp, [{
    key: "build",
    value: function build(e) {
      if (5 !== (e = ah(e)).length) throw new bu("Input should have rank 5; Received input shape: " + JSON.stringify(e));
      var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
      if (null == e[t]) throw new bu("The channel dimension of the inputs should be defined. Found `None`.");
      var n = e[t],
          s = this.kernelSize.concat([this.filters, n]);
      this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new ch({
        ndim: 5,
        axes: _defineProperty({}, t, n)
      })], this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this94 = this;

      return Yn(function () {
        var t = rh(e);
        if (5 !== t.shape.length) throw new bu("Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-".concat(t.shape.length));
        var n = t.shape;
        var s, r, a;
        "channelsFirst" === _this94.dataFormat ? (a = 2, s = 3, r = 4) : (a = 1, s = 2, r = 3);
        var i = n[s],
            o = n[r],
            l = _this94.kernelSize[1],
            u = _this94.kernelSize[2],
            c = _this94.strides[1],
            h = _this94.strides[2],
            d = [n[0], lp(n[a], _this94.strides[0], _this94.kernelSize[0], _this94.padding), lp(i, c, l, _this94.padding), lp(o, h, u, _this94.padding), _this94.filters];
        "channelsLast" !== _this94.dataFormat && (t = $n(t, [0, 2, 3, 4, 1]));
        var p = tr(t, _this94.kernel.read(), d, _this94.strides, _this94.padding);
        return "channelsLast" !== _this94.dataFormat && (p = $n(p, [0, 4, 1, 2, 3])), null !== _this94.bias && (p = Sc(p, _this94.bias.read(), _this94.dataFormat)), null !== _this94.activation && (p = _this94.activation.apply(p)), p;
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = (e = ah(e)).slice();
      var n, s, r, a;
      "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3, a = 4) : (n = 4, s = 1, r = 2, a = 3);
      var i = this.kernelSize[0],
          o = this.kernelSize[1],
          l = this.kernelSize[2],
          u = this.strides[0],
          c = this.strides[1],
          h = this.strides[2];
      return t[n] = this.filters, t[s] = lp(t[s], u, i, this.padding), t[r] = lp(t[r], c, o, this.padding), t[a] = lp(t[a], h, l, this.padding), t;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(bp.prototype), "getConfig", this).call(this);

      return delete e.dilationRate, e;
    }
  }]);

  return bp;
}(gp);

bp.className = "Conv3DTranspose", qn(bp);

var xp = /*#__PURE__*/function (_pp3) {
  "use strict";

  _inherits(xp, _pp3);

  var _super74 = _createSuper(xp);

  function xp(e, t) {
    var _this95;

    _classCallCheck(this, xp);

    if (_this95 = _super74.call(this, e, t), _this95.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", _this95.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", _this95.depthwiseKernel = null, _this95.pointwiseKernel = null, null == t.filters) throw new bu("The `filters` configuration field is required by SeparableConv, but is unspecified.");
    if (null != t.kernelInitializer || null != t.kernelRegularizer || null != t.kernelConstraint) throw new bu("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
    if (null != t.padding && "same" !== t.padding && "valid" !== t.padding) throw new bu("SeparableConv".concat(_this95.rank, "D supports only padding modes: 'same' and 'valid', but received ").concat(JSON.stringify(t.padding)));
    _this95.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, _this95.depthwiseInitializer = Jc(t.depthwiseInitializer || _this95.DEFAULT_DEPTHWISE_INITIALIZER), _this95.depthwiseRegularizer = Qd(t.depthwiseRegularizer), _this95.depthwiseConstraint = Ku(t.depthwiseConstraint), _this95.pointwiseInitializer = Jc(t.depthwiseInitializer || _this95.DEFAULT_POINTWISE_INITIALIZER), _this95.pointwiseRegularizer = Qd(t.pointwiseRegularizer), _this95.pointwiseConstraint = Ku(t.pointwiseConstraint);
    return _possibleConstructorReturn(_this95);
  }

  _createClass(xp, [{
    key: "build",
    value: function build(e) {
      if ((e = ah(e)).length < this.rank + 2) throw new bu("Inputs to SeparableConv".concat(this.rank, "D should have rank ").concat(this.rank + 2, ", but received input shape: ").concat(JSON.stringify(e)));
      var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
      if (null == e[t] || e[t] < 0) throw new bu("The channel dimension of the inputs should be defined, but found ".concat(JSON.stringify(e[t])));
      var n = e[t],
          s = this.kernelSize.concat([n, this.depthMultiplier]),
          r = [];

      for (var _e212 = 0; _e212 < this.rank; ++_e212) {
        r.push(1);
      }

      r.push(n * this.depthMultiplier, this.filters);
      var a = !0;
      this.depthwiseKernel = this.addWeight("depthwise_kernel", s, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, a, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, a, this.pointwiseConstraint), this.bias = this.useBias ? this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, a, this.biasConstraint) : null, this.inputSpec = [new ch({
        ndim: this.rank + 2,
        axes: _defineProperty({}, t, n)
      })], this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this96 = this;

      return Yn(function () {
        var t;
        if (e = rh(e), 1 === _this96.rank) throw new xu("1D separable convolution is not implemented yet.");
        return 2 === _this96.rank && ("channelsFirst" === _this96.dataFormat && (e = $n(e, [0, 2, 3, 1])), t = Xa(e, _this96.depthwiseKernel.read(), _this96.pointwiseKernel.read(), _this96.strides, _this96.padding, _this96.dilationRate, "NHWC")), _this96.useBias && (t = Sc(t, _this96.bias.read(), _this96.dataFormat)), null != _this96.activation && (t = _this96.activation.apply(t)), "channelsFirst" === _this96.dataFormat && (t = $n(t, [0, 3, 1, 2])), t;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(xp.prototype), "getConfig", this).call(this);

      return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = Yc(this.depthwiseInitializer), e.pointwiseInitializer = Yc(this.pointwiseInitializer), e.depthwiseRegularizer = Jd(this.depthwiseRegularizer), e.pointwiseRegularizer = Jd(this.pointwiseRegularizer), e.depthwiseConstraint = ju(this.depthwiseConstraint), e.pointwiseConstraint = ju(this.pointwiseConstraint), e;
    }
  }]);

  return xp;
}(pp);

xp.className = "SeparableConv";

var yp = /*#__PURE__*/function (_xp) {
  "use strict";

  _inherits(yp, _xp);

  var _super75 = _createSuper(yp);

  function yp(e) {
    _classCallCheck(this, yp);

    return _super75.call(this, 2, e);
  }

  return yp;
}(xp);

yp.className = "SeparableConv2D", qn(yp);

var kp = /*#__PURE__*/function (_pp4) {
  "use strict";

  _inherits(kp, _pp4);

  var _super76 = _createSuper(kp);

  function kp(e) {
    var _this97;

    _classCallCheck(this, kp);

    _this97 = _super76.call(this, 1, e), kp.verifyArgs(e), _this97.inputSpec = [{
      ndim: 3
    }];
    return _this97;
  }

  _createClass(kp, [{
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(kp.prototype), "getConfig", this).call(this);

      return delete e.rank, delete e.dataFormat, e;
    }
  }], [{
    key: "verifyArgs",
    value: function verifyArgs(e) {
      if ("number" != typeof e.kernelSize && !Ou(e.kernelSize, "number", 1, 1)) throw new bu("Conv1D expects config.kernelSize to be number or number[] with length 1, but received ".concat(JSON.stringify(e.kernelSize), "."));
    }
  }]);

  return kp;
}(pp);

kp.className = "Conv1D", qn(kp);

var wp = /*#__PURE__*/function (_gh10) {
  "use strict";

  _inherits(wp, _gh10);

  var _super77 = _createSuper(wp);

  function wp(e) {
    var _this98;

    _classCallCheck(this, wp);

    _this98 = _super77.call(this, e), _this98.cropping = "number" == typeof e.cropping ? [[e.cropping, e.cropping], [e.cropping, e.cropping]] : "number" == typeof e.cropping[0] ? [[e.cropping[0], e.cropping[0]], [e.cropping[1], e.cropping[1]]] : e.cropping, _this98.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, _this98.inputSpec = [{
      ndim: 4
    }];
    return _this98;
  }

  _createClass(wp, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this99 = this;

      return Yn(function () {
        if (e = rh(e), "channelsLast" === _this99.dataFormat) {
          var _t251 = xc(e, _this99.cropping[0][0], e.shape[1] - _this99.cropping[0][0] - _this99.cropping[0][1], 2);

          return xc(_t251, _this99.cropping[1][0], e.shape[2] - _this99.cropping[1][1] - _this99.cropping[1][0], 3);
        }

        {
          var _t252 = xc(e, _this99.cropping[0][0], e.shape[2] - _this99.cropping[0][0] - _this99.cropping[0][1], 3);

          return xc(_t252, _this99.cropping[1][0], e.shape[3] - _this99.cropping[1][1] - _this99.cropping[1][0], 4);
        }
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        cropping: this.cropping,
        dataFormat: this.dataFormat
      },
          t = _get(_getPrototypeOf(wp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return wp;
}(gh);

wp.className = "Cropping2D", qn(wp);

var vp = /*#__PURE__*/function (_gh11) {
  "use strict";

  _inherits(vp, _gh11);

  var _super78 = _createSuper(vp);

  function vp(e) {
    var _this100;

    _classCallCheck(this, vp);

    _this100 = _super78.call(this, e), _this100.DEFAULT_SIZE = [2, 2], _this100.inputSpec = [{
      ndim: 4
    }], _this100.size = null == e.size ? _this100.DEFAULT_SIZE : e.size, _this100.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(_this100.dataFormat), _this100.interpolation = null == e.interpolation ? "nearest" : e.interpolation, _u(Yu, "InterpolationFormat", _this100.interpolation);
    return _this100;
  }

  _createClass(vp, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return "channelsFirst" === this.dataFormat ? [e[0], e[1], null == e[2] ? null : this.size[0] * e[2], null == e[3] ? null : this.size[1] * e[3]] : [e[0], null == e[1] ? null : this.size[0] * e[1], null == e[2] ? null : this.size[1] * e[2], e[3]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this101 = this;

      return Yn(function () {
        var t = rh(e);
        var n = t.shape;

        if ("channelsFirst" === _this101.dataFormat) {
          t = $n(t, [0, 2, 3, 1]);

          var _e213 = _this101.size[0] * n[2],
              _s103 = _this101.size[1] * n[3],
              _r75 = "nearest" === _this101.interpolation ? ho.resizeNearestNeighbor(t, [_e213, _s103]) : ho.resizeBilinear(t, [_e213, _s103]);

          return $n(_r75, [0, 3, 1, 2]);
        }

        {
          var _e214 = _this101.size[0] * n[1],
              _s104 = _this101.size[1] * n[2];

          return "nearest" === _this101.interpolation ? ho.resizeNearestNeighbor(t, [_e214, _s104]) : ho.resizeBilinear(t, [_e214, _s104]);
        }
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        size: this.size,
        dataFormat: this.dataFormat
      },
          t = _get(_getPrototypeOf(vp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return vp;
}(gh);

vp.className = "UpSampling2D", qn(vp);

var Ip = /*#__PURE__*/function (_dp2) {
  "use strict";

  _inherits(Ip, _dp2);

  var _super79 = _createSuper(Ip);

  function Ip(e) {
    var _this102;

    _classCallCheck(this, Ip);

    _this102 = _super79.call(this, 2, e), _this102.depthwiseKernel = null, _this102.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, _this102.depthwiseInitializer = Jc(e.depthwiseInitializer || _this102.DEFAULT_KERNEL_INITIALIZER), _this102.depthwiseConstraint = Ku(e.depthwiseConstraint), _this102.depthwiseRegularizer = Qd(e.depthwiseRegularizer);
    return _this102;
  }

  _createClass(Ip, [{
    key: "build",
    value: function build(e) {
      if ((e = ah(e)).length < 4) throw new bu("Inputs to DepthwiseConv2D should have rank 4. Received input shape: ".concat(JSON.stringify(e), "."));
      var t = "channelsFirst" === this.dataFormat ? 1 : 3;
      if (null == e[t] || e[t] < 0) throw new bu("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (".concat(e[t], ")."));
      var n = e[t];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier], null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.bias = this.useBias ? this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this103 = this;

      return Yn(function () {
        var t = function (e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1];
          var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "valid";
          var r = arguments.length > 4 ? arguments[4] : undefined;
          var a = arguments.length > 5 ? arguments[5] : undefined;
          return Yn(function () {
            null == r && (r = "channelsLast"), tc(r);
            var i = up(e, r);
            if (4 !== e.rank) throw new bu("Input for depthwiseConv2d is required to be 4-D, but is instead ".concat(e.rank, "-D"));
            if (4 !== t.rank) throw new bu("depthwiseKernel is required to be 4-D, but is instead ".concat(t.rank, "-D"));
            return i = ir(i, t, n, "same" === s ? "same" : "valid", "NHWC", a), "channelsFirst" === r && (i = $n(i, [0, 3, 1, 2])), i;
          });
        }(e = rh(e), _this103.depthwiseKernel.read(), _this103.strides, _this103.padding, _this103.dataFormat, null);

        return _this103.useBias && (t = Sc(t, _this103.bias.read(), _this103.dataFormat)), null != _this103.activation && (t = _this103.activation.apply(t)), t;
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      e = ah(e);
      var t = "channelsFirst" === this.dataFormat ? e[3] : e[2],
          n = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
          s = op("channelsFirst" === this.dataFormat ? e[2] : e[1], this.kernelSize[0], this.padding, this.strides[0]),
          r = op(t, this.kernelSize[1], this.padding, this.strides[1]);
      return "channelsFirst" === this.dataFormat ? [e[0], n, s, r] : [e[0], s, r, n];
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(Ip.prototype), "getConfig", this).call(this);

      return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = Yc(this.depthwiseInitializer), e.depthwiseRegularizer = Jd(this.depthwiseRegularizer), e.depthwiseConstraint = ju(this.depthwiseRegularizer), e;
    }
  }]);

  return Ip;
}(dp);

function $p(e, t, n, s) {
  if (Array.isArray(e)) {
    if (null != t || null != n) throw new bu("When inputs is an array, neither initialState or constants should be provided");
    null != s && (n = e.slice(e.length - s, e.length), e = e.slice(0, e.length - s)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0];
  }

  function r(e) {
    return null == e || Array.isArray(e) ? e : [e];
  }

  return {
    inputs: e,
    initialState: t = r(t),
    constants: n = r(n)
  };
}

function Np(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = arguments.length > 4 ? arguments[4] : undefined;
  var a = arguments.length > 5 ? arguments[5] : undefined;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
  var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
  return Yn(function () {
    var l = t.shape.length;
    if (l < 3) throw new bu("Input should be at least 3D, but is ".concat(l, "D."));
    var u = [1, 0].concat(pc(2, l));
    if (t = $n(t, u), null != a) throw new xu("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
    i && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != r && ((r = pn(pn(r, "bool"), "float32")).rank === l - 1 && (r = yr(r, -1)), r = $n(r, u)), s && (t = Ga(t, 0), null != r && (r = Ga(r, 0)));
    var c = [];
    var h,
        d = n;
    var p = t.shape[0],
        f = vi(t);
    var g, m;
    null != r && (g = vi(r));

    var _loop24 = function _loop24(_t253) {
      var n = f[_t253],
          s = Yn(function () {
        return e(n, d);
      });
      if (null == r) h = s[0], d = s[1];else {
        var _e215 = Yn(function () {
          var e = g[_t253],
              n = Vr(xa(e), e);
          return {
            output: es(ss(s[0], e), ss(d[0], n)),
            newStates: d.map(function (t, r) {
              return es(ss(s[1][r], e), ss(t, n));
            })
          };
        });

        h = _e215.output, d = _e215.newStates;
      }
      o && c.push(h);
    };

    for (var _t253 = 0; _t253 < p; ++_t253) {
      _loop24(_t253);
    }

    return o && (m = di(c, 1)), [h, m, d];
  });
}

Ip.className = "DepthwiseConv2D", qn(Ip);

var Cp = /*#__PURE__*/function (_gh12) {
  "use strict";

  _inherits(Cp, _gh12);

  var _super80 = _createSuper(Cp);

  function Cp(e) {
    var _this104;

    _classCallCheck(this, Cp);

    var t;
    if (_this104 = _super80.call(this, e), null == e.cell) throw new bu("cell property is missing for the constructor of RNN.");
    if (t = Array.isArray(e.cell) ? new _p({
      cells: e.cell
    }) : e.cell, null == t.stateSize) throw new bu("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
    _this104.cell = t, _this104.returnSequences = null != e.returnSequences && e.returnSequences, _this104.returnState = null != e.returnState && e.returnState, _this104.goBackwards = null != e.goBackwards && e.goBackwards, _this104._stateful = null != e.stateful && e.stateful, _this104.unroll = null != e.unroll && e.unroll, _this104.supportsMasking = !0, _this104.inputSpec = [new ch({
      ndim: 3
    })], _this104.stateSpec = null, _this104.states_ = null, _this104.numConstants = null, _this104.keptStates = [];
    return _possibleConstructorReturn(_this104);
  }

  _createClass(Cp, [{
    key: "getStates",
    value: function getStates() {
      return null == this.states_ ? pc(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (e) {
        return null;
      }) : this.states_;
    }
  }, {
    key: "setStates",
    value: function setStates(e) {
      this.states_ = e;
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      nh(e) && (e = e[0]), e = e;
      var t = this.cell.stateSize;
      Array.isArray(t) || (t = [t]);
      var n = t[0];
      var s;

      if (s = this.returnSequences ? [e[0], e[1], n] : [e[0], n], this.returnState) {
        var _n124 = [];

        var _iterator92 = _createForOfIteratorHelper(t),
            _step92;

        try {
          for (_iterator92.s(); !(_step92 = _iterator92.n()).done;) {
            var _s105 = _step92.value;

            _n124.push([e[0], _s105]);
          }
        } catch (err) {
          _iterator92.e(err);
        } finally {
          _iterator92.f();
        }

        return [s].concat(_n124);
      }

      return s;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var _this105 = this;

      return Yn(function () {
        Array.isArray(t) && (t = t[0]);
        var e = _this105.returnSequences ? t : null;

        if (_this105.returnState) {
          var _t254 = _this105.states.map(function (e) {
            return null;
          });

          return [e].concat(_t254);
        }

        return e;
      });
    }
  }, {
    key: "states",
    get: function get() {
      if (null == this.states_) {
        var _e216 = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1,
            t = [];

        for (var _n125 = 0; _n125 < _e216; ++_n125) {
          t.push(null);
        }

        return t;
      }

      return this.states_;
    },
    set: function set(e) {
      this.states_ = e;
    }
  }, {
    key: "build",
    value: function build(e) {
      if (null != this.numConstants) throw new xu("Constants support is not implemented in RNN yet.");
      nh(e) && (e = e[0]), e = e;
      var t = this.stateful ? e[0] : null,
          n = e.slice(2);
      this.inputSpec[0] = new ch({
        shape: [t, null].concat(_toConsumableArray(n))
      });
      var s = [e[0]].concat(e.slice(2));
      var r;

      if (this.cell.build(s), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
        if (!p(this.stateSpec.map(function (e) {
          return e.shape[e.shape.length - 1];
        }), r)) throw new bu("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=".concat(this.stateSpec, "; However cell.stateSize is ").concat(this.cell.stateSize));
      } else this.stateSpec = r.map(function (e) {
        return new ch({
          shape: [null, e]
        });
      });

      this.stateful && this.resetStates();
    }
  }, {
    key: "resetStates",
    value: function resetStates(e) {
      var _this106 = this;

      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      Yn(function () {
        if (!_this106.stateful) throw new gu("Cannot call resetStates() on an RNN Layer that is not stateful.");
        var n = _this106.inputSpec[0].shape[0];
        if (null == n) throw new bu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (null == _this106.states_) _this106.states_ = Array.isArray(_this106.cell.stateSize) ? _this106.cell.stateSize.map(function (e) {
          return ua([n, e]);
        }) : [ua([n, _this106.cell.stateSize])];else if (null == e) Jn(_this106.states_), null != _this106.keptStates && (Jn(_this106.keptStates), _this106.keptStates = []), Array.isArray(_this106.cell.stateSize) ? _this106.states_ = _this106.cell.stateSize.map(function (e) {
          return ua([n, e]);
        }) : _this106.states_[0] = ua([n, _this106.cell.stateSize]);else {
          if (Array.isArray(e) || (e = [e]), e.length !== _this106.states_.length) throw new bu("Layer ".concat(_this106.name, " expects ").concat(_this106.states_.length, " state(s), but it received ").concat(e.length, " state value(s). Input received: ").concat(e));
          !0 === t ? _this106.keptStates.push(_this106.states_.slice()) : Jn(_this106.states_);

          for (var _t255 = 0; _t255 < _this106.states_.length; ++_t255) {
            var _s106 = e[_t255],
                _r76 = Array.isArray(_this106.cell.stateSize) ? _this106.cell.stateSize[_t255] : _this106.cell.stateSize,
                a = [n, _r76];

            if (!p(_s106.shape, a)) throw new bu("State ".concat(_t255, " is incompatible with layer ").concat(_this106.name, ": expected shape=").concat(a, ", received shape=").concat(_s106.shape));
            _this106.states_[_t255] = _s106;
          }
        }
        _this106.states_ = _this106.states_.map(function (e) {
          return Zn(e.clone());
        });
      });
    }
  }, {
    key: "apply",
    value: function apply(e, t) {
      var n = null == t ? null : t.initialState,
          s = null == t ? null : t.constants;
      null == t && (t = {});
      var r = $p(e, n, s, this.numConstants);
      e = r.inputs, n = r.initialState, s = r.constants;
      var a = [],
          i = [];

      if (null != n) {
        t.initialState = n, a = a.concat(n), this.stateSpec = [];

        var _iterator93 = _createForOfIteratorHelper(n),
            _step93;

        try {
          for (_iterator93.s(); !(_step93 = _iterator93.n()).done;) {
            var _e217 = _step93.value;
            this.stateSpec.push(new ch({
              shape: _e217.shape
            }));
          }
        } catch (err) {
          _iterator93.e(err);
        } finally {
          _iterator93.f();
        }

        i = i.concat(this.stateSpec);
      }

      if (null != s && (t.constants = s, a = a.concat(s), this.numConstants = s.length), a[0] instanceof hh) {
        var _n126 = [e].concat(a),
            _s107 = this.inputSpec.concat(i),
            _r77 = this.inputSpec;

        this.inputSpec = _s107;

        var o = _get(_getPrototypeOf(Cp.prototype), "apply", this).call(this, _n126, t);

        return this.inputSpec = _r77, o;
      }

      return _get(_getPrototypeOf(Cp.prototype), "apply", this).call(this, e, t);
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this107 = this;

      return Yn(function () {
        var n = null == t ? null : t.mask,
            s = null == t ? null : t.training;
        var r = null == t ? null : t.initialState;
        e = rh(e), null == r && (r = _this107.stateful ? _this107.states_ : _this107.getInitialState(e));
        var a = Array.isArray(_this107.cell.stateSize) ? _this107.cell.stateSize.length : 1;
        if (r.length !== a) throw new bu("RNN Layer has ".concat(a, " state(s) but was passed ").concat(r.length, " initial state(s)."));
        _this107.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        var i = {
          training: s
        },
            o = Np(function (e, t) {
          var n = _this107.cell.call([e].concat(t), i);

          return [n[0], n.slice(1)];
        }, e, r, _this107.goBackwards, n, null, _this107.unroll, _this107.returnSequences),
            l = o[0],
            u = o[1],
            c = o[2];
        _this107.stateful && _this107.resetStates(c, s);
        var h = _this107.returnSequences ? u : l;
        return _this107.returnState ? [h].concat(c) : h;
      });
    }
  }, {
    key: "getInitialState",
    value: function getInitialState(e) {
      var _this108 = this;

      return Yn(function () {
        var t = ua(e.shape);
        return t = Gr(t, [1, 2]), t = gc(t), Array.isArray(_this108.cell.stateSize) ? _this108.cell.stateSize.map(function (e) {
          return e > 1 ? wc(t, [1, e]) : t;
        }) : _this108.cell.stateSize > 1 ? [wc(t, [1, _this108.cell.stateSize])] : [t];
      });
    }
  }, {
    key: "trainableWeights",
    get: function get() {
      return this.trainable ? this.cell.trainableWeights : [];
    }
  }, {
    key: "nonTrainableWeights",
    get: function get() {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    }
  }, {
    key: "setFastWeightInitDuringBuild",
    value: function setFastWeightInitDuringBuild(e) {
      _get(_getPrototypeOf(Cp.prototype), "setFastWeightInitDuringBuild", this).call(this, e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(Cp.prototype), "getConfig", this).call(this),
          t = {
        returnSequences: this.returnSequences,
        returnState: this.returnState,
        goBackwards: this.goBackwards,
        stateful: this.stateful,
        unroll: this.unroll
      };

      null != this.numConstants && (t.numConstants = this.numConstants);
      var n = this.cell.getConfig();
      return this.getClassName() === Cp.className && (t.cell = {
        className: this.cell.getClassName(),
        config: n
      }), Object.assign({}, n, e, t);
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var s = Eh(t.cell, n);
      return new e(Object.assign(t, {
        cell: s
      }));
    }
  }]);

  return Cp;
}(gh);

Cp.className = "RNN", qn(Cp);

var Sp = /*#__PURE__*/function (_gh13) {
  "use strict";

  _inherits(Sp, _gh13);

  var _super81 = _createSuper(Sp);

  function Sp() {
    _classCallCheck(this, Sp);

    return _super81.apply(this, arguments);
  }

  return Sp;
}(gh);

var Tp = /*#__PURE__*/function (_Sp) {
  "use strict";

  _inherits(Tp, _Sp);

  var _super82 = _createSuper(Tp);

  function Tp(e) {
    var _this109;

    _classCallCheck(this, Tp);

    _this109 = _super82.call(this, e), _this109.DEFAULT_ACTIVATION = "tanh", _this109.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", _this109.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", _this109.DEFAULT_BIAS_INITIALIZER = "zeros", _this109.units = e.units, Mu(_this109.units, "units"), _this109.activation = qd(null == e.activation ? _this109.DEFAULT_ACTIVATION : e.activation), _this109.useBias = null == e.useBias || e.useBias, _this109.kernelInitializer = Jc(e.kernelInitializer || _this109.DEFAULT_KERNEL_INITIALIZER), _this109.recurrentInitializer = Jc(e.recurrentInitializer || _this109.DEFAULT_RECURRENT_INITIALIZER), _this109.biasInitializer = Jc(e.biasInitializer || _this109.DEFAULT_BIAS_INITIALIZER), _this109.kernelRegularizer = Qd(e.kernelRegularizer), _this109.recurrentRegularizer = Qd(e.recurrentRegularizer), _this109.biasRegularizer = Qd(e.biasRegularizer), _this109.kernelConstraint = Ku(e.kernelConstraint), _this109.recurrentConstraint = Ku(e.recurrentConstraint), _this109.biasConstraint = Ku(e.biasConstraint), _this109.dropout = hc([1, dc([0, null == e.dropout ? 0 : e.dropout])]), _this109.recurrentDropout = hc([1, dc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), _this109.stateSize = _this109.units, _this109.dropoutMask = null, _this109.recurrentDropoutMask = null;
    return _this109;
  }

  _createClass(Tp, [{
    key: "build",
    value: function build(e) {
      e = ah(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.bias = this.useBias ? this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this110 = this;

      return Yn(function () {
        if (2 !== (e = e).length) throw new bu("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length, "."));
        var n = e[1];
        e = e[0];
        var s = null != t.training && t.training;
        var r;
        0 < _this110.dropout && _this110.dropout < 1 && null == _this110.dropoutMask && (_this110.dropoutMask = Op({
          ones: function ones() {
            return xa(e);
          },
          rate: _this110.dropout,
          training: s
        })), 0 < _this110.recurrentDropout && _this110.recurrentDropout < 1 && null == _this110.recurrentDropoutMask && (_this110.recurrentDropoutMask = Op({
          ones: function ones() {
            return xa(n);
          },
          rate: _this110.recurrentDropout,
          training: s
        }));
        var a = _this110.dropoutMask,
            i = _this110.recurrentDropoutMask;
        r = Ic(null != a ? ss(e, a) : e, _this110.kernel.read()), null != _this110.bias && (r = Sc(r, _this110.bias.read())), null != i && (n = ss(n, i));
        var o = es(r, Ic(n, _this110.recurrentKernel.read()));
        return null != _this110.activation && (o = _this110.activation.apply(o)), [o, o];
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(Tp.prototype), "getConfig", this).call(this),
          t = {
        units: this.units,
        activation: Hd(this.activation),
        useBias: this.useBias,
        kernelInitializer: Yc(this.kernelInitializer),
        recurrentInitializer: Yc(this.recurrentInitializer),
        biasInitializer: Yc(this.biasInitializer),
        kernelRegularizer: Jd(this.kernelRegularizer),
        recurrentRegularizer: Jd(this.recurrentRegularizer),
        biasRegularizer: Jd(this.biasRegularizer),
        activityRegularizer: Jd(this.activityRegularizer),
        kernelConstraint: ju(this.kernelConstraint),
        recurrentConstraint: ju(this.recurrentConstraint),
        biasConstraint: ju(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout
      };

      return Object.assign({}, e, t);
    }
  }]);

  return Tp;
}(Sp);

Tp.className = "SimpleRNNCell", qn(Tp);

var Ep = /*#__PURE__*/function (_Cp) {
  "use strict";

  _inherits(Ep, _Cp);

  var _super83 = _createSuper(Ep);

  function Ep(e) {
    var _this111;

    _classCallCheck(this, Ep);

    e.cell = new Tp(e), _this111 = _super83.call(this, e);
    return _this111;
  }

  _createClass(Ep, [{
    key: "call",
    value: function call(e, t) {
      var _this112 = this;

      return Yn(function () {
        return null != _this112.cell.dropoutMask && (Jn(_this112.cell.dropoutMask), _this112.cell.dropoutMask = null), null != _this112.cell.recurrentDropoutMask && (Jn(_this112.cell.recurrentDropoutMask), _this112.cell.recurrentDropoutMask = null), _get(_getPrototypeOf(Ep.prototype), "call", _this112).call(_this112, e, {
          mask: null == t ? null : t.mask,
          training: null == t ? null : t.training,
          initialState: null == t ? null : t.initialState
        });
      });
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t);
    }
  }]);

  return Ep;
}(Cp);

Ep.className = "SimpleRNN", qn(Ep);

var Rp = /*#__PURE__*/function (_Sp2) {
  "use strict";

  _inherits(Rp, _Sp2);

  var _super84 = _createSuper(Rp);

  function Rp(e) {
    var _this113;

    _classCallCheck(this, Rp);

    if (_this113 = _super84.call(this, e), _this113.DEFAULT_ACTIVATION = "tanh", _this113.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", _this113.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", _this113.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", _this113.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter) throw new bu("GRUCell does not support reset_after parameter set to true.");
    _this113.units = e.units, Mu(_this113.units, "units"), _this113.activation = qd(void 0 === e.activation ? _this113.DEFAULT_ACTIVATION : e.activation), _this113.recurrentActivation = qd(void 0 === e.recurrentActivation ? _this113.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), _this113.useBias = null == e.useBias || e.useBias, _this113.kernelInitializer = Jc(e.kernelInitializer || _this113.DEFAULT_KERNEL_INITIALIZER), _this113.recurrentInitializer = Jc(e.recurrentInitializer || _this113.DEFAULT_RECURRENT_INITIALIZER), _this113.biasInitializer = Jc(e.biasInitializer || _this113.DEFAULT_BIAS_INITIALIZER), _this113.kernelRegularizer = Qd(e.kernelRegularizer), _this113.recurrentRegularizer = Qd(e.recurrentRegularizer), _this113.biasRegularizer = Qd(e.biasRegularizer), _this113.kernelConstraint = Ku(e.kernelConstraint), _this113.recurrentConstraint = Ku(e.recurrentConstraint), _this113.biasConstraint = Ku(e.biasConstraint), _this113.dropout = hc([1, dc([0, null == e.dropout ? 0 : e.dropout])]), _this113.recurrentDropout = hc([1, dc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), _this113.implementation = e.implementation, _this113.stateSize = _this113.units, _this113.dropoutMask = null, _this113.recurrentDropoutMask = null;
    return _possibleConstructorReturn(_this113);
  }

  _createClass(Rp, [{
    key: "build",
    value: function build(e) {
      e = ah(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.bias = this.useBias ? this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : null, this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this114 = this;

      return Yn(function () {
        if (2 !== (e = e).length) throw new bu("GRUCell expects 2 input Tensors (inputs, h, c), got ".concat(e.length, "."));
        var n = null != t.training && t.training;
        var s = e[1];
        e = e[0], 0 < _this114.dropout && _this114.dropout < 1 && null == _this114.dropoutMask && (_this114.dropoutMask = Op({
          ones: function ones() {
            return xa(e);
          },
          rate: _this114.dropout,
          training: n,
          count: 3
        })), 0 < _this114.recurrentDropout && _this114.recurrentDropout < 1 && null == _this114.recurrentDropoutMask && (_this114.recurrentDropoutMask = Op({
          ones: function ones() {
            return xa(s);
          },
          rate: _this114.recurrentDropout,
          training: n,
          count: 3
        }));
        var r = _this114.recurrentDropoutMask;
        var a, i, o;
        0 < _this114.dropout && _this114.dropout < 1 && (e = ss(e, _this114.dropoutMask[0]));
        var l = Ic(e, _this114.kernel.read());
        _this114.useBias && (l = Sc(l, _this114.bias.read())), 0 < _this114.recurrentDropout && _this114.recurrentDropout < 1 && (s = ss(s, r[0]));

        var u = _this114.recurrentKernel.read(),
            _oi3 = oi(u, [2 * _this114.units, _this114.units], u.rank - 1),
            _oi4 = _slicedToArray(_oi3, 2),
            c = _oi4[0],
            h = _oi4[1],
            d = Ic(s, c),
            _oi5 = oi(l, 3, l.rank - 1),
            _oi6 = _slicedToArray(_oi5, 3),
            p = _oi6[0],
            f = _oi6[1],
            g = _oi6[2],
            _oi7 = oi(d, 2, d.rank - 1),
            _oi8 = _slicedToArray(_oi7, 2),
            m = _oi8[0],
            b = _oi8[1];

        a = _this114.recurrentActivation.apply(es(p, m)), i = _this114.recurrentActivation.apply(es(f, b));
        var x = Ic(ss(i, s), h);
        o = _this114.activation.apply(es(g, x));
        var y = es(ss(a, s), ss(es(1, Br(a)), o));
        return [y, y];
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(Rp.prototype), "getConfig", this).call(this),
          t = {
        units: this.units,
        activation: Hd(this.activation),
        recurrentActivation: Hd(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: Yc(this.kernelInitializer),
        recurrentInitializer: Yc(this.recurrentInitializer),
        biasInitializer: Yc(this.biasInitializer),
        kernelRegularizer: Jd(this.kernelRegularizer),
        recurrentRegularizer: Jd(this.recurrentRegularizer),
        biasRegularizer: Jd(this.biasRegularizer),
        activityRegularizer: Jd(this.activityRegularizer),
        kernelConstraint: ju(this.kernelConstraint),
        recurrentConstraint: ju(this.recurrentConstraint),
        biasConstraint: ju(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation,
        resetAfter: !1
      };

      return Object.assign({}, e, t);
    }
  }]);

  return Rp;
}(Sp);

Rp.className = "GRUCell", qn(Rp);

var Ap = /*#__PURE__*/function (_Cp2) {
  "use strict";

  _inherits(Ap, _Cp2);

  var _super85 = _createSuper(Ap);

  function Ap(e) {
    var _this115;

    _classCallCheck(this, Ap);

    0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Rp(e), _this115 = _super85.call(this, e);
    return _this115;
  }

  _createClass(Ap, [{
    key: "call",
    value: function call(e, t) {
      var _this116 = this;

      return Yn(function () {
        return null != _this116.cell.dropoutMask && (Jn(_this116.cell.dropoutMask), _this116.cell.dropoutMask = null), null != _this116.cell.recurrentDropoutMask && (Jn(_this116.cell.recurrentDropoutMask), _this116.cell.recurrentDropoutMask = null), _get(_getPrototypeOf(Ap.prototype), "call", _this116).call(_this116, e, {
          mask: null == t ? null : t.mask,
          training: null == t ? null : t.training,
          initialState: null == t ? null : t.initialState
        });
      });
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return 0 === t.implmentation && (t.implementation = 1), new e(t);
    }
  }]);

  return Ap;
}(Cp);

Ap.className = "GRU", qn(Ap);

var Fp = /*#__PURE__*/function (_Sp3) {
  "use strict";

  _inherits(Fp, _Sp3);

  var _super86 = _createSuper(Fp);

  function Fp(e) {
    var _this117;

    _classCallCheck(this, Fp);

    _this117 = _super86.call(this, e), _this117.DEFAULT_ACTIVATION = "tanh", _this117.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", _this117.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", _this117.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", _this117.DEFAULT_BIAS_INITIALIZER = "zeros", _this117.units = e.units, Mu(_this117.units, "units"), _this117.activation = qd(void 0 === e.activation ? _this117.DEFAULT_ACTIVATION : e.activation), _this117.recurrentActivation = qd(void 0 === e.recurrentActivation ? _this117.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), _this117.useBias = null == e.useBias || e.useBias, _this117.kernelInitializer = Jc(e.kernelInitializer || _this117.DEFAULT_KERNEL_INITIALIZER), _this117.recurrentInitializer = Jc(e.recurrentInitializer || _this117.DEFAULT_RECURRENT_INITIALIZER), _this117.biasInitializer = Jc(e.biasInitializer || _this117.DEFAULT_BIAS_INITIALIZER), _this117.unitForgetBias = e.unitForgetBias, _this117.kernelRegularizer = Qd(e.kernelRegularizer), _this117.recurrentRegularizer = Qd(e.recurrentRegularizer), _this117.biasRegularizer = Qd(e.biasRegularizer), _this117.kernelConstraint = Ku(e.kernelConstraint), _this117.recurrentConstraint = Ku(e.recurrentConstraint), _this117.biasConstraint = Ku(e.biasConstraint), _this117.dropout = hc([1, dc([0, null == e.dropout ? 0 : e.dropout])]), _this117.recurrentDropout = hc([1, dc([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), _this117.implementation = e.implementation, _this117.stateSize = [_this117.units, _this117.units], _this117.dropoutMask = null, _this117.recurrentDropoutMask = null;
    return _this117;
  }

  _createClass(Fp, [{
    key: "build",
    value: function build(e) {
      var t;
      var n;

      if (e = ah(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
        if (this.unitForgetBias) {
          var _e218 = this.biasInitializer,
              _s108 = this.units;
          n = new ((t = /*#__PURE__*/function (_Fc10) {
            _inherits(t, _Fc10);

            var _super87 = _createSuper(t);

            function t() {
              _classCallCheck(this, t);

              return _super87.apply(this, arguments);
            }

            _createClass(t, [{
              key: "apply",
              value: function apply(_t256, n) {
                var r = _e218.apply([_s108]),
                    a = new _c().apply([_s108]),
                    i = _e218.apply([2 * _s108]);

                return kc(kc(r, a), i);
              }
            }]);

            return t;
          }(Fc)).className = "CustomInit", t)();
        } else n = this.biasInitializer;

        this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint);
      } else this.bias = null;

      this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this118 = this;

      return Yn(function () {
        var n = null != t.training && t.training;
        if (3 !== (e = e).length) throw new bu("LSTMCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length, "."));
        var s = e[1];
        var r = e[2];
        e = e[0], 0 < _this118.dropout && _this118.dropout < 1 && null == _this118.dropoutMask && (_this118.dropoutMask = Op({
          ones: function ones() {
            return xa(e);
          },
          rate: _this118.dropout,
          training: n,
          count: 4
        })), 0 < _this118.recurrentDropout && _this118.recurrentDropout < 1 && null == _this118.recurrentDropoutMask && (_this118.recurrentDropoutMask = Op({
          ones: function ones() {
            return xa(s);
          },
          rate: _this118.recurrentDropout,
          training: n,
          count: 4
        }));
        var a = _this118.recurrentDropoutMask;
        var i, o, l, u;
        0 < _this118.dropout && _this118.dropout < 1 && (e = ss(e, _this118.dropoutMask[0]));
        var c = Ic(e, _this118.kernel.read());
        0 < _this118.recurrentDropout && _this118.recurrentDropout < 1 && (s = ss(s, a[0])), c = es(c, Ic(s, _this118.recurrentKernel.read())), _this118.useBias && (c = Sc(c, _this118.bias.read()));

        var _oi9 = oi(c, 4, c.rank - 1),
            _oi10 = _slicedToArray(_oi9, 4),
            h = _oi10[0],
            d = _oi10[1],
            p = _oi10[2],
            f = _oi10[3];

        i = _this118.recurrentActivation.apply(h), o = _this118.recurrentActivation.apply(d), l = es(ss(o, r), ss(i, _this118.activation.apply(p))), u = _this118.recurrentActivation.apply(f);
        var g = ss(u, _this118.activation.apply(l));
        return [g, g, l];
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(Fp.prototype), "getConfig", this).call(this),
          t = {
        units: this.units,
        activation: Hd(this.activation),
        recurrentActivation: Hd(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: Yc(this.kernelInitializer),
        recurrentInitializer: Yc(this.recurrentInitializer),
        biasInitializer: Yc(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: Jd(this.kernelRegularizer),
        recurrentRegularizer: Jd(this.recurrentRegularizer),
        biasRegularizer: Jd(this.biasRegularizer),
        activityRegularizer: Jd(this.activityRegularizer),
        kernelConstraint: ju(this.kernelConstraint),
        recurrentConstraint: ju(this.recurrentConstraint),
        biasConstraint: ju(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
      };

      return Object.assign({}, e, t);
    }
  }]);

  return Fp;
}(Sp);

Fp.className = "LSTMCell", qn(Fp);

var Dp = /*#__PURE__*/function (_Cp3) {
  "use strict";

  _inherits(Dp, _Cp3);

  var _super88 = _createSuper(Dp);

  function Dp(e) {
    var _this119;

    _classCallCheck(this, Dp);

    0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Fp(e), _this119 = _super88.call(this, e);
    return _this119;
  }

  _createClass(Dp, [{
    key: "call",
    value: function call(e, t) {
      var _this120 = this;

      return Yn(function () {
        return null != _this120.cell.dropoutMask && (Jn(_this120.cell.dropoutMask), _this120.cell.dropoutMask = null), null != _this120.cell.recurrentDropoutMask && (Jn(_this120.cell.recurrentDropoutMask), _this120.cell.recurrentDropoutMask = null), _get(_getPrototypeOf(Dp.prototype), "call", _this120).call(_this120, e, {
          mask: null == t ? null : t.mask,
          training: null == t ? null : t.training,
          initialState: null == t ? null : t.initialState
        });
      });
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return 0 === t.implmentation && (t.implementation = 1), new e(t);
    }
  }]);

  return Dp;
}(Cp);

Dp.className = "LSTM", qn(Dp);

var _p = /*#__PURE__*/function (_Sp4) {
  "use strict";

  _inherits(_p, _Sp4);

  var _super89 = _createSuper(_p);

  function _p(e) {
    var _this121;

    _classCallCheck(this, _p);

    _this121 = _super89.call(this, e), _this121.cells = e.cells;
    return _this121;
  }

  _createClass(_p, [{
    key: "stateSize",
    get: function get() {
      var e = [];

      var _iterator94 = _createForOfIteratorHelper(this.cells.slice().reverse()),
          _step94;

      try {
        for (_iterator94.s(); !(_step94 = _iterator94.n()).done;) {
          var t = _step94.value;
          Array.isArray(t.stateSize) ? e.push.apply(e, _toConsumableArray(t.stateSize)) : e.push(t.stateSize);
        }
      } catch (err) {
        _iterator94.e(err);
      } finally {
        _iterator94.f();
      }

      return e;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this122 = this;

      return Yn(function () {
        var n = (e = e).slice(1);
        var s = [];

        var _iterator95 = _createForOfIteratorHelper(_this122.cells.slice().reverse()),
            _step95;

        try {
          for (_iterator95.s(); !(_step95 = _iterator95.n()).done;) {
            var _e219 = _step95.value;
            Array.isArray(_e219.stateSize) ? s.push(n.splice(0, _e219.stateSize.length)) : s.push(n.splice(0, 1));
          }
        } catch (err) {
          _iterator95.e(err);
        } finally {
          _iterator95.f();
        }

        s.reverse();
        var r = [];
        var a;

        for (var i = 0; i < _this122.cells.length; ++i) {
          var o = _this122.cells[i];
          n = s[i], a = 0 === i ? [e[0]].concat(n) : [a[0]].concat(n), a = o.call(a, t), r.push(a.slice(1));
        }

        n = [];

        var _iterator96 = _createForOfIteratorHelper(r.slice().reverse()),
            _step96;

        try {
          for (_iterator96.s(); !(_step96 = _iterator96.n()).done;) {
            var _n127;

            var _e220 = _step96.value;

            (_n127 = n).push.apply(_n127, _toConsumableArray(_e220));
          }
        } catch (err) {
          _iterator96.e(err);
        } finally {
          _iterator96.f();
        }

        return [a[0]].concat(n);
      });
    }
  }, {
    key: "build",
    value: function build(e) {
      var t;
      nh(e) && (e = e[0]), e = e, this.cells.forEach(function (n, s) {
        ac("RNNCell_".concat(s), function () {
          n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t];
        });
      }), this.built = !0;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(_p.prototype), "getConfig", this).call(this),
          t = this.cells.map(function (e) {
        return {
          className: e.getClassName(),
          config: e.getConfig()
        };
      });

      return Object.assign({}, e, {
        cells: t
      });
    }
  }, {
    key: "trainableWeights",
    get: function get() {
      if (!this.trainable) return [];
      var e = [];

      var _iterator97 = _createForOfIteratorHelper(this.cells),
          _step97;

      try {
        for (_iterator97.s(); !(_step97 = _iterator97.n()).done;) {
          var t = _step97.value;
          e.push.apply(e, _toConsumableArray(t.trainableWeights));
        }
      } catch (err) {
        _iterator97.e(err);
      } finally {
        _iterator97.f();
      }

      return e;
    }
  }, {
    key: "nonTrainableWeights",
    get: function get() {
      var e = [];

      var _iterator98 = _createForOfIteratorHelper(this.cells),
          _step98;

      try {
        for (_iterator98.s(); !(_step98 = _iterator98.n()).done;) {
          var _t257 = _step98.value;
          e.push.apply(e, _toConsumableArray(_t257.nonTrainableWeights));
        }
      } catch (err) {
        _iterator98.e(err);
      } finally {
        _iterator98.f();
      }

      if (!this.trainable) {
        var t = [];

        var _iterator99 = _createForOfIteratorHelper(this.cells),
            _step99;

        try {
          for (_iterator99.s(); !(_step99 = _iterator99.n()).done;) {
            var _e221 = _step99.value;
            t.push.apply(t, _toConsumableArray(_e221.trainableWeights));
          }
        } catch (err) {
          _iterator99.e(err);
        } finally {
          _iterator99.f();
        }

        return t.concat(e);
      }

      return e;
    }
  }, {
    key: "getWeights",
    value: function getWeights() {
      var e = [];

      var _iterator100 = _createForOfIteratorHelper(this.cells),
          _step100;

      try {
        for (_iterator100.s(); !(_step100 = _iterator100.n()).done;) {
          var t = _step100.value;
          e.push.apply(e, _toConsumableArray(t.weights));
        }
      } catch (err) {
        _iterator100.e(err);
      } finally {
        _iterator100.f();
      }

      return lh(e);
    }
  }, {
    key: "setWeights",
    value: function setWeights(e) {
      var t = [];

      var _iterator101 = _createForOfIteratorHelper(this.cells),
          _step101;

      try {
        for (_iterator101.s(); !(_step101 = _iterator101.n()).done;) {
          var _n128 = _step101.value;

          var _s109 = e.splice(_n128.weights.length);

          for (var _e222 = 0; _e222 < _n128.weights.length; ++_e222) {
            t.push([_n128.weights[_e222], _s109[_e222]]);
          }
        }
      } catch (err) {
        _iterator101.e(err);
      } finally {
        _iterator101.f();
      }

      uh(t);
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var s = [];

      var _iterator102 = _createForOfIteratorHelper(t.cells),
          _step102;

      try {
        for (_iterator102.s(); !(_step102 = _iterator102.n()).done;) {
          var _e223 = _step102.value;
          s.push(Eh(_e223, n));
        }
      } catch (err) {
        _iterator102.e(err);
      } finally {
        _iterator102.f();
      }

      return new e({
        cells: s
      });
    }
  }]);

  return _p;
}(Sp);

function Op(e) {
  var t = e.ones,
      n = e.rate,
      _e$training = e.training,
      s = _e$training === void 0 ? !1 : _e$training,
      _e$count = e.count,
      r = _e$count === void 0 ? 1 : _e$count,
      a = function a() {
    return Tc(t(), n);
  },
      i = function i() {
    return Ec(a, t, s);
  };

  return !r || r <= 1 ? Zn(i().clone()) : Array(r).fill(void 0).map(i).map(function (e) {
    return Zn(e.clone());
  });
}

var Mp, Lp, zp;
_p.className = "StackedRNNCells", qn(_p);

var Bp = /*#__PURE__*/function (_Cp4) {
  "use strict";

  _inherits(Bp, _Cp4);

  var _super90 = _createSuper(Bp);

  function Bp(e) {
    var _this123;

    _classCallCheck(this, Bp);

    if (e.unroll) throw new xu("Unrolling is not possible with convolutional RNNs.");
    if (Array.isArray(e.cell)) throw new xu("It is not possible at the moment to stack convolutional cells.");
    _this123 = _super90.call(this, e), _this123.inputSpec = [new ch({
      ndim: 5
    })];
    return _this123;
  }

  _createClass(Bp, [{
    key: "call",
    value: function call(e, t) {
      var _this124 = this;

      return Yn(function () {
        if (null != _this124.cell.dropoutMask && (Jn(_this124.cell.dropoutMask), _this124.cell.dropoutMask = null), null != _this124.cell.recurrentDropoutMask && (Jn(_this124.cell.recurrentDropoutMask), _this124.cell.recurrentDropoutMask = null), t && t.constants) throw new bu("ConvRNN2D cell does not support constants");
        return _get(_getPrototypeOf(Bp.prototype), "call", _this124).call(_this124, e, {
          mask: null == t ? null : t.mask,
          training: null == t ? null : t.training,
          initialState: null == t ? null : t.initialState
        });
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = this.computeSingleOutputShape(e);
      return this.returnSequences || (t = [t[0]].concat(_toConsumableArray(t.slice(2)))), this.returnState && (t = [t].concat(_toConsumableArray(Array(2).fill([e[0]].concat(_toConsumableArray(t.slice(-3))))))), t;
    }
  }, {
    key: "getInitialState",
    value: function getInitialState(e) {
      var _this125 = this;

      return Yn(function () {
        var t = _this125.cell.stateSize,
            n = _this125.computeSingleOutputShape(e.shape),
            s = ua([n[0]].concat(_toConsumableArray(n.slice(2))));

        return Array.isArray(t) ? Array(t.length).fill(s) : [s];
      });
    }
  }, {
    key: "resetStates",
    value: function resetStates(e) {
      var _this126 = this;

      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      Yn(function () {
        if (!_this126.stateful) throw new gu("Cannot call resetStates() on an RNN Layer that is not stateful.");

        var n = _this126.inputSpec[0].shape,
            s = _this126.computeSingleOutputShape(n),
            r = [s[0]].concat(_toConsumableArray(s.slice(2)));

        if (null == n[0]) throw new bu("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (null == _this126.getStates()) _this126.states_ = Array.isArray(_this126.cell.stateSize) ? _this126.cell.stateSize.map(function () {
          return ua(r);
        }) : [ua(r)];else if (null == e) Jn(_this126.states_), null != _this126.keptStates && (Jn(_this126.keptStates), _this126.keptStates = []), Array.isArray(_this126.cell.stateSize) ? _this126.states_ = _this126.cell.stateSize.map(function () {
          return ua(r);
        }) : _this126.states_[0] = ua(r);else {
          if (Array.isArray(e) || (e = [e]), e.length !== _this126.states_.length) throw new bu("Layer ".concat(_this126.name, " expects ").concat(_this126.states_.length, " state(s), but it received ").concat(e.length, " state value(s). Input received: ").concat(e));
          t ? _this126.keptStates.push(_this126.states_.slice()) : Jn(_this126.states_);

          for (var _t258 = 0; _t258 < _this126.states_.length; ++_t258) {
            var _n129 = e[_t258],
                _s110 = r;
            if (!p(_n129.shape, _s110)) throw new bu("State ".concat(_t258, " is incompatible with layer ").concat(_this126.name, ": expected shape=").concat(_s110, ", received shape=").concat(_n129.shape));
            _this126.states_[_t258] = _n129;
          }
        }
        _this126.states_ = _this126.states_.map(function (e) {
          return Zn(e.clone());
        });
      });
    }
  }, {
    key: "computeSingleOutputShape",
    value: function computeSingleOutputShape(e) {
      var _this$cell = this.cell,
          t = _this$cell.dataFormat,
          n = _this$cell.filters,
          s = _this$cell.kernelSize,
          r = _this$cell.padding,
          a = _this$cell.strides,
          i = _this$cell.dilationRate,
          o = "channelsFirst" === t,
          l = e[o ? 4 : 3],
          u = op(e[o ? 3 : 2], s[0], r, a[0], i[0]),
          c = op(l, s[1], r, a[1], i[1]);
      return [].concat(_toConsumableArray(e.slice(0, 2)), _toConsumableArray(o ? [n, u, c] : [u, c, n]));
    }
  }]);

  return Bp;
}(Cp);

Bp.className = "ConvRNN2D";

var Pp = /*#__PURE__*/function (_Fp) {
  "use strict";

  _inherits(Pp, _Fp);

  var _super91 = _createSuper(Pp);

  function Pp(e) {
    var _this127;

    _classCallCheck(this, Pp);

    var t = e.filters,
        n = e.kernelSize,
        s = e.strides,
        r = e.padding,
        a = e.dataFormat,
        i = e.dilationRate;
    _this127 = _super91.call(this, Object.assign({}, e, {
      units: t
    })), _this127.filters = t, Mu(_this127.filters, "filters"), _this127.kernelSize = ip(n, 2, "kernelSize"), _this127.kernelSize.forEach(function (e) {
      return Mu(e, "kernelSize");
    }), _this127.strides = ip(s || 1, 2, "strides"), _this127.strides.forEach(function (e) {
      return Mu(e, "strides");
    }), _this127.padding = r || "valid", nc(_this127.padding), _this127.dataFormat = a || "channelsLast", tc(_this127.dataFormat), _this127.dilationRate = ip(i || 1, 2, "dilationRate"), _this127.dilationRate.forEach(function (e) {
      return Mu(e, "dilationRate");
    });
    return _this127;
  }

  _createClass(Pp, [{
    key: "build",
    value: function build(e) {
      var t;
      e = ah(e);
      var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
      if (null == e[n]) throw new bu("The channel dimension of the input should be defined. Found ".concat(e[n]));
      var s = this.kernelSize.concat([e[n], 4 * this.filters]);
      this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
      var r = this.kernelSize.concat([this.filters, 4 * this.filters]);

      if (this.recurrentKernel = this.addWeight("recurrent_kernel", r, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
        var _e224;

        if (this.unitForgetBias) {
          var _n130 = this.biasInitializer,
              _s111 = this.filters;
          _e224 = new ((t = /*#__PURE__*/function (_Fc11) {
            _inherits(t, _Fc11);

            var _super92 = _createSuper(t);

            function t() {
              _classCallCheck(this, t);

              return _super92.apply(this, arguments);
            }

            _createClass(t, [{
              key: "apply",
              value: function apply(e, _t259) {
                return yc([_n130.apply([_s111]), ca([_s111]), _n130.apply([2 * _s111])]);
              }
            }]);

            return t;
          }(Fc)).className = "CustomInit", t)();
        } else _e224 = this.biasInitializer;

        this.bias = this.addWeight("bias", [4 * this.filters], null, _e224, this.biasRegularizer, !0, this.biasConstraint);
      }

      this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this128 = this;

      return Yn(function () {
        if (3 !== e.length) throw new bu("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ".concat(e.length, "."));
        var n = t.training || !1,
            s = e[0],
            r = e[1],
            a = e[2];
        0 < _this128.dropout && _this128.dropout < 1 && null == _this128.dropoutMask && (_this128.dropoutMask = Op({
          ones: function ones() {
            return xa(s);
          },
          rate: _this128.dropout,
          training: n,
          count: 4
        }));

        var i = _this128.dropoutMask,
            o = function o(e, t, n) {
          return t && t[n] ? ss(t[n], e) : e;
        };

        var l = o(s, i, 0),
            u = o(s, i, 1),
            c = o(s, i, 2),
            h = o(s, i, 3);
        0 < _this128.recurrentDropout && _this128.recurrentDropout < 1 && null == _this128.recurrentDropoutMask && (_this128.recurrentDropoutMask = Op({
          ones: function ones() {
            return xa(r);
          },
          rate: _this128.recurrentDropout,
          training: n,
          count: 4
        }));
        var d = _this128.recurrentDropoutMask;
        var p = o(r, d, 0),
            f = o(r, d, 1),
            g = o(r, d, 2),
            m = o(r, d, 3);

        var _oi11 = oi(_this128.kernel.read(), 4, 3),
            _oi12 = _slicedToArray(_oi11, 4),
            b = _oi12[0],
            x = _oi12[1],
            y = _oi12[2],
            k = _oi12[3],
            _ref17 = _this128.useBias ? oi(_this128.bias.read(), 4) : [null, null, null, null],
            _ref18 = _slicedToArray(_ref17, 4),
            w = _ref18[0],
            v = _ref18[1],
            I = _ref18[2],
            $ = _ref18[3];

        l = _this128.inputConv(l, b, w, _this128.padding), u = _this128.inputConv(u, x, v, _this128.padding), c = _this128.inputConv(c, y, I, _this128.padding), h = _this128.inputConv(h, k, $, _this128.padding);

        var _oi13 = oi(_this128.recurrentKernel.read(), 4, 3),
            _oi14 = _slicedToArray(_oi13, 4),
            N = _oi14[0],
            C = _oi14[1],
            S = _oi14[2],
            T = _oi14[3];

        p = _this128.recurrentConv(p, N), f = _this128.recurrentConv(f, C), g = _this128.recurrentConv(g, S), m = _this128.recurrentConv(m, T);

        var E = _this128.recurrentActivation.apply(es(l, p)),
            R = _this128.recurrentActivation.apply(es(u, f)),
            A = es(ss(R, a), ss(E, _this128.activation.apply(es(c, g)))),
            F = ss(_this128.recurrentActivation.apply(es(h, m)), _this128.activation.apply(A));

        return [F, F, A];
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = function (e, t) {
        var n = {};

        for (var s in e) {
          Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
        }

        if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
          var r = 0;

          for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) {
            t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]]);
          }
        }

        return n;
      }(_get(_getPrototypeOf(Pp.prototype), "getConfig", this).call(this), ["units"]);

      return Object.assign({}, e, {
        filters: this.filters,
        kernelSize: this.kernelSize,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        strides: this.strides
      });
    }
  }, {
    key: "inputConv",
    value: function inputConv(e, t, n, s) {
      var r = Xs(e, t, this.strides, s || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
      return n ? Sc(r, n, this.dataFormat) : r;
    }
  }, {
    key: "recurrentConv",
    value: function recurrentConv(e, t) {
      return Xs(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC");
    }
  }]);

  return Pp;
}(Fp);

Pp.className = "ConvLSTM2DCell", qn(Pp);

var Wp = /*#__PURE__*/function (_Bp) {
  "use strict";

  _inherits(Wp, _Bp);

  var _super93 = _createSuper(Wp);

  function Wp(e) {
    _classCallCheck(this, Wp);

    var t = new Pp(e);
    return _super93.call(this, Object.assign({}, e, {
      cell: t
    }));
  }

  _createClass(Wp, null, [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      return new e(t);
    }
  }]);

  return Wp;
}(Bp);

Wp.className = "ConvLSTM2D", qn(Wp);

var Up = /*#__PURE__*/function (_gh14) {
  "use strict";

  _inherits(Up, _gh14);

  var _super94 = _createSuper(Up);

  function Up(e) {
    var _this129;

    _classCallCheck(this, Up);

    _this129 = _super94.call(this, e), _this129.rate = Math.max(Math.min(e.rate, 1), 0), _this129.noiseShape = e.noiseShape, _this129.seed = e.seed, _this129.supportsMasking = !0;
    return _this129;
  }

  _createClass(Up, [{
    key: "getNoiseShape",
    value: function getNoiseShape(e) {
      if (null == this.noiseShape) return this.noiseShape;
      var t = e.shape,
          n = [];

      for (var _e225 = 0; _e225 < this.noiseShape.length; ++_e225) {
        n.push(null == this.noiseShape[_e225] ? t[_e225] : this.noiseShape[_e225]);
      }

      return n;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this130 = this;

      return Yn(function () {
        _this130.invokeCallHook(e, t);

        var n = rh(e);

        if (0 < _this130.rate && _this130.rate < 1) {
          var _e226 = null != t.training && t.training,
              _s112 = _this130.getNoiseShape(n);

          return Ec(function () {
            return Tc(n, _this130.rate, _s112, _this130.seed);
          }, function () {
            return n;
          }, _e226);
        }

        return e;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        rate: this.rate,
        noiseShape: this.noiseShape,
        seed: this.seed
      },
          t = _get(_getPrototypeOf(Up.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      return _get(_getPrototypeOf(Up.prototype), "dispose", this).call(this);
    }
  }]);

  return Up;
}(gh);

Up.className = "Dropout", qn(Up);

var Vp = /*#__PURE__*/function (_Up) {
  "use strict";

  _inherits(Vp, _Up);

  var _super95 = _createSuper(Vp);

  function Vp(e) {
    var _this131;

    _classCallCheck(this, Vp);

    _this131 = _super95.call(this, e), _this131.inputSpec = [{
      ndim: 3
    }];
    return _this131;
  }

  _createClass(Vp, [{
    key: "getNoiseShape",
    value: function getNoiseShape(e) {
      var t = e.shape;
      return [t[0], 1, t[2]];
    }
  }]);

  return Vp;
}(Up);

Vp.className = "SpatialDropout1D", qn(Vp);

var Gp = /*#__PURE__*/function (_gh15) {
  "use strict";

  _inherits(Gp, _gh15);

  var _super96 = _createSuper(Gp);

  function Gp(e) {
    var _this132;

    _classCallCheck(this, Gp);

    if (_this132 = _super96.call(this, e), _this132.activation = null, _this132.useBias = !0, _this132.kernel = null, _this132.bias = null, _this132.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", _this132.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
      var t = null;
      null != e.batchSize && (t = e.batchSize), _this132.batchInputShape = [t, e.inputDim];
    }

    _this132.units = e.units, Mu(_this132.units, "units"), _this132.activation = qd(e.activation), null != e.useBias && (_this132.useBias = e.useBias), _this132.kernelInitializer = Jc(e.kernelInitializer || _this132.DEFAULT_KERNEL_INITIALIZER), _this132.biasInitializer = Jc(e.biasInitializer || _this132.DEFAULT_BIAS_INITIALIZER), _this132.kernelConstraint = Ku(e.kernelConstraint), _this132.biasConstraint = Ku(e.biasConstraint), _this132.kernelRegularizer = Qd(e.kernelRegularizer), _this132.biasRegularizer = Qd(e.biasRegularizer), _this132.activityRegularizer = Qd(e.activityRegularizer), _this132.supportsMasking = !0, _this132.inputSpec = [{
      minNDim: 2
    }];
    return _possibleConstructorReturn(_this132);
  }

  _createClass(Gp, [{
    key: "build",
    value: function build(e) {
      var t = (e = ah(e))[e.length - 1];
      null == this.kernel && (this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
        minNDim: 2,
        axes: _defineProperty({}, -1, t)
      }], this.built = !0;
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = (e = ah(e)).slice();
      return t[t.length - 1] = this.units, t;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this133 = this;

      return Yn(function () {
        _this133.invokeCallHook(e, t);

        var n = rh(e),
            s = zu(_this133.activation.getClassName());
        var r;
        return null != s ? r = Ic(n, _this133.kernel.read(), s, _this133.bias ? _this133.bias.read() : null) : (r = Ic(n, _this133.kernel.read()), null != _this133.bias && (r = Sc(r, _this133.bias.read())), null != _this133.activation && (r = _this133.activation.apply(r))), r;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        units: this.units,
        activation: Hd(this.activation),
        useBias: this.useBias,
        kernelInitializer: Yc(this.kernelInitializer),
        biasInitializer: Yc(this.biasInitializer),
        kernelRegularizer: Jd(this.kernelRegularizer),
        biasRegularizer: Jd(this.biasRegularizer),
        activityRegularizer: Jd(this.activityRegularizer),
        kernelConstraint: ju(this.kernelConstraint),
        biasConstraint: ju(this.biasConstraint)
      },
          t = _get(_getPrototypeOf(Gp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return Gp;
}(gh);

Gp.className = "Dense", qn(Gp);

var Hp = /*#__PURE__*/function (_gh16) {
  "use strict";

  _inherits(Hp, _gh16);

  var _super97 = _createSuper(Hp);

  function Hp(e) {
    var _this134;

    _classCallCheck(this, Hp);

    _this134 = _super97.call(this, e = e || {}), _this134.inputSpec = [{
      minNDim: 3
    }], _this134.dataFormat = e.dataFormat;
    return _this134;
  }

  _createClass(Hp, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      e = ah(e);

      var _iterator103 = _createForOfIteratorHelper(e.slice(1)),
          _step103;

      try {
        for (_iterator103.s(); !(_step103 = _iterator103.n()).done;) {
          var t = _step103.value;
          if (null == t) throw new bu("The shape of the input to \"Flatten\" is not fully defined (got ".concat(e.slice(1), "). Make sure to pass a complete \"input_shape\" or \"batch_input_shape\" argument to the first layer in your model."));
        }
      } catch (err) {
        _iterator103.e(err);
      } finally {
        _iterator103.f();
      }

      return [e[0], cc(e, 1)];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this135 = this;

      return Yn(function () {
        _this135.invokeCallHook(e, t);

        var n = rh(e);

        if ("channelsFirst" === _this135.dataFormat && n.rank > 1) {
          var _e227 = [0];

          for (var _t260 = 2; _t260 < n.rank; ++_t260) {
            _e227.push(_t260);
          }

          _e227.push(1), n = $n(n, _e227);
        }

        return function (e) {
          if (e.rank <= 1) throw new bu("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank, "."));
          var t = [e.shape[0], cc(e.shape, 1)];
          return Es(e, t);
        }(n);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {};
      null != this.dataFormat && (e.dataFormat = this.dataFormat);

      var t = _get(_getPrototypeOf(Hp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return Hp;
}(gh);

Hp.className = "Flatten", qn(Hp);

var jp = /*#__PURE__*/function (_gh17) {
  "use strict";

  _inherits(jp, _gh17);

  var _super98 = _createSuper(jp);

  function jp(e) {
    var _this136;

    _classCallCheck(this, jp);

    _this136 = _super98.call(this, e), _this136.supportsMasking = !0, _this136.activation = qd(e.activation);
    return _this136;
  }

  _createClass(jp, [{
    key: "call",
    value: function call(e, t) {
      var _this137 = this;

      return Yn(function () {
        _this137.invokeCallHook(e, t);

        var n = rh(e);
        return _this137.activation.apply(n);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        activation: Hd(this.activation)
      },
          t = _get(_getPrototypeOf(jp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return jp;
}(gh);

jp.className = "Activation", qn(jp);

var qp = /*#__PURE__*/function (_gh18) {
  "use strict";

  _inherits(qp, _gh18);

  var _super99 = _createSuper(qp);

  function qp(e) {
    var _this138;

    _classCallCheck(this, qp);

    _this138 = _super99.call(this, e), _this138.n = e.n, _this138.inputSpec = [{
      ndim: 2
    }];
    return _this138;
  }

  _createClass(qp, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return [e[0], this.n, e[1]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this139 = this;

      return Yn(function () {
        return e = rh(e), t = e, n = _this139.n, Yn(function () {
          if (2 !== t.shape.length) throw new bu("repeat() expects a rank-2 tensor, but received a rank-".concat(t.shape.length, " tensor."));
          return wc(gc(t, 1), [1, n, 1]);
        });
        var t, n;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        n: this.n
      },
          t = _get(_getPrototypeOf(qp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return qp;
}(gh);

qp.className = "RepeatVector", qn(qp);

var Kp = /*#__PURE__*/function (_gh19) {
  "use strict";

  _inherits(Kp, _gh19);

  var _super100 = _createSuper(Kp);

  function Kp(e) {
    var _this140;

    _classCallCheck(this, Kp);

    _this140 = _super100.call(this, e), _this140.targetShape = e.targetShape;

    for (var _e228 = 0; _e228 < _this140.targetShape.length; ++_e228) {
      _this140.isUnknown(_this140.targetShape[_e228]) && (_this140.targetShape[_e228] = null);
    }

    return _this140;
  }

  _createClass(Kp, [{
    key: "isUnknown",
    value: function isUnknown(e) {
      return e < 0 || null == e;
    }
  }, {
    key: "fixUnknownDimension",
    value: function fixUnknownDimension(e, t) {
      var n = "Total size of new array must be unchanged.",
          s = t.slice();
      var r = 1,
          a = null;

      for (var _e229 = 0; _e229 < s.length; ++_e229) {
        var _t261 = s[_e229];

        if (this.isUnknown(_t261)) {
          if (null !== a) throw new bu("Can only specifiy one unknown dimension.");
          a = _e229;
        } else r *= _t261;
      }

      var i = cc(e);

      if (null !== a) {
        if (0 === r || i % r != 0) throw new bu(n);
        s[a] = i / r;
      } else if (i !== r) throw new bu(n);

      return s;
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = !1;

      for (var _n131 = 0; _n131 < e.length; ++_n131) {
        if (this.isUnknown(e[_n131])) {
          t = !0;
          break;
        }
      }

      return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this141 = this;

      return Yn(function () {
        _this141.invokeCallHook(e, t);

        var n = rh(e),
            s = n.shape,
            r = s.slice(0, 1).concat(_this141.fixUnknownDimension(s.slice(1), _this141.targetShape));
        return Es(n, r);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        targetShape: this.targetShape
      },
          t = _get(_getPrototypeOf(Kp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return Kp;
}(gh);

Kp.className = "Reshape", qn(Kp);

var Xp = /*#__PURE__*/function (_gh20) {
  "use strict";

  _inherits(Xp, _gh20);

  var _super101 = _createSuper(Xp);

  function Xp(e) {
    var _this142;

    _classCallCheck(this, Xp);

    if (_this142 = _super101.call(this, e), null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
    if (!Array.isArray(e.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received ".concat(e.dims, " instead."));
    var t = pc(1, e.dims.length + 1);
    if (!p(e.dims.slice().sort(), t)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
    _this142.dims = e.dims, _this142.dimsIncludingBatch = [0].concat(_this142.dims), _this142.inputSpec = [new ch({
      ndim: _this142.dims.length + 1
    })];
    return _possibleConstructorReturn(_this142);
  }

  _createClass(Xp, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = (e = ah(e)).slice();
      return this.dims.forEach(function (n, s) {
        t[s + 1] = e[n];
      }), t;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      return $n(rh(e), this.dimsIncludingBatch);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        dims: this.dims
      },
          t = _get(_getPrototypeOf(Xp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return Xp;
}(gh);

Xp.className = "Permute", qn(Xp);

var Yp = /*#__PURE__*/function (_gh21) {
  "use strict";

  _inherits(Yp, _gh21);

  var _super102 = _createSuper(Yp);

  function Yp(e) {
    var _this143;

    _classCallCheck(this, Yp);

    _this143 = _super102.call(this, null == e ? {} : e), _this143.supportsMasking = !0, _this143.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0;
    return _this143;
  }

  _createClass(Yp, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(Yp.prototype), "getConfig", this).call(this),
          t = {
        maskValue: this.maskValue
      };

      return Object.assign(t, e), t;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var n = rh(e);
      return ls(ba(n, this.maskValue), -1);
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this144 = this;

      return Yn(function () {
        _this144.invokeCallHook(e, t);

        var n = rh(e),
            s = ls(ba(n, _this144.maskValue), -1, !0);
        return ss(n, pn(s, n.dtype));
      });
    }
  }]);

  return Yp;
}(gh);

Yp.className = "Masking", qn(Yp);

var Jp = /*#__PURE__*/function (_gh22) {
  "use strict";

  _inherits(Jp, _gh22);

  var _super103 = _createSuper(Jp);

  function Jp(e) {
    var _this145;

    _classCallCheck(this, Jp);

    if (_this145 = _super103.call(this, e), _this145.embeddings = null, _this145.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
      var t = null;
      null != e.batchSize && (t = e.batchSize), _this145.batchInputShape = null == e.inputLength ? [t, null] : [t].concat($u(e.inputLength));
    }

    _this145.inputDim = e.inputDim, Mu(_this145.inputDim, "inputDim"), _this145.outputDim = e.outputDim, Mu(_this145.outputDim, "outputDim"), _this145.embeddingsInitializer = Jc(e.embeddingsInitializer || _this145.DEFAULT_EMBEDDINGS_INITIALIZER), _this145.embeddingsRegularizer = Qd(e.embeddingsRegularizer), _this145.activityRegularizer = Qd(e.activityRegularizer), _this145.embeddingsConstraint = Ku(e.embeddingsConstraint), _this145.maskZero = e.maskZero, _this145.supportsMasking = e.maskZero, _this145.inputLength = e.inputLength;
    return _possibleConstructorReturn(_this145);
  }

  _createClass(Jp, [{
    key: "build",
    value: function build(e) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
    }
  }, {
    key: "warnOnIncompatibleInputShape",
    value: function warnOnIncompatibleInputShape(e) {}
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var _this146 = this;

      return Yn(function () {
        return _this146.maskZero ? (e = rh(e), ba(e, pr(e))) : null;
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      if (e = ah(e), null == this.inputLength) return [].concat(_toConsumableArray(e), [this.outputDim]);
      var t = $u(this.inputLength);
      if (t.length !== e.length - 1) throw new bu("\"inputLength\" is ".concat(this.inputLength, ", but received input shape has shape ").concat(e));
      {
        var _n132 = 0;

        for (var _s113 = 0; _s113 < t.length; ++_s113) {
          var _r78 = t[_s113],
              a = e[_s113 + 1];
          if (null != _r78 && null != a && _r78 !== a) throw new bu("\"inputLength\" is ".concat(this.inputLength, ", but received input shape has shape ").concat(e));
          null == _r78 && (t[_n132] = a), _n132++;
        }
      }
      return [e[0]].concat(_toConsumableArray(t), [this.outputDim]);
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this147 = this;

      return Yn(function () {
        _this147.invokeCallHook(e, t);

        var n = rh(e);
        "int32" !== n.dtype && (n = fc(n, "int32"));
        var s = $c(_this147.embeddings.read(), Es(n, [n.size]));
        return Es(s, ah(_this147.computeOutputShape(n.shape)));
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        inputDim: this.inputDim,
        outputDim: this.outputDim,
        embeddingsInitializer: Yc(this.embeddingsInitializer),
        embeddingsRegularizer: Jd(this.embeddingsRegularizer),
        activityRegularizer: Jd(this.activityRegularizer),
        embeddingsConstraint: ju(this.embeddingsConstraint),
        maskZero: this.maskZero,
        inputLength: this.inputLength
      },
          t = _get(_getPrototypeOf(Jp.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return Jp;
}(gh);

Jp.className = "Embedding", qn(Jp);

var Zp = /*#__PURE__*/function (_gh23) {
  "use strict";

  _inherits(Zp, _gh23);

  var _super104 = _createSuper(Zp);

  function Zp(e) {
    var _this148;

    _classCallCheck(this, Zp);

    _this148 = _super104.call(this, e || {}), _this148.supportsMasking = !0;
    return _this148;
  }

  _createClass(Zp, [{
    key: "mergeFunction",
    value: function mergeFunction(e) {
      throw new xu();
    }
  }, {
    key: "computeElementwiseOpOutputShape",
    value: function computeElementwiseOpOutputShape(e, t) {
      if (null == e || null == t) return null;
      if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
      if (0 === t.length) return e;
      var n = e.slice(0, e.length - t.length);

      for (var _s114 = 0; _s114 < t.length; ++_s114) {
        var _r79 = e[e.length - t.length + _s114],
            a = t[_s114];
        if (null == _r79 || null == a || _r79 < 0 || a < 0) n.push(null);else if (1 === _r79) n.push(a);else if (1 === a) n.push(_r79);else {
          if (_r79 !== a) throw new bu("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
          n.push(_r79);
        }
      }

      return n;
    }
  }, {
    key: "build",
    value: function build(e) {
      if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [ah(e)]), (e = e).length < 2) throw new bu("A merge layer should be called on an Array of at least 2 inputs. Got ".concat(e.length, " input(s)."));
      var t = [];

      var _iterator104 = _createForOfIteratorHelper(e),
          _step104;

      try {
        for (_iterator104.s(); !(_step104 = _iterator104.n()).done;) {
          var _n133 = _step104.value;
          null != _n133 && null !== _n133[0] && t.push(_n133[0]);
        }
      } catch (err) {
        _iterator104.e(err);
      } finally {
        _iterator104.f();
      }

      if (t = Fu(t), t.length > 1) throw new bu("Can not merge tensors with different batch sizes. Got tensors with shapes: ".concat(JSON.stringify(e), "."));
      var n = null == e[0] ? null : e[0].slice(1);

      for (var _t262 = 1; _t262 < e.length; ++_t262) {
        var _s115 = null == e[_t262] ? null : e[_t262].slice(1);

        n = this.computeElementwiseOpOutputShape(n, _s115);
      }

      var s = e.map(function (e) {
        return e.length;
      });
      this.reshapeRequired = -1 !== e.indexOf(null) || 1 !== Fu(s).length;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this149 = this;

      return Yn(function () {
        if (e = e, _this149.reshapeRequired) {
          var _t263 = [],
              _n134 = e.map(function (e) {
            return e.rank;
          });

          if (-1 === _n134.indexOf(null)) {
            var _s116 = dc(_n134);

            var _iterator105 = _createForOfIteratorHelper(e),
                _step105;

            try {
              for (_iterator105.s(); !(_step105 = _iterator105.n()).done;) {
                var _n135 = _step105.value;
                var _e230 = _n135.rank;

                for (var _t264 = 0; _t264 < _s116 - _e230; ++_t264) {
                  _n135 = gc(_n135, 1);
                }

                _t263.push(_n135);
              }
            } catch (err) {
              _iterator105.e(err);
            } finally {
              _iterator105.f();
            }

            return _this149.mergeFunction(_t263);
          }

          {
            var _n136 = !1;

            var _iterator106 = _createForOfIteratorHelper(e),
                _step106;

            try {
              for (_iterator106.s(); !(_step106 = _iterator106.n()).done;) {
                var _s118 = _step106.value;
                var _e233 = _s118.rank;

                if (null == _e233) {
                  var _e234 = _s118.shape,
                      _r81 = _e234[0],
                      a = _e234.slice(1).concat([_r81]);

                  var i = Es(_s118, [_r81].concat(cc(_e234.slice(1))));
                  i = $n(i, [1, 0]), i = Es(i, a), _t263.push(i), _n136 = !0;
                } else if (_e233 > 1) {
                  var _r82 = pc(1, _e233).concat([0]);

                  _t263.push($n(_s118, _r82)), _n136 = !0;
                } else _t263.push(_s118);
              }
            } catch (err) {
              _iterator106.e(err);
            } finally {
              _iterator106.f();
            }

            var _s117 = _this149.mergeFunction(_t263);

            var _r80 = _s117.rank;
            if (_n136) if (null == _r80) {
              var _e231 = _s117.shape,
                  _t265 = _e231[_e231.length - 1],
                  _n137 = [_t265].concat(_e231.slice(0, _e231.length - 1));

              _s117 = Es($n(Es(_s117, [-1, _t265]), [1, 0]), _n137);
            } else if (_r80 > 1) {
              var _e232 = [_r80 - 1].concat(pc(0, _r80 - 1));

              _s117 = $n(_s117, _e232);
            }
            return _s117;
          }
        }

        return _this149.mergeFunction(e);
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t;
      t = null == (e = e)[0] ? null : e[0].slice(1);

      for (var _n138 = 1; _n138 < e.length; ++_n138) {
        var _s119 = null == e[_n138] ? null : e[_n138].slice(1);

        t = this.computeElementwiseOpOutputShape(t, _s119);
      }

      var n = [];

      var _iterator107 = _createForOfIteratorHelper(e),
          _step107;

      try {
        for (_iterator107.s(); !(_step107 = _iterator107.n()).done;) {
          var _t266 = _step107.value;
          null != _t266 && null !== _t266[0] && n.push(_t266[0]);
        }
      } catch (err) {
        _iterator107.e(err);
      } finally {
        _iterator107.f();
      }

      return n = Fu(n), t = 1 === n.length ? n.concat(t) : [null].concat(t), t;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      return Yn(function () {
        if (null == t) return null;
        if (!Array.isArray(t)) throw new bu("`mask` should be an Array");
        if (!Array.isArray(e)) throw new bu("`inputs` should be an Array");
        if (t.length !== e.length) throw new bu("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (".concat(e.length, " vs ").concat(t.length, ")"));
        if (t.every(function (e) {
          return null == e;
        })) return null;
        var n = (t = t.map(function (e) {
          return null == e ? e : yr(e, 0);
        }))[0];

        for (var _e235 = 1; _e235 < t.length - 1; ++_e235) {
          n = ta(n, t[_e235]);
        }

        return n;
      });
    }
  }]);

  return Zp;
}(gh);

var Qp = /*#__PURE__*/function (_Zp) {
  "use strict";

  _inherits(Qp, _Zp);

  var _super105 = _createSuper(Qp);

  function Qp(e) {
    _classCallCheck(this, Qp);

    return _super105.call(this, e);
  }

  _createClass(Qp, [{
    key: "mergeFunction",
    value: function mergeFunction(e) {
      return Yn(function () {
        var t = e[0].clone();

        for (var _n139 = 1; _n139 < e.length; ++_n139) {
          t = es(t, e[_n139]);
        }

        return t;
      });
    }
  }]);

  return Qp;
}(Zp);

Qp.className = "Add", qn(Qp);

var ef = /*#__PURE__*/function (_Zp2) {
  "use strict";

  _inherits(ef, _Zp2);

  var _super106 = _createSuper(ef);

  function ef(e) {
    _classCallCheck(this, ef);

    return _super106.call(this, e);
  }

  _createClass(ef, [{
    key: "mergeFunction",
    value: function mergeFunction(e) {
      return Yn(function () {
        var t = e[0].clone();

        for (var _n140 = 1; _n140 < e.length; ++_n140) {
          t = ss(t, e[_n140]);
        }

        return t;
      });
    }
  }]);

  return ef;
}(Zp);

ef.className = "Multiply", qn(ef);

var tf = /*#__PURE__*/function (_Zp3) {
  "use strict";

  _inherits(tf, _Zp3);

  var _super107 = _createSuper(tf);

  function tf(e) {
    _classCallCheck(this, tf);

    return _super107.call(this, e);
  }

  _createClass(tf, [{
    key: "mergeFunction",
    value: function mergeFunction(e) {
      return Yn(function () {
        var t = e[0].clone();

        for (var _n141 = 1; _n141 < e.length; ++_n141) {
          t = es(t, e[_n141]);
        }

        return ss(1 / e.length, t);
      });
    }
  }]);

  return tf;
}(Zp);

tf.className = "Average", qn(tf);

var nf = /*#__PURE__*/function (_Zp4) {
  "use strict";

  _inherits(nf, _Zp4);

  var _super108 = _createSuper(nf);

  function nf(e) {
    _classCallCheck(this, nf);

    return _super108.call(this, e);
  }

  _createClass(nf, [{
    key: "mergeFunction",
    value: function mergeFunction(e) {
      return Yn(function () {
        var t = e[0];

        for (var _n142 = 1; _n142 < e.length; ++_n142) {
          t = oa(t, e[_n142]);
        }

        return t;
      });
    }
  }]);

  return nf;
}(Zp);

nf.className = "Maximum", qn(nf);

var sf = /*#__PURE__*/function (_Zp5) {
  "use strict";

  _inherits(sf, _Zp5);

  var _super109 = _createSuper(sf);

  function sf(e) {
    _classCallCheck(this, sf);

    return _super109.call(this, e);
  }

  _createClass(sf, [{
    key: "mergeFunction",
    value: function mergeFunction(e) {
      return Yn(function () {
        var t = e[0];

        for (var _n143 = 1; _n143 < e.length; ++_n143) {
          t = da(t, e[_n143]);
        }

        return t;
      });
    }
  }]);

  return sf;
}(Zp);

sf.className = "Minimum", qn(sf);

var rf = /*#__PURE__*/function (_Zp6) {
  "use strict";

  _inherits(rf, _Zp6);

  var _super110 = _createSuper(rf);

  function rf(e) {
    var _this150;

    _classCallCheck(this, rf);

    _this150 = _super110.call(this, e), _this150.DEFAULT_AXIS = -1, null == e && (e = {}), _this150.axis = null == e.axis ? _this150.DEFAULT_AXIS : e.axis, _this150.supportsMasking = !0, _this150.reshapeRequired = !1;
    return _this150;
  }

  _createClass(rf, [{
    key: "build",
    value: function build(e) {
      if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new bu("A `Concatenate` layer should be called on a list of at least 2 inputs");
      e = e;
      var t = !0;

      var _iterator108 = _createForOfIteratorHelper(e),
          _step108;

      try {
        for (_iterator108.s(); !(_step108 = _iterator108.n()).done;) {
          var _n144 = _step108.value;

          if (null != _n144) {
            t = !1;
            break;
          }
        }
      } catch (err) {
        _iterator108.e(err);
      } finally {
        _iterator108.f();
      }

      if (t) return;
      var n = [];

      for (var _t267 = 0; _t267 < e.length; ++_t267) {
        var _s120 = e[_t267].slice();

        _s120.splice(this.axis, 1);

        var _r83 = !1;

        var _iterator109 = _createForOfIteratorHelper(n),
            _step109;

        try {
          for (_iterator109.s(); !(_step109 = _iterator109.n()).done;) {
            var _e236 = _step109.value;

            if (p(_e236, _s120)) {
              _r83 = !0;
              break;
            }
          }
        } catch (err) {
          _iterator109.e(err);
        } finally {
          _iterator109.f();
        }

        _r83 || n.push(_s120);
      }

      if (n.length > 1) throw new bu("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
    }
  }, {
    key: "mergeFunction",
    value: function mergeFunction(e) {
      var _this151 = this;

      return Yn(function () {
        return yc(e, _this151.axis);
      });
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      if (!Array.isArray(e) || !Array.isArray(e[0])) throw new bu("A `Concatenate` layer should be called on a list of inputs.");
      var t = e,
          n = t[0].slice(),
          s = this.axis < 0 ? n.length + this.axis : this.axis;

      var _iterator110 = _createForOfIteratorHelper(t.slice(1)),
          _step110;

      try {
        for (_iterator110.s(); !(_step110 = _iterator110.n()).done;) {
          var _e237 = _step110.value;

          if (null == n[s] || null == _e237[s]) {
            n[s] = null;
            break;
          }

          n[s] += _e237[s];
        }
      } catch (err) {
        _iterator110.e(err);
      } finally {
        _iterator110.f();
      }

      return n;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var _this152 = this;

      if (null == t) return null;
      if (!Array.isArray(t)) throw new bu("`mask` should be an array for Concatenate");
      if (!Array.isArray(e)) throw new bu("`inputs` should be an array for Concatenate");
      if (t.length !== e.length) throw new bu("Mismatch in the length of mask (".concat(t.length, ") and the legnth of inputs (").concat(e.length, ")"));
      return Yn(function () {
        var n = !0;
        if (t.forEach(function (e) {
          null == e || (n = !1);
        }), n) return null;
        var s = [];

        for (var _n145 = 0; _n145 < e.length; ++_n145) {
          s.push(null == t[_n145] ? pn(xa(e[_n145]), "bool") : t[_n145].rank < e[_n145].rank ? yr(t[_n145], -1) : t[_n145]);
        }

        var r = Fs(s, _this152.axis);
        return os(r, -1, !1);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        axis: this.axis
      },
          t = _get(_getPrototypeOf(rf.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return rf;
}(Zp);

function af(e, t) {
  for (; e < 0;) {
    e += t;
  }

  return e;
}

rf.className = "Concatenate", qn(rf);

var of = /*#__PURE__*/function (_Zp7) {
  "use strict";

  _inherits(of, _Zp7);

  var _super111 = _createSuper(of);

  function of(e) {
    var _this153;

    _classCallCheck(this, of);

    _this153 = _super111.call(this, e), _this153.axes = e.axes, _this153.normalize = null != e.normalize && e.normalize, _this153.supportsMasking = !0, _this153.reshapeRequired = !1;
    return _this153;
  }

  _createClass(of, [{
    key: "build",
    value: function build(e) {
      l(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
        return "A `Dot` layer should be called on a list of exactly 2 inputs.";
      });
      var t = e[0],
          n = e[1];
      if (t.length > 3 || n.length > 3) throw new xu("Dot layer does not support tensors of 4D or higher rank yet.");
      var s = this.interpretAxes(t, n);
      if (t[s[0]] !== n[s[1]]) throw new bu("Dimension incompatibility: ".concat(t[s[0]], " !== ").concat(n[s[1]]));
    }
  }, {
    key: "mergeFunction",
    value: function mergeFunction(e) {
      if (2 !== e.length) throw new bu("A `Dot` layer must be called on exactly 2 inputs, but received ".concat(e.length, " input(s)."));
      var t,
          n = e[0],
          s = e[1];
      return t = Array.isArray(this.axes) ? this.axes.map(function (t, n) {
        return af(t, e[n].shape.length);
      }) : [af(this.axes, n.shape.length), af(this.axes, s.shape.length)], this.normalize && (n = Rh(n, t[0]), s = Rh(s, t[1])), function (e, t, n) {
        if (e.shape.length > 3 || t.shape.length > 3) throw new xu("batchDot is not implemented for tensors of 4D or higher rank yet");
        if (l(e.shape.length >= 2, function () {
          return "batchDot requires the rank of x to be >= 2, but got ".concat(e.shape.length);
        }), l(e.shape.length >= 2, function () {
          return "batchDot requires the rank of y to be >= 2, but got ".concat(t.shape.length);
        }), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new xu("batchDot is not implemented for complex64-type Tensors yet.");
        var s = e.shape.length,
            r = t.shape.length;
        null == n && (n = [s - 1, r - 2]);
        var a = n;
        return Yn(function () {
          var n, i;

          if (s > r) {
            n = s - r;
            var _e238 = [];

            for (var _t268 = 0; _t268 < n; ++_t268) {
              _e238.push(1);
            }

            t = Es(t, t.shape.concat(_e238));
          } else if (r > s) {
            n = r - s;
            var _t269 = [];

            for (var _e239 = 0; _e239 < n; ++_e239) {
              _t269.push(1);
            }

            e = Es(e, e.shape.concat(_t269));
          } else n = 0;

          if (i = 2 === e.shape.length && 2 === t.shape.length ? a[0] === a[1] ? Gr(ss(e, t), a[0]) : Gr(ss($n(e, [1, 0]), t), a[1]) : vn(e, t, a[0] !== e.shape.length - 1, a[1] === t.shape.length - 1), n > 0) {
            var _e240;

            _e240 = s > r ? s + r - 3 : s - 1;
            var _t270 = [];

            for (var _s121 = _e240; _s121 < _e240 + n; ++_s121) {
              _t270.push(_s121);
            }

            i = hi(i, _t270);
          }

          return 1 === i.shape.length && (i = yr(i, 1)), i;
        });
      }(n, s, t);
    }
  }, {
    key: "interpretAxes",
    value: function interpretAxes(e, t) {
      var n;
      return n = Array.isArray(this.axes) ? this.axes : [af(this.axes, e.length), af(this.axes, t.length)], n;
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      l(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
        return "A `Dot` layer should be called on a list of exactly 2 inputs.";
      });
      var t = e[0].slice(),
          n = e[1].slice();
      if (t.length > 3 || n.length > 3) throw new xu("Dot layer does not support tensors of 4D or higher rank yet.");
      var s = this.interpretAxes(t, n);
      t.splice(s[0], 1), n.splice(s[1], 1), n.splice(0, 1);
      var r = t.concat(n);
      return 1 === r.length && r.push(1), r;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      return null;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        axes: this.axes,
        normalize: this.normalize
      },
          t = _get(_getPrototypeOf(of.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return of;
}(Zp);

of.className = "Dot", qn(of);

var lf = /*#__PURE__*/function (_gh24) {
  "use strict";

  _inherits(lf, _gh24);

  var _super112 = _createSuper(lf);

  function lf(e) {
    var _this154;

    _classCallCheck(this, lf);

    _this154 = _super112.call(this, e), _this154.supportsMasking = !0, _this154.stddev = e.stddev;
    return _this154;
  }

  _createClass(lf, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(lf.prototype), "getConfig", this).call(this),
          t = {
        stddev: this.stddev
      };

      return Object.assign(t, e), t;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this155 = this;

      return Yn(function () {
        _this155.invokeCallHook(e, t);

        var n = rh(e);
        return Ec(function () {
          return es(vc(n.shape, 0, _this155.stddev), n);
        }, function () {
          return n;
        }, t.training || !1);
      });
    }
  }]);

  return lf;
}(gh);

lf.className = "GaussianNoise", qn(lf);

var uf = /*#__PURE__*/function (_gh25) {
  "use strict";

  _inherits(uf, _gh25);

  var _super113 = _createSuper(uf);

  function uf(e) {
    var _this156;

    _classCallCheck(this, uf);

    _this156 = _super113.call(this, e), _this156.supportsMasking = !0, _this156.rate = e.rate;
    return _this156;
  }

  _createClass(uf, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(uf.prototype), "getConfig", this).call(this),
          t = {
        rate: this.rate
      };

      return Object.assign(t, e), t;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this157 = this;

      return Yn(function () {
        _this157.invokeCallHook(e, t);

        var n = rh(e);
        return _this157.rate > 0 && _this157.rate < 1 ? Ec(function () {
          var e = Math.sqrt(_this157.rate / (1 - _this157.rate));
          return ss(n, vc(n.shape, 1, e));
        }, function () {
          return n;
        }, t.training || !1) : n;
      });
    }
  }]);

  return uf;
}(gh);

uf.className = "GaussianDropout", qn(uf);

var cf = /*#__PURE__*/function (_gh26) {
  "use strict";

  _inherits(cf, _gh26);

  var _super114 = _createSuper(cf);

  function cf(e) {
    var _this158;

    _classCallCheck(this, cf);

    _this158 = _super114.call(this, e), _this158.supportsMasking = !0, _this158.rate = e.rate, _this158.noiseShape = e.noiseShape;
    return _this158;
  }

  _createClass(cf, [{
    key: "_getNoiseShape",
    value: function _getNoiseShape(e) {
      return this.noiseShape || rh(e).shape;
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e;
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = _get(_getPrototypeOf(cf.prototype), "getConfig", this).call(this),
          t = {
        rate: this.rate
      };

      return Object.assign(t, e), t;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this159 = this;

      return Yn(function () {
        if (_this159.rate < 1 && _this159.rate > 0) {
          var _n146 = _this159._getNoiseShape(e);

          return Ec(function () {
            var t = rh(e),
                s = -1.7580993408473766;
            var r = Sr(za(_n146), _this159.rate);
            r = fc(r, "float32");
            var a = Math.pow((1 - _this159.rate) * (1 + _this159.rate * Math.pow(s, 2)), -.5),
                i = -a * s * _this159.rate,
                o = es(ss(t, r), ss(es(r, -1), s));
            return es(ss(o, a), i);
          }, function () {
            return rh(e);
          }, t.training || !1);
        }

        return e;
      });
    }
  }]);

  return cf;
}(gh);

function hf(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : .001;
  var i;
  if (2 === e.rank) i = zs(e, t, n, s, r, a);else if (3 === e.rank) i = Bs(e, t, n, s, r, a);else {
    if (4 !== e.rank) throw new xu("batchNormalization is not implemented for array of rank ".concat(e.rank, " yet"));
    i = Ps(e, t, n, s, r, a);
  }
  return i;
}

cf.className = "AlphaDropout", qn(cf);

var df = /*#__PURE__*/function (_gh27) {
  "use strict";

  _inherits(df, _gh27);

  var _super115 = _createSuper(df);

  function df(e) {
    var _this160;

    _classCallCheck(this, df);

    null == e && (e = {}), _this160 = _super115.call(this, e), _this160.supportsMasking = !0, _this160.axis = null == e.axis ? -1 : e.axis, _this160.momentum = null == e.momentum ? .99 : e.momentum, _this160.epsilon = null == e.epsilon ? .001 : e.epsilon, _this160.center = null == e.center || e.center, _this160.scale = null == e.scale || e.scale, _this160.betaInitializer = Jc(e.betaInitializer || "zeros"), _this160.gammaInitializer = Jc(e.gammaInitializer || "ones"), _this160.movingMeanInitializer = Jc(e.movingMeanInitializer || "zeros"), _this160.movingVarianceInitializer = Jc(e.movingVarianceInitializer || "ones"), _this160.betaConstraint = Ku(e.betaConstraint), _this160.gammaConstraint = Ku(e.gammaConstraint), _this160.betaRegularizer = Qd(e.betaRegularizer), _this160.gammaRegularizer = Qd(e.gammaRegularizer);
    return _this160;
  }

  _createClass(df, [{
    key: "build",
    value: function build(e) {
      e = ah(e);
      var t = this.axis >= 0 ? this.axis : this.axis + e.length,
          n = e[t];
      if (null == n) throw new bu("Axis ".concat(t, " of input tensor should have a defined dimension but the layer received an input with shape ").concat(JSON.stringify(e), "."));
      this.inputSpec = [new ch({
        ndim: e.length,
        axes: _defineProperty({}, t, n)
      })];
      var s = [n];
      this.scale && (this.gamma = this.addWeight("gamma", s, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", s, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", s, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", s, null, this.movingVarianceInitializer, null, !1), this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this161 = this;

      return Yn(function () {
        var n = null != t.training && t.training,
            s = rh(e),
            r = s.shape,
            a = r.length,
            i = pc(0, a),
            o = _this161.axis >= 0 ? _this161.axis : _this161.axis + a;
        i.splice(o, 1);
        var l = ku(1, a);
        l[o] = r[o];
        var u = i.slice();
        u.sort();
        var c = !p(u, pc(0, a).slice(0, a - 1));
        if (!n) return function () {
          if (c) {
            var _e241 = Es(_this161.movingMean.read(), l),
                _t271 = Es(_this161.movingVariance.read(), l),
                _n147 = _this161.center ? Es(_this161.beta.read(), l) : null,
                _r84 = _this161.scale ? Es(_this161.gamma.read(), l) : null;

            return hf(s, _e241, _t271, _n147, _r84, _this161.epsilon);
          }

          return hf(s, _this161.movingMean.read(), _this161.movingVariance.read(), null == _this161.beta ? null : _this161.beta.read(), null == _this161.gamma ? null : _this161.gamma.read(), _this161.epsilon);
        }();

        var _ref19 = function (e, t, n, s) {
          var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
          return p(s.slice().sort(), pc(0, e.rank - 1)) ? function (e, t, n, s) {
            var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
            return Yn(function () {
              var a = ma(e, s),
                  i = a.mean,
                  o = a.variance;
              return [hf(e, i, o, n, t, r), i, o];
            });
          }(e, t, n, s, r) : function (e, t, n, s) {
            var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : .001;
            return Yn(function () {
              var a = ma(e, s),
                  i = a.mean,
                  o = a.variance,
                  l = [];

              var _iterator111 = _createForOfIteratorHelper(pc(0, e.rank)),
                  _step111;

              try {
                for (_iterator111.s(); !(_step111 = _iterator111.n()).done;) {
                  var _t272 = _step111.value;
                  -1 !== s.indexOf(_t272) ? l.push(1) : l.push(e.shape[_t272]);
                }
              } catch (err) {
                _iterator111.e(err);
              } finally {
                _iterator111.f();
              }

              var u = Es(i, l),
                  c = Es(o, l),
                  h = null == t ? null : Es(t, l),
                  d = null == n ? null : Es(n, l);
              return [hf(e, u, c, d, h, r), i, o];
            });
          }(e, t, n, s, r);
        }(s, _this161.gamma.read(), _this161.beta.read(), i, _this161.epsilon),
            _ref20 = _slicedToArray(_ref19, 3),
            h = _ref20[0],
            d = _ref20[1],
            f = _ref20[2],
            g = function g(e, t, n) {
          Yn(function () {
            var s = 1 - n,
                r = e.read(),
                a = ss(Vr(r, t), s);
            e.write(Vr(r, a));
          });
        };

        return function () {
          g(_this161.movingMean, d, _this161.momentum), g(_this161.movingVariance, f, _this161.momentum);
        }(), h;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        axis: this.axis,
        momentum: this.momentum,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: Yc(this.betaInitializer),
        gammaInitializer: Yc(this.gammaInitializer),
        movingMeanInitializer: Yc(this.movingMeanInitializer),
        movingVarianceInitializer: Yc(this.movingVarianceInitializer),
        betaRegularizer: Jd(this.betaRegularizer),
        gammaRegularizer: Jd(this.gammaRegularizer),
        betaConstraint: ju(this.betaConstraint),
        gammaConstraint: ju(this.gammaConstraint)
      },
          t = _get(_getPrototypeOf(df.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return df;
}(gh);

df.className = "BatchNormalization", qn(df);

var pf = /*#__PURE__*/function (_gh28) {
  "use strict";

  _inherits(pf, _gh28);

  var _super116 = _createSuper(pf);

  function pf(e) {
    var _this162;

    _classCallCheck(this, pf);

    if (null == e && (e = {}), _this162 = _super116.call(this, e), _this162.axis = null == e.axis ? -1 : e.axis, "number" == typeof _this162.axis) {
      if (!Number.isInteger(_this162.axis)) throw new Error("Expected axis to be an integer, but received ".concat(_this162.axis));
    } else {
      if (!Array.isArray(_this162.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received ".concat(JSON.stringify(_this162.axis)));

      var _iterator112 = _createForOfIteratorHelper(_this162.axis),
          _step112;

      try {
        for (_iterator112.s(); !(_step112 = _iterator112.n()).done;) {
          var _e242 = _step112.value;
          if (!Number.isInteger(_e242)) throw new Error("Expected axis to be an array of integers, but received ".concat(JSON.stringify(_this162.axis)));
        }
      } catch (err) {
        _iterator112.e(err);
      } finally {
        _iterator112.f();
      }
    }

    _this162.epsilon = null == e.epsilon ? .001 : e.epsilon, _this162.center = null == e.center || e.center, _this162.scale = null == e.scale || e.scale, _this162.betaInitializer = Jc(e.betaInitializer || "zeros"), _this162.gammaInitializer = Jc(e.gammaInitializer || "ones"), _this162.betaRegularizer = Qd(e.betaRegularizer), _this162.gammaRegularizer = Qd(e.gammaRegularizer), _this162.supportsMasking = !0;
    return _possibleConstructorReturn(_this162);
  }

  _createClass(pf, [{
    key: "build",
    value: function build(e) {
      var t = (e = ah(e)).length;
      "number" == typeof this.axis && (this.axis = [this.axis]);

      for (var _e243 = 0; _e243 < this.axis.length; ++_e243) {
        this.axis[_e243] < 0 && (this.axis[_e243] += t);
      }

      var _iterator113 = _createForOfIteratorHelper(this.axis),
          _step113;

      try {
        for (_iterator113.s(); !(_step113 = _iterator113.n()).done;) {
          var _e244 = _step113.value;
          if (_e244 < 0 || _e244 >= t) throw new Error("Invalid axis: ".concat(_e244));
        }
      } catch (err) {
        _iterator113.e(err);
      } finally {
        _iterator113.f();
      }

      if (this.axis.length !== Fu(this.axis).length) throw new Error("Found duplicate axes in: ".concat(this.axis));
      var n = this.axis.map(function (t) {
        return e[t];
      });
      this.gamma = this.scale ? this.addWeight("gamma", n, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : null, this.beta = this.center ? this.addWeight("beta", n, "float32", this.betaInitializer, this.betaRegularizer, !0) : null, this.built = !0;
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this163 = this;

      var n = rh(e),
          s = n.shape,
          r = s.length;
      return Yn(function () {
        var _ma = ma(n, _this163.axis, !0),
            e = _ma.mean,
            t = _ma.variance;

        var a = ku(1, r);

        var _iterator114 = _createForOfIteratorHelper(_this163.axis),
            _step114;

        try {
          for (_iterator114.s(); !(_step114 = _iterator114.n()).done;) {
            var _e246 = _step114.value;
            a[_e246] = s[_e246];
          }
        } catch (err) {
          _iterator114.e(err);
        } finally {
          _iterator114.f();
        }

        var i = function i(e) {
          return null != e && e.shape.length !== r && _this163.axis !== [r - 1] ? Es(e, a) : e;
        };

        var o = i(_this163.gamma.read()),
            l = i(_this163.beta.read());
        var u = [],
            c = [];

        for (var _e245 = 0; _e245 < r; ++_e245) {
          -1 !== _this163.axis.indexOf(_e245) ? (u.push(s[_e245]), c.push(1)) : (u.push(1), c.push(s[_e245]));
        }

        return e = wr(e, u), t = wr(t, u), o = wr(o, c), l = wr(l, c), hf(n, e, t, l, o, _this163.epsilon);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        axis: this.axis,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: Yc(this.betaInitializer),
        gammaInitializer: Yc(this.gammaInitializer),
        betaRegularizer: Jd(this.betaRegularizer),
        gammaRegularizer: Jd(this.gammaRegularizer)
      },
          t = _get(_getPrototypeOf(pf.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return pf;
}(gh);

pf.className = "LayerNormalization", qn(pf);

var ff = /*#__PURE__*/function (_gh29) {
  "use strict";

  _inherits(ff, _gh29);

  var _super117 = _createSuper(ff);

  function ff(e) {
    var _this164;

    _classCallCheck(this, ff);

    if (null == e && (e = {}), _this164 = _super117.call(this, e), _this164.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, null == e.padding) _this164.padding = [[1, 1], [1, 1]];else if ("number" == typeof e.padding) _this164.padding = [[e.padding, e.padding], [e.padding, e.padding]];else {
      if (e.padding = e.padding, 2 !== e.padding.length) throw new bu("ZeroPadding2D expects padding to be a length-2 array, but received a length-".concat(e.padding.length, " array."));

      var t, _n148;

      if ("number" == typeof e.padding[0]) t = [e.padding[0], e.padding[0]], _n148 = [e.padding[1], e.padding[1]];else {
        if (e.padding = e.padding, 2 !== e.padding[0].length) throw new bu("ZeroPadding2D expects height padding to be a length-2 array, but received a length-".concat(e.padding[0].length, " array."));
        if (t = e.padding[0], 2 !== e.padding[1].length) throw new bu("ZeroPadding2D expects width padding to be a length-2 array, but received a length-".concat(e.padding[1].length, " array."));
        _n148 = e.padding[1];
      }
      _this164.padding = [t, _n148];
    }
    _this164.inputSpec = [new ch({
      ndim: 4
    })];
    return _possibleConstructorReturn(_this164);
  }

  _createClass(ff, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t, n;
      return e = ah(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]]);
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this165 = this;

      return Yn(function () {
        return t = rh(e), n = _this165.padding, s = _this165.dataFormat, Yn(function () {
          if (4 !== t.rank) throw new bu("temporalPadding expects input tensor to be 4-D, but received a ".concat(t.rank, "-D tensor."));
          if (null == n && (n = [[1, 1], [1, 1]]), 2 !== n.length || 2 !== n[0].length || 2 !== n[1].length) throw new bu("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
          if (null == s && (s = "channelsLast"), "channelsLast" !== s && "channelsFirst" !== s) throw new bu("Unknown data format: ".concat(s, ". Supported data formats are 'channelsLast' and 'channelsFirst."));
          var e;
          return e = "channelsFirst" === s ? [[0, 0], [0, 0], n[0], n[1]] : [[0, 0], n[0], n[1], [0, 0]], ya(t, e);
        });
        var t, n, s;
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        padding: this.padding,
        dataFormat: this.dataFormat
      },
          t = _get(_getPrototypeOf(ff.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return ff;
}(gh);

function gf(e, t, n, s, r, a) {
  return Yn(function () {
    var i;
    tc(r), sc(a), nc(s), null == n && (n = [1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = up(e, r);
    var o = "same" === s ? "same" : "valid";
    return i = "max" === a ? aa(e, t, n, o) : Rs(e, t, n, o), "channelsFirst" === r && (i = $n(i, [0, 3, 1, 2])), i;
  });
}

function mf(e, t, n, s, r, a) {
  return Yn(function () {
    var i;
    tc(r), sc(a), nc(s), null == n && (n = [1, 1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = cp(e, r);
    var o = "same" === s ? "same" : "valid";
    return i = "max" === a ? ia(e, t, n, o) : As(e, t, n, o), "channelsFirst" === r && (i = $n(i, [0, 4, 1, 2, 3])), i;
  });
}

ff.className = "ZeroPadding2D", qn(ff);

var bf = /*#__PURE__*/function (_gh30) {
  "use strict";

  _inherits(bf, _gh30);

  var _super118 = _createSuper(bf);

  function bf(e) {
    var _this166;

    _classCallCheck(this, bf);

    if (null == e.poolSize && (e.poolSize = 2), _this166 = _super118.call(this, e), "number" == typeof e.poolSize) _this166.poolSize = [e.poolSize];else {
      if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new bu("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.poolSize)));
      _this166.poolSize = e.poolSize;
    }
    if (Mu(_this166.poolSize, "poolSize"), null == e.strides) _this166.strides = _this166.poolSize;else if ("number" == typeof e.strides) _this166.strides = [e.strides];else {
      if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new bu("strides for 1D convolutional layer must be a number or an Array of a single number, but received ".concat(JSON.stringify(e.strides)));
      _this166.strides = e.strides;
    }
    Mu(_this166.strides, "strides"), _this166.padding = null == e.padding ? "valid" : e.padding, nc(_this166.padding), _this166.inputSpec = [new ch({
      ndim: 3
    })];
    return _possibleConstructorReturn(_this166);
  }

  _createClass(bf, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = op((e = ah(e))[1], this.poolSize[0], this.padding, this.strides[0]);
      return [e[0], t, e[2]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this167 = this;

      return Yn(function () {
        _this167.invokeCallHook(e, t), e = gc(rh(e), 2);

        var n = _this167.poolingFunction(rh(e), [_this167.poolSize[0], 1], [_this167.strides[0], 1], _this167.padding, "channelsLast");

        return hi(n, [2]);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides
      },
          t = _get(_getPrototypeOf(bf.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return bf;
}(gh);

var xf = /*#__PURE__*/function (_bf) {
  "use strict";

  _inherits(xf, _bf);

  var _super119 = _createSuper(xf);

  function xf(e) {
    _classCallCheck(this, xf);

    return _super119.call(this, e);
  }

  _createClass(xf, [{
    key: "poolingFunction",
    value: function poolingFunction(e, t, n, s, r) {
      return tc(r), nc(s), gf(e, t, n, s, r, "max");
    }
  }]);

  return xf;
}(bf);

xf.className = "MaxPooling1D", qn(xf);

var yf = /*#__PURE__*/function (_bf2) {
  "use strict";

  _inherits(yf, _bf2);

  var _super120 = _createSuper(yf);

  function yf(e) {
    _classCallCheck(this, yf);

    return _super120.call(this, e);
  }

  _createClass(yf, [{
    key: "poolingFunction",
    value: function poolingFunction(e, t, n, s, r) {
      return tc(r), nc(s), gf(e, t, n, s, r, "avg");
    }
  }]);

  return yf;
}(bf);

yf.className = "AveragePooling1D", qn(yf);

var kf = /*#__PURE__*/function (_gh31) {
  "use strict";

  _inherits(kf, _gh31);

  var _super121 = _createSuper(kf);

  function kf(e) {
    var _this168;

    _classCallCheck(this, kf);

    if (null == e.poolSize && (e.poolSize = [2, 2]), _this168 = _super121.call(this, e), _this168.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) _this168.strides = _this168.poolSize;else if (Array.isArray(e.strides)) {
      if (2 !== e.strides.length) throw new bu("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ".concat(e.strides.length, "."));
      _this168.strides = e.strides;
    } else _this168.strides = [e.strides, e.strides];
    Mu(_this168.poolSize, "poolSize"), Mu(_this168.strides, "strides"), _this168.padding = null == e.padding ? "valid" : e.padding, _this168.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(_this168.dataFormat), nc(_this168.padding), _this168.inputSpec = [new ch({
      ndim: 4
    })];
    return _possibleConstructorReturn(_this168);
  }

  _createClass(kf, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      e = ah(e);
      var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
          n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
      return t = op(t, this.poolSize[0], this.padding, this.strides[0]), n = op(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this169 = this;

      return Yn(function () {
        return _this169.invokeCallHook(e, t), _this169.poolingFunction(rh(e), _this169.poolSize, _this169.strides, _this169.padding, _this169.dataFormat);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      },
          t = _get(_getPrototypeOf(kf.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return kf;
}(gh);

var wf = /*#__PURE__*/function (_kf) {
  "use strict";

  _inherits(wf, _kf);

  var _super122 = _createSuper(wf);

  function wf(e) {
    _classCallCheck(this, wf);

    return _super122.call(this, e);
  }

  _createClass(wf, [{
    key: "poolingFunction",
    value: function poolingFunction(e, t, n, s, r) {
      return tc(r), nc(s), gf(e, t, n, s, r, "max");
    }
  }]);

  return wf;
}(kf);

wf.className = "MaxPooling2D", qn(wf);

var vf = /*#__PURE__*/function (_kf2) {
  "use strict";

  _inherits(vf, _kf2);

  var _super123 = _createSuper(vf);

  function vf(e) {
    _classCallCheck(this, vf);

    return _super123.call(this, e);
  }

  _createClass(vf, [{
    key: "poolingFunction",
    value: function poolingFunction(e, t, n, s, r) {
      return tc(r), nc(s), gf(e, t, n, s, r, "avg");
    }
  }]);

  return vf;
}(kf);

vf.className = "AveragePooling2D", qn(vf);

var If = /*#__PURE__*/function (_gh32) {
  "use strict";

  _inherits(If, _gh32);

  var _super124 = _createSuper(If);

  function If(e) {
    var _this170;

    _classCallCheck(this, If);

    if (null == e.poolSize && (e.poolSize = [2, 2, 2]), _this170 = _super124.call(this, e), _this170.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) _this170.strides = _this170.poolSize;else if (Array.isArray(e.strides)) {
      if (3 !== e.strides.length) throw new bu("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ".concat(e.strides.length, "."));
      _this170.strides = e.strides;
    } else _this170.strides = [e.strides, e.strides, e.strides];
    Mu(_this170.poolSize, "poolSize"), Mu(_this170.strides, "strides"), _this170.padding = null == e.padding ? "valid" : e.padding, _this170.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(_this170.dataFormat), nc(_this170.padding), _this170.inputSpec = [new ch({
      ndim: 5
    })];
    return _possibleConstructorReturn(_this170);
  }

  _createClass(If, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      e = ah(e);
      var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
          n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
          s = "channelsFirst" === this.dataFormat ? e[4] : e[3];
      return t = op(t, this.poolSize[0], this.padding, this.strides[0]), n = op(n, this.poolSize[1], this.padding, this.strides[1]), s = op(s, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, s] : [e[0], t, n, s, e[4]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this171 = this;

      return Yn(function () {
        return _this171.invokeCallHook(e, t), _this171.poolingFunction(rh(e), _this171.poolSize, _this171.strides, _this171.padding, _this171.dataFormat);
      });
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      },
          t = _get(_getPrototypeOf(If.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return If;
}(gh);

var $f = /*#__PURE__*/function (_If) {
  "use strict";

  _inherits($f, _If);

  var _super125 = _createSuper($f);

  function $f(e) {
    _classCallCheck(this, $f);

    return _super125.call(this, e);
  }

  _createClass($f, [{
    key: "poolingFunction",
    value: function poolingFunction(e, t, n, s, r) {
      return tc(r), nc(s), mf(e, t, n, s, r, "max");
    }
  }]);

  return $f;
}(If);

$f.className = "MaxPooling3D", qn($f);

var Nf = /*#__PURE__*/function (_If2) {
  "use strict";

  _inherits(Nf, _If2);

  var _super126 = _createSuper(Nf);

  function Nf(e) {
    _classCallCheck(this, Nf);

    return _super126.call(this, e);
  }

  _createClass(Nf, [{
    key: "poolingFunction",
    value: function poolingFunction(e, t, n, s, r) {
      return tc(r), nc(s), mf(e, t, n, s, r, "avg");
    }
  }]);

  return Nf;
}(If);

Nf.className = "AveragePooling3D", qn(Nf);

var Cf = /*#__PURE__*/function (_gh33) {
  "use strict";

  _inherits(Cf, _gh33);

  var _super127 = _createSuper(Cf);

  function Cf(e) {
    var _this172;

    _classCallCheck(this, Cf);

    _this172 = _super127.call(this, e), _this172.inputSpec = [new ch({
      ndim: 3
    })];
    return _this172;
  }

  _createClass(Cf, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return [e[0], e[2]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      throw new xu();
    }
  }]);

  return Cf;
}(gh);

var Sf = /*#__PURE__*/function (_Cf) {
  "use strict";

  _inherits(Sf, _Cf);

  var _super128 = _createSuper(Sf);

  function Sf(e) {
    _classCallCheck(this, Sf);

    return _super128.call(this, e || {});
  }

  _createClass(Sf, [{
    key: "call",
    value: function call(e, t) {
      return Yn(function () {
        var t = rh(e);
        return la(t, 1);
      });
    }
  }]);

  return Sf;
}(Cf);

Sf.className = "GlobalAveragePooling1D", qn(Sf);

var Tf = /*#__PURE__*/function (_Cf2) {
  "use strict";

  _inherits(Tf, _Cf2);

  var _super129 = _createSuper(Tf);

  function Tf(e) {
    _classCallCheck(this, Tf);

    return _super129.call(this, e || {});
  }

  _createClass(Tf, [{
    key: "call",
    value: function call(e, t) {
      return Yn(function () {
        var t = rh(e);
        return Ur(t, 1);
      });
    }
  }]);

  return Tf;
}(Cf);

Tf.className = "GlobalMaxPooling1D", qn(Tf);

var Ef = /*#__PURE__*/function (_gh34) {
  "use strict";

  _inherits(Ef, _gh34);

  var _super130 = _createSuper(Ef);

  function Ef(e) {
    var _this173;

    _classCallCheck(this, Ef);

    _this173 = _super130.call(this, e), _this173.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, tc(_this173.dataFormat), _this173.inputSpec = [new ch({
      ndim: 4
    })];
    return _this173;
  }

  _createClass(Ef, [{
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      return e = e, "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]];
    }
  }, {
    key: "call",
    value: function call(e, t) {
      throw new xu();
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        dataFormat: this.dataFormat
      },
          t = _get(_getPrototypeOf(Ef.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }]);

  return Ef;
}(gh);

var Rf = /*#__PURE__*/function (_Ef) {
  "use strict";

  _inherits(Rf, _Ef);

  var _super131 = _createSuper(Rf);

  function Rf() {
    _classCallCheck(this, Rf);

    return _super131.apply(this, arguments);
  }

  _createClass(Rf, [{
    key: "call",
    value: function call(e, t) {
      var _this174 = this;

      return Yn(function () {
        var t = rh(e);
        return la(t, "channelsLast" === _this174.dataFormat ? [1, 2] : [2, 3]);
      });
    }
  }]);

  return Rf;
}(Ef);

Rf.className = "GlobalAveragePooling2D", qn(Rf);

var Af = /*#__PURE__*/function (_Ef2) {
  "use strict";

  _inherits(Af, _Ef2);

  var _super132 = _createSuper(Af);

  function Af() {
    _classCallCheck(this, Af);

    return _super132.apply(this, arguments);
  }

  _createClass(Af, [{
    key: "call",
    value: function call(e, t) {
      var _this175 = this;

      return Yn(function () {
        var t = rh(e);
        return Ur(t, "channelsLast" === _this175.dataFormat ? [1, 2] : [2, 3]);
      });
    }
  }]);

  return Af;
}(Ef);

Af.className = "GlobalMaxPooling2D", qn(Af);

var Ff = /*#__PURE__*/function (_gh35) {
  "use strict";

  _inherits(Ff, _gh35);

  var _super133 = _createSuper(Ff);

  function Ff(e) {
    var _this176;

    _classCallCheck(this, Ff);

    _this176 = _super133.call(this, e), _this176.layer = e.layer;
    return _this176;
  }

  _createClass(Ff, [{
    key: "build",
    value: function build(e) {
      this.built = !0;
    }
  }, {
    key: "trainable",
    get: function get() {
      return null != this.layer && this.layer.trainable;
    },
    set: function set(e) {
      null != this.layer && (this.layer.trainable = e);
    }
  }, {
    key: "trainableWeights",
    get: function get() {
      return this.layer.trainableWeights;
    }
  }, {
    key: "nonTrainableWeights",
    get: function get() {
      return this.layer.nonTrainableWeights;
    }
  }, {
    key: "updates",
    get: function get() {
      return this.layer._updates;
    }
  }, {
    key: "losses",
    get: function get() {
      return this.layer.losses;
    }
  }, {
    key: "getWeights",
    value: function getWeights() {
      return this.layer.getWeights();
    }
  }, {
    key: "setWeights",
    value: function setWeights(e) {
      this.layer.setWeights(e);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        layer: {
          className: this.layer.getClassName(),
          config: this.layer.getConfig()
        }
      },
          t = _get(_getPrototypeOf(Ff.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }, {
    key: "setFastWeightInitDuringBuild",
    value: function setFastWeightInitDuringBuild(e) {
      _get(_getPrototypeOf(Ff.prototype), "setFastWeightInitDuringBuild", this).call(this, e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e);
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var s = Eh(t.layer, n);
      delete t.layer;
      var r = {
        layer: s
      };
      return Object.assign(r, t), new e(r);
    }
  }]);

  return Ff;
}(gh);

var Df = /*#__PURE__*/function (_Ff) {
  "use strict";

  _inherits(Df, _Ff);

  var _super134 = _createSuper(Df);

  function Df(e) {
    var _this177;

    _classCallCheck(this, Df);

    _this177 = _super134.call(this, e), _this177.supportsMasking = !0;
    return _this177;
  }

  _createClass(Df, [{
    key: "build",
    value: function build(e) {
      if ((e = ah(e)).length < 3) throw new bu("TimeDistributed layer expects an input shape >= 3D, but received input shape ".concat(JSON.stringify(e)));
      this.inputSpec = [{
        shape: e
      }];
      var t = [e[0]].concat(e.slice(2));
      this.layer.built || (this.layer.build(t), this.layer.built = !0), _get(_getPrototypeOf(Df.prototype), "build", this).call(this, e);
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t = [(e = ah(e))[0]].concat(e.slice(2)),
          n = this.layer.computeOutputShape(t);
      return [n[0], e[1]].concat(n.slice(1));
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this178 = this;

      return Yn(function () {
        return Np(function (e, n) {
          return [rh(_this178.layer.call(e, t)), []];
        }, e = rh(e), [], !1, null, null, !1, !0)[1];
      });
    }
  }]);

  return Df;
}(Ff);

Df.className = "TimeDistributed", qn(Df);

var _f = /*#__PURE__*/function (_Ff2) {
  "use strict";

  _inherits(_f, _Ff2);

  var _super135 = _createSuper(_f);

  function _f(e) {
    var _this179;

    _classCallCheck(this, _f);

    _this179 = _super135.call(this, e);
    var t = e.layer.getConfig(),
        n = {};
    n.className = e.layer.getClassName(), n.config = t, _this179.forwardLayer = Eh(n), t.goBackwards = !0 !== t.goBackwards;
    var s = {};
    if (s.className = e.layer.getClassName(), s.config = t, _this179.backwardLayer = Eh(s), _this179.forwardLayer.name = "forward_" + _this179.forwardLayer.name, _this179.backwardLayer.name = "backward_" + _this179.backwardLayer.name, _this179.mergeMode = void 0 === e.mergeMode ? "concat" : e.mergeMode, _u(Qu, "BidirectionalMergeMode", _this179.mergeMode), e.weights) throw new xu("weights support is not implemented for Bidirectional layer yet.");
    _this179._stateful = e.layer.stateful, _this179.returnSequences = e.layer.returnSequences, _this179.returnState = e.layer.returnState, _this179.supportsMasking = !0, _this179._trainable = !0, _this179.inputSpec = e.layer.inputSpec, _this179.numConstants = null;
    return _this179;
  }

  _createClass(_f, [{
    key: "trainable",
    get: function get() {
      return this._trainable;
    },
    set: function set(e) {
      this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e);
    }
  }, {
    key: "getWeights",
    value: function getWeights() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }
  }, {
    key: "setWeights",
    value: function setWeights(e) {
      var t = Math.floor(e.length / 2);
      this.forwardLayer.setWeights(e.slice(0, t)), this.backwardLayer.setWeights(e.slice(t));
    }
  }, {
    key: "computeOutputShape",
    value: function computeOutputShape(e) {
      var t,
          n,
          s,
          r = this.forwardLayer.computeOutputShape(e);
      return Array.isArray(r) && Array.isArray(r[0]) || (r = [r]), r = r, this.returnState ? (s = r.slice(1), t = r[0]) : t = r[0], t = t, "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(s).concat(s.slice()) : [t].concat(s).concat(s.slice()) : Iu(n);
    }
  }, {
    key: "apply",
    value: function apply(e, t) {
      var n = null == t ? null : t.initialState,
          s = null == t ? null : t.constants;
      null == t && (t = {});
      var r = $p(e, n, s, this.numConstants);
      if (e = r.inputs, n = r.initialState, s = r.constants, Array.isArray(e) && (n = e.slice(1), e = e[0]), (null == n || 0 === n.length) && null == s) return _get(_getPrototypeOf(_f.prototype), "apply", this).call(this, e, t);
      var a = [],
          i = [];

      if (null != n) {
        var _e247 = n.length;
        if (_e247 % 2 > 0) throw new bu("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        t.initialState = n, a.push.apply(a, _toConsumableArray(n));

        var _s122 = n.map(function (e) {
          return new ch({
            shape: e.shape
          });
        });

        this.forwardLayer.stateSpec = _s122.slice(0, _e247 / 2), this.backwardLayer.stateSpec = _s122.slice(_e247 / 2), i.push.apply(i, _toConsumableArray(_s122));
      }

      if (null != s) throw new xu("Support for constants in Bidirectional layers is not implemented yet.");
      var o = a[0] instanceof hh;

      for (var _i49 = 0, _a58 = a; _i49 < _a58.length; _i49++) {
        var _e248 = _a58[_i49];
        if (_e248 instanceof hh !== o) throw new bu("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
      }

      if (o) {
        var _n149 = [e].concat(a),
            _s123 = this.inputSpec.concat(i),
            _r85 = this.inputSpec;

        this.inputSpec = _s123;

        var _o26 = _get(_getPrototypeOf(_f.prototype), "apply", this).call(this, _n149, t);

        return this.inputSpec = _r85, _o26;
      }

      return _get(_getPrototypeOf(_f.prototype), "apply", this).call(this, e, t);
    }
  }, {
    key: "call",
    value: function call(e, t) {
      var _this180 = this;

      return Yn(function () {
        var n = t.initialState;
        var s, r, a, i;
        if (null == n) s = _this180.forwardLayer.call(e, t), r = _this180.backwardLayer.call(e, t);else {
          var _a59 = n.slice(0, n.length / 2),
              _i50 = n.slice(n.length / 2);

          s = _this180.forwardLayer.call(e, Object.assign(t, {
            initialState: _a59
          })), r = _this180.backwardLayer.call(e, Object.assign(t, {
            initialState: _i50
          }));
        }
        return _this180.returnState && (Array.isArray(s) && (a = s.slice(1).concat(r.slice(1))), s = s[0], r = r[0]), _this180.returnSequences && (r = Ga(r, 1)), "concat" === _this180.mergeMode ? i = yc([s, r]) : "sum" === _this180.mergeMode ? i = es(s, r) : "ave" === _this180.mergeMode ? i = ss(.5, es(s, r)) : "mul" === _this180.mergeMode ? i = ss(s, r) : null == _this180.mergeMode && (i = [s, r]), _this180.returnState ? null == _this180.mergeMode ? i.concat(a) : [i].concat(a) : i;
      });
    }
  }, {
    key: "resetStates",
    value: function resetStates(e) {
      this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
    }
  }, {
    key: "build",
    value: function build(e) {
      var _this181 = this;

      ac(this.forwardLayer.name, function () {
        _this181.forwardLayer.build(e);
      }), ac(this.backwardLayer.name, function () {
        _this181.backwardLayer.build(e);
      }), this.built = !0;
    }
  }, {
    key: "computeMask",
    value: function computeMask(e, t) {
      var n;

      if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
        var _e249 = this.forwardLayer.states.map(function (e) {
          return null;
        });

        return Array.isArray(n) ? n.concat(_e249).concat(_e249) : [n].concat(_e249).concat(_e249);
      }

      return n;
    }
  }, {
    key: "trainableWeights",
    get: function get() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }
  }, {
    key: "nonTrainableWeights",
    get: function get() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }
  }, {
    key: "setFastWeightInitDuringBuild",
    value: function setFastWeightInitDuringBuild(e) {
      _get(_getPrototypeOf(_f.prototype), "setFastWeightInitDuringBuild", this).call(this, e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e);
    }
  }, {
    key: "getConfig",
    value: function getConfig() {
      var e = {
        mergeMode: this.mergeMode
      },
          t = _get(_getPrototypeOf(_f.prototype), "getConfig", this).call(this);

      return Object.assign(e, t), e;
    }
  }], [{
    key: "fromConfig",
    value: function fromConfig(e, t) {
      var n = Eh(t.layer);
      if (delete t.layer, null != t.numConstants) throw new xu("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
      var s = t;
      return s.layer = n, new e(s);
    }
  }]);

  return _f;
}(Ff);

function Of(e) {
  return new kp(e);
}

function Mf(e) {
  return new Up(e);
}

function Lf(e) {
  return new xf(e);
}

function zf(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach(function (e) {
    null != e && l("complex64" !== e.dtype, function () {
      return "".concat(t, " does not support complex64 tensors in the CPU backend.");
    });
  });
}

_f.className = "Bidirectional", qn(_f), function (e) {
  e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(Mp || (Mp = {})), function (e) {
  var t;
  (t = e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2";
}(Lp || (Lp = {})), function (e) {
  e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST";
}(zp || (zp = {}));
var Bf = Ii;

var Pf = /*#__PURE__*/function (_n150) {
  "use strict";

  _inherits(Pf, _n150);

  var _super136 = _createSuper(Pf);

  function Pf() {
    var _this182;

    _classCallCheck(this, Pf);

    _this182 = _super136.call(this), _this182.blockSize = 48, _this182.firstUse = !0, _this182.data = new t(_assertThisInitialized(_this182), Kn());
    return _this182;
  }

  _createClass(Pf, [{
    key: "nextDataId",
    value: function nextDataId() {
      return Pf.nextDataId++;
    }
  }, {
    key: "write",
    value: function write(e, t, n) {
      this.firstUse && (this.firstUse = !1, V().get("IS_NODE") && Oo("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
      var s = {
        id: this.nextDataId()
      };
      return this.data.set(s, {
        values: e,
        dtype: n,
        refCount: 1
      }), s;
    }
  }, {
    key: "makeTensorInfo",
    value: function makeTensorInfo(e, t, n) {
      var s;

      if ("string" === t && null != n && n.length > 0 && C(n[0])) {
        var _r86 = n.map(function (e) {
          return Ge(e);
        });

        s = this.write(_r86, e, t);
      } else s = this.write(n, e, t);

      return {
        dataId: s,
        shape: e,
        dtype: t
      };
    }
  }, {
    key: "refCount",
    value: function refCount(e) {
      return this.data.has(e) ? this.data.get(e).refCount : 0;
    }
  }, {
    key: "incRef",
    value: function incRef(e) {
      this.data.get(e).refCount++;
    }
  }, {
    key: "decRef",
    value: function decRef(e) {
      this.data.has(e) && this.data.get(e).refCount--;
    }
  }, {
    key: "move",
    value: function move(e, t, n, s, r) {
      this.data.set(e, {
        values: t,
        dtype: s,
        refCount: r
      });
    }
  }, {
    key: "numDataIds",
    value: function numDataIds() {
      return this.data.numDataIds();
    }
  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee85(e) {
        return _regeneratorRuntime.wrap(function _callee85$(_context88) {
          while (1) {
            switch (_context88.prev = _context88.next) {
              case 0:
                return _context88.abrupt("return", this.readSync(e));

              case 1:
              case "end":
                return _context88.stop();
            }
          }
        }, _callee85, this);
      }));

      function read(_x135) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "readSync",
    value: function readSync(e) {
      var _this$data$get = this.data.get(e),
          t = _this$data$get.dtype,
          n = _this$data$get.complexTensorInfos;

      return "complex64" === t ? Mo(this.readSync(n.real.dataId), this.readSync(n.imag.dataId)) : this.data.get(e).values;
    }
  }, {
    key: "bufferSync",
    value: function bufferSync(e) {
      var t = this.readSync(e.dataId);
      var n = t;
      if ("string" === e.dtype) try {
        n = t.map(function (e) {
          return He(e);
        });
      } catch (e) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return dn(e.shape, e.dtype, n);
    }
  }, {
    key: "makeOutput",
    value: function makeOutput(e, t, n) {
      var s = this.write(e, t, n);
      return Kn().makeTensorFromDataId(s, t, n, this);
    }
  }, {
    key: "disposeData",
    value: function disposeData(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;

      if (this.data.has(e)) {
        if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return !1;

        var _this$data$get2 = this.data.get(e),
            _n151 = _this$data$get2.complexTensorInfos;

        null != _n151 && (this.disposeData(_n151.real.dataId, !0), this.disposeData(_n151.imag.dataId, !0)), this.data.delete(e);
      }

      return !0;
    }
  }, {
    key: "disposeIntermediateTensorInfo",
    value: function disposeIntermediateTensorInfo(e) {
      this.disposeData(e.dataId);
    }
  }, {
    key: "time",
    value: function () {
      var _time2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee86(e) {
        var t;
        return _regeneratorRuntime.wrap(function _callee86$(_context89) {
          while (1) {
            switch (_context89.prev = _context89.next) {
              case 0:
                t = Ve();
                return _context89.abrupt("return", (e(), {
                  kernelMs: Ve() - t
                }));

              case 2:
              case "end":
                return _context89.stop();
            }
          }
        }, _callee86);
      }));

      function time(_x136) {
        return _time2.apply(this, arguments);
      }

      return time;
    }()
  }, {
    key: "memory",
    value: function memory() {
      return {
        unreliable: !0,
        reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
      };
    }
  }, {
    key: "where",
    value: function where(e) {
      zf([e], "where");
      var t = this.readSync(e.dataId);
      return Bf(e.shape, t);
    }
  }, {
    key: "dispose",
    value: function dispose() {}
  }, {
    key: "floatPrecision",
    value: function floatPrecision() {
      return 32;
    }
  }, {
    key: "epsilon",
    value: function epsilon() {
      return _get(_getPrototypeOf(Pf.prototype), "epsilon", this).call(this);
    }
  }]);

  return Pf;
}(n);

function Wf(e) {
  var t = new Float32Array(e.length);

  for (var _n152 = 0; _n152 < e.length; ++_n152) {
    t[_n152] = Math.abs(e[_n152]);
  }

  return t;
}

Pf.nextDataId = 0;
var Uf = {
  kernelName: "Abs",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs.x,
        n = e.backend;
    zf(t, "abs");
    var s = new Float32Array(d(t.shape));
    return s = Wf(n.data.get(t.dataId).values), n.makeOutput(s, t.shape, "float32");
  }
};

function Vf(e) {
  return function (t, n, s, r, a) {
    var i = cr(t, n),
        o = i.length,
        l = A(i),
        u = w(a, d(i)),
        c = t.length,
        h = n.length,
        p = A(t),
        f = A(n),
        g = lr(t, i),
        m = lr(n, i);
    if (g.length + m.length === 0) for (var _t273 = 0; _t273 < u.length; ++_t273) {
      u[_t273] = e(s[_t273 % s.length], r[_t273 % r.length]);
    } else {
      var _loop25 = function _loop25(_t274) {
        var n = B(_t274, o, l),
            a = n.slice(-c);
        g.forEach(function (e) {
          return a[e] = 0;
        });
        var i = z(a, c, p),
            d = n.slice(-h);
        m.forEach(function (e) {
          return d[e] = 0;
        });
        var b = z(d, h, f);
        u[_t274] = e(s[i], r[b]);
      };

      for (var _t274 = 0; _t274 < u.length; ++_t274) {
        _loop25(_t274);
      }
    }
    return [u, i];
  };
}

function Gf(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.real,
      r = t.imag,
      a = n.data.get(s.dataId).values,
      i = n.data.get(r.dataId).values,
      o = n.makeTensorInfo(s.shape, "complex64");
  return n.data.get(o.dataId).complexTensorInfos = {
    real: n.makeTensorInfo(s.shape, "float32", a),
    imag: n.makeTensorInfo(r.shape, "float32", i)
  }, o;
}

var Hf = {
  kernelName: "Complex",
  backendName: "cpu",
  kernelFunc: Gf
};

function jf(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "float32";
  if ("complex64" === n) return Gf({
    inputs: {
      real: jf(e, t, "float32"),
      imag: jf(e, t, "float32")
    },
    backend: e
  });
  var s = O(d(t), n);
  return e.makeTensorInfo(t, n, s);
}

function qf(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.x;
  return n.incRef(s.dataId), {
    dataId: s.dataId,
    shape: s.shape,
    dtype: s.dtype
  };
}

var Kf = {
  kernelName: "Identity",
  backendName: "cpu",
  kernelFunc: qf
};

function Xf(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.input,
      r = n.data.get(s.dataId).complexTensorInfos.real,
      a = n.data.get(r.dataId).values;
  return n.makeTensorInfo(r.shape, r.dtype, a);
}

var Yf = {
  kernelName: "Real",
  backendName: "cpu",
  kernelFunc: Xf
};

function Jf(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.dtype;

  if ("complex64" === a) {
    if ("complex64" === r.dtype) return qf({
      inputs: {
        x: r
      },
      backend: n
    });

    var _e250 = jf(n, r.shape, r.dtype),
        _t275 = Jf({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        dtype: "float32"
      }
    }),
        _s124 = Gf({
      inputs: {
        real: _t275,
        imag: _e250
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e250), n.disposeIntermediateTensorInfo(_t275), _s124;
  }

  if ("complex64" === r.dtype) {
    var _e251 = Xf({
      inputs: {
        input: r
      },
      backend: n
    }),
        _t276 = Jf({
      inputs: {
        x: _e251
      },
      backend: n,
      attrs: {
        dtype: a
      }
    });

    return n.disposeIntermediateTensorInfo(_e251), _t276;
  }

  if (!I(r.dtype, a)) {
    var _e252 = qf({
      inputs: {
        x: r
      },
      backend: n
    });

    return {
      dataId: _e252.dataId,
      shape: _e252.shape,
      dtype: a
    };
  }

  if ("int32" === a) {
    var _e253 = n.data.get(r.dataId).values,
        _t277 = Int32Array.from(_e253);

    return n.makeTensorInfo(r.shape, "int32", _t277);
  }

  if ("bool" === a) {
    var _e254 = n.data.get(r.dataId).values,
        _t278 = Ue([0], r.dtype),
        _Vf = Vf(function (e, t) {
      return e !== t ? 1 : 0;
    })(r.shape, [], _e254, _t278, "bool"),
        _Vf2 = _slicedToArray(_Vf, 2),
        _s125 = _Vf2[0],
        _a60 = _Vf2[1];

    return n.makeTensorInfo(_a60, "bool", _s125);
  }

  throw new Error("Error in Cast: failed to cast ".concat(r.dtype, " to ").concat(a));
}

var Zf = {
  kernelName: "Cast",
  backendName: "cpu",
  kernelFunc: Jf
};

function Qf(e, t, n, s) {
  return null == n ? function (_ref21) {
    var n = _ref21.inputs,
        r = _ref21.backend;
    var a = n.a,
        i = n.b,
        o = r;
    zf([a, i], e);

    var l = o.data.get(a.dataId).values,
        u = o.data.get(i.dataId).values,
        c = "string" === a.dtype ? tl(l) : l,
        h = "string" === a.dtype ? tl(u) : u,
        d = s || a.dtype,
        _t279 = t(a.shape, i.shape, c, h, d),
        _t280 = _slicedToArray(_t279, 2),
        p = _t280[0],
        f = _t280[1];

    return o.makeTensorInfo(f, d, p);
  } : function (_ref22) {
    var e = _ref22.inputs,
        r = _ref22.backend;
    var a = e.a,
        i = e.b,
        o = r;

    if ("complex64" === a.dtype || "complex64" === i.dtype) {
      var _e255 = Jf({
        inputs: {
          x: a
        },
        backend: o,
        attrs: {
          dtype: "complex64"
        }
      }),
          _t281 = o.data.get(_e255.dataId),
          _s126 = _t281.complexTensorInfos.imag,
          _r87 = o.data.get(_t281.complexTensorInfos.real.dataId).values,
          _l19 = o.data.get(_s126.dataId).values,
          u = Jf({
        inputs: {
          x: i
        },
        backend: o,
        attrs: {
          dtype: "complex64"
        }
      }),
          c = o.data.get(u.dataId),
          h = c.complexTensorInfos.imag,
          _d8 = o.data.get(c.complexTensorInfos.real.dataId).values,
          _p7 = o.data.get(h.dataId).values,
          _n153 = n(a.shape, i.shape, _r87, _l19, _d8, _p7),
          _n154 = _slicedToArray(_n153, 3),
          _f6 = _n154[0],
          _g8 = _n154[1],
          _m7 = _n154[2],
          _b6 = o.makeTensorInfo(_m7, "float32", _f6),
          x = o.makeTensorInfo(_m7, "float32", _g8),
          _y6 = Gf({
        inputs: {
          real: _b6,
          imag: x
        },
        backend: o
      });

      return o.disposeIntermediateTensorInfo(_e255), o.disposeIntermediateTensorInfo(u), o.disposeIntermediateTensorInfo(_b6), o.disposeIntermediateTensorInfo(x), _y6;
    }

    {
      var _e256 = o.data.get(a.dataId).values,
          _n155 = o.data.get(i.dataId).values,
          _r88 = s || a.dtype,
          _t282 = t(a.shape, i.shape, _e256, _n155, _r88),
          _t283 = _slicedToArray(_t282, 2),
          _l20 = _t283[0],
          _u10 = _t283[1];

      return o.makeTensorInfo(_u10, _r88, _l20);
    }
  };
}

function eg(e) {
  return function (t, n, s, r, a, i) {
    var o = cr(t, n),
        l = d(o),
        u = o.length,
        c = A(o),
        h = w("float32", l),
        p = w("float32", l),
        f = lr(t, o),
        g = lr(n, o),
        m = Mo(s, r),
        b = Mo(a, i),
        x = t.length,
        y = A(t),
        k = n.length,
        v = A(n);
    if (f.length + g.length === 0) for (var _t284 = 0; _t284 < h.length; _t284++) {
      var _n156 = _t284 % m.length,
          _s127 = _t284 % b.length,
          _r89 = e(m[2 * _n156], m[2 * _n156 + 1], b[2 * _s127], b[2 * _s127 + 1]);

      h[_t284] = _r89.real, p[_t284] = _r89.imag;
    } else {
      var _loop26 = function _loop26(_t285) {
        var n = B(_t285, u, c),
            s = n.slice(-x);
        f.forEach(function (e) {
          return s[e] = 0;
        });
        var r = z(s, x, y),
            a = n.slice(-k);
        g.forEach(function (e) {
          return a[e] = 0;
        });
        var i = z(a, k, v),
            o = e(m[2 * r], m[2 * r + 1], b[2 * i], b[2 * i + 1]);
        h[_t285] = o.real, p[_t285] = o.imag;
      };

      for (var _t285 = 0; _t285 < h.length; _t285++) {
        _loop26(_t285);
      }
    }
    return [h, p, o];
  };
}

var tg = Vf(function (e, t) {
  return e + t;
}),
    ng = Qf("Add", tg, eg(function (e, t, n, s) {
  return {
    real: e + n,
    imag: t + s
  };
})),
    sg = {
  kernelName: "Add",
  backendName: "cpu",
  kernelFunc: ng
};

function rg(e, t, n, s, r) {
  var a = d(s),
      i = O(r, n);

  for (var _n157 = 0; _n157 < e.length; _n157++) {
    var _s128 = e[_n157];
    if (_s128 < 0) throw new Error("Input x must be non-negative!");
    _s128 >= r || (i[_s128] += a > 0 ? t[_n157] : 1);
  }

  return i;
}

function ag(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  var r = e.shape[0],
      a = e.shape[1],
      i = dn([r, n], t.dtype);

  for (var o = 0; o < r; o++) {
    for (var _r90 = 0; _r90 < a; _r90++) {
      var _a61 = e.get(o, _r90);

      if (_a61 < 0) throw new Error("Input x must be non-negative!");
      _a61 >= n || i.set(s ? 1 : t.size > 0 ? i.get(o, _a61) + t.get(o, _r90) : i.get(o, _a61) + 1, o, _a61);
    }
  }

  return i;
}

function ig(e) {
  return function (t, n, s) {
    var r = w(n, t.length);

    for (var _n158 = 0; _n158 < t.length; ++_n158) {
      r[_n158] = e(t[_n158], s);
    }

    return r;
  };
}

function og(e, t, n) {
  return function (_ref23) {
    var s = _ref23.inputs,
        r = _ref23.attrs,
        a = _ref23.backend;
    var i = s.x;
    if (zf(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
    var o = a,
        l = o.data.get(i.dataId).values,
        u = d(i.shape),
        c = n || i.dtype,
        h = v(c, u);

    for (var _e257 = 0; _e257 < u; ++_e257) {
      h[_e257] = t(l[_e257], r);
    }

    return o.makeTensorInfo(i.shape, c, h);
  };
}

function lg(e, t, n) {
  return function (_ref24) {
    var s = _ref24.inputs,
        r = _ref24.attrs,
        a = _ref24.backend;
    var i = s.x;
    if (zf(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
    var o = a,
        l = o.data.get(i.dataId).values,
        u = n || i.dtype,
        c = t(l, u, r);
    return o.makeTensorInfo(i.shape, u, c);
  };
}

var ug = ig(function (e) {
  return Math.ceil(e);
}),
    cg = {
  kernelName: "Ceil",
  backendName: "cpu",
  kernelFunc: lg("Ceil", ug)
};

function hg(e, t, n, s) {
  var r = v(n, d(t));

  if (s && "string" !== n) {
    var _t286 = 0;
    e.forEach(function (e) {
      var n = d(e.shape);
      r.set(e.vals, _t286), _t286 += n;
    });
  } else {
    var _s129 = 0;
    e.forEach(function (e) {
      var a = "string" === n ? tl(e.vals) : e.vals;
      var i = 0;

      for (var _n159 = 0; _n159 < e.shape[0]; ++_n159) {
        var o = _n159 * t[1] + _s129;

        for (var _t287 = 0; _t287 < e.shape[1]; ++_t287) {
          r[o + _t287] = a[i++];
        }
      }

      _s129 += e.shape[1];
    });
  }

  return r;
}

var dg = Vf(function (e, t) {
  return e === t ? 1 : 0;
}),
    pg = Qf("Equal", dg, null, "bool"),
    fg = {
  kernelName: "Equal",
  backendName: "cpu",
  kernelFunc: pg
},
    gg = ig(function (e) {
  return Math.exp(e);
}),
    mg = lg("Exp", gg),
    bg = {
  kernelName: "Exp",
  backendName: "cpu",
  kernelFunc: mg
},
    xg = ig(function (e) {
  return Math.expm1(e);
}),
    yg = {
  kernelName: "Expm1",
  backendName: "cpu",
  kernelFunc: lg("Expm1", xg)
},
    kg = ig(function (e) {
  return Math.floor(e);
}),
    wg = {
  kernelName: "Floor",
  backendName: "cpu",
  kernelFunc: lg("Floor", kg)
};

function vg(e, t, n, s, r, a, i, o, l) {
  var u = dn([s, a], n);

  for (var _n160 = 0; _n160 < s; _n160++) {
    var _s130 = [];
    var c = 0;

    for (var _t288 = 0; _t288 < r; _t288++) {
      var _a62 = e[_n160 * r + _t288];
      c += _a62 * i[_t288], _s130.push(_a62);
    }

    if (c < 0 || c >= l / a) throw new Error("Invalid indices: ".concat(_s130, " does not index into ").concat(o));

    for (var _e258 = 0; _e258 < a; _e258++) {
      u.values[_n160 * a + _e258] = t.get.apply(t, _toConsumableArray(t.indexToLoc(c * a + _e258)));
    }
  }

  return u;
}

function Ig(e, t, n) {
  var s = dn(n, e.dtype);

  for (var _n161 = 0; _n161 < s.size; ++_n161) {
    var _r91 = s.indexToLoc(_n161).slice(),
        a = t.locToIndex([_r91[0], _r91[2]]);

    _r91[2] = t.values[a];
    var i = e.locToIndex(_r91);
    s.values[_n161] = e.values[i];
  }

  return s;
}

var $g = Vf(function (e, t) {
  return e > t ? 1 : 0;
}),
    Ng = {
  kernelName: "Greater",
  backendName: "cpu",
  kernelFunc: Qf("Greater", $g, null, "bool")
},
    Cg = Vf(function (e, t) {
  return e >= t ? 1 : 0;
}),
    Sg = {
  kernelName: "GreaterEqual",
  backendName: "cpu",
  kernelFunc: Qf("GreaterEqual", Cg, null, "bool")
},
    Tg = Vf(function (e, t) {
  return e < t ? 1 : 0;
}),
    Eg = {
  kernelName: "Less",
  backendName: "cpu",
  kernelFunc: Qf("Less", Tg, null, "bool")
},
    Rg = Vf(function (e, t) {
  return e <= t ? 1 : 0;
}),
    Ag = {
  kernelName: "LessEqual",
  backendName: "cpu",
  kernelFunc: Qf("LessEqual", Rg, null, "bool")
};

function Fg(e, t, n) {
  var s = (t - e) / (n - 1),
      r = O(n, "float32");
  r[0] = e;

  for (var _e259 = 1; _e259 < r.length; _e259++) {
    r[_e259] = r[_e259 - 1] + s;
  }

  return r;
}

var Dg = ig(function (e) {
  return Math.log(e);
}),
    _g = {
  kernelName: "Log",
  backendName: "cpu",
  kernelFunc: lg("Log", Dg)
};

function Og(e, t, n, s) {
  var r = w(s, d(n));

  for (var _n162 = 0; _n162 < r.length; ++_n162) {
    var _s131 = _n162 * t;

    var a = e[_s131];

    for (var _n163 = 0; _n163 < t; ++_n163) {
      var _t289 = e[_s131 + _n163];
      (Number.isNaN(_t289) || _t289 > a) && (a = _t289);
    }

    r[_n162] = a;
  }

  return r;
}

var Mg = Vf(function (e, t) {
  return Math.max(e, t);
}),
    Lg = {
  kernelName: "Maximum",
  backendName: "cpu",
  kernelFunc: Qf("Maximum", Mg)
},
    zg = Vf(function (e, t) {
  return Math.min(e, t);
}),
    Bg = {
  kernelName: "Minimum",
  backendName: "cpu",
  kernelFunc: Qf("Minimum", zg)
},
    Pg = Vf(function (e, t) {
  return e * t;
}),
    Wg = eg(function (e, t, n, s) {
  return {
    real: e * n - t * s,
    imag: e * s + t * n
  };
}),
    Ug = Qf("Multiply", Pg, Wg),
    Vg = {
  kernelName: "Multiply",
  backendName: "cpu",
  kernelFunc: Ug
};

function Gg(e, t, n) {
  var s = We(-1, n);
  return Pg([], t, s, e, n);
}

var Hg = {
  kernelName: "Neg",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x;
    zf(s, "neg");

    var r = n.data.get(s.dataId).values,
        _Gg = Gg(r, s.shape, s.dtype),
        _Gg2 = _slicedToArray(_Gg, 2),
        a = _Gg2[0],
        i = _Gg2[1];

    return n.makeTensorInfo(i, s.dtype, a);
  }
},
    jg = Vf(function (e, t) {
  return e !== t ? 1 : 0;
}),
    qg = {
  kernelName: "NotEqual",
  backendName: "cpu",
  kernelFunc: Qf("NotEqual", jg, null, "bool")
};

function Kg(e, t, n, s, r) {
  var a = t.length,
      i = d(t),
      o = A(t),
      l = A(r),
      u = w(n, d(r));

  for (var _t290 = 0; _t290 < i; ++_t290) {
    var _n164 = B(_t290, a, o),
        _r92 = new Array(_n164.length);

    for (var _e260 = 0; _e260 < _r92.length; _e260++) {
      _r92[_e260] = _n164[s[_e260]];
    }

    u[z(_r92, a, l)] = e[_t290];
  }

  return u;
}

function Xg(e) {
  var t = e.inputs,
      n = e.attrs,
      s = e.backend,
      r = t.x,
      a = n.perm;
  zf(r, "transpose");
  var i = new Array(r.shape.length);

  for (var _e261 = 0; _e261 < i.length; _e261++) {
    i[_e261] = r.shape[a[_e261]];
  }

  var o = Kg(s.data.get(r.dataId).values, r.shape, r.dtype, a, i);
  return {
    dataId: s.write(o, i, r.dtype),
    shape: i,
    dtype: r.dtype
  };
}

var Yg = {
  kernelName: "Transpose",
  backendName: "cpu",
  kernelFunc: Xg
};

function Jg(e, t, n, s) {
  var _Kr = Kr(e, s),
      _Kr2 = _slicedToArray(_Kr, 2),
      r = _Kr2[0],
      a = _Kr2[1],
      i = dt(t, "int32"),
      o = O(d(r), i),
      l = d(a);

  for (var _e262 = 0; _e262 < o.length; ++_e262) {
    var _t291 = _e262 * l;

    var _s132 = 1;

    for (var _e263 = 0; _e263 < l; ++_e263) {
      _s132 *= n[_t291 + _e263];
    }

    o[_e262] = _s132;
  }

  return {
    outVals: o,
    outShape: r,
    outDtype: i
  };
}

var Zg = {
  kernelName: "Prod",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims;
    zf(r, "prod");
    var o = r.shape.length,
        l = y(a, r.shape),
        u = Jr(l, o);
    var c = l,
        h = r;
    var d = [];
    null != u && (h = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), d.push(h), c = Qr(c.length, o));

    var p = n.data.get(h.dataId).values,
        _Jg = Jg(h.shape, h.dtype, p, c),
        f = _Jg.outVals,
        g = _Jg.outShape,
        m = _Jg.outDtype;

    var b = g;
    return i && (b = Xr(g, l)), d.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), n.makeTensorInfo(b, m, f);
  }
};

function Qg(e, t, n, s) {
  if (e === t || e < t && n < 0 || t < e && n > 1) return O(0, s);
  var r = O(Math.abs(Math.ceil((t - e) / n)), s);
  t < e && 1 === n && (n = -1), r[0] = e;

  for (var _e264 = 1; _e264 < r.length; _e264++) {
    r[_e264] = r[_e264 - 1] + n;
  }

  return r;
}

var em = ig(function (e) {
  return 1 / Math.sqrt(e);
}),
    tm = {
  kernelName: "Rsqrt",
  backendName: "cpu",
  kernelFunc: lg("Rsqrt", em)
};

function nm(e, t, n, s, r) {
  var a = Pn(s, t, n),
      i = d(n),
      o = A(s);

  if (a) {
    var _n165 = Wn(t, o);

    return "string" === r ? e.slice(_n165, _n165 + i) : e.subarray(_n165, _n165 + i);
  }

  var l = dn(s, r, "string" === r ? tl(e) : e),
      u = dn(n, r);

  for (var _e265 = 0; _e265 < u.size; ++_e265) {
    var _n166 = u.indexToLoc(_e265),
        _s133 = _n166.map(function (e, n) {
      return e + t[n];
    });

    u.set.apply(u, [l.get.apply(l, _toConsumableArray(_s133))].concat(_toConsumableArray(_n166)));
  }

  return "string" === r ? nl(u.values) : u.values;
}

function sm(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.begin,
      i = s.size;
  zf(r, "slice");

  var _Un3 = Un(r, a, i),
      _Un4 = _slicedToArray(_Un3, 2),
      o = _Un4[0],
      l = _Un4[1];

  Tn(r, o, l);
  var u = nm(n.data.get(r.dataId).values, o, l, r.shape, r.dtype);
  return n.makeTensorInfo(l, r.dtype, u);
}

var rm = {
  kernelName: "Slice",
  backendName: "cpu",
  kernelFunc: sm
};

function am(e, t, n, s, r, a, i) {
  var o = t[0],
      l = a[0],
      u = new Array(l),
      c = new Array(o),
      h = t[1];

  if (0 === l) {
    if (0 !== o) throw new Error("Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ".concat(o));
    return [v(n, 0), [0, h], v(r, 0), u, c];
  }

  var d = !0,
      p = 0;
  var f = new Array(l).fill(0);

  for (var _t292 = 0; _t292 < o; ++_t292) {
    var _n167 = e[_t292 * h];
    if (_n167 < 0) throw new Error("indices(".concat(_t292, ", 0) is invalid: ").concat(_n167, " < 0"));
    if (_n167 >= l) throw new Error("indices(".concat(_t292, ", 0) is invalid: ").concat(_n167, " >= ").concat(l));
    ++f[_n167], d = d && _n167 >= p, p = _n167;
  }

  var g = !0;

  for (var _e266 = 0; _e266 < l; ++_e266) {
    var _t293 = 0 === f[_e266];

    u[_e266] = _t293, g = g && !_t293, f[_e266] = Math.max(f[_e266], 1), _e266 > 0 && (f[_e266] += f[_e266 - 1]);
  }

  if (g && d) {
    var _t294 = e,
        _n168 = s;

    for (var _e267 = 0; _e267 < o; ++_e267) {
      c[_e267] = _e267;
    }

    return [_t294, [o, h], _n168, u, c];
  }

  {
    var _t295 = f[l - 1],
        _a63 = v(n, _t295 * h),
        _d9 = v(r, _t295),
        _p8 = new Array(l).fill(0);

    for (var _t296 = 0; _t296 < o; ++_t296) {
      var _n169 = e[_t296 * h],
          _r93 = (0 === _n169 ? 0 : f[_n169 - 1]) + _p8[_n169];

      _p8[_n169]++;

      for (var _n170 = 0; _n170 < h; ++_n170) {
        _a63[_r93 * h + _n170] = e[_t296 * h + _n170];
      }

      _d9[_r93] = s[_t296], c[_t296] = _r93;
    }

    for (var _e268 = 0; _e268 < l; ++_e268) {
      if (0 === _p8[_e268]) {
        var _t297 = 0 === _e268 ? 0 : f[_e268 - 1];

        _a63[_t297 * h + 0] = _e268;

        for (var _e269 = 1; _e269 < h; ++_e269) {
          _a63[_t297 * h + _e269] = 0;
        }

        _d9[_t297] = i;
      }
    }

    return [_a63, [_t295, h], _d9, u, c];
  }
}

function im(e, t, n, s, r) {
  var a = d(s),
      i = t[0],
      o = r.length,
      l = [];
  var u = 1,
      c = -1;

  for (var _e270 = 0; _e270 < o; ++_e270) {
    var _t298 = r[_e270];

    if (-1 === _t298) {
      if (-1 !== c) throw new Error("only one output dimension may be -1, not both ".concat(c, " and ").concat(_e270));
      c = _e270, l.push(1);
    } else {
      if (_t298 < 0) throw new Error("size ".concat(_e270, " must be non-negative, not ").concat(_t298));
      u *= _t298, l.push(_t298);
    }
  }

  if (-1 !== c) {
    if (u <= 0) throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");

    var _e271 = Math.trunc(a / u);

    if (u * _e271 !== a) throw new Error("Input to reshape is a SparseTensor with ".concat(a, "\n          dense values, but the requested shape requires a multiple of ").concat(u, ". inputShape=").concat(s, " outputShape= ").concat(l));
    l[c] = _e271;
  }

  var h = d(l);
  if (h !== a) throw new Error("Input to reshape is a tensor with ".concat(a, " dense values, but the requested shape has ").concat(h, ". inputShape=").concat(s, " outputShape=").concat(l));
  var p = s.length,
      f = [];

  if (p > 0) {
    f[p - 1] = 1;

    for (var _e272 = p - 2; _e272 >= 0; --_e272) {
      f[_e272] = f[_e272 + 1] * s[_e272 + 1];
    }
  }

  var g = [];

  if (o > 0) {
    g[o - 1] = 1;

    for (var _e273 = o - 2; _e273 >= 0; --_e273) {
      g[_e273] = g[_e273 + 1] * l[_e273 + 1];
    }
  }

  var m = v(n, i * o);

  for (var _t299 = 0; _t299 < i; ++_t299) {
    var _n171 = 0;

    for (var _s134 = 0; _s134 < p; ++_s134) {
      _n171 += e[_t299 * p + _s134] * f[_s134];
    }

    for (var _e274 = 0; _e274 < o; ++_e274) {
      m[_t299 * o + _e274] = Math.trunc(_n171 / g[_e274]), _n171 %= g[_e274];
    }
  }

  return [m, [i, o], l];
}

function om(e, t, n, s, r) {
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var o = s.length;
  if (o !== r.length) throw new Error("segmentIds and indices should have same size.");
  var l = [t[0], e.length / t[0]],
      u = l[1],
      c = o > 0 ? r[o - 1] + 1 : 0;
  if (c < 0) throw new Error("segment ids must be >= 0");
  var h = t.slice();
  h[0] = c;
  var d = v(n, h.reduce(function (e, t) {
    return e * t;
  }, 1));
  if (0 === o) return c > 0 && d.fill(i), [d, h];
  if (c <= 0) throw new Error("segment ids must be >= 0");
  var p = 0,
      f = 1,
      g = 0,
      m = r[p];

  for (;;) {
    var _t300 = 0;

    if (f < o) {
      if (_t300 = r[f], m === _t300) {
        ++f;
        continue;
      }

      if (m >= _t300) throw new Error("segment ids are not increasing");
    }

    if (m < 0 || m >= c) throw new Error("Segment id ".concat(m, " out of range [0, ").concat(c, "), possibly because segmentIds input is not sorted."));
    m > g && d.fill(i, g * u, m * u);

    for (var _t301 = p; _t301 < f; ++_t301) {
      var _n172 = s[_t301];
      if (_n172 < 0 || _n172 >= l[0]) throw new Error("Bad: indices[".concat(_t301, "] == ").concat(s[_t301], " out of range [0, ").concat(l[0], ")"));

      for (var _t302 = 0; _t302 < u; _t302++) {
        d[m * u + _t302] += e[_n172 * u + _t302];
      }
    }

    if (a) for (var _e275 = 0; _e275 < u; _e275++) {
      d[m * u + _e275] /= f - p;
    }
    if (p = f, ++f, g = m + 1, m = _t300, f > o) break;
  }

  return g < c && d.fill(i, g * u, c * u), [d, h];
}

var lm = Vf(function (e, t) {
  var n = e - t;
  return n * n;
}),
    um = {
  kernelName: "SquaredDifference",
  backendName: "cpu",
  kernelFunc: Qf("SquaredDifference", lm)
};

function cm(e, t, n, s) {
  var r = dn(e, t.dtype);

  for (var _e276 = 0; _e276 < r.size; _e276++) {
    var a = r.indexToLoc(_e276),
        i = new Array(a.length);

    for (var _e277 = 0; _e277 < i.length; _e277++) {
      i[_e277] = a[_e277] * n[_e277] + s[_e277];
    }

    r.set.apply(r, [t.get.apply(t, i)].concat(_toConsumableArray(a)));
  }

  return r;
}

var hm = /*#__PURE__*/function () {
  "use strict";

  function hm(e, t, n, s, r, a) {
    _classCallCheck(this, hm);

    this.separator = Ge(e), this.nGramWidths = t, this.leftPad = Ge(n), this.rightPad = Ge(s), this.padWidth = r, this.preserveShort = a;
  }

  _createClass(hm, [{
    key: "getPadWidth",
    value: function getPadWidth(e) {
      return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
    }
  }, {
    key: "getNumNGrams",
    value: function getNumNGrams(e, t) {
      var n = this.getPadWidth(t);
      return Math.max(0, e + 2 * n - t + 1);
    }
  }, {
    key: "createNGrams",
    value: function createNGrams(e, t, n, s, r, a) {
      var _this183 = this;

      var _loop27 = function _loop27(i) {
        var o = _this183.getPadWidth(a),
            l = Math.max(0, o - i),
            u = Math.max(0, o - (r - (i + 1))),
            c = a - (l + u),
            h = t + (l > 0 ? 0 : i - o);

        var d = 0;
        d += l * _this183.leftPad.length;

        for (var _t303 = 0; _t303 < c; ++_t303) {
          d += e[h + _t303].length;
        }

        d += u * _this183.rightPad.length, d += (l + u + c - 1) * _this183.separator.length, n[s + i] = new Uint8Array(d);
        var p = n[s + i];
        var f = 0;

        var g = function g(e) {
          return e.forEach(function (e) {
            return p[f++] = e;
          });
        };

        for (var _e278 = 0; _e278 < l; ++_e278) {
          g(_this183.leftPad), g(_this183.separator);
        }

        for (var _t304 = 0; _t304 < c - 1; ++_t304) {
          g(e[h + _t304]), g(_this183.separator);
        }

        if (c > 0) {
          g(e[h + c - 1]);

          for (var _e279 = 0; _e279 < u; ++_e279) {
            g(_this183.separator), g(_this183.rightPad);
          }
        } else {
          for (var _e280 = 0; _e280 < u - 1; ++_e280) {
            g(_this183.rightPad), g(_this183.separator);
          }

          g(_this183.rightPad);
        }
      };

      for (var i = 0; i < r; ++i) {
        _loop27(i);
      }
    }
  }, {
    key: "compute",
    value: function compute(e, t) {
      var _this184 = this;

      var n = e.length,
          s = t.length;

      if (s > 0) {
        var _e281 = t[0];
        if (0 !== _e281) throw new Error("First split value must be 0, got ".concat(_e281));

        for (var _r94 = 1; _r94 < s; ++_r94) {
          var _s135 = t[_r94] >= _e281;

          if (_s135 = _s135 && t[_r94] <= n, !_s135) throw new Error("Invalid split value ".concat(t[_r94], ", must be in [").concat(_e281, ", ").concat(n, "]"));
          _e281 = t[_r94];
        }

        if (_e281 !== n) throw new Error("Last split value must be data size. Expected ".concat(n, ", got ").concat(_e281));
      }

      var r = s - 1,
          a = v("int32", s);

      if (0 === n || 0 === s) {
        var _e282 = new Array(n);

        for (var _e283 = 0; _e283 <= r; ++_e283) {
          a[_e283] = 0;
        }

        return [_e282, a];
      }

      a[0] = 0;

      var _loop28 = function _loop28(_e284) {
        var n = t[_e284] - t[_e284 - 1];
        var s = 0;
        _this184.nGramWidths.forEach(function (e) {
          s += _this184.getNumNGrams(n, e);
        }), _this184.preserveShort && n > 0 && 0 === s && (s = 1), a[_e284] = a[_e284 - 1] + s;
      };

      for (var _e284 = 1; _e284 <= r; ++_e284) {
        _loop28(_e284);
      }

      var i = new Array(a[r]);

      var _loop29 = function _loop29(_n173) {
        var s = t[_n173];
        var r = a[_n173];

        if (_this184.nGramWidths.forEach(function (a) {
          var o = _this184.getNumNGrams(t[_n173 + 1] - t[_n173], a);

          _this184.createNGrams(e, s, i, r, o, a), r += o;
        }), _this184.preserveShort && r === a[_n173]) {
          var _a64 = t[_n173 + 1] - t[_n173];

          if (0 === _a64) return "continue";

          _this184.createNGrams(e, s, i, r, 1, _a64 + 2 * _this184.padWidth);
        }
      };

      for (var _n173 = 0; _n173 < r; ++_n173) {
        var _ret4 = _loop29(_n173);

        if (_ret4 === "continue") continue;
      }

      return [i, a];
    }
  }]);

  return hm;
}();

function dm(e, t, n, s, r, a, i, o) {
  return new hm(n, s, r, a, i, o).compute(e, t);
}

function pm(e, t, n) {
  if (!e.length) return [];

  if (0 === t.length) {
    var _t305 = new Array(e.length);

    for (var _n174 = 0; _n174 < e.length; ++_n174) {
      _t305[_n174] = e.subarray(_n174, _n174 + 1);
    }

    return _t305;
  }

  if (1 === t.length) {
    var _s136 = t[0],
        _r95 = [];
    var a = e.indexOf(_s136);

    for (; -1 !== a;) {
      var _t306 = e.subarray(0, a);

      n && 0 === _t306.length || _r95.push(_t306), a = (e = e.subarray(a + 1)).indexOf(_s136);
    }

    return n && 0 === e.length || _r95.push(e), _r95;
  }

  var s = [];
  var r = 0;

  for (var _a65 = 0; _a65 < e.length + 1; _a65++) {
    if (_a65 === e.length || -1 !== t.indexOf(e[_a65])) {
      var _t307 = e.subarray(r, _a65);

      n && 0 === _t307.length || s.push(_t307), r = _a65 + 1;
    }
  }

  return s;
}

function fm(e, t, n) {
  var s = e.length,
      r = [];
  var a = 0,
      i = 0;
  var o = new Array(s);

  for (var _l21 = 0; _l21 < s; ++_l21) {
    var _s137 = pm(e[_l21], t, n),
        _u11 = _s137.length;

    o[_l21] = _u11, a += _u11, i = Math.max(i, _u11), r.push.apply(r, _toConsumableArray(_s137));
  }

  var l = v("int32", 2 * a),
      u = new Array(a),
      c = [s, i];
  var h = 0;

  for (var _e285 = 0; _e285 < s; ++_e285) {
    for (var _t308 = 0; _t308 < o[_e285]; ++_t308) {
      l[2 * h] = _e285, l[2 * h + 1] = _t308, u[h] = r[h], ++h;
    }
  }

  return [l, u, c];
}

function gm(e, t) {
  var n = v("int32", e.length);

  for (var _s138 = 0; _s138 < e.length; ++_s138) {
    n[_s138] = Pe(e[_s138]).modulo(t).getLowBitsUnsigned();
  }

  return n;
}

var mm = Vf(function (e, t) {
  return e - t;
}),
    bm = Qf("Sub", mm, eg(function (e, t, n, s) {
  return {
    real: e - n,
    imag: t - s
  };
})),
    xm = {
  kernelName: "Sub",
  backendName: "cpu",
  kernelFunc: bm
};

function ym(e, t) {
  var n = new Array(e.rank);

  for (var _s139 = 0; _s139 < n.length; _s139++) {
    n[_s139] = e.shape[_s139] * t[_s139];
  }

  var s = dn(n, e.dtype);

  for (var _t309 = 0; _t309 < s.values.length; ++_t309) {
    var _n175 = s.indexToLoc(_t309),
        _r96 = new Array(e.rank);

    for (var _t310 = 0; _t310 < _r96.length; _t310++) {
      _r96[_t310] = _n175[_t310] % e.shape[_t310];
    }

    var a = e.locToIndex(_r96);
    s.values[_t309] = e.values[a];
  }

  return s;
}

var km = function km(e, t) {
  var n = t.value - e.value;
  return 0 === n ? e.index - t.index : n;
};

function wm(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.length - 1;

  for (; s > n;) {
    if (s - n > 600) {
      var _r98 = s - n + 1,
          _a66 = t - n + 1,
          _i51 = Math.log(_r98),
          _o27 = .5 * Math.exp(2 * _i51 / 3),
          _l22 = .5 * Math.sqrt(_i51 * _o27 * (_r98 - _o27) / _r98) * Math.sign(_a66 - _r98 / 2);

      wm(e, t, Math.max(n, Math.floor(t - _a66 * _o27 / _r98 + _l22)), Math.min(s, Math.floor(t + (_r98 - _a66) * _o27 / _r98 + _l22)));
    }

    var _r97 = e[t];
    var a = n,
        i = s;

    for (o(e, n, t), km(e[s], _r97) > 0 && o(e, n, s); a < i;) {
      for (o(e, a, i), a++, i--; km(e[a], _r97) < 0;) {
        a += 1;
      }

      for (; km(e[i], _r97) > 0;) {
        i -= 1;
      }
    }

    0 === km(e[n], _r97) ? o(e, n, i) : (i += 1, o(e, i, s)), i <= t && (n = i + 1), t <= i && (s = i - 1);
  }
}

function vm(e, t, n, s, r) {
  var a = t[t.length - 1],
      i = e.length / a,
      o = a,
      l = w(n, i * s),
      u = w("int32", i * s);

  var _loop30 = function _loop30(_t311) {
    var n = _t311 * o,
        a = e.subarray(n, n + o);
    var i = new Array(a.length);
    a.forEach(function (e, t) {
      return i[t] = {
        value: e,
        index: t
      };
    }), s < i.length && (wm(i, s), i = i.slice(0, s)), r && i.sort(km);
    var c = _t311 * s,
        h = l.subarray(c, c + s),
        d = u.subarray(c, c + s);

    for (var _e286 = 0; _e286 < s; _e286++) {
      h[_e286] = i[_e286].value, d[_e286] = i[_e286].index;
    }
  };

  for (var _t311 = 0; _t311 < i; _t311++) {
    _loop30(_t311);
  }

  var c = t.slice();
  return c[c.length - 1] = s, [dn(c, n, l), dn(c, "int32", u)];
}

function Im(e, t, n, s) {
  var r = y(t, n)[0],
      a = [1, n[0], 1];

  for (var _e287 = 0; _e287 < r; _e287++) {
    a[0] *= n[_e287];
  }

  a[1] = n[r];

  for (var _e288 = r + 1; _e288 < n.length; _e288++) {
    a[2] *= n[_e288];
  }

  var i = {},
      o = new Int32Array(n[r]),
      l = new et(a, s, e),
      u = [],
      c = 1 === a[0] && 1 === a[2];

  for (var _t312 = 0; _t312 < n[r]; _t312++) {
    var _n176 = void 0;

    if (c) _n176 = e[_t312].toString();else {
      var _e289 = [];

      for (var _n177 = 0; _n177 < a[0]; _n177++) {
        for (var _s140 = 0; _s140 < a[2]; _s140++) {
          _e289.push(l.get(_n177, _t312, _s140));
        }
      }

      _n176 = _e289.join(",");
    }
    if (void 0 !== i[_n176]) o[_t312] = i[_n176];else {
      var _e290 = Object.keys(i).length;
      i[_n176] = _e290, o[_t312] = _e290, u.push(_t312);
    }
  }

  var h = a.slice();
  h[1] = Object.keys(i).length;
  var d = new et(h, s);
  u.forEach(function (e, t) {
    for (var _n178 = 0; _n178 < a[0]; _n178++) {
      for (var _s141 = 0; _s141 < a[2]; _s141++) {
        d.set(l.get(_n178, e, _s141), _n178, t, _s141);
      }
    }
  });
  var p = n.slice();
  return p[r] = h[1], {
    outputValues: d.values,
    outputShape: p,
    indices: o
  };
}

var $m = {
  __proto__: null,
  simpleAbsImpl: Wf,
  addImpl: tg,
  bincountImpl: rg,
  bincountReduceImpl: ag,
  ceilImpl: ug,
  concatImpl: hg,
  equalImpl: dg,
  expImpl: gg,
  expm1Impl: xg,
  floorImpl: kg,
  gatherNdImpl: vg,
  gatherV2Impl: Ig,
  greaterImpl: $g,
  greaterEqualImpl: Cg,
  lessImpl: Tg,
  lessEqualImpl: Rg,
  linSpaceImpl: Fg,
  logImpl: Dg,
  maxImpl: Og,
  maximumImpl: Mg,
  minimumImpl: zg,
  multiplyImpl: Pg,
  negImpl: Gg,
  notEqualImpl: jg,
  prodImpl: Jg,
  rangeImpl: Qg,
  rsqrtImpl: em,
  sliceImpl: nm,
  sparseFillEmptyRowsImpl: am,
  sparseReshapeImpl: im,
  sparseSegmentReductionImpl: om,
  squaredDifferenceImpl: lm,
  stridedSliceImpl: cm,
  stringNGramsImpl: dm,
  stringSplitImpl: fm,
  stringToHashBucketFastImpl: gm,
  subImpl: mm,
  tileImpl: ym,
  topKImpl: vm,
  transposeImpl: Kg,
  uniqueImpl: Im
};
Qn("cpu", function () {
  return new Pf();
}, 1);
var Nm = og("Elu", function (e) {
  return e >= 0 ? e : Math.exp(e) - 1;
}),
    Cm = {
  kernelName: "Elu",
  backendName: "cpu",
  kernelFunc: Nm
};

function Sm(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.alpha;
  zf([r], "leakyRelu");
  var i = d(r.shape),
      o = n.data.get(r.dataId).values,
      l = w("float32", i);

  for (var _e291 = 0; _e291 < o.length; _e291++) {
    l[_e291] = o[_e291] < 0 ? a * o[_e291] : o[_e291];
  }

  return n.makeTensorInfo(r.shape, "float32", l);
}

var Tm = {
  kernelName: "LeakyRelu",
  backendName: "cpu",
  kernelFunc: Sm
},
    Em = Vf(function (e, t) {
  return e < 0 ? t * e : e;
});

function Rm(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.x,
      r = t.alpha;
  zf([s, r], "prelu");

  var a = n.data.get(s.dataId).values,
      i = n.data.get(r.dataId).values,
      _Em = Em(s.shape, r.shape, a, i, s.dtype),
      _Em2 = _slicedToArray(_Em, 2),
      o = _Em2[0],
      l = _Em2[1];

  return n.makeTensorInfo(l, s.dtype, o);
}

var Am = {
  kernelName: "Prelu",
  backendName: "cpu",
  kernelFunc: Rm
},
    Fm = og("Relu", function (e) {
  return Math.max(0, e);
}),
    Dm = {
  kernelName: "Relu",
  backendName: "cpu",
  kernelFunc: Fm
},
    _m = og("Relu6", function (e) {
  return Math.min(Math.max(0, e), 6);
}),
    Om = {
  kernelName: "Relu6",
  backendName: "cpu",
  kernelFunc: _m
},
    Mm = og("Sigmoid", function (e) {
  return 1 / (1 + Math.exp(-e));
}),
    Lm = {
  kernelName: "Sigmoid",
  backendName: "cpu",
  kernelFunc: Mm
};

function zm(e, t, n, s, r) {
  if ("linear" === n) return qf({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("relu" === n) return Fm({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("elu" === n) return Nm({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("relu6" === n) return _m({
    inputs: {
      x: t
    },
    backend: e
  });
  if ("prelu" === n) return Rm({
    inputs: {
      x: t,
      alpha: s
    },
    backend: e
  });
  if ("leakyrelu" === n) return Sm({
    inputs: {
      x: t
    },
    backend: e,
    attrs: {
      alpha: r
    }
  });
  if ("sigmoid" === n) return Mm({
    inputs: {
      x: t
    },
    backend: e
  });
  throw new Error("Activation ".concat(n, " has not been implemented for the CPU backend."));
}

function Bm(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.shape,
      i = d(r.shape),
      o = x(a, i),
      u = d(o);
  l(i === u, function () {
    return "The new shape (".concat(o, ") has ").concat(u, " elements and the old shape (").concat(r.shape, ") has ").concat(i, " elements. The new shape and old shape must have the same number of elements.");
  }), n.incRef(r.dataId);
  var c = n.data.get(r.dataId);

  if (null != c.complexTensorInfos) {
    var _e292 = c.complexTensorInfos.imag;
    c.complexTensorInfos.real.shape = o, _e292.shape = o;
  }

  return {
    dataId: r.dataId,
    shape: o,
    dtype: r.dtype
  };
}

var Pm = {
  kernelName: "Reshape",
  backendName: "cpu",
  kernelFunc: Bm
};

function Wm(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.a,
      a = t.b,
      i = s.transposeA,
      o = s.transposeB;
  zf([r, a], "matMul");
  var u = r.shape.length,
      c = a.shape.length,
      h = i ? r.shape[u - 2] : r.shape[u - 1],
      p = o ? a.shape[c - 1] : a.shape[c - 2],
      f = i ? r.shape[u - 1] : r.shape[u - 2],
      g = o ? a.shape[c - 2] : a.shape[c - 1],
      m = r.shape.slice(0, -2),
      b = a.shape.slice(0, -2),
      x = d(m),
      y = d(b);
  l(u >= 2 && c >= 2 && (x === y || 1 === x || 1 === y), function () {
    return "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (".concat(m, ") and (").concat(b, ").");
  });
  var k = (x > y ? r.shape.slice(0, -2) : a.shape.slice(0, -2)).concat([f, g]);
  l(h === p, function () {
    return "Error in matMul: inner shapes (".concat(h, ") and (").concat(p, ") of Tensors with shapes ").concat(r.shape, " and ").concat(a.shape, " and transposeA=").concat(i, " and transposeB=").concat(o, " must match.");
  });

  var w = o ? [y, g, p] : [y, p, g],
      v = Bm({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: i ? [x, h, f] : [x, f, h]
    }
  }),
      I = Bm({
    inputs: {
      x: a
    },
    backend: n,
    attrs: {
      shape: w
    }
  }),
      $ = i ? v.shape[1] : v.shape[2],
      N = i ? v.shape[2] : v.shape[1],
      C = o ? I.shape[1] : I.shape[2],
      S = Math.max(x, y),
      T = n.data.get(v.dataId).values,
      E = n.data.get(I.dataId).values,
      R = A(v.shape),
      F = A(I.shape),
      _ref25 = i ? [R[0], 1, R[1]] : [R[0], R[1], 1],
      _ref26 = _slicedToArray(_ref25, 3),
      D = _ref26[0],
      _ = _ref26[1],
      O = _ref26[2],
      _ref27 = o ? [1, F[1], F[0]] : [F[1], 1, F[0]],
      _ref28 = _slicedToArray(_ref27, 3),
      M = _ref28[0],
      L = _ref28[1],
      z = _ref28[2],
      B = N * C,
      P = dn([S, N, C], v.dtype),
      W = P.values,
      U = n.blockSize;

  for (var _e293 = 0; _e293 < S; _e293++) {
    for (var _t313 = 0; _t313 < N; _t313 += U) {
      for (var _n179 = 0; _n179 < C; _n179 += U) {
        for (var _s142 = 0; _s142 < $; _s142 += U) {
          var _r99 = Math.min(_t313 + U, N),
              _a67 = Math.min(_n179 + U, C),
              _i52 = Math.min(_s142 + U, $);

          for (var _o28 = _t313; _o28 < _r99; _o28++) {
            for (var _t314 = _n179; _t314 < _a67; _t314++) {
              var _n180 = 0;

              for (var _r100 = _s142; _r100 < _i52; _r100++) {
                var _s143 = Math.min(_e293, x - 1) * D,
                    _a68 = Math.min(_e293, y - 1) * z;

                _n180 += T[_s143 + _o28 * _ + _r100 * O] * E[_r100 * M + _t314 * L + _a68];
              }

              W[_e293 * B + (_o28 * C + _t314)] += _n180;
            }
          }
        }
      }
    }
  }

  return n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(I), n.makeTensorInfo(k, P.dtype, P.values);
}

var Um = {
  kernelName: "BatchMatMul",
  backendName: "cpu",
  kernelFunc: Wm
},
    Vm = {
  kernelName: "_FusedMatMul",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.a,
        a = t.b,
        i = t.bias,
        o = t.preluActivationWeights,
        l = s.transposeA,
        u = s.transposeB,
        c = s.activation,
        h = s.leakyreluAlpha;
    var d, p, f;
    var g = [];
    d = Wm({
      inputs: {
        a: r,
        b: a
      },
      attrs: {
        transposeA: l,
        transposeB: u
      },
      backend: n
    }), i && (p = ng({
      inputs: {
        a: d,
        b: i
      },
      backend: n
    }), g.push(d), d = p), c && (f = zm(n, d, c, o, h), g.push(d), d = f);

    for (var _i53 = 0, _g9 = g; _i53 < _g9.length; _i53++) {
      var _e294 = _g9[_i53];
      n.disposeIntermediateTensorInfo(_e294);
    }

    return d;
  }
},
    Gm = {
  kernelName: "Acos",
  backendName: "cpu",
  kernelFunc: og("Acos", function (e) {
    return Math.acos(e);
  })
},
    Hm = {
  kernelName: "Acosh",
  backendName: "cpu",
  kernelFunc: og("Acosh", function (e) {
    return Math.acosh(e);
  })
},
    jm = {
  kernelName: "AddN",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t;
    zf(t, "addN");
    var r = s.map(function (e) {
      return n.data.get(e.dataId).values;
    }),
        a = dn(s[0].shape, s[0].dtype),
        i = a.values;

    for (var _e295 = 0; _e295 < s.length; _e295++) {
      var _t315 = r[_e295];

      for (var _e296 = 0; _e296 < i.length; _e296++) {
        i[_e296] += _t315[_e296];
      }
    }

    return n.makeTensorInfo(a.shape, a.dtype, a.values);
  }
},
    qm = {
  kernelName: "All",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims;
    zf(r, "all");
    var o = y(a, r.shape);
    var l = o;
    var u = Jr(l, r.shape.length);
    var c = r;
    null != u && (c = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = Qr(l.length, r.shape.length)), Yr("all", l, c.shape.length);

    var _Kr3 = Kr(c.shape, l),
        _Kr4 = _slicedToArray(_Kr3, 2),
        h = _Kr4[0],
        p = _Kr4[1],
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e297 = 0; _e297 < g.length; ++_e297) {
      var _t316 = _e297 * f;

      var _n181 = m[_t316];

      for (var _e298 = 0; _e298 < f; ++_e298) {
        var _s144 = m[_t316 + _e298];
        _n181 = _n181 && _s144;
      }

      g[_e297] = _n181;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e299 = Bm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Xr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e299;
    }

    return b;
  }
},
    Km = {
  kernelName: "Any",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims;
    zf(r, "any");
    var o = y(a, r.shape);
    var l = o;
    var u = Jr(l, r.shape.length);
    var c = r;
    null != u && (c = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = Qr(l.length, r.shape.length)), Yr("any", l, c.shape.length);

    var _Kr5 = Kr(c.shape, l),
        _Kr6 = _slicedToArray(_Kr5, 2),
        h = _Kr6[0],
        p = _Kr6[1],
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e300 = 0; _e300 < g.length; ++_e300) {
      var _t317 = _e300 * f;

      var _n182 = m[_t317];

      for (var _e301 = 0; _e301 < f; ++_e301) {
        var _s145 = m[_t317 + _e301];
        _n182 = _n182 || _s145;
      }

      g[_e300] = _n182;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e302 = Bm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Xr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e302;
    }

    return b;
  }
},
    Xm = {
  kernelName: "ArgMax",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis;
    zf(r, "argMax");
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), i = [i[0]], Yr("argMax", i, l.shape.length);

    var _Kr7 = Kr(l.shape, i),
        _Kr8 = _slicedToArray(_Kr7, 2),
        c = _Kr8[0],
        h = _Kr8[1],
        p = O(d(c), "int32"),
        f = d(h),
        g = n.data.get(l.dataId).values;

    for (var _e303 = 0; _e303 < p.length; ++_e303) {
      var _t318 = _e303 * f;

      var _n183 = g[_t318],
          _s146 = 0;

      for (var _e304 = 0; _e304 < f; ++_e304) {
        var _r101 = g[_t318 + _e304];
        _r101 > _n183 && (_n183 = _r101, _s146 = _e304);
      }

      p[_e303] = _s146;
    }

    return u.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), n.makeTensorInfo(c, "int32", p);
  }
},
    Ym = {
  kernelName: "ArgMin",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis;
    zf(r, "argMin");
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), i = [i[0]], Yr("argMin", i, l.shape.length);

    var _Kr9 = Kr(l.shape, i),
        _Kr10 = _slicedToArray(_Kr9, 2),
        c = _Kr10[0],
        h = _Kr10[1],
        p = O(d(c), "int32"),
        f = d(h),
        g = n.data.get(l.dataId).values;

    for (var _e305 = 0; _e305 < p.length; ++_e305) {
      var _t319 = _e305 * f;

      var _n184 = g[_t319],
          _s147 = 0;

      for (var _e306 = 0; _e306 < f; ++_e306) {
        var _r102 = g[_t319 + _e306];
        _r102 < _n184 && (_n184 = _r102, _s147 = _e306);
      }

      p[_e305] = _s147;
    }

    return u.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), n.makeTensorInfo(c, "int32", p);
  }
},
    Jm = {
  kernelName: "Asin",
  backendName: "cpu",
  kernelFunc: og("Asin", function (e) {
    return Math.asin(e);
  })
},
    Zm = {
  kernelName: "Asinh",
  backendName: "cpu",
  kernelFunc: og("Asinh", function (e) {
    return Math.asinh(e);
  })
},
    Qm = {
  kernelName: "Atan",
  backendName: "cpu",
  kernelFunc: og("Atan", function (e) {
    return Math.atan(e);
  })
},
    eb = {
  kernelName: "Atan2",
  backendName: "cpu",
  kernelFunc: Qf("Atan2", Vf(function (e, t) {
    return Math.atan2(e, t);
  }))
},
    tb = {
  kernelName: "Atanh",
  backendName: "cpu",
  kernelFunc: og("Atanh", function (e) {
    return Math.atanh(e);
  })
};

function nb(e, t, n, s, r, a) {
  var i = r.strideHeight,
      o = r.strideWidth,
      l = r.dilationHeight,
      u = r.dilationWidth,
      c = r.effectiveFilterHeight,
      h = r.effectiveFilterWidth,
      d = r.padInfo.top,
      p = r.padInfo.left,
      f = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      g = dn(r.outShape, n),
      m = g.values,
      b = r.outShape[1] * r.outShape[2] * r.outShape[3],
      x = r.outShape[2] * r.outShape[3],
      y = r.outShape[3];

  for (var _t320 = 0; _t320 < r.batchSize; ++_t320) {
    var _n185 = _t320 * b,
        _g10 = _t320 * s[0];

    for (var _t321 = 0; _t321 < r.inChannels; ++_t321) {
      for (var _b7 = 0; _b7 < r.outHeight; ++_b7) {
        var _k4 = _b7 * i - d,
            _w3 = Math.max(0, _k4),
            _v3 = Math.min(r.inHeight, c + _k4),
            _I2 = _n185 + _b7 * x;

        for (var _n186 = 0; _n186 < r.outWidth; ++_n186) {
          var _i54 = _n186 * o - p,
              _c10 = Math.max(0, _i54),
              _d10 = Math.min(r.inWidth, h + _i54);

          var _b8 = f,
              _x137 = 0,
              _k5 = 0;

          for (var _n187 = _w3; _n187 < _v3; _n187 += l) {
            var _r103 = _g10 + _n187 * s[1];

            for (var _n188 = _c10; _n188 < _d10; _n188 += u) {
              var _i55 = e[_r103 + _n188 * s[2] + _t321];
              "max" === a && _i55 > _b8 ? _b8 = _i55 : "avg" === a && (_x137 += _i55, _k5++);
            }

            if (isNaN(_b8)) break;
          }

          m[_I2 + _n186 * y + _t321] = "avg" === a ? _x137 / _k5 : _b8;
        }
      }
    }
  }

  return g;
}

function sb(e, t, n, s) {
  var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
  var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  var i = dn(s.outShape, "int32"),
      o = s.strideHeight,
      l = s.strideWidth,
      u = s.dilationHeight,
      c = s.dilationWidth,
      h = s.effectiveFilterHeight,
      d = s.effectiveFilterWidth,
      p = s.padInfo.top,
      f = s.padInfo.left,
      g = dn(t, n, e);

  for (var _e307 = 0; _e307 < s.batchSize; ++_e307) {
    for (var _t322 = 0; _t322 < s.inChannels; ++_t322) {
      for (var _n189 = 0; _n189 < s.outHeight; ++_n189) {
        var _m8 = _n189 * o - p;

        var _b9 = _m8;

        for (; _b9 < 0;) {
          _b9 += u;
        }

        var x = Math.min(s.inHeight, h + _m8);

        for (var _o29 = 0; _o29 < s.outWidth; ++_o29) {
          var _h7 = _o29 * l - f;

          var _p9 = _h7;

          for (; _p9 < 0;) {
            _p9 += c;
          }

          var _y7 = Math.min(s.inWidth, d + _h7);

          var _k6 = Number.NEGATIVE_INFINITY,
              _w4 = -1;

          for (var _n190 = _b9; _n190 < x; _n190 += u) {
            var _i56 = _n190 - _m8;

            for (var _o30 = _p9; _o30 < _y7; _o30 += c) {
              var _l23 = _o30 - _h7,
                  _u12 = g.get(_e307, _n190, _o30, _t322);

              _u12 > _k6 && (_k6 = _u12, _w4 = r ? a ? ((_e307 * s.inHeight + _n190) * s.inWidth + _o30) * s.inChannels + _t322 : (_n190 * s.inWidth + _o30) * s.inChannels + _t322 : _i56 * d + _l23);
            }
          }

          i.set(_w4, _e307, _n189, _o29, _t322);
        }
      }
    }
  }

  return i;
}

function rb(e, t, n, s, r, a) {
  var i = r.strideDepth,
      o = r.strideHeight,
      l = r.strideWidth,
      u = r.dilationDepth,
      c = r.dilationHeight,
      h = r.dilationWidth,
      d = r.effectiveFilterDepth,
      p = r.effectiveFilterHeight,
      f = r.effectiveFilterWidth,
      g = r.padInfo.front,
      m = r.padInfo.top,
      b = r.padInfo.left,
      x = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      y = dn(r.outShape, n),
      k = y.values,
      w = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4],
      v = r.outShape[2] * r.outShape[3] * r.outShape[4],
      I = r.outShape[3] * r.outShape[4],
      $ = r.outShape[4];

  for (var _t323 = 0; _t323 < r.batchSize; ++_t323) {
    var _n191 = _t323 * w,
        _y8 = _t323 * s[0];

    for (var _t324 = 0; _t324 < r.inChannels; ++_t324) {
      for (var _w5 = 0; _w5 < r.outDepth; ++_w5) {
        var _N2 = _w5 * i - g;

        var _C2 = _N2;

        for (; _C2 < 0;) {
          _C2 += u;
        }

        var _S = Math.min(r.inDepth, d + _N2),
            _T = _n191 + _w5 * v;

        for (var _n192 = 0; _n192 < r.outHeight; ++_n192) {
          var _i57 = _n192 * o - m;

          var _d11 = _i57;

          for (; _d11 < 0;) {
            _d11 += c;
          }

          var _g11 = Math.min(r.inHeight, p + _i57),
              _w6 = _T + _n192 * I;

          for (var _n193 = 0; _n193 < r.outWidth; ++_n193) {
            var _i58 = _n193 * l - b;

            var _o31 = _i58;

            for (; _o31 < 0;) {
              _o31 += h;
            }

            var _p10 = Math.min(r.inWidth, f + _i58),
                _m9 = _w6 + _n193 * $;

            var _v4 = x,
                _I3 = 0,
                _N3 = 0;

            for (var _n194 = _C2; _n194 < _S; _n194 += u) {
              var _r104 = _y8 + _n194 * s[1];

              for (var _n195 = _d11; _n195 < _g11; _n195 += c) {
                var _i59 = _r104 + _n195 * s[2];

                for (var _n196 = _o31; _n196 < _p10; _n196 += h) {
                  var _r105 = e[_i59 + _n196 * s[3] + _t324];
                  if ("max" === a && _r105 > _v4 ? _v4 = _r105 : "avg" === a && (_I3 += _r105, _N3++), isNaN(_v4)) break;
                }

                if (isNaN(_v4)) break;
              }

              if (isNaN(_v4)) break;
            }

            k[_m9 + _t324] = "avg" === a ? _I3 / _N3 : _v4;
          }
        }
      }
    }
  }

  return y;
}

var ab = {
  kernelName: "AvgPool",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x;
    zf(r, "avgPool");
    var a = s.filterSize,
        i = s.strides,
        o = s.pad,
        u = s.dimRoundingMode;
    l(Ss(i, 1), function () {
      return "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'");
    });
    var c = bs(r.shape, a, i, 1, o, u);
    var h;
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) h = qf({
      inputs: {
        x: r
      },
      backend: n
    });else {
      var _e308 = n.data.get(r.dataId).values,
          _t325 = A(r.shape),
          _s148 = nb(_e308, 0, r.dtype, _t325, c, "avg");

      h = n.makeTensorInfo(c.outShape, r.dtype, _s148.values);
    }
    return h;
  }
},
    ib = {
  kernelName: "AvgPool3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.filterSize,
        i = s.strides,
        o = s.pad,
        l = s.dimRoundingMode,
        u = s.dataFormat;
    zf(r, "avgPool3d");
    var c = xs(r.shape, a, i, 1, o, l, u),
        h = rb(n.data.get(r.dataId).values, 0, r.dtype, A(r.shape), c, "avg");
    return n.makeTensorInfo(h.shape, "float32", h.values);
  }
},
    ob = {
  kernelName: "AvgPool3DGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = s.filterSize,
        o = s.strides,
        l = s.pad,
        u = s.dimRoundingMode;
    zf([r, a], "avgPool3DGrad");
    var c = xs(a.shape, i, o, 1, l, u),
        h = c.strideDepth,
        d = c.strideHeight,
        p = c.strideWidth,
        f = c.filterDepth,
        g = c.filterHeight,
        m = c.filterWidth,
        b = c.dilationDepth,
        x = c.dilationHeight,
        y = c.dilationWidth,
        k = c.effectiveFilterDepth,
        w = c.effectiveFilterHeight,
        v = c.effectiveFilterWidth,
        I = k - 1 - c.padInfo.front,
        $ = v - 1 - c.padInfo.left,
        N = w - 1 - c.padInfo.top,
        C = dn(a.shape, "float32"),
        S = 1 / (f * g * m),
        T = n.bufferSync(r);

    for (var _e309 = 0; _e309 < c.batchSize; ++_e309) {
      for (var _t326 = 0; _t326 < c.inChannels; ++_t326) {
        for (var _n197 = 0; _n197 < c.inDepth; ++_n197) {
          for (var _s149 = 0; _s149 < c.inHeight; ++_s149) {
            for (var _r106 = 0; _r106 < c.inWidth; ++_r106) {
              var _a69 = _n197 - I,
                  _i60 = _s149 - N,
                  _o32 = _r106 - $;

              var _l24 = 0;

              for (var _n198 = 0; _n198 < k; _n198 += b) {
                var _s150 = (_a69 + _n198) / h;

                if (!(_s150 < 0 || _s150 >= c.outDepth || Math.floor(_s150) !== _s150)) for (var _n199 = 0; _n199 < w; _n199 += x) {
                  var _r107 = (_i60 + _n199) / d;

                  if (!(_r107 < 0 || _r107 >= c.outHeight || Math.floor(_r107) !== _r107)) for (var _n200 = 0; _n200 < v; _n200 += y) {
                    var _a70 = (_o32 + _n200) / p;

                    _a70 < 0 || _a70 >= c.outWidth || Math.floor(_a70) !== _a70 || (_l24 += T.get(_e309, _s150, _r107, _a70, _t326));
                  }
                }
              }

              C.set(_l24 * S, _e309, _n197, _s149, _r106, _t326);
            }
          }
        }
      }
    }

    return n.makeTensorInfo(C.shape, C.dtype, C.values);
  }
},
    lb = {
  kernelName: "AvgPoolGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = a;
    zf([r, a], "avgPoolGrad");
    var o = s.filterSize,
        l = s.strides,
        u = s.pad,
        c = bs(i.shape, o, l, 1, u),
        h = c.strideHeight,
        d = c.strideWidth,
        p = c.filterHeight,
        f = c.filterWidth,
        g = c.dilationHeight,
        m = c.dilationWidth,
        b = c.effectiveFilterHeight,
        x = c.effectiveFilterWidth,
        y = x - 1 - c.padInfo.left,
        k = b - 1 - c.padInfo.top,
        w = dn(i.shape, "float32"),
        v = 1 / (p * f),
        I = n.data.get(r.dataId).values,
        $ = dn(r.shape, "float32", I);

    for (var _e310 = 0; _e310 < c.batchSize; ++_e310) {
      for (var _t327 = 0; _t327 < c.inChannels; ++_t327) {
        for (var _n201 = 0; _n201 < c.inHeight; ++_n201) {
          for (var _s151 = 0; _s151 < c.inWidth; ++_s151) {
            var _r108 = _n201 - k,
                _a71 = _s151 - y;

            var _i61 = 0;

            for (var _n202 = 0; _n202 < b; _n202 += g) {
              var _s152 = (_r108 + _n202) / h;

              if (!(_s152 < 0 || _s152 >= c.outHeight || Math.floor(_s152) !== _s152)) for (var _n203 = 0; _n203 < x; _n203 += m) {
                var _r109 = (_a71 + _n203) / d;

                _r109 < 0 || _r109 >= c.outWidth || Math.floor(_r109) !== _r109 || (_i61 += $.get(_e310, _s152, _r109, _t327));
              }
            }

            w.set(_i61 * v, _e310, _n201, _s151, _t327);
          }
        }
      }
    }

    return n.makeTensorInfo(w.shape, w.dtype, w.values);
  }
},
    ub = {
  kernelName: "FusedBatchNorm",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.scale,
        i = t.offset,
        o = t.mean,
        u = t.variance;
    l(o.shape.length === u.shape.length, function () {
      return "Batch normalization gradient requires mean and variance to have equal ranks.";
    }), l(null == i || o.shape.length === i.shape.length, function () {
      return "Batch normalization gradient requires mean and offset to have equal ranks.";
    }), l(null == a || o.shape.length === a.shape.length, function () {
      return "Batch normalization gradient requires mean and scale to have equal ranks.";
    }), zf([r, o, u, a, i], "batchNorm");
    var c = s.varianceEpsilon;
    null == c && (c = .001);
    var h = n.data.get(r.dataId).values,
        d = n.data.get(o.dataId).values,
        p = n.data.get(u.dataId).values,
        f = a ? n.data.get(a.dataId).values : new Float32Array([1]),
        g = i ? n.data.get(i.dataId).values : new Float32Array([0]),
        m = new Float32Array(h.length),
        b = g.length,
        x = f.length,
        y = p.length,
        k = d.length;
    var w = 0,
        v = 0,
        I = 0,
        $ = 0;

    for (var _e311 = 0; _e311 < h.length; ++_e311) {
      m[_e311] = g[w++] + (h[_e311] - d[v++]) * f[I++] / Math.sqrt(p[$++] + c), w >= b && (w = 0), v >= k && (v = 0), I >= x && (I = 0), $ >= y && ($ = 0);
    }

    return n.makeTensorInfo(r.shape, r.dtype, m);
  }
},
    cb = {
  kernelName: "BatchToSpaceND",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.blockShape,
        i = s.crops;
    zf([r], "batchToSpaceND");

    var o = a.reduce(function (e, t) {
      return e * t;
    }),
        l = Ro(r.shape, a, o),
        u = Ao(l.length, a.length),
        c = Fo(r.shape, a, o),
        h = Do(i, a.length),
        d = _o(c, i, a.length),
        p = Bm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: l
      }
    }),
        f = Xg({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        perm: u
      }
    }),
        g = Bm({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        shape: c
      }
    }),
        m = sm({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        begin: h,
        size: d
      }
    });

    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
  }
},
    hb = {
  kernelName: "Bincount",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.weights,
        i = s.size,
        o = rg(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);
    return n.makeTensorInfo([i], a.dtype, o);
  }
},
    db = {
  kernelName: "ClipByValue",
  backendName: "cpu",
  kernelFunc: og("ClipByValue", function (e, t) {
    return e > t.clipValueMax ? t.clipValueMax : e < t.clipValueMin ? t.clipValueMin : e;
  })
},
    pb = {
  kernelName: "ComplexAbs",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs.x,
        n = e.backend,
        s = new Float32Array(d(t.shape)),
        r = n.data.get(t.dataId),
        a = r.complexTensorInfos.imag,
        i = n.data.get(r.complexTensorInfos.real.dataId).values,
        o = n.data.get(a.dataId).values;

    for (var _e312 = 0; _e312 < i.length; _e312++) {
      s[_e312] = Math.hypot(i[_e312], o[_e312]);
    }

    return n.makeOutput(s, t.shape, "float32");
  }
};

function fb(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.input,
      r = n.data.get(s.dataId).complexTensorInfos.imag,
      a = n.data.get(r.dataId).values;
  return n.makeTensorInfo(r.shape, r.dtype, a);
}

var gb = {
  kernelName: "Imag",
  backendName: "cpu",
  kernelFunc: fb
};

function mb(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = s.axis,
      a = y(r, t[0].shape)[0];
  var i = So(t.map(function (e) {
    return e.shape;
  }), a);
  if (0 === d(i)) return n.makeTensorInfo(i, t[0].dtype, []);
  var o = t.filter(function (e) {
    return d(e.shape) > 0;
  });
  if (1 === o.length) return qf({
    inputs: {
      x: o[0]
    },
    backend: n
  });

  if (Co(o.map(function (e) {
    return e.shape;
  }), a), "complex64" === o[0].dtype) {
    var _e313 = o.map(function (e) {
      return Xf({
        inputs: {
          input: e
        },
        backend: n
      });
    }),
        _t328 = o.map(function (e) {
      return fb({
        inputs: {
          input: e
        },
        backend: n
      });
    }),
        _s153 = mb({
      inputs: _e313,
      backend: n,
      attrs: {
        axis: a
      }
    }),
        _r110 = mb({
      inputs: _t328,
      backend: n,
      attrs: {
        axis: a
      }
    }),
        _i62 = Gf({
      inputs: {
        real: _s153,
        imag: _r110
      },
      backend: n
    });

    return _e313.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), _t328.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), n.disposeIntermediateTensorInfo(_s153), n.disposeIntermediateTensorInfo(_r110), _i62;
  }

  var l = o.map(function (e) {
    var t = d(e.shape.slice(a));
    return Bm({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        shape: [-1, t]
      }
    });
  }),
      u = l.map(function (e) {
    return {
      vals: n.data.get(e.dataId).values,
      shape: e.shape
    };
  });
  i = So(l.map(function (e) {
    return e.shape;
  }), 1);
  var c = hg(u, i, t[0].dtype, 1 === l[0].shape[0]),
      h = So(o.map(function (e) {
    return e.shape;
  }), a),
      p = n.makeTensorInfo(h, t[0].dtype, c);
  return l.forEach(function (e) {
    return n.disposeIntermediateTensorInfo(e);
  }), p;
}

var bb = {
  kernelName: "Concat",
  backendName: "cpu",
  kernelFunc: mb
};

function xb(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = t.filter,
      i = s.strides,
      o = s.pad,
      l = s.dataFormat,
      u = s.dilations,
      c = s.dimRoundingMode;
  zf([r, a], "conv2d");
  var h = Ts(l),
      d = ys(r.shape, a.shape, i, u, o, c, !1, h),
      p = d.filterHeight,
      f = d.filterWidth,
      g = d.dilationHeight,
      m = d.dilationWidth,
      b = d.padInfo.left,
      x = d.padInfo.top,
      y = "channelsLast" === d.dataFormat,
      k = new et(d.outShape, r.dtype),
      w = A(r.shape),
      v = A(a.shape),
      I = w[0],
      $ = y ? w[1] : w[2],
      N = y ? w[2] : 1,
      C = y ? 1 : w[1],
      S = k.strides[0],
      T = y ? k.strides[1] : k.strides[2],
      E = y ? k.strides[2] : 1,
      R = y ? 1 : k.strides[1],
      F = n.data.get(r.dataId).values,
      D = n.data.get(a.dataId).values,
      _ = k.values;

  for (var _e314 = 0; _e314 < d.batchSize; ++_e314) {
    var _t329 = _e314 * I,
        _n204 = _e314 * S;

    for (var _e315 = 0; _e315 < d.outHeight; ++_e315) {
      var _s154 = _n204 + _e315 * T,
          _r111 = _e315 * d.strideHeight - x;

      for (var _e316 = 0; _e316 < p; ++_e316) {
        var _n205 = _r111 + _e316 * g;

        if (_n205 < 0 || _n205 >= d.inHeight) continue;

        var _a72 = _e316 * v[0],
            _i63 = _t329 + _n205 * $;

        for (var _e317 = 0; _e317 < d.outWidth; ++_e317) {
          var _t330 = _s154 + _e317 * E,
              _n206 = _e317 * d.strideWidth - b;

          for (var _e318 = 0; _e318 < f; ++_e318) {
            var _s155 = _n206 + _e318 * m;

            if (_s155 < 0 || _s155 >= d.inWidth) continue;

            var _r112 = _i63 + _s155 * N;

            var _o33 = _a72 + _e318 * v[1];

            for (var _e319 = 0; _e319 < d.inChannels; ++_e319) {
              var _n207 = F[_r112 + _e319 * C];

              for (var _e320 = 0; _e320 < d.outChannels; ++_e320) {
                _[_t330 + _e320 * R] += _n207 * D[_o33 + _e320];
              }

              _o33 += d.outChannels;
            }
          }
        }
      }
    }
  }

  return n.makeTensorInfo(k.shape, k.dtype, _);
}

var yb = {
  kernelName: "Conv2D",
  backendName: "cpu",
  kernelFunc: xb
},
    kb = {
  kernelName: "Conv2DBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.dy,
        i = s.strides,
        o = s.pad,
        l = s.dataFormat,
        u = s.dimRoundingMode,
        c = s.filterShape;
    zf([r, a], "conv2dBackpropFilter");
    var h = Ts(l),
        d = ys(r.shape, c, i, 1, o, u, !1, h),
        p = d.strideHeight,
        f = d.strideWidth,
        g = d.filterHeight,
        m = d.filterWidth,
        b = "channelsLast" === d.dataFormat,
        x = new et(d.filterShape, "float32"),
        y = d.padInfo.left,
        k = d.padInfo.top,
        w = n.data.get(r.dataId).values,
        v = n.data.get(a.dataId).values,
        I = new et(r.shape, r.dtype, w),
        $ = new et(a.shape, a.dtype, v);

    for (var _e321 = 0; _e321 < g; ++_e321) {
      var _t331 = Math.max(0, Math.ceil((k - _e321) / p)),
          _n208 = Math.min(d.outHeight, (d.inHeight + k - _e321) / p);

      for (var _s156 = 0; _s156 < m; ++_s156) {
        var _r113 = Math.max(0, Math.ceil((y - _s156) / f)),
            _a73 = Math.min(d.outWidth, (d.inWidth + y - _s156) / f);

        for (var _i64 = 0; _i64 < d.inChannels; ++_i64) {
          for (var _o34 = 0; _o34 < d.outChannels; ++_o34) {
            var _l25 = 0;

            for (var _u13 = 0; _u13 < d.batchSize; ++_u13) {
              for (var _c11 = _t331; _c11 < _n208; ++_c11) {
                var _t332 = _e321 + _c11 * p - k;

                for (var _e322 = _r113; _e322 < _a73; ++_e322) {
                  var _n209 = _s156 + _e322 * f - y;

                  _l25 += b ? I.get(_u13, _t332, _n209, _i64) * $.get(_u13, _c11, _e322, _o34) : I.get(_u13, _i64, _t332, _n209) * $.get(_u13, _o34, _c11, _e322);
                }
              }
            }

            x.set(_l25, _e321, _s156, _i64, _o34);
          }
        }
      }
    }

    return n.makeTensorInfo(x.shape, x.dtype, x.values);
  }
},
    wb = {
  kernelName: "Conv2DBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.filter,
        i = s.inputShape,
        o = s.strides,
        l = s.pad,
        u = s.dataFormat,
        c = s.dimRoundingMode;
    zf([r, a], "conv2dBackpropInput");
    var h = A(a.shape),
        d = A(r.shape);
    var p = Ts(u);

    var f = ys(i, a.shape, o, 1, l, c, !1, p),
        g = new et(f.inShape, "float32"),
        m = g.values,
        b = n.data.get(r.dataId).values,
        x = n.data.get(a.dataId).values,
        _h8 = _slicedToArray(h, 3),
        y = _h8[0],
        k = _h8[1],
        w = _h8[2],
        v = f.batchSize,
        I = f.filterHeight,
        $ = f.filterWidth,
        N = f.inChannels,
        C = f.inHeight,
        S = f.inWidth,
        T = f.outChannels,
        E = f.outHeight,
        R = f.outWidth,
        F = f.strideHeight,
        D = f.strideWidth;

    p = f.dataFormat;

    var _ = I - 1 - f.padInfo.top,
        O = $ - 1 - f.padInfo.left,
        M = "channelsLast" === p,
        L = g.strides[0],
        z = M ? g.strides[1] : g.strides[2],
        B = M ? g.strides[2] : 1,
        P = M ? 1 : g.strides[1],
        W = d[0],
        U = M ? d[1] : d[2],
        V = M ? d[2] : 1,
        G = M ? 1 : d[1];

    for (var _e323 = 0; _e323 < v; ++_e323) {
      for (var _t333 = 0; _t333 < N; ++_t333) {
        for (var _n210 = 0; _n210 < C; ++_n210) {
          var _s157 = _n210 - _,
              _r114 = Math.max(0, Math.ceil(_s157 / F)),
              _a74 = Math.min(E, (I + _s157) / F);

          for (var _i65 = 0; _i65 < S; ++_i65) {
            var _o35 = _i65 - O,
                _l26 = Math.max(0, Math.ceil(_o35 / D)),
                _u14 = Math.min(R, ($ + _o35) / D);

            var _c12 = 0;

            for (var _n211 = _r114; _n211 < _a74; ++_n211) {
              var _r115 = _n211 * F - _s157;

              for (var _s158 = _l26; _s158 < _u14; ++_s158) {
                var _a75 = W * _e323 + U * _n211 + V * _s158,
                    _i66 = y * (I - 1 - _r115) + k * ($ - 1 - (_s158 * D - _o35)) + w * _t333;

                for (var _e324 = 0; _e324 < T; ++_e324) {
                  _c12 += b[_a75 + G * _e324] * x[_i66 + _e324];
                }
              }
            }

            m[L * _e323 + z * _n210 + B * _i65 + P * _t333] = _c12;
          }
        }
      }
    }

    return n.makeTensorInfo(g.shape, g.dtype, g.values);
  }
},
    vb = {
  kernelName: "Conv3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = s.strides,
        o = s.pad,
        l = s.dilations;
    zf([r, a], "conv3d");
    var u = ks(r.shape, a.shape, i, l, o),
        c = u.filterDepth,
        h = u.filterHeight,
        d = u.filterWidth,
        p = u.dilationDepth,
        f = u.dilationHeight,
        g = u.dilationWidth,
        m = u.padInfo,
        b = m.front,
        x = m.left,
        y = m.top,
        k = new et(u.outShape, r.dtype),
        w = n.data.get(r.dataId).values,
        v = n.data.get(a.dataId).values,
        I = k.values,
        $ = A(r.shape),
        N = A(a.shape);

    for (var _e325 = 0; _e325 < u.batchSize; ++_e325) {
      var _t334 = _e325 * $[0],
          _n212 = _e325 * k.strides[0];

      for (var _e326 = 0; _e326 < u.outDepth; ++_e326) {
        var _s159 = _n212 + _e326 * k.strides[1],
            _r116 = _e326 * u.strideDepth - b;

        for (var _e327 = 0; _e327 < c; ++_e327) {
          var _n213 = _r116 + _e327 * p;

          if (_n213 < 0 || _n213 >= u.inDepth) continue;

          var _a76 = _e327 * N[0],
              _i67 = _t334 + _n213 * $[1];

          for (var _e328 = 0; _e328 < u.outHeight; ++_e328) {
            var _t335 = _s159 + _e328 * k.strides[2],
                _n214 = _e328 * u.strideHeight - y;

            for (var _e329 = 0; _e329 < h; ++_e329) {
              var _s160 = _n214 + _e329 * f;

              if (_s160 < 0 || _s160 >= u.inHeight) continue;

              var _r117 = _a76 + _e329 * N[1],
                  _o36 = _i67 + _s160 * $[2];

              for (var _e330 = 0; _e330 < u.outWidth; ++_e330) {
                var _n215 = _t335 + _e330 * u.outChannels,
                    _s161 = _e330 * u.strideWidth - x;

                for (var _e331 = 0; _e331 < d; ++_e331) {
                  var _t336 = _s161 + _e331 * g;

                  if (_t336 < 0 || _t336 >= u.inWidth) continue;

                  var _a77 = _o36 + _t336 * u.inChannels;

                  var _i68 = _r117 + _e331 * N[2];

                  for (var _e332 = 0; _e332 < u.inChannels; ++_e332) {
                    var _t337 = w[_a77 + _e332];

                    for (var _e333 = 0; _e333 < u.outChannels; ++_e333) {
                      I[_n215 + _e333] += _t337 * v[_i68 + _e333];
                    }

                    _i68 += u.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }

    return n.makeTensorInfo(k.shape, k.dtype, k.values);
  }
},
    Ib = {
  kernelName: "Conv3DBackpropFilterV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.dy,
        i = s.strides,
        o = s.pad,
        l = s.filterShape;
    zf([r, a], "conv3dBackpropFilterV2");

    var u = A(r.shape),
        c = A(a.shape),
        h = ks(r.shape, l, i, 1, o),
        d = h.strideDepth,
        p = h.strideHeight,
        f = h.strideWidth,
        g = h.filterDepth,
        m = h.filterHeight,
        b = h.filterWidth,
        x = new et(h.filterShape, "float32"),
        y = x.values,
        _x$strides = _slicedToArray(x.strides, 4),
        k = _x$strides[0],
        w = _x$strides[1],
        v = _x$strides[2],
        I = _x$strides[3],
        $ = n.data.get(a.dataId).values,
        _c13 = _slicedToArray(c, 4),
        N = _c13[0],
        C = _c13[1],
        S = _c13[2],
        T = _c13[3],
        E = n.data.get(r.dataId).values,
        _u15 = _slicedToArray(u, 4),
        R = _u15[0],
        F = _u15[1],
        D = _u15[2],
        _ = _u15[3],
        O = h.padInfo.front,
        M = h.padInfo.left,
        L = h.padInfo.top;

    for (var _e334 = 0; _e334 < g; ++_e334) {
      var _t338 = Math.max(0, Math.ceil((O - _e334) / d)),
          _n216 = Math.min(h.outDepth, (h.inDepth + O - _e334) / d),
          _s162 = _e334 * k;

      for (var _r118 = 0; _r118 < m; ++_r118) {
        var _a78 = Math.max(0, Math.ceil((L - _r118) / p)),
            _i69 = Math.min(h.outHeight, (h.inHeight + L - _r118) / p),
            _o37 = _r118 * w + _s162;

        for (var _s163 = 0; _s163 < b; ++_s163) {
          var _l27 = Math.max(0, Math.ceil((M - _s163) / f)),
              _u16 = Math.min(h.outWidth, (h.inWidth + M - _s163) / f),
              _c14 = _s163 * v + _o37;

          for (var _o38 = 0; _o38 < h.inChannels; ++_o38) {
            var _g12 = _o38 * I + _c14;

            for (var _c15 = 0; _c15 < h.outChannels; ++_c15) {
              var _m10 = 0;

              for (var _g13 = 0; _g13 < h.batchSize; ++_g13) {
                var _h9 = _g13 * R,
                    _b10 = _g13 * N;

                for (var _g14 = _t338; _g14 < _n216; ++_g14) {
                  var _t339 = (_e334 + _g14 * d - O) * F + _h9,
                      _n217 = _g14 * C + _b10;

                  for (var _e335 = _a78; _e335 < _i69; ++_e335) {
                    var _a79 = (_r118 + _e335 * p - L) * D + _t339,
                        _i70 = _e335 * S + _n217;

                    for (var _e336 = _l27; _e336 < _u16; ++_e336) {
                      _m10 += E[(_s163 + _e336 * f - M) * _ + _a79 + _o38] * $[_e336 * T + _i70 + _c15];
                    }
                  }
                }
              }

              y[_g12 + _c15] = _m10;
            }
          }
        }
      }
    }

    return n.makeTensorInfo(x.shape, x.dtype, x.values);
  }
},
    $b = {
  kernelName: "Conv3DBackpropInputV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.filter,
        i = s.pad,
        o = s.strides,
        l = s.inputShape;
    zf([r], "conv3dBackpropInputV2");

    var u = A(r.shape),
        c = A(a.shape),
        h = ks(l, a.shape, o, 1, i),
        d = new et(h.inShape, "float32"),
        p = d.values,
        _d$strides = _slicedToArray(d.strides, 4),
        f = _d$strides[0],
        g = _d$strides[1],
        m = _d$strides[2],
        b = _d$strides[3],
        x = n.data.get(r.dataId).values,
        _u17 = _slicedToArray(u, 4),
        y = _u17[0],
        k = _u17[1],
        w = _u17[2],
        v = _u17[3],
        I = n.data.get(a.dataId).values,
        _c16 = _slicedToArray(c, 4),
        $ = _c16[0],
        N = _c16[1],
        C = _c16[2],
        S = _c16[3],
        T = h.batchSize,
        E = h.filterDepth,
        R = h.filterHeight,
        F = h.filterWidth,
        D = h.inChannels,
        _ = h.inDepth,
        O = h.inHeight,
        M = h.inWidth,
        L = h.outChannels,
        z = h.outDepth,
        B = h.outHeight,
        P = h.outWidth,
        W = h.strideDepth,
        U = h.strideHeight,
        V = h.strideWidth,
        G = E - 1 - h.padInfo.front,
        H = R - 1 - h.padInfo.top,
        j = F - 1 - h.padInfo.left;

    for (var _e337 = 0; _e337 < T; ++_e337) {
      for (var _t340 = 0; _t340 < D; ++_t340) {
        for (var _n218 = 0; _n218 < _; ++_n218) {
          var _s164 = _n218 - G,
              _r119 = Math.max(0, Math.ceil(_s164 / W)),
              _a80 = Math.min(z, (E + _s164) / W);

          for (var _i71 = 0; _i71 < O; ++_i71) {
            var _o39 = _i71 - H,
                _l28 = Math.max(0, Math.ceil(_o39 / U)),
                _u18 = Math.min(B, (R + _o39) / U);

            for (var _c17 = 0; _c17 < M; ++_c17) {
              var _h10 = _c17 - j,
                  _d12 = Math.max(0, Math.ceil(_h10 / V)),
                  _T2 = Math.min(P, (F + _h10) / V);

              var _A = 0;

              for (var _n219 = _r119; _n219 < _a80; ++_n219) {
                var _r120 = _n219 * W - _s164;

                for (var _s165 = _l28; _s165 < _u18; ++_s165) {
                  var _a81 = _s165 * U - _o39;

                  for (var _i72 = _d12; _i72 < _T2; ++_i72) {
                    var _o40 = y * _e337 + k * _n219 + w * _s165 + v * _i72,
                        _l29 = $ * (E - 1 - _r120) + N * (R - 1 - _a81) + C * (F - 1 - (_i72 * V - _h10)) + S * _t340;

                    for (var _e338 = 0; _e338 < L; ++_e338) {
                      _A += x[_o40 + _e338] * I[_l29 + _e338];
                    }
                  }
                }
              }

              p[f * _e337 + g * _n218 + m * _i71 + b * _c17 + _t340] = _A;
            }
          }
        }
      }
    }

    return n.makeTensorInfo(d.shape, d.dtype, d.values);
  }
},
    Nb = {
  kernelName: "Cos",
  backendName: "cpu",
  kernelFunc: og("Cos", function (e) {
    return Math.cos(e);
  })
},
    Cb = {
  kernelName: "Cosh",
  backendName: "cpu",
  kernelFunc: og("Cosh", function (e) {
    return Math.cosh(e);
  })
},
    Sb = {
  kernelName: "CropAndResize",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.image,
        a = t.boxes,
        i = t.boxInd,
        o = s.cropSize,
        l = s.method,
        u = s.extrapolationValue,
        _r$shape = _slicedToArray(r.shape, 4),
        c = _r$shape[0],
        h = _r$shape[1],
        d = _r$shape[2],
        p = _r$shape[3],
        f = a.shape[0],
        _o41 = _slicedToArray(o, 2),
        g = _o41[0],
        m = _o41[1],
        b = dn([f, g, m, p], "float32"),
        x = n.data.get(a.dataId).values,
        y = n.data.get(i.dataId).values,
        k = n.data.get(r.dataId).values,
        w = A(r.shape),
        v = A(b.shape);

    for (var _e339 = 0; _e339 < f; _e339++) {
      var _t341 = 4 * _e339,
          _n220 = x[_t341],
          _s166 = x[_t341 + 1],
          _r121 = x[_t341 + 2],
          _a82 = x[_t341 + 3],
          _i73 = y[_e339];

      if (_i73 >= c) continue;

      var _o42 = g > 1 ? (_r121 - _n220) * (h - 1) / (g - 1) : 0,
          _f7 = m > 1 ? (_a82 - _s166) * (d - 1) / (m - 1) : 0;

      for (var _t342 = 0; _t342 < g; _t342++) {
        var _c18 = g > 1 ? _n220 * (h - 1) + _t342 * _o42 : .5 * (_n220 + _r121) * (h - 1);

        if (_c18 < 0 || _c18 > h - 1) for (var _n221 = 0; _n221 < m; _n221++) {
          for (var _s167 = 0; _s167 < p; _s167++) {
            b.values[_s167 + _n221 * v[2] + _t342 * v[1] + _e339 * v[0]] = u;
          }
        } else if ("bilinear" === l) {
          var _n222 = Math.floor(_c18),
              _r122 = Math.ceil(_c18),
              _o43 = _c18 - _n222;

          for (var _l30 = 0; _l30 < m; _l30++) {
            var _c19 = m > 1 ? _s166 * (d - 1) + _l30 * _f7 : .5 * (_s166 + _a82) * (d - 1);

            if (_c19 < 0 || _c19 > d - 1) {
              for (var _n223 = 0; _n223 < p; _n223++) {
                b.values[_n223 + _l30 * v[2] + _t342 * v[1] + _e339 * v[0]] = u;
              }

              continue;
            }

            var _h11 = Math.floor(_c19),
                _g15 = Math.ceil(_c19),
                _x138 = _c19 - _h11;

            for (var _s168 = 0; _s168 < p; _s168++) {
              var _a83 = _s168 + _h11 * w[2] + _n222 * w[1] + _i73 * w[0];

              var _u19 = k[_a83];
              _a83 = _s168 + _g15 * w[2] + _n222 * w[1] + _i73 * w[0];
              var _c20 = k[_a83];
              _a83 = _s168 + _h11 * w[2] + _r122 * w[1] + _i73 * w[0];
              var _d13 = k[_a83];
              _a83 = _s168 + _g15 * w[2] + _r122 * w[1] + _i73 * w[0];

              var _p11 = k[_a83],
                  _f8 = _u19 + (_c20 - _u19) * _x138;

              _a83 = _s168 + _l30 * v[2] + _t342 * v[1] + _e339 * v[0], b.values[_a83] = _f8 + (_d13 + (_p11 - _d13) * _x138 - _f8) * _o43;
            }
          }
        } else for (var _n224 = 0; _n224 < m; ++_n224) {
          var _r123 = m > 1 ? _s166 * (d - 1) + _n224 * _f7 : .5 * (_s166 + _a82) * (d - 1);

          if (_r123 < 0 || _r123 > d - 1) {
            for (var _s169 = 0; _s169 < p; _s169++) {
              b.values[_s169 + _n224 * v[2] + _t342 * v[1] + _e339 * v[0]] = u;
            }

            continue;
          }

          var _o44 = Math.round(_r123),
              _l31 = Math.round(_c18);

          for (var _s170 = 0; _s170 < p; _s170++) {
            b.values[_s170 + _n224 * v[2] + _t342 * v[1] + _e339 * v[0]] = k[_s170 + _o44 * w[2] + _l31 * w[1] + _i73 * w[0]];
          }
        }
      }
    }

    return n.makeTensorInfo(b.shape, b.dtype, b.values);
  }
},
    Tb = {
  kernelName: "Cumsum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.exclusive,
        o = s.reverse;
    zf(r, "cumsum");
    var l = Jr([a], r.shape.length);
    var u = r;
    null != l && (u = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: l
      }
    }));
    var c = Qr(1, r.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=".concat(u.shape.length - 1, " but got axis=").concat(c));
    var h = dt(u.dtype, "int32"),
        p = O(d(u.shape), h),
        f = n.data.get(u.dataId).values,
        g = u.shape[u.shape.length - 1],
        m = o ? function (e, t) {
      return e + g - t - 1;
    } : function (e, t) {
      return e + t;
    };

    for (var _e340 = 0; _e340 < f.length; _e340 += g) {
      for (var _t343 = 0; _t343 < g; _t343++) {
        var _n225 = m(_e340, _t343);

        if (0 === _t343) p[_n225] = i ? 0 : f[_n225];else {
          var _s171 = m(_e340, _t343 - 1);

          p[_n225] = i ? f[_s171] + p[_s171] : f[_n225] + p[_s171];
        }
      }
    }

    var b = n.makeTensorInfo(u.shape, h, p);

    if (null != l) {
      var _e341 = Xg({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          perm: Zr(l)
        }
      });

      return n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(u), _e341;
    }

    return b;
  }
},
    Eb = {
  kernelName: "DenseBincount",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.weights,
        i = s.size,
        o = s.binaryOutput;

    if (1 === r.shape.length) {
      var _e342 = rg(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);

      return n.makeTensorInfo([i], a.dtype, _e342);
    }

    if (2 === r.shape.length) {
      var _e343 = ag(n.bufferSync(r), n.bufferSync(a), i, o);

      return n.makeTensorInfo(_e343.shape, a.dtype, _e343.values);
    }

    throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length, "."));
  }
},
    Rb = {
  kernelName: "DepthToSpace",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.blockSize,
        i = s.dataFormat;
    l("NHWC" === i, function () {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i);
    }), l(a > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: ".concat(a);
    });
    var o = r.shape[0],
        u = r.shape[1],
        c = r.shape[2],
        h = r.shape[3],
        d = u * a,
        p = c * a,
        f = h / (a * a),
        g = n.data.get(r.dataId).values,
        m = new Float32Array(o * d * p * f);
    var b = 0;

    for (var _e344 = 0; _e344 < o; ++_e344) {
      for (var _t344 = 0; _t344 < d; ++_t344) {
        var _n226 = Math.floor(_t344 / a),
            _s172 = _t344 % a;

        for (var _t345 = 0; _t345 < p; ++_t345) {
          var _r124 = Math.floor(_t345 / a),
              _i74 = (_s172 * a + _t345 % a) * f;

          for (var _t346 = 0; _t346 < f; ++_t346) {
            m[b++] = g[_t346 + _i74 + h * (_r124 + c * (_n226 + u * _e344))];
          }
        }
      }
    }

    return n.makeTensorInfo([o, d, p, f], r.dtype, m);
  }
};

function Ab(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = t.filter,
      i = s.strides,
      o = s.pad,
      u = s.dilations,
      c = s.dimRoundingMode;
  zf([r, a], "depthwiseConv2DNative");
  var h = A(r.shape),
      d = A(a.shape);
  var p = u;
  null == p && (p = [1, 1]), l(Ss(i, p), function () {
    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '").concat(p, "'");
  });
  var f = ys(r.shape, a.shape, i, p, o, c, !0),
      g = f.filterHeight,
      m = f.filterWidth,
      b = f.dilationHeight,
      x = f.dilationWidth,
      y = f.padInfo,
      k = y.left,
      w = y.top,
      v = f.outChannels / f.inChannels,
      I = new et(f.outShape, r.dtype),
      $ = n.data.get(r.dataId).values,
      N = n.data.get(a.dataId).values,
      C = I.values;

  for (var _e345 = 0; _e345 < f.batchSize; ++_e345) {
    var _t347 = _e345 * h[0],
        _n227 = _e345 * I.strides[0];

    for (var _e346 = 0; _e346 < f.outHeight; ++_e346) {
      var _s173 = _n227 + _e346 * I.strides[1],
          _r125 = _e346 * f.strideHeight - w;

      for (var _e347 = 0; _e347 < g; ++_e347) {
        var _n228 = _r125 + _e347 * b;

        if (_n228 < 0 || _n228 >= f.inHeight) continue;

        var _a84 = _e347 * d[0],
            _i75 = _t347 + _n228 * h[1];

        for (var _e348 = 0; _e348 < f.outWidth; ++_e348) {
          var _t348 = _s173 + _e348 * I.strides[2],
              _n229 = _e348 * f.strideWidth - k;

          for (var _e349 = 0; _e349 < m; ++_e349) {
            var _s174 = _n229 + _e349 * x;

            if (_s174 < 0 || _s174 >= f.inWidth) continue;

            var _r126 = _i75 + _s174 * f.inChannels;

            var _o45 = _t348,
                _l32 = _a84 + _e349 * d[1];

            for (var _e350 = 0; _e350 < f.inChannels; ++_e350) {
              var _t349 = $[_r126 + _e350];

              for (var _e351 = 0; _e351 < v; ++_e351) {
                C[_o45 + _e351] += _t349 * N[_l32 + _e351];
              }

              _o45 += v, _l32 += v;
            }
          }
        }
      }
    }
  }

  return n.makeTensorInfo(I.shape, I.dtype, I.values);
}

var Fb = {
  kernelName: "DepthwiseConv2dNative",
  backendName: "cpu",
  kernelFunc: Ab
},
    Db = {
  kernelName: "DepthwiseConv2dNativeBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.dy,
        i = s.strides,
        o = s.dilations,
        l = s.pad,
        u = s.dimRoundingMode,
        c = s.filterShape;
    zf([r, a], "depthwiseConv2dNativeBackpropFilter");
    var h = ys(r.shape, c, i, o, l, u, !0),
        d = h.strideHeight,
        p = h.strideWidth,
        f = h.filterHeight,
        g = h.filterWidth,
        m = new et(h.filterShape, "float32"),
        b = h.padInfo.left,
        x = h.padInfo.top,
        y = h.outChannels / h.inChannels,
        k = n.data.get(r.dataId).values,
        w = new et(r.shape, r.dtype, k),
        v = n.data.get(a.dataId).values,
        I = new et(a.shape, a.dtype, v);

    for (var _e352 = 0; _e352 < f; ++_e352) {
      var _t350 = Math.max(0, Math.ceil((x - _e352) / d)),
          _n230 = Math.min(h.outHeight, (h.inHeight + x - _e352) / d);

      for (var _s175 = 0; _s175 < g; ++_s175) {
        var _r127 = Math.max(0, Math.ceil((b - _s175) / p)),
            _a85 = Math.min(h.outWidth, (h.inWidth + b - _s175) / p);

        for (var _i76 = 0; _i76 < h.outChannels; ++_i76) {
          var _o46 = Math.trunc(_i76 / y),
              _l33 = _i76 % y;

          var _u20 = 0;

          for (var _l34 = 0; _l34 < h.batchSize; ++_l34) {
            for (var _c21 = _t350; _c21 < _n230; ++_c21) {
              var _t351 = _e352 + _c21 * d - x;

              for (var _e353 = _r127; _e353 < _a85; ++_e353) {
                _u20 += w.get(_l34, _t351, _s175 + _e353 * p - b, _o46) * I.get(_l34, _c21, _e353, _i76);
              }
            }
          }

          m.set(_u20, _e352, _s175, _o46, _l33);
        }
      }
    }

    return n.makeTensorInfo(m.shape, m.dtype, m.values);
  }
},
    _b = {
  kernelName: "DepthwiseConv2dNativeBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.filter,
        i = s.strides,
        o = s.dilations,
        l = s.pad,
        u = s.dimRoundingMode,
        c = s.inputShape;
    zf([r, a], "depthwiseConv2DNativeBackpropInput");

    var h = A(r.shape),
        d = A(a.shape),
        p = ys(c, a.shape, i, o, l, u, !0),
        f = new et(p.inShape, "float32"),
        g = f.values,
        _f$strides = _slicedToArray(f.strides, 3),
        m = _f$strides[0],
        b = _f$strides[1],
        x = _f$strides[2],
        y = n.data.get(r.dataId).values,
        _h12 = _slicedToArray(h, 3),
        k = _h12[0],
        w = _h12[1],
        v = _h12[2],
        I = n.data.get(a.dataId).values,
        _d14 = _slicedToArray(d, 3),
        $ = _d14[0],
        N = _d14[1],
        C = _d14[2],
        S = p.batchSize,
        T = p.filterHeight,
        E = p.filterWidth,
        R = p.inChannels,
        F = p.inHeight,
        D = p.inWidth,
        _ = p.outChannels,
        O = p.outHeight,
        M = p.outWidth,
        L = p.strideHeight,
        z = p.strideWidth,
        B = T - 1 - p.padInfo.top,
        P = E - 1 - p.padInfo.left,
        W = _ / R;

    for (var _e354 = 0; _e354 < S; ++_e354) {
      for (var _t352 = 0; _t352 < R; ++_t352) {
        for (var _n231 = 0; _n231 < F; ++_n231) {
          var _s176 = _n231 - B,
              _r128 = Math.max(0, Math.ceil(_s176 / L)),
              _a86 = Math.min(O, (T + _s176) / L);

          for (var _i77 = 0; _i77 < D; ++_i77) {
            var _o47 = _i77 - P,
                _l35 = Math.max(0, Math.ceil(_o47 / z)),
                _u21 = Math.min(M, (E + _o47) / z);

            var _c22 = 0;

            for (var _n232 = _r128; _n232 < _a86; ++_n232) {
              var _r129 = _n232 * L - _s176;

              for (var _s177 = _l35; _s177 < _u21; ++_s177) {
                var _a87 = k * _e354 + w * _n232 + v * _s177,
                    _i78 = $ * (T - 1 - _r129) + N * (E - 1 - (_s177 * z - _o47)) + C * _t352;

                for (var _e355 = 0; _e355 < W; ++_e355) {
                  _c22 += y[_a87 + (_t352 * W + _e355)] * I[_i78 + _e355];
                }
              }
            }

            g[m * _e354 + b * _n231 + x * _i77 + _t352] = _c22;
          }
        }
      }
    }

    return n.makeTensorInfo(f.shape, f.dtype, f.values);
  }
},
    Ob = {
  kernelName: "Diag",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x,
        r = d(s.shape),
        a = n.data.get(s.dataId).values,
        i = dn([r, r], s.dtype),
        o = i.values;

    for (var _e356 = 0; _e356 < a.length; _e356++) {
      o[_e356 * r + _e356] = a[_e356];
    }

    var l = [].concat(_toConsumableArray(s.shape), _toConsumableArray(s.shape));
    return n.makeTensorInfo(l, i.dtype, i.values);
  }
},
    Mb = {
  kernelName: "Dilation2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref29) {
    var e = _ref29.inputs,
        t = _ref29.backend,
        n = _ref29.attrs;

    var s = e.x,
        r = e.filter,
        a = n.strides,
        i = n.pad,
        o = n.dilations,
        l = t,
        u = l.data.get(s.dataId).values,
        c = s.shape.length,
        h = l.data.get(r.dataId).values,
        p = r.shape.length,
        _ms = ms(s.shape, r.shape, a, i, "NHWC", o),
        f = _ms.batchSize,
        g = _ms.inHeight,
        m = _ms.inWidth,
        b = _ms.inChannels,
        x = _ms.outHeight,
        y = _ms.outWidth,
        k = _ms.padInfo,
        w = _ms.strideHeight,
        I = _ms.strideWidth,
        $ = _ms.filterHeight,
        N = _ms.filterWidth,
        C = _ms.dilationHeight,
        S = _ms.dilationWidth,
        T = _ms.outShape,
        E = d(T),
        R = T.length,
        F = v(s.dtype, E);

    for (var _e357 = 0; _e357 < f; ++_e357) {
      for (var _t353 = 0; _t353 < x; ++_t353) {
        var _n233 = _t353 * w - k.top;

        for (var _a88 = 0; _a88 < y; ++_a88) {
          var _i79 = _a88 * I - k.left;

          for (var _o48 = 0; _o48 < b; ++_o48) {
            var _l36 = Number.MIN_SAFE_INTEGER;

            for (var _t354 = 0; _t354 < $; ++_t354) {
              var _a89 = _n233 + _t354 * C;

              if (_a89 >= 0 && _a89 < g) for (var _n234 = 0; _n234 < N; ++_n234) {
                var _d15 = _i79 + _n234 * S;

                if (_d15 >= 0 && _d15 < m) {
                  var _i80 = z([_e357, _a89, _d15, _o48], c, A(s.shape)),
                      _f9 = z([_t354, _n234, _o48], p, A(r.shape)),
                      _g16 = u[_i80] + h[_f9];

                  _g16 > _l36 && (_l36 = _g16);
                }
              }
            }

            F[z([_e357, _t353, _a88, _o48], R, A(T))] = _l36;
          }
        }
      }
    }

    return {
      dataId: l.write(Ue(F, s.dtype), T, s.dtype),
      shape: T,
      dtype: s.dtype
    };
  }
},
    Lb = {
  kernelName: "Dilation2DBackpropFilter",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref30) {
    var e = _ref30.inputs,
        t = _ref30.backend,
        n = _ref30.attrs;

    var s = e.x,
        r = e.filter,
        a = e.dy,
        i = n.strides,
        o = n.pad,
        u = n.dilations,
        c = t,
        h = D(s.shape, c.data.get(s.dataId).values),
        d = D(r.shape, c.data.get(r.dataId).values),
        _ms2 = ms(s.shape, r.shape, i, o, "NHWC", u),
        p = _ms2.batchSize,
        f = _ms2.inHeight,
        g = _ms2.inWidth,
        m = _ms2.inChannels,
        b = _ms2.outHeight,
        x = _ms2.outWidth,
        y = _ms2.padInfo,
        k = _ms2.strideHeight,
        w = _ms2.strideWidth,
        v = _ms2.filterHeight,
        I = _ms2.filterWidth,
        $ = _ms2.dilationHeight,
        N = _ms2.dilationWidth,
        C = _ms2.outShape;

    l(a.rank === C.length, function () {
      return "Error in Dilation2DBackpropFilter, dy must have the same rank as output ".concat(C.length, ", but got ").concat(a.rank);
    });
    var S = D(C, c.data.get(a.dataId).values),
        T = M(r.shape, r.dtype);

    for (var _e358 = 0; _e358 < p; ++_e358) {
      for (var _t355 = 0; _t355 < b; ++_t355) {
        var _n235 = _t355 * k - y.top;

        for (var _s178 = 0; _s178 < x; ++_s178) {
          var _r130 = _s178 * w - y.left;

          for (var _a90 = 0; _a90 < m; ++_a90) {
            var _i81 = Number.MIN_SAFE_INTEGER,
                _o49 = 0,
                _l37 = 0;

            for (var _t356 = 0; _t356 < v; ++_t356) {
              var _s179 = _n235 + _t356 * $;

              if (_s179 >= 0 && _s179 < f) for (var _n236 = 0; _n236 < I; ++_n236) {
                var _u22 = _r130 + _n236 * N;

                if (_u22 >= 0 && _u22 < g) {
                  var _r131 = h[_e358][_s179][_u22][_a90] + d[_t356][_n236][_a90];

                  _r131 > _i81 && (_i81 = _r131, _o49 = _t356, _l37 = _n236);
                }
              }
            }

            T[_o49][_l37][_a90] += S[_e358][_t355][_s178][_a90];
          }
        }
      }
    }

    return {
      dataId: c.write(Ue(T, s.dtype), r.shape, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
},
    zb = {
  kernelName: "Dilation2DBackpropInput",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref31) {
    var e = _ref31.inputs,
        t = _ref31.backend,
        n = _ref31.attrs;

    var s = e.x,
        r = e.filter,
        a = e.dy,
        i = n.strides,
        o = n.pad,
        u = n.dilations,
        c = t,
        h = D(s.shape, c.data.get(s.dataId).values),
        d = D(r.shape, c.data.get(r.dataId).values),
        _ms3 = ms(s.shape, r.shape, i, o, "NHWC", u),
        p = _ms3.batchSize,
        f = _ms3.inHeight,
        g = _ms3.inWidth,
        m = _ms3.inChannels,
        b = _ms3.outHeight,
        x = _ms3.outWidth,
        y = _ms3.padInfo,
        k = _ms3.strideHeight,
        w = _ms3.strideWidth,
        v = _ms3.filterHeight,
        I = _ms3.filterWidth,
        $ = _ms3.dilationHeight,
        N = _ms3.dilationWidth,
        C = _ms3.outShape;

    l(a.rank === C.length, function () {
      return "Error in Dilation2DBackpropInput, dy must have the same rank as output ".concat(C.length, ", but got ").concat(a.rank);
    });
    var S = D(C, c.data.get(a.dataId).values),
        T = M(s.shape, s.dtype);

    for (var _e359 = 0; _e359 < p; ++_e359) {
      for (var _t357 = 0; _t357 < b; ++_t357) {
        var _n237 = _t357 * k - y.top;

        for (var _s180 = 0; _s180 < x; ++_s180) {
          var _r132 = _s180 * w - y.left;

          for (var _a91 = 0; _a91 < m; ++_a91) {
            var _i82 = Number.MIN_SAFE_INTEGER,
                _o50 = _n237 < 0 ? 0 : _n237,
                _l38 = _r132 < 0 ? 0 : _r132;

            for (var _t358 = 0; _t358 < v; ++_t358) {
              var _s181 = _n237 + _t358 * $;

              if (_s181 >= 0 && _s181 < f) for (var _n238 = 0; _n238 < I; ++_n238) {
                var _u23 = _r132 + _n238 * N;

                if (_u23 >= 0 && _u23 < g) {
                  var _r133 = h[_e359][_s181][_u23][_a91] + d[_t358][_n238][_a91];

                  _r133 > _i82 && (_i82 = _r133, _o50 = _s181, _l38 = _u23);
                }
              }
            }

            T[_e359][_o50][_l38][_a91] += S[_e359][_t357][_s180][_a91];
          }
        }
      }
    }

    return {
      dataId: c.write(Ue(T, s.dtype), s.shape, s.dtype),
      shape: s.shape,
      dtype: s.dtype
    };
  }
};

function Bb(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.axis,
      i = s.keepDims;
  var o;
  zf(r, "sum"), o = "bool" === r.dtype ? Jf({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      dtype: "int32"
    }
  }) : qf({
    inputs: {
      x: r
    },
    backend: n
  });
  var l = o.shape.length,
      u = y(a, o.shape),
      c = Jr(u, l);
  var h = u,
      p = o;
  null != c && (p = Xg({
    inputs: {
      x: o
    },
    backend: n,
    attrs: {
      perm: c
    }
  }), h = Qr(h.length, l)), Yr("sum", h, p.shape.length);

  var _Kr11 = Kr(p.shape, h),
      _Kr12 = _slicedToArray(_Kr11, 2),
      f = _Kr12[0],
      g = _Kr12[1];

  var m = jf(n, f, dt(p.dtype, "int32"));
  var b = d(g),
      x = n.data.get(m.dataId).values,
      k = n.data.get(p.dataId).values;

  for (var _e360 = 0; _e360 < x.length; ++_e360) {
    var _t359 = _e360 * b;

    var _n239 = 0;

    for (var _e361 = 0; _e361 < b; ++_e361) {
      _n239 += k[_t359 + _e361];
    }

    x[_e360] = _n239;
  }

  if (i) {
    var _e362 = m;
    m = Bm({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(m.shape, u)
      }
    }), n.disposeIntermediateTensorInfo(_e362);
  }

  return n.disposeIntermediateTensorInfo(o), null != c && n.disposeIntermediateTensorInfo(p), m;
}

var Pb = {
  kernelName: "Sum",
  backendName: "cpu",
  kernelFunc: Bb
},
    Wb = {
  kernelName: "Einsum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.equation,
        a = t,
        _Ho = Ho(r, a.length),
        i = _Ho.allDims,
        o = _Ho.summedDims,
        l = _Ho.idDims;

    qo(i.length, l, a);

    var _Ko = Ko(o, l),
        u = _Ko.path,
        c = _Ko.steps,
        h = c.length;

    var d = null,
        f = i.length;
    var g = [];

    for (var _e363 = 0; _e363 < h; ++_e363) {
      var _iterator115 = _createForOfIteratorHelper(c[_e363]),
          _step115;

      try {
        for (_iterator115.s(); !(_step115 = _iterator115.n()).done;) {
          var _t360 = _step115.value;

          var _jo = jo(f, l[_t360]),
              _e364 = _jo.permutationIndices,
              _s182 = _jo.expandDims;

          var _r134 = void 0;

          Xo(_e364) ? _r134 = a[_t360] : (_r134 = Xg({
            inputs: {
              x: a[_t360]
            },
            backend: n,
            attrs: {
              perm: _e364
            }
          }), g.push(_r134));

          var _i83 = _r134.shape.slice();

          for (var _e365 = 0; _e365 < _s182.length; ++_e365) {
            _i83.splice(_s182[_e365], 0, 1);
          }

          p(_r134.shape, _i83) || (_r134 = Bm({
            inputs: {
              x: _r134
            },
            backend: n,
            attrs: {
              shape: _i83
            }
          }), g.push(_r134)), null === d ? d = _r134 : (d = Ug({
            inputs: {
              a: _r134,
              b: d
            },
            backend: n
          }), g.push(d));
        }
      } catch (err) {
        _iterator115.e(err);
      } finally {
        _iterator115.f();
      }

      _e363 < h - 1 && (u[_e363] >= 0 && (d = Bb({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          axis: u[_e363] - (i.length - f),
          keepDims: !1
        }
      }), g.push(d)), f--);
    }

    for (var _i84 = 0, _g17 = g; _i84 < _g17.length; _i84++) {
      var _e366 = _g17[_i84];
      _e366 !== d && n.disposeIntermediateTensorInfo(_e366);
    }

    return d;
  }
},
    Ub = {
  kernelName: "EluGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.dy,
        r = t.y;
    zf([s, r], "eluGrad");
    var a = new Float32Array(d(r.shape)),
        i = n.data.get(r.dataId).values,
        o = n.data.get(s.dataId).values;

    for (var _e367 = 0; _e367 < i.length; ++_e367) {
      var _t361 = i[_e367];
      a[_e367] = _t361 >= 1 ? o[_e367] : o[_e367] * (_t361 + 1);
    }

    return n.makeTensorInfo(r.shape, "float32", a);
  }
},
    Vb = {
  kernelName: "Erf",
  backendName: "cpu",
  kernelFunc: og("Erf", function (e) {
    var t = Math.sign(e),
        n = Math.abs(e),
        s = 1 / (1 + .3275911 * n);
    return t * (1 - ((((1.061405429 * s - 1.453152027) * s + 1.421413741) * s - .284496736) * s + .254829592) * s * Math.exp(-n * n));
  })
};

function Gb(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.input,
      a = s.dim,
      i = r.shape.length,
      o = r.shape.slice();
  var u = a;
  return a < 0 && (l(-(i + 1) <= a, function () {
    return "Axis must be in the interval [".concat(-(i + 1), ", ").concat(i, "]");
  }), u = i + a + 1), o.splice(u, 0, 1), Bm({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: o
    }
  });
}

var Hb = {
  kernelName: "ExpandDims",
  backendName: "cpu",
  kernelFunc: Gb
},
    jb = Qf("RealDiv", Vf(function (e, t) {
  return e / t;
})),
    qb = {
  kernelName: "RealDiv",
  backendName: "cpu",
  kernelFunc: jb
};

function Kb(e, t, n) {
  var s = e.shape,
      r = s[0],
      a = s[1],
      i = n.data.get(e.dataId),
      o = i.complexTensorInfos.real,
      l = i.complexTensorInfos.imag,
      u = [r, a],
      c = d(u),
      h = w("float32", c),
      p = w("float32", c);

  for (var _e368 = 0; _e368 < r; _e368++) {
    var _s183 = sm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        begin: [_e368, 0],
        size: [1, a]
      }
    }),
        _r135 = sm({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        begin: [_e368, 0],
        size: [1, a]
      }
    }),
        _i85 = Gf({
      inputs: {
        real: _s183,
        imag: _r135
      },
      backend: n
    }),
        _Xb = Xb(_i85, t, n),
        _u24 = _Xb.real,
        _c23 = _Xb.imag,
        _d16 = Mo(_u24, _c23);

    for (var _t362 = 0; _t362 < a; _t362++) {
      var _n240 = Po(_d16, _t362);

      h[_e368 * a + _t362] = _n240.real, p[_e368 * a + _t362] = _n240.imag;
    }

    n.disposeIntermediateTensorInfo(_s183), n.disposeIntermediateTensorInfo(_r135), n.disposeIntermediateTensorInfo(_i85);
  }

  var f = n.makeTensorInfo(u, "float32", h),
      g = n.makeTensorInfo(u, "float32", p),
      m = Gf({
    inputs: {
      real: f,
      imag: g
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
}

function Xb(e, t, n) {
  var s = d(e.shape),
      r = n.data.get(e.dataId),
      a = n.data.get(r.complexTensorInfos.real.dataId).values,
      i = n.data.get(r.complexTensorInfos.imag.dataId).values;

  if (0 == ((o = s) & o - 1)) {
    var _r136 = Yb(a, i, s, t, n),
        _o51 = [e.shape[0], e.shape[1]];

    if (t) {
      var _e369 = n.makeTensorInfo(_o51, "float32", _r136.real),
          _t363 = n.makeTensorInfo(_o51, "float32", _r136.imag),
          _a92 = n.makeTensorInfo([], "float32", We(s, "float32")),
          _i86 = qf({
        inputs: {
          x: _a92
        },
        backend: n
      }),
          _l39 = qb.kernelFunc({
        inputs: {
          a: _e369,
          b: _a92
        },
        backend: n
      }),
          u = qb.kernelFunc({
        inputs: {
          a: _t363,
          b: _i86
        },
        backend: n
      }),
          c = n.data.get(_l39.dataId).values,
          h = n.data.get(u.dataId).values;

      return n.disposeIntermediateTensorInfo(_e369), n.disposeIntermediateTensorInfo(_t363), n.disposeIntermediateTensorInfo(_a92), n.disposeIntermediateTensorInfo(_i86), n.disposeIntermediateTensorInfo(_l39), n.disposeIntermediateTensorInfo(u), {
        real: c,
        imag: h
      };
    }

    return _r136;
  }

  return Lo(function (e, t, n) {
    var s = new Float32Array(2 * t);

    for (var _r137 = 0; _r137 < t; _r137++) {
      var _a93 = 0,
          _i87 = 0;

      for (var _s184 = 0; _s184 < t; _s184++) {
        var _o52 = Vo(_r137 * _s184, t, n),
            _l40 = Po(e, _s184);

        _a93 += _l40.real * _o52.real - _l40.imag * _o52.imag, _i87 += _l40.real * _o52.imag + _l40.imag * _o52.real;
      }

      n && (_a93 /= t, _i87 /= t), Wo(s, _a93, _i87, _r137);
    }

    return s;
  }(Mo(a, i), s, t));
  var o;
}

function Yb(e, t, n, s, r) {
  if (1 === n) return {
    real: e,
    imag: t
  };

  var a = Mo(e, t),
      i = n / 2,
      o = zo(a),
      l = o.real,
      u = o.imag,
      c = [l.length],
      h = r.makeTensorInfo(c, "float32", l),
      d = r.makeTensorInfo(c, "float32", u),
      p = Gf({
    inputs: {
      real: h,
      imag: d
    },
    backend: r
  }),
      f = Bo(a),
      g = f.real,
      m = f.imag,
      b = [g.length],
      x = r.makeTensorInfo(b, "float32", g),
      y = r.makeTensorInfo(b, "float32", m),
      k = Gf({
    inputs: {
      real: x,
      imag: y
    },
    backend: r
  }),
      w = Yb(l, u, i, s, r),
      v = w.real,
      I = w.imag,
      $ = [v.length],
      N = r.makeTensorInfo($, "float32", v),
      C = r.makeTensorInfo($, "float32", I),
      S = Gf({
    inputs: {
      real: N,
      imag: C
    },
    backend: r
  }),
      T = Yb(g, m, i, s, r),
      E = T.real,
      R = T.imag,
      A = [E.length],
      F = r.makeTensorInfo(A, "float32", E),
      D = r.makeTensorInfo(A, "float32", R),
      _ = Gf({
    inputs: {
      real: F,
      imag: D
    },
    backend: r
  }),
      O = Uo(n, s),
      M = [O.real.length],
      L = r.makeTensorInfo(M, "float32", O.real),
      z = r.makeTensorInfo(M, "float32", O.imag),
      B = Gf({
    inputs: {
      real: L,
      imag: z
    },
    backend: r
  }),
      P = Ug({
    inputs: {
      a: B,
      b: _
    },
    backend: r
  }),
      W = ng({
    inputs: {
      a: S,
      b: P
    },
    backend: r
  }),
      U = bm({
    inputs: {
      a: S,
      b: P
    },
    backend: r
  }),
      V = Xf({
    inputs: {
      input: W
    },
    backend: r
  }),
      G = Xf({
    inputs: {
      input: U
    },
    backend: r
  }),
      H = fb({
    inputs: {
      input: W
    },
    backend: r
  }),
      j = fb({
    inputs: {
      input: U
    },
    backend: r
  }),
      q = mb({
    inputs: [V, G],
    backend: r,
    attrs: {
      axis: 0
    }
  }),
      K = mb({
    inputs: [H, j],
    backend: r,
    attrs: {
      axis: 0
    }
  }),
      X = r.data.get(q.dataId).values,
      Y = r.data.get(K.dataId).values;

  return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(x), r.disposeIntermediateTensorInfo(y), r.disposeIntermediateTensorInfo(k), r.disposeIntermediateTensorInfo(N), r.disposeIntermediateTensorInfo(C), r.disposeIntermediateTensorInfo(S), r.disposeIntermediateTensorInfo(F), r.disposeIntermediateTensorInfo(D), r.disposeIntermediateTensorInfo(_), r.disposeIntermediateTensorInfo(L), r.disposeIntermediateTensorInfo(z), r.disposeIntermediateTensorInfo(B), r.disposeIntermediateTensorInfo(P), r.disposeIntermediateTensorInfo(W), r.disposeIntermediateTensorInfo(U), r.disposeIntermediateTensorInfo(V), r.disposeIntermediateTensorInfo(H), r.disposeIntermediateTensorInfo(G), r.disposeIntermediateTensorInfo(j), r.disposeIntermediateTensorInfo(q), r.disposeIntermediateTensorInfo(K), {
    real: X,
    imag: Y
  };
}

var Jb = {
  kernelName: "FFT",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.input,
        r = d(s.shape),
        a = s.shape[s.shape.length - 1],
        i = Bm({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [r / a, a]
      }
    }),
        o = Kb(i, !1, n),
        l = Bm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s.shape
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), l;
  }
};

function Zb(e) {
  var t = e.backend,
      n = e.attrs,
      s = n.shape,
      r = n.value,
      a = n.dtype,
      i = a || T(r),
      o = v(i, d(s));
  return function (e, t, n) {
    e.fill(t);
  }(o, r), t.makeTensorInfo(s, i, o);
}

var Qb = {
  kernelName: "Fill",
  backendName: "cpu",
  kernelFunc: Zb
},
    ex = {
  kernelName: "FlipLeftRight",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref32) {
    var e = _ref32.inputs,
        t = _ref32.backend;

    var n = e.image,
        s = t,
        r = w(n.dtype, d(n.shape)),
        _n$shape = _slicedToArray(n.shape, 4),
        a = _n$shape[0],
        i = _n$shape[1],
        o = _n$shape[2],
        l = _n$shape[3],
        u = s.data.get(n.dataId).values;

    for (var _e370 = 0; _e370 < a; _e370++) {
      var _t364 = _e370 * o * i * l;

      for (var _e371 = 0; _e371 < i; _e371++) {
        var _n241 = _e371 * (o * l);

        for (var _e372 = 0; _e372 < o; _e372++) {
          var _s185 = _e372 * l;

          for (var _a94 = 0; _a94 < l; _a94++) {
            var _i88 = Math.round(o - _e372 - 1),
                c = _t364 + _n241 + _s185 + _a94;

            var h = u[c];
            _i88 >= 0 && _i88 < o && (h = u[_t364 + _n241 + _i88 * l + _a94]), r[c] = h;
          }
        }
      }
    }

    return {
      dataId: s.write(r, n.shape, n.dtype),
      shape: n.shape,
      dtype: n.dtype
    };
  }
},
    tx = {
  kernelName: "FloorDiv",
  backendName: "cpu",
  kernelFunc: Qf("FloorDiv", Vf(function (e, t) {
    return Math.floor(e / t);
  }), null, "int32")
},
    nx = {
  kernelName: "FusedConv2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = t.bias,
        o = t.preluActivationWeights,
        l = s.strides,
        u = s.pad,
        c = s.dataFormat,
        h = s.dilations,
        d = s.dimRoundingMode,
        p = s.activation,
        f = s.leakyreluAlpha;
    var g = xb({
      inputs: {
        x: r,
        filter: a
      },
      backend: n,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });

    if (i) {
      var _e373 = g;
      g = ng({
        inputs: {
          a: g,
          b: i
        },
        backend: n
      }), n.disposeIntermediateTensorInfo(_e373);
    }

    if (p) {
      var _e374 = g;
      g = zm(n, g, p, o, f), n.disposeIntermediateTensorInfo(_e374);
    }

    return g;
  }
},
    sx = {
  kernelName: "FusedDepthwiseConv2D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = t.bias,
        o = t.preluActivationWeights,
        l = s.strides,
        u = s.pad,
        c = s.dataFormat,
        h = s.dilations,
        d = s.dimRoundingMode,
        p = s.activation,
        f = s.leakyreluAlpha;
    var g = Ab({
      inputs: {
        x: r,
        filter: a
      },
      backend: n,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });

    if (i) {
      var _e375 = g;
      g = ng({
        inputs: {
          a: g,
          b: i
        },
        backend: n
      }), n.disposeIntermediateTensorInfo(_e375);
    }

    if (p) {
      var _e376 = g;
      g = zm(n, g, p, o, f), n.disposeIntermediateTensorInfo(_e376);
    }

    return g;
  }
},
    rx = {
  kernelName: "GatherNd",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.params,
        r = t.indices,
        a = d(s.shape),
        i = r.shape,
        o = i[i.length - 1],
        _Nn = Nn(s, r),
        _Nn2 = _slicedToArray(_Nn, 4),
        l = _Nn2[0],
        u = _Nn2[1],
        c = _Nn2[2],
        h = _Nn2[3];

    if (0 === u) return n.makeTensorInfo(l, s.dtype, []);
    var p = vg(n.data.get(r.dataId).values, n.bufferSync(s), s.dtype, u, o, c, h, s.shape, a);
    return n.makeTensorInfo(l, s.dtype, p.values);
  }
},
    ax = {
  kernelName: "GatherV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.indices,
        i = s.axis,
        o = s.batchDims;
    zf([r, a], "gatherV2");
    var l = o;
    null == o && (l = 0);
    var u = d(a.shape),
        c = el(r, a, y(i, r.shape)[0], l),
        h = Bm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [c.batchSize, c.outerSize, c.dimSize, c.sliceSize]
      }
    }),
        p = Bm({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [c.batchSize, u / c.batchSize]
      }
    }),
        f = [c.batchSize, c.outerSize, u / c.batchSize, c.sliceSize],
        g = n.bufferSync(p),
        m = Ig(n.bufferSync(h), g, f);
    return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.makeTensorInfo(c.outputShape, m.dtype, m.values);
  }
},
    ix = {
  kernelName: "IFFT",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.input,
        r = d(s.shape),
        a = s.shape[s.shape.length - 1],
        i = Bm({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [r / a, a]
      }
    }),
        o = Kb(i, !0, n),
        l = Bm({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s.shape
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), l;
  }
},
    ox = {
  kernelName: "IsFinite",
  backendName: "cpu",
  kernelFunc: og("IsFinite", function (e) {
    return Number.isFinite(e) ? 1 : 0;
  }, "bool")
},
    lx = {
  kernelName: "IsInf",
  backendName: "cpu",
  kernelFunc: og("IsInf", function (e) {
    return Infinity === Math.abs(e) ? 1 : 0;
  }, "bool")
},
    ux = {
  kernelName: "IsNan",
  backendName: "cpu",
  kernelFunc: og("IsNan", function (e) {
    return Number.isNaN(e) ? 1 : 0;
  }, "bool")
},
    cx = {
  kernelName: "LinSpace",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.backend,
        n = e.attrs,
        s = n.start,
        r = n.stop,
        a = n.num,
        i = Fg(s, r, a);
    return t.makeTensorInfo([i.length], "float32", i);
  }
},
    hx = {
  kernelName: "Log1p",
  backendName: "cpu",
  kernelFunc: og("Log1p", function (e) {
    return Math.log1p(e);
  })
},
    dx = {
  kernelName: "LogicalAnd",
  backendName: "cpu",
  kernelFunc: Qf("LogicalAnd", Vf(function (e, t) {
    return e && t;
  }), null, "bool")
},
    px = {
  kernelName: "LogicalNot",
  backendName: "cpu",
  kernelFunc: og("LogicalNot", function (e) {
    return e ? 0 : 1;
  }, "bool")
},
    fx = {
  kernelName: "LogicalOr",
  backendName: "cpu",
  kernelFunc: Qf("LogicalOr", Vf(function (e, t) {
    return e || t;
  }), null, "bool")
},
    gx = {
  kernelName: "LRN",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.depthRadius,
        i = s.bias,
        o = s.alpha,
        l = s.beta;
    zf(r, "LRN");
    var u = r.shape[3],
        c = u - 1,
        h = n.data.get(r.dataId).values,
        p = d(r.shape),
        f = new Float32Array(p);

    function g(e) {
      var t = e % u;
      var n = e - t + Math.max(0, t - a);
      var s = e - t + Math.min(t + a, c);
      var r = 0;

      for (; n <= s; n++) {
        var _e377 = h[n];
        r += _e377 * _e377;
      }

      return r;
    }

    for (var _e378 = 0; _e378 < p; _e378++) {
      var _t365 = g(_e378),
          _n242 = h[_e378] * Math.pow(i + o * _t365, -l);

      f[_e378] = _n242;
    }

    return n.makeTensorInfo(r.shape, r.dtype, f);
  }
},
    mx = {
  kernelName: "LRNGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.y,
        i = t.dy,
        o = s.depthRadius,
        l = s.bias,
        u = s.alpha,
        c = s.beta;
    zf(i, "LRNGrad");
    var h = d(i.shape),
        p = i.shape[3],
        f = n.data.get(i.dataId).values,
        g = n.data.get(r.dataId).values,
        m = n.data.get(a.dataId).values,
        b = new Float32Array(h),
        x = h;

    for (var _e379 = 0; _e379 < x; _e379++) {
      var _t366 = _e379 % p,
          _n243 = _e379 - _t366 + Math.max(0, _t366 - o),
          _s186 = _e379 - _t366 + Math.min(p, _t366 + o + 1);

      var _r138 = 0;

      for (var _e380 = _n243; _e380 < _s186; _e380++) {
        _r138 += Math.pow(g[_e380], 2);
      }

      _r138 = u * _r138 + l;

      for (var _t367 = _n243; _t367 < _s186; _t367++) {
        var _n244 = -2 * u * c * g[_t367] * m[_e379] / _r138;

        _e379 === _t367 && (_n244 += Math.pow(_r138, -c)), _n244 *= f[_e379], b[_t367] += _n244;
      }
    }

    return n.makeTensorInfo(i.shape, r.dtype, b);
  }
};

function bx(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.reductionIndices,
      i = s.keepDims,
      o = n;
  var l = r.shape;
  var u = l.length,
      c = y(a, l);
  var h = c;
  var p = Jr(h, u);
  var f = o.data.get(r.dataId).values;

  if (null != p) {
    var _e381 = new Array(u);

    for (var _t368 = 0; _t368 < _e381.length; _t368++) {
      _e381[_t368] = l[p[_t368]];
    }

    f = Kg(f, l, r.dtype, p, _e381), h = Qr(h.length, u), l = _e381;
  }

  zf(r, "max"), Yr("max", h, u);

  var _Kr13 = Kr(l, h),
      _Kr14 = _slicedToArray(_Kr13, 2),
      g = _Kr14[0],
      m = _Kr14[1],
      b = Og(f, d(m), g, r.dtype),
      x = o.write(b, g, r.dtype);

  var k = g;
  return i && (k = Xr(g, c)), {
    dataId: x,
    shape: k,
    dtype: r.dtype
  };
}

var xx = {
  kernelName: "Max",
  backendName: "cpu",
  kernelFunc: bx
},
    yx = {
  kernelName: "MaxPool",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x;
    zf(r, "maxPool");
    var a = s.filterSize,
        i = s.strides,
        o = s.pad,
        u = s.dimRoundingMode;
    l(Ss(i, 1), function () {
      return "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'");
    });
    var c = bs(r.shape, a, i, 1, o, u);
    var h;
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) h = qf({
      inputs: {
        x: r
      },
      backend: n
    });else {
      var _e382 = n.data.get(r.dataId).values,
          _t369 = A(r.shape),
          _s187 = nb(_e382, 0, r.dtype, _t369, c, "max");

      h = n.makeTensorInfo(c.outShape, r.dtype, _s187.values);
    }
    return h;
  }
},
    kx = {
  kernelName: "MaxPool3D",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.filterSize,
        i = s.strides,
        o = s.pad,
        l = s.dimRoundingMode,
        u = s.dataFormat;
    zf(r, "maxPool3d");
    var c = xs(r.shape, a, i, 1, o, l, u),
        h = rb(n.data.get(r.dataId).values, 0, r.dtype, A(r.shape), c, "max");
    return n.makeTensorInfo(h.shape, "float32", h.values);
  }
},
    wx = {
  kernelName: "MaxPool3DGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = s.filterSize,
        o = s.strides,
        l = s.pad,
        u = s.dimRoundingMode;
    zf([r, a], "maxPool3DGrad");

    var c = xs(a.shape, i, o, 1, l, u),
        h = function (e, t) {
      var n = dn(t.outShape, "int32"),
          s = t.strideDepth,
          r = t.strideHeight,
          a = t.strideWidth,
          i = t.dilationDepth,
          o = t.dilationHeight,
          l = t.dilationWidth,
          u = t.effectiveFilterDepth,
          c = t.effectiveFilterHeight,
          h = t.effectiveFilterWidth,
          d = t.padInfo.front,
          p = t.padInfo.top,
          f = t.padInfo.left;

      for (var _g18 = 0; _g18 < t.batchSize; ++_g18) {
        for (var _m11 = 0; _m11 < t.inChannels; ++_m11) {
          for (var _b11 = 0; _b11 < t.outDepth; ++_b11) {
            var _x139 = _b11 * s - d;

            var _y9 = _x139;

            for (; _y9 < 0;) {
              _y9 += i;
            }

            var _k7 = Math.min(t.inDepth, u + _x139);

            for (var _s188 = 0; _s188 < t.outHeight; ++_s188) {
              var _u25 = _s188 * r - p;

              var _d17 = _u25;

              for (; _d17 < 0;) {
                _d17 += o;
              }

              var _w7 = Math.min(t.inHeight, c + _u25);

              for (var _r139 = 0; _r139 < t.outWidth; ++_r139) {
                var _p12 = _r139 * a - f;

                var _v5 = _p12;

                for (; _v5 < 0;) {
                  _v5 += l;
                }

                var _I4 = Math.min(t.inWidth, h + _p12);

                var _$2 = Number.NEGATIVE_INFINITY,
                    _N4 = -1;

                for (var _t370 = _y9; _t370 < _k7; _t370 += i) {
                  var _n245 = _t370 - _x139;

                  for (var _s189 = _d17; _s189 < _w7; _s189 += o) {
                    var _r140 = _s189 - _u25;

                    for (var _a95 = _v5; _a95 < _I4; _a95 += l) {
                      var _i89 = _a95 - _p12,
                          _o53 = e.get(_g18, _t370, _s189, _a95, _m11);

                      _o53 >= _$2 && (_$2 = _o53, _N4 = _n245 * c * h + _r140 * c + _i89);
                    }
                  }
                }

                n.set(_N4, _g18, _b11, _s188, _r139, _m11);
              }
            }
          }
        }
      }

      return n;
    }(n.bufferSync(a), c),
        d = c.strideDepth,
        p = c.strideHeight,
        f = c.strideWidth,
        g = c.dilationDepth,
        m = c.dilationHeight,
        b = c.dilationWidth,
        x = c.effectiveFilterDepth,
        y = c.effectiveFilterHeight,
        k = c.effectiveFilterWidth,
        w = x - 1 - c.padInfo.front,
        v = k - 1 - c.padInfo.left,
        I = y - 1 - c.padInfo.top,
        $ = dn(a.shape, "float32"),
        N = n.bufferSync(r);

    for (var _e383 = 0; _e383 < c.batchSize; ++_e383) {
      for (var _t371 = 0; _t371 < c.inChannels; ++_t371) {
        for (var _n246 = 0; _n246 < c.inDepth; ++_n246) {
          for (var _s190 = 0; _s190 < c.inHeight; ++_s190) {
            for (var _r141 = 0; _r141 < c.inWidth; ++_r141) {
              var _a96 = _n246 - w,
                  _i90 = _s190 - I,
                  _o54 = _r141 - v;

              var _l41 = 0;

              for (var _n247 = 0; _n247 < x; _n247 += g) {
                var _s191 = (_a96 + _n247) / d;

                if (!(_s191 < 0 || _s191 >= c.outDepth || Math.floor(_s191) !== _s191)) for (var _r142 = 0; _r142 < y; _r142 += m) {
                  var _a97 = (_i90 + _r142) / p;

                  if (!(_a97 < 0 || _a97 >= c.outHeight || Math.floor(_a97) !== _a97)) for (var _i91 = 0; _i91 < k; _i91 += b) {
                    var _u26 = (_o54 + _i91) / f;

                    if (_u26 < 0 || _u26 >= c.outWidth || Math.floor(_u26) !== _u26) continue;

                    var _d18 = x * y * k - 1 - h.get(_e383, _s191, _a97, _u26, _t371) === _n247 * y * k + _r142 * k + _i91 ? 1 : 0;

                    0 !== _d18 && (_l41 += N.get(_e383, _s191, _a97, _u26, _t371) * _d18);
                  }
                }
              }

              $.set(_l41, _e383, _n246, _s190, _r141, _t371);
            }
          }
        }
      }
    }

    return n.makeTensorInfo($.shape, $.dtype, $.values);
  }
},
    vx = {
  kernelName: "MaxPoolGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = t.output,
        o = a;
    zf([a, i], "maxPoolGrad");
    var l = s.filterSize,
        u = s.strides,
        c = s.pad,
        h = s.dimRoundingMode,
        d = bs(o.shape, l, u, 1, c, h),
        p = n.data.get(o.dataId).values,
        f = dn(d.outShape, o.dtype, sb(p, o.shape, o.dtype, d).values),
        g = d.strideHeight,
        m = d.strideWidth,
        b = d.dilationHeight,
        x = d.dilationWidth,
        y = d.effectiveFilterHeight,
        k = d.effectiveFilterWidth,
        w = k - 1 - d.padInfo.left,
        v = y - 1 - d.padInfo.top,
        I = dn(o.shape, "float32"),
        $ = n.data.get(r.dataId).values,
        N = dn(r.shape, "float32", $);

    for (var _e384 = 0; _e384 < d.batchSize; ++_e384) {
      for (var _t372 = 0; _t372 < d.inChannels; ++_t372) {
        for (var _n248 = 0; _n248 < d.inHeight; ++_n248) {
          for (var _s192 = 0; _s192 < d.inWidth; ++_s192) {
            var _r143 = _n248 - v,
                _a98 = _s192 - w;

            var _i92 = 0;

            for (var _n249 = 0; _n249 < y; _n249 += b) {
              var _s193 = (_r143 + _n249) / g;

              if (!(_s193 < 0 || _s193 >= d.outHeight || Math.floor(_s193) !== _s193)) for (var _r144 = 0; _r144 < k; _r144 += x) {
                var _o55 = (_a98 + _r144) / m;

                if (_o55 < 0 || _o55 >= d.outWidth || Math.floor(_o55) !== _o55) continue;

                var _l42 = y * k - 1 - f.get(_e384, _s193, _o55, _t372) === _n249 * k + _r144 ? 1 : 0;

                0 !== _l42 && (_i92 += N.get(_e384, _s193, _o55, _t372) * _l42);
              }
            }

            I.set(_i92, _e384, _n248, _s192, _t372);
          }
        }
      }
    }

    return n.makeTensorInfo(I.shape, I.dtype, I.values);
  }
},
    Ix = {
  kernelName: "MaxPoolWithArgmax",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref33) {
    var e = _ref33.inputs,
        t = _ref33.attrs,
        n = _ref33.backend;
    var s = e.x,
        r = t.filterSize,
        a = t.strides,
        i = t.pad,
        o = t.includeBatchInIndex,
        l = n;
    zf(s, "MaxPoolWithArgmax");

    var u = l.data.get(s.dataId).values,
        c = bs(s.shape, r, a, [1, 1], i),
        _ref34 = function (e, t, n, s, r) {
      var a = nb(e, 0, n, A(t), r, "max"),
          i = sb(e, t, n, r, !0, s);
      return [a.values, i.values];
    }(u, s.shape, s.dtype, o, c),
        _ref35 = _slicedToArray(_ref34, 2),
        h = _ref35[0],
        d = _ref35[1],
        p = l.write(h, c.outShape, s.dtype),
        f = l.write(d, c.outShape, s.dtype);

    return [{
      dataId: p,
      shape: c.outShape,
      dtype: s.dtype
    }, {
      dataId: f,
      shape: c.outShape,
      dtype: "int32"
    }];
  }
},
    $x = {
  kernelName: "Mean",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims,
        o = y(a, r.shape),
        l = d(Kr(r.shape, o)[1]),
        u = [],
        c = n.makeTensorInfo([], "float32", new Float32Array([l]));
    u.push(c);
    var h = Jf({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        dtype: "float32"
      }
    });
    u.push(h);
    var p = jb({
      inputs: {
        a: h,
        b: c
      },
      backend: n
    });
    u.push(p);
    var f = Bb({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        axis: a,
        keepDims: i
      }
    });
    return u.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), f;
  }
},
    Nx = {
  kernelName: "Min",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims;
    zf(r, "min");
    var o = y(a, r.shape);
    var l = o;
    var u = Jr(l, r.shape.length);
    var c = r;
    null != u && (c = Xg({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }), l = Qr(l.length, r.shape.length)), Yr("min", l, c.shape.length);

    var _Kr15 = Kr(c.shape, l),
        _Kr16 = _slicedToArray(_Kr15, 2),
        h = _Kr16[0],
        p = _Kr16[1],
        f = d(p),
        g = O(d(h), c.dtype),
        m = n.data.get(c.dataId).values;

    for (var _e385 = 0; _e385 < g.length; ++_e385) {
      var _t373 = _e385 * f;

      var _n250 = m[_t373];

      for (var _e386 = 0; _e386 < f; ++_e386) {
        var _s194 = m[_t373 + _e386];
        (Number.isNaN(_s194) || _s194 < _n250) && (_n250 = _s194);
      }

      g[_e385] = _n250;
    }

    null != u && n.disposeIntermediateTensorInfo(c);
    var b = n.makeTensorInfo(h, c.dtype, g);

    if (i) {
      var _e387 = Bm({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: Xr(h, o)
        }
      });

      return n.disposeIntermediateTensorInfo(b), _e387;
    }

    return b;
  }
},
    Cx = {
  kernelName: "MirrorPad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.paddings,
        i = s.mode;
    zf(r, "mirrorPad");
    var o = a.map(function (e, t) {
      return e[0] + r.shape[t] + e[1];
    }),
        l = a.map(function (e) {
      return e[0];
    }),
        u = a.map(function (e, t) {
      return e[0] + r.shape[t];
    }),
        c = "reflect" === i ? 0 : 1,
        h = n.data.get(r.dataId).values,
        p = r.shape.length,
        f = A(r.shape),
        g = d(o),
        m = o.length,
        b = A(o),
        x = w(r.dtype, g);

    for (var _e388 = 0; _e388 < g; _e388++) {
      var _t374 = B(_e388, m, b);

      for (var _e389 = 0; _e389 < m; _e389++) {
        _t374[_e389] < l[_e389] ? _t374[_e389] = 2 * l[_e389] - _t374[_e389] - c : _t374[_e389] >= u[_e389] && (_t374[_e389] = 2 * (u[_e389] - 1) - _t374[_e389] + c);
      }

      _t374 = _t374.map(function (e, t) {
        return e - l[t];
      });

      var _n251 = z(_t374, p, f);

      x[_e388] = h[_n251];
    }

    return {
      dataId: n.write(x, o, r.dtype),
      shape: o,
      dtype: r.dtype
    };
  }
},
    Sx = {
  kernelName: "Mod",
  backendName: "cpu",
  kernelFunc: Qf("Mod", Vf(function (e, t) {
    var n = e % t;
    return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t;
  }))
};

function Tx(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.logits,
      a = s.dim,
      i = r.shape.length;
  var o = a;
  if (-1 === o && (o = i - 1), o !== i - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank ".concat(i, " and dim was ").concat(o));
  var l = y([o], r.shape),
      u = bx({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      reductionIndices: l,
      keepDims: !1
    }
  }),
      c = Xr(u.shape, l),
      h = Bm({
    inputs: {
      x: u
    },
    backend: n,
    attrs: {
      shape: c
    }
  }),
      d = bm({
    inputs: {
      a: r,
      b: h
    },
    backend: n
  }),
      p = mg({
    inputs: {
      x: d
    },
    backend: n
  }),
      f = Bb({
    inputs: {
      x: p
    },
    backend: n,
    attrs: {
      axis: l,
      keepDims: !1
    }
  }),
      g = Bm({
    inputs: {
      x: f
    },
    backend: n,
    attrs: {
      shape: c
    }
  }),
      m = jb({
    inputs: {
      a: p,
      b: g
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
}

var Ex = {
  kernelName: "Softmax",
  backendName: "cpu",
  kernelFunc: Tx
},
    Rx = {
  kernelName: "Multinomial",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.logits,
        a = s.numSamples,
        i = s.seed,
        o = s.normalized;
    zf(r, "multinomial");
    var l = o ? r : Tx({
      inputs: {
        logits: r
      },
      backend: n,
      attrs: {
        dim: -1
      }
    }),
        u = l.shape[0],
        c = l.shape[1],
        h = n.data.get(l.dataId).values,
        p = [u, a],
        f = O(d(p), "int32");

    for (var _e390 = 0; _e390 < u; ++_e390) {
      var _t375 = _e390 * c,
          _n252 = new Float32Array(c - 1);

      _n252[0] = h[_t375];

      for (var _e391 = 1; _e391 < _n252.length; ++_e391) {
        _n252[_e391] = _n252[_e391 - 1] + h[_t375 + _e391];
      }

      var _s195 = _a.alea(i.toString()),
          _r145 = _e390 * a;

      for (var _e392 = 0; _e392 < a; ++_e392) {
        var _t376 = _s195();

        f[_r145 + _e392] = _n252.length;

        for (var _s196 = 0; _s196 < _n252.length; _s196++) {
          if (_t376 < _n252[_s196]) {
            f[_r145 + _e392] = _s196;
            break;
          }
        }
      }
    }

    return o || n.disposeIntermediateTensorInfo(l), n.makeTensorInfo(p, "int32", f);
  }
},
    Ax = ji,
    Fx = {
  kernelName: "NonMaxSuppressionV3",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.boxes,
        a = t.scores,
        i = s.maxOutputSize,
        o = s.iouThreshold,
        l = s.scoreThreshold;
    zf(r, "NonMaxSuppression");

    var u = n.data.get(r.dataId).values,
        c = n.data.get(a.dataId).values,
        _Ax = Ax(u, c, i, o, l),
        h = _Ax.selectedIndices;

    return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
  }
},
    Dx = qi,
    _x = {
  kernelName: "NonMaxSuppressionV4",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.boxes,
        a = t.scores,
        i = s.maxOutputSize,
        o = s.iouThreshold,
        l = s.scoreThreshold,
        u = s.padToMaxOutputSize;
    zf(r, "NonMaxSuppressionPadded");

    var c = n.data.get(r.dataId).values,
        h = n.data.get(a.dataId).values,
        _Dx = Dx(c, h, i, o, l, u),
        d = _Dx.selectedIndices,
        p = _Dx.validOutputs;

    return [n.makeTensorInfo([d.length], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([p]))];
  }
},
    Ox = Ki,
    Mx = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.boxes,
        a = t.scores,
        i = s.maxOutputSize,
        o = s.iouThreshold,
        l = s.scoreThreshold,
        u = s.softNmsSigma;
    zf(r, "NonMaxSuppressionWithScore");

    var c = n.data.get(r.dataId).values,
        h = n.data.get(a.dataId).values,
        d = i,
        p = o,
        f = l,
        g = u,
        _Ox = Ox(c, h, d, p, f, g),
        m = _Ox.selectedIndices,
        b = _Ox.selectedScores;

    return [n.makeTensorInfo([m.length], "int32", new Int32Array(m)), n.makeTensorInfo([b.length], "float32", new Float32Array(b))];
  }
},
    Lx = {
  kernelName: "OneHot",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.indices,
        a = s.depth,
        i = s.onValue,
        o = s.offValue;
    zf(r, "oneHot");
    var l = d(r.shape),
        u = new Float32Array(l * a);
    u.fill(o);
    var c = n.data.get(r.dataId).values;

    for (var _e393 = 0; _e393 < l; ++_e393) {
      c[_e393] >= 0 && c[_e393] < a && (u[_e393 * a + c[_e393]] = i);
    }

    return n.makeTensorInfo([].concat(_toConsumableArray(r.shape), [a]), "int32", u);
  }
};

function zx(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.x;
  if ("string" === s.dtype) throw new Error("zerosLike is not supported for string tensors");

  if ("complex64" === s.dtype) {
    var _e394 = Xf({
      inputs: {
        input: s
      },
      backend: n
    }),
        _t377 = zx({
      inputs: {
        x: _e394
      },
      backend: n
    }),
        _r146 = fb({
      inputs: {
        input: s
      },
      backend: n
    }),
        a = zx({
      inputs: {
        x: _r146
      },
      backend: n
    }),
        i = Gf({
      inputs: {
        real: _t377,
        imag: a
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e394), n.disposeIntermediateTensorInfo(_t377), n.disposeIntermediateTensorInfo(_r146), n.disposeIntermediateTensorInfo(a), i;
  }

  return Zb({
    backend: n,
    attrs: {
      shape: s.shape,
      value: 0,
      dtype: s.dtype
    }
  });
}

var Bx = {
  kernelName: "ZerosLike",
  backendName: "cpu",
  kernelFunc: zx
},
    Px = {
  kernelName: "OnesLike",
  backendName: "cpu",
  kernelFunc: function e(t) {
    var n = t.inputs,
        s = t.backend,
        r = n.x;
    if ("string" === r.dtype) throw new Error("onesLike is not supported for string tensors");

    if ("complex64" === r.dtype) {
      var _t378 = Xf({
        inputs: {
          input: r
        },
        backend: s
      }),
          _n253 = e({
        inputs: {
          x: _t378
        },
        backend: s
      }),
          a = fb({
        inputs: {
          input: r
        },
        backend: s
      }),
          i = zx({
        inputs: {
          x: a
        },
        backend: s
      }),
          _o56 = Gf({
        inputs: {
          real: _n253,
          imag: i
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_t378), s.disposeIntermediateTensorInfo(_n253), s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), _o56;
    }

    return Zb({
      backend: s,
      attrs: {
        shape: r.shape,
        value: 1,
        dtype: r.dtype
      }
    });
  }
};

function Wx(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = s.axis;
  if (1 === t.length) return Gb({
    inputs: {
      input: t[0]
    },
    backend: n,
    attrs: {
      dim: r
    }
  });
  var a = t[0].shape,
      i = t[0].dtype;
  t.forEach(function (e) {
    u(a, e.shape, "All tensors passed to stack must have matching shapes"), l(i === e.dtype, function () {
      return "All tensors passed to stack must have matching dtypes";
    });
  });
  var o = [],
      c = mb({
    inputs: t.map(function (e) {
      var t = Gb({
        inputs: {
          input: e
        },
        backend: n,
        attrs: {
          dim: r
        }
      });
      return o.push(t), t;
    }),
    backend: n,
    attrs: {
      axis: r
    }
  });
  return o.forEach(function (e) {
    return n.disposeIntermediateTensorInfo(e);
  }), c;
}

var Ux = {
  kernelName: "Pack",
  backendName: "cpu",
  kernelFunc: Wx
},
    Vx = {
  kernelName: "PadV2",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.paddings,
        i = s.constantValue;
    zf(r, "pad");
    var o = a.map(function (e, t) {
      return e[0] + r.shape[t] + e[1];
    }),
        l = a.map(function (e) {
      return e[0];
    }),
        u = n.data.get(r.dataId).values,
        c = d(r.shape),
        h = r.shape.length,
        p = A(r.shape),
        f = d(o),
        g = o.length,
        m = A(o),
        b = w(r.dtype, f);
    0 !== i && b.fill(i);

    for (var _e395 = 0; _e395 < c; _e395++) {
      b[z(B(_e395, h, p).map(function (e, t) {
        return e + l[t];
      }), g, m)] = u[_e395];
    }

    return {
      dataId: n.write(b, o, r.dtype),
      shape: o,
      dtype: r.dtype
    };
  }
},
    Gx = {
  kernelName: "Pow",
  backendName: "cpu",
  kernelFunc: Qf("Pow", Vf(function (e, t) {
    return Math.pow(e, t);
  }))
},
    Hx = {
  kernelName: "Range",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.backend,
        n = e.attrs,
        s = n.start,
        r = n.stop,
        a = n.dtype,
        i = n.step,
        o = Qg(s, r, i, a);
    return t.makeTensorInfo([o.length], a, o);
  }
},
    jx = {
  kernelName: "Reciprocal",
  backendName: "cpu",
  kernelFunc: og("Reciprocal", function (e) {
    return 1 / e;
  })
},
    qx = {
  kernelName: "ResizeBilinear",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = s.alignCorners,
        i = s.halfPixelCenters,
        o = s.size;
    zf(r, "resizeBilinear");

    var l = A(r.shape),
        _o57 = _slicedToArray(o, 2),
        u = _o57[0],
        c = _o57[1],
        _r$shape2 = _slicedToArray(r.shape, 4),
        h = _r$shape2[0],
        p = _r$shape2[1],
        f = _r$shape2[2],
        g = _r$shape2[3],
        m = n.data.get(r.dataId).values,
        b = new Float32Array(d([h, u, c, g])),
        x = [a && u > 1 ? p - 1 : p, a && c > 1 ? f - 1 : f],
        y = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c];

    var k = 0;
    var w = x[0] / y[0],
        v = x[1] / y[1];

    for (var _e396 = 0; _e396 < h; _e396++) {
      for (var _t379 = 0; _t379 < u; _t379++) {
        var _n254 = void 0;

        _n254 = i ? w * (_t379 + .5) - .5 : w * _t379;

        var _s197 = Math.max(0, Math.floor(_n254)),
            _r147 = _n254 - _s197,
            _a99 = Math.min(p - 1, Math.ceil(_n254)),
            _o58 = _e396 * l[0] + _s197 * l[1],
            _u27 = _e396 * l[0] + _a99 * l[1];

        for (var _e397 = 0; _e397 < c; _e397++) {
          var _t380 = void 0;

          _t380 = i ? v * (_e397 + .5) - .5 : v * _e397;

          var _n255 = Math.max(0, Math.floor(_t380)),
              _s198 = _t380 - _n255,
              _a100 = Math.min(f - 1, Math.ceil(_t380)),
              _c24 = _o58 + _n255 * l[2],
              _h13 = _u27 + _n255 * l[2],
              _d19 = _o58 + _a100 * l[2],
              _p13 = _u27 + _a100 * l[2];

          for (var _e398 = 0; _e398 < g; _e398++) {
            var _t381 = m[_c24 + _e398],
                _n256 = m[_h13 + _e398],
                _a101 = _t381 + (m[_d19 + _e398] - _t381) * _s198;

            b[k++] = _a101 + (_n256 + (m[_p13 + _e398] - _n256) * _s198 - _a101) * _r147;
          }
        }
      }
    }

    return n.makeTensorInfo([h, u, c, g], "float32", b);
  }
},
    Kx = {
  kernelName: "ResizeBilinearGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = t.dy,
        i = s.alignCorners;
    zf([a, r], "resizeBilinearGrad");

    var o = A(r.shape),
        _r$shape3 = _slicedToArray(r.shape, 4),
        l = _r$shape3[0],
        u = _r$shape3[1],
        c = _r$shape3[2],
        h = _r$shape3[3],
        _a$shape = _slicedToArray(a.shape, 3),
        d = _a$shape[1],
        p = _a$shape[2],
        f = new Float32Array(l * u * c * h),
        g = [i && d > 1 ? u - 1 : u, i && p > 1 ? c - 1 : c],
        m = [i && d > 1 ? d - 1 : d, i && p > 1 ? p - 1 : p],
        b = g[0] / m[0],
        x = g[1] / m[1],
        y = n.data.get(a.dataId).values;

    var k = 0;

    for (var _e399 = 0; _e399 < l; _e399++) {
      var _t382 = _e399 * o[0];

      for (var _e400 = 0; _e400 < d; _e400++) {
        var _n257 = _e400 * b,
            _s199 = Math.floor(_n257),
            _r148 = Math.min(Math.ceil(_n257), u - 1),
            _a102 = _t382 + _s199 * o[1],
            _i93 = _t382 + _r148 * o[1],
            _l43 = _n257 - _s199,
            _d20 = 1 - _l43;

        for (var _e401 = 0; _e401 < p; _e401++) {
          var _t383 = _e401 * x,
              _n258 = Math.floor(_t383),
              _s200 = Math.min(Math.ceil(_t383), c - 1),
              _r149 = _t383 - _n258,
              _u28 = 1 - _r149,
              _p14 = _a102 + _n258 * o[2],
              _g19 = _a102 + _s200 * o[2],
              _m12 = _i93 + _n258 * o[2],
              _b12 = _i93 + _s200 * o[2],
              _w8 = _d20 * _u28,
              _v6 = _d20 * _r149,
              _I5 = _l43 * _u28,
              _$3 = _l43 * _r149;

          for (var _e402 = 0; _e402 < h; _e402++) {
            var _t384 = y[k++];
            f[_p14 + _e402] += _t384 * _w8, f[_g19 + _e402] += _t384 * _v6, f[_m12 + _e402] += _t384 * _I5, f[_b12 + _e402] += _t384 * _$3;
          }
        }
      }
    }

    return n.makeTensorInfo([l, c, u, h], "float32", f);
  }
},
    Xx = {
  kernelName: "ResizeNearestNeighbor",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = s.alignCorners,
        i = s.halfPixelCenters,
        o = s.size;
    zf(r, "resizeNearestNeighbor");

    var l = A(r.shape),
        _o59 = _slicedToArray(o, 2),
        u = _o59[0],
        c = _o59[1],
        _r$shape4 = _slicedToArray(r.shape, 4),
        h = _r$shape4[0],
        d = _r$shape4[1],
        p = _r$shape4[2],
        f = _r$shape4[3],
        g = n.data.get(r.dataId).values,
        m = new Float32Array(h * u * c * f),
        b = [a && u > 1 ? d - 1 : d, a && c > 1 ? p - 1 : p],
        x = [a && u > 1 ? u - 1 : u, a && c > 1 ? c - 1 : c],
        y = b[0] / x[0],
        k = b[1] / x[1];

    var w = 0;

    for (var _e403 = 0; _e403 < h; _e403++) {
      var _t385 = _e403 * l[0];

      for (var _e404 = 0; _e404 < u; _e404++) {
        var _n259 = i ? y * (_e404 + .5) : y * _e404;

        var _s201 = Math.min(d - 1, a ? Math.round(_n259) : Math.floor(_n259));

        i && (_s201 = Math.max(0, _s201));

        var _r150 = _t385 + _s201 * l[1];

        for (var _e405 = 0; _e405 < c; _e405++) {
          var _t386 = i ? k * (_e405 + .5) : k * _e405;

          var _n260 = Math.min(p - 1, a ? Math.round(_t386) : Math.floor(_t386));

          i && (_n260 = Math.max(0, _n260));

          var _s202 = _r150 + _n260 * l[2];

          for (var _e406 = 0; _e406 < f; _e406++) {
            m[w++] = g[_s202 + _e406];
          }
        }
      }
    }

    return n.makeTensorInfo([h, u, c, f], r.dtype, m);
  }
},
    Yx = {
  kernelName: "ResizeNearestNeighborGrad",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = t.dy,
        i = s.alignCorners;
    zf([a, r], "resizeNearestNeighborGrad");

    var o = A(r.shape),
        l = A(a.shape),
        _r$shape5 = _slicedToArray(r.shape, 4),
        u = _r$shape5[0],
        c = _r$shape5[1],
        h = _r$shape5[2],
        d = _r$shape5[3],
        _a$shape2 = _slicedToArray(a.shape, 3),
        p = _a$shape2[1],
        f = _a$shape2[2],
        g = new Float32Array(u * c * h * d),
        m = n.data.get(a.dataId).values,
        b = [i && p > 1 ? c - 1 : c, i && f > 1 ? h - 1 : h],
        x = [i && p > 1 ? p - 1 : p, i && f > 1 ? f - 1 : f],
        y = b[0] / x[0],
        k = b[1] / x[1],
        w = 1 / y,
        v = 1 / k,
        I = 2 * Math.ceil(w) + 2,
        $ = 2 * Math.ceil(v) + 2;

    for (var _e407 = 0; _e407 < u; _e407++) {
      var _t387 = _e407 * o[0];

      for (var _e408 = 0; _e408 < c; _e408++) {
        var _n261 = _t387 + _e408 * o[1],
            _s203 = Math.floor(_e408 * w),
            _r151 = Math.floor(_s203 - I / 2);

        for (var _s204 = 0; _s204 < h; _s204++) {
          var _a103 = _n261 + _s204 * o[2],
              _u29 = Math.floor(_s204 * v),
              _b13 = Math.floor(_u29 - $ / 2);

          for (var _n262 = 0; _n262 < d; _n262++) {
            var _o60 = 0;

            for (var _a104 = 0; _a104 < I; _a104++) {
              var _u30 = _a104 + _r151;

              if (_u30 < 0 || _u30 >= p) continue;

              var _d21 = _t387 + _u30 * l[1],
                  _g20 = _u30 * y;

              if (_e408 === Math.min(c - 1, i ? Math.round(_g20) : Math.floor(_g20))) for (var _e409 = 0; _e409 < $; _e409++) {
                var _t388 = _e409 + _b13;

                if (_t388 < 0 || _t388 >= f) continue;

                var _r152 = _d21 + _t388 * l[2],
                    _a105 = _t388 * k;

                _s204 === Math.min(h - 1, i ? Math.round(_a105) : Math.floor(_a105)) && (_o60 += m[_r152 + _n262]);
              }
            }

            g[_a103 + _n262] = _o60;
          }
        }
      }
    }

    return n.makeTensorInfo(r.shape, r.dtype, g);
  }
},
    Jx = {
  kernelName: "Reverse",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.dims;
    zf(r, "reverse");
    var i = r.shape.length,
        o = y(a, r.shape);
    if (0 === i) return qf({
      inputs: {
        x: r
      },
      backend: n
    });
    var l = new et(r.shape, r.dtype),
        u = n.bufferSync(r);

    var _loop31 = function _loop31(_e410) {
      var t = l.indexToLoc(_e410),
          n = t.slice();
      o.forEach(function (e) {
        return n[e] = r.shape[e] - 1 - n[e];
      }), l.set.apply(l, [u.get.apply(u, _toConsumableArray(n))].concat(_toConsumableArray(t)));
    };

    for (var _e410 = 0; _e410 < l.size; _e410++) {
      _loop31(_e410);
    }

    return n.makeTensorInfo(l.shape, l.dtype, l.values);
  }
},
    Zx = {
  kernelName: "RotateWithOffset",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref36) {
    var e = _ref36.inputs,
        t = _ref36.attrs,
        n = _ref36.backend;

    var s = e.image,
        r = t.radians,
        a = t.fillValue,
        i = t.center,
        o = n,
        l = w(s.dtype, d(s.shape)),
        _s$shape = _slicedToArray(s.shape, 4),
        u = _s$shape[0],
        c = _s$shape[1],
        h = _s$shape[2],
        p = _s$shape[3],
        _Eo = Eo(i, c, h),
        _Eo2 = _slicedToArray(_Eo, 2),
        f = _Eo2[0],
        g = _Eo2[1],
        m = Math.sin(r),
        b = Math.cos(r),
        x = o.data.get(s.dataId).values;

    for (var _e411 = 0; _e411 < u; _e411++) {
      var _t389 = _e411 * h * c * p;

      for (var _e412 = 0; _e412 < c; _e412++) {
        var _n263 = _e412 * (h * p);

        for (var _s205 = 0; _s205 < h; _s205++) {
          var _r153 = _s205 * p;

          for (var _i94 = 0; _i94 < p; _i94++) {
            var _o61 = [u, _e412, _s205, _i94],
                _d22 = _o61[2],
                _y10 = _o61[1];

            var _k8 = (_d22 - f) * b - (_y10 - g) * m,
                _w9 = (_d22 - f) * m + (_y10 - g) * b;

            _k8 = Math.round(_k8 + f), _w9 = Math.round(_w9 + g);
            var _v7 = a;
            "number" != typeof a && (_v7 = 3 === _i94 ? 255 : a[_i94]), _k8 >= 0 && _k8 < h && _w9 >= 0 && _w9 < c && (_v7 = x[_t389 + _w9 * (h * p) + _k8 * p + _i94]), l[_t389 + _n263 + _r153 + _i94] = _v7;
          }
        }
      }
    }

    return {
      dataId: o.write(l, s.shape, s.dtype),
      shape: s.shape,
      dtype: s.dtype
    };
  }
},
    Qx = {
  kernelName: "Round",
  backendName: "cpu",
  kernelFunc: og("Round", function (e) {
    var t = Math.floor(e);
    return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1;
  })
};

function ey(e, t, n, s, r, a, i, o, l, u) {
  var c = [s / r, r],
      h = e.values,
      d = t.values;
  if (0 === s) return dn(n, t.dtype);
  var p = dn(c, t.dtype);
  p.values.fill(l);

  for (var _e413 = 0; _e413 < a; _e413++) {
    var _a106 = [];
    var _l44 = 0;

    for (var _t390 = 0; _t390 < i; _t390++) {
      var _n264 = h[_e413 * i + _t390];
      _a106.push(_n264), _l44 += _n264 * o[_t390];
    }

    if (_l44 < 0 || _l44 >= s / r) throw new Error("Invalid indices: ".concat(_a106, " does not index into ").concat(n));

    for (var _n265 = 0; _n265 < r; _n265++) {
      u ? p.values[_l44 * r + _n265] += d[_e413 * r + _n265] : p.values[_l44 * r + _n265] = 0 === t.rank ? d[0] : d[_e413 * r + _n265];
    }
  }

  return p;
}

var ty = {
  kernelName: "ScatterNd",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.indices,
        a = t.updates,
        i = s.shape,
        _Sn = Sn(0, r, i),
        o = _Sn.sliceRank,
        l = _Sn.numUpdates,
        u = _Sn.sliceSize,
        c = _Sn.strides,
        h = _Sn.outputSize,
        d = ey(n.bufferSync(r), n.bufferSync(a), i, h, u, l, o, c, 0, !0);

    return n.makeTensorInfo(i, d.dtype, d.values);
  }
},
    ny = {
  kernelName: "Select",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.condition,
        r = t.t,
        a = t.e;
    zf([s, r, a], "select");
    var i = s.shape.length,
        o = n.data.get(s.dataId).values,
        l = n.data.get(r.dataId).values,
        u = n.data.get(a.dataId).values,
        c = dt(r.dtype, a.dtype),
        h = O(d(r.shape), c);
    var p = 0;
    var f = 0 === i || i > 1 || 1 === r.shape.length ? 1 : d(r.shape.slice(1));

    for (var _e414 = 0; _e414 < o.length; _e414++) {
      for (var _t391 = 0; _t391 < f; _t391++) {
        h[p++] = 1 === o[_e414] ? l[_e414] : u[_e414];
      }
    }

    return n.makeTensorInfo(r.shape, c, h);
  }
},
    sy = {
  kernelName: "Selu",
  backendName: "cpu",
  kernelFunc: og("Selu", function (e) {
    return e >= 0 ? 1.0507009873554805 * e : 1.7580993408473768 * (Math.exp(e) - 1);
  })
},
    ry = {
  kernelName: "Sign",
  backendName: "cpu",
  kernelFunc: og("Sign", function (e) {
    return e < 0 ? -1 : e > 0 ? 1 : 0;
  })
},
    ay = {
  kernelName: "Sin",
  backendName: "cpu",
  kernelFunc: og("Sin", function (e) {
    return Math.sin(e);
  })
},
    iy = {
  kernelName: "Sinh",
  backendName: "cpu",
  kernelFunc: og("Sinh", function (e) {
    return Math.sinh(e);
  })
},
    oy = Math.log(1.1920928955078125e-7) + 2,
    ly = {
  kernelName: "Softplus",
  backendName: "cpu",
  kernelFunc: og("Softplus", function (e) {
    var t = e > -oy,
        n = e < oy,
        s = Math.exp(e);
    var r;
    return r = n ? s : t ? e : Math.log(1 + s), r;
  })
},
    uy = {
  kernelName: "SpaceToBatchND",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.blockShape,
        i = s.paddings;
    zf([r], "spaceToBatchND");
    var o = d(a),
        l = [[0, 0]];
    l.push.apply(l, _toConsumableArray(i));

    for (var _e415 = 1 + a.length; _e415 < r.shape.length; ++_e415) {
      l.push([0, 0]);
    }

    var u = Vx.kernelFunc({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }),
        c = Ro(u.shape, a, o, !1),
        h = Ao(c.length, a.length, !1),
        p = Fo(u.shape, a, o, !1),
        f = Bm({
      inputs: {
        x: u
      },
      backend: n,
      attrs: {
        shape: c
      }
    }),
        g = Xg({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        perm: h
      }
    }),
        m = Bm({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        shape: p
      }
    });
    return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(g), m;
  }
},
    cy = {
  kernelName: "SparseFillEmptyRows",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.indices,
        r = t.values,
        a = t.denseShape,
        i = t.defaultValue;
    if (1 !== a.shape.length) throw new Error("Dense shape must be a vector, saw:\n        ".concat(a.shape));
    if (2 !== s.shape.length) throw new Error("Indices must be a matrix, saw:\n        ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));
    if (0 !== i.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));

    var o = n.data.get(s.dataId).values,
        l = n.data.get(r.dataId).values,
        u = n.data.get(a.dataId).values,
        c = n.data.get(i.dataId).values[0],
        _am = am(o, s.shape, s.dtype, l, r.dtype, u, c),
        _am2 = _slicedToArray(_am, 5),
        h = _am2[0],
        d = _am2[1],
        p = _am2[2],
        f = _am2[3],
        g = _am2[4];

    return [n.makeTensorInfo(d, s.dtype, h), n.makeTensorInfo([d[0]], r.dtype, p), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map(function (e) {
      return Number(e);
    }))), n.makeTensorInfo([g.length], s.dtype, new Int32Array(g))];
  }
},
    hy = {
  kernelName: "SparseReshape",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.inputIndices,
        r = t.inputShape,
        a = t.newShape;
    if (2 !== s.shape.length) throw new Error("Input indices should be a matrix but received shape\n        ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(a.shape));

    var i = Array.from(n.data.get(r.dataId).values),
        o = n.data.get(s.dataId).values,
        l = Array.from(n.data.get(a.dataId).values),
        _im = im(o, s.shape, s.dtype, i, l),
        _im2 = _slicedToArray(_im, 3),
        u = _im2[0],
        c = _im2[1],
        h = _im2[2];

    return [n.makeTensorInfo(c, s.dtype, u), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))];
  }
},
    dy = {
  kernelName: "SparseSegmentMean",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.data,
        r = t.indices,
        a = t.segmentIds;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n          ".concat(a.shape));

    var i = n.data.get(s.dataId).values,
        o = n.data.get(r.dataId).values,
        l = n.data.get(a.dataId).values,
        _om = om(i, s.shape, s.dtype, o, l, !0),
        _om2 = _slicedToArray(_om, 2),
        u = _om2[0],
        c = _om2[1];

    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    py = {
  kernelName: "SparseSegmentSum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.data,
        r = t.indices,
        a = t.segmentIds;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n         ".concat(a.shape));

    var i = n.data.get(s.dataId).values,
        o = n.data.get(r.dataId).values,
        l = n.data.get(a.dataId).values,
        _om3 = om(i, s.shape, s.dtype, o, l),
        _om4 = _slicedToArray(_om3, 2),
        u = _om4[0],
        c = _om4[1];

    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    fy = {
  kernelName: "SparseToDense",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.sparseIndices,
        a = t.sparseValues,
        i = t.defaultValue,
        o = s.outputShape,
        _Sn2 = Sn(0, r, o),
        l = _Sn2.sliceRank,
        u = _Sn2.numUpdates,
        c = _Sn2.sliceSize,
        h = _Sn2.strides,
        d = _Sn2.outputSize,
        p = ey(n.bufferSync(r), n.bufferSync(a), o, d, c, u, l, h, n.data.get(i.dataId).values[0], !1);

    return n.makeTensorInfo(o, p.dtype, p.values);
  }
},
    gy = {
  kernelName: "SplitV",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.numOrSizeSplits,
        i = s.axis,
        o = y(i, r.shape)[0],
        l = Jo(r, a, o),
        u = new Array(r.shape.length).fill(0),
        c = r.shape.slice();
    return l.map(function (e) {
      var t = _toConsumableArray(c);

      t[o] = e;
      var s = sm({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: u,
          size: t
        }
      });
      return u[o] += e, s;
    });
  }
},
    my = {
  kernelName: "Sqrt",
  backendName: "cpu",
  kernelFunc: og("Sqrt", function (e) {
    return Math.sqrt(e);
  })
},
    by = {
  kernelName: "Square",
  backendName: "cpu",
  kernelFunc: function kernelFunc(_ref37) {
    var e = _ref37.inputs,
        t = _ref37.backend;
    var n = e.x,
        s = t;
    zf(n, "square");
    var r = s.data.get(n.dataId).values,
        a = new Float32Array(r.length);

    for (var _e416 = 0; _e416 < r.length; ++_e416) {
      var _t392 = r[_e416];
      a[_e416] = _t392 * _t392;
    }

    return {
      dataId: s.write(a, n.shape, n.dtype),
      shape: n.shape,
      dtype: n.dtype
    };
  }
},
    xy = {
  kernelName: "Step",
  backendName: "cpu",
  kernelFunc: og("Step", function (e, t) {
    var n = t;
    return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha;
  })
},
    yy = {
  kernelName: "StridedSlice",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.begin,
        i = s.end,
        o = s.strides,
        l = s.beginMask,
        u = s.endMask,
        c = s.ellipsisMask,
        h = s.newAxisMask,
        d = s.shrinkAxisMask;
    zf(r, "stridedSlice");

    var _Vn = Vn(r.shape, a, i, o, l, u, c, h, d),
        p = _Vn.nonStrided,
        f = _Vn.$begin,
        g = _Vn.$strides,
        m = _Vn.size,
        b = _Vn.newShape,
        x = _Vn.outShape,
        y = Bm({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: b
      }
    });

    var k;

    if (p) {
      var _e417 = sm({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          begin: f,
          size: m
        }
      });

      k = Bm({
        inputs: {
          x: _e417
        },
        backend: n,
        attrs: {
          shape: x
        }
      }), n.disposeIntermediateTensorInfo(_e417);
    } else if (x.some(function (e) {
      return 0 === e;
    })) k = n.makeTensorInfo(x, r.dtype, []);else {
      var _e418 = cm(x, n.bufferSync(y), g, f);

      k = n.makeTensorInfo(_e418.shape, _e418.dtype, _e418.values);
    }

    var w = Bm({
      inputs: {
        x: k
      },
      backend: n,
      attrs: {
        shape: x
      }
    });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(k), w;
  }
},
    ky = {
  kernelName: "StringNGrams",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.separator,
        a = s.nGramWidths,
        i = s.leftPad,
        o = s.rightPad,
        l = s.padWidth,
        u = s.preserveShortSequences,
        c = t.data,
        h = t.dataSplits,
        d = n.data.get(c.dataId).values,
        p = n.data.get(h.dataId).values,
        _dm = dm(d, p, r, a, i, o, l, u),
        _dm2 = _slicedToArray(_dm, 2),
        f = _dm2[0],
        g = _dm2[1];

    return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", g)];
  }
},
    wy = {
  kernelName: "StringSplit",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.skipEmpty,
        a = t.input,
        i = t.delimiter;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
    if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));

    var o = n.data.get(a.dataId).values,
        l = n.data.get(i.dataId).values[0],
        _fm = fm(o, l, r),
        _fm2 = _slicedToArray(_fm, 3),
        u = _fm2[0],
        c = _fm2[1],
        h = _fm2[2],
        d = c.length;

    return [n.makeTensorInfo([d, 2], "int32", u), n.makeTensorInfo([d], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))];
  }
},
    vy = {
  kernelName: "StringToHashBucketFast",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.numBuckets,
        a = t.input;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (r <= 0) throw new Error("Number of buckets must be at least 1");
    var i = gm(n.data.get(a.dataId).values, r);
    return n.makeTensorInfo(a.shape, "int32", i);
  }
},
    Iy = {
  kernelName: "Tan",
  backendName: "cpu",
  kernelFunc: og("Tan", function (e) {
    return Math.tan(e);
  })
},
    $y = og("Tanh", function (e) {
  return Math.tanh(e);
});

function Ny(e, t, n) {
  switch (n) {
    case "reflect":
      return function (e, t) {
        var n = e;
        if (n < 0) {
          if (t <= 1) n = 0;else {
            var _e419 = 2 * t;

            n < _e419 && (n = _e419 * Math.trunc(-n / _e419) + n), n = n < -t ? n + _e419 : -n - 1;
          }
        } else if (n > t - 1) if (t <= 1) n = 0;else {
          var _e420 = 2 * t;

          n -= _e420 * Math.trunc(n / _e420), n >= t && (n = _e420 - n - 1);
        }
        return a(0, n, t - 1);
      }(e, t);

    case "wrap":
      return function (e, t) {
        var n = e;
        return n < 0 ? t <= 1 ? n = 0 : n += t * (Math.trunc(-n / (t - 1)) + 1) : n > t - 1 && (t <= 1 ? n = 0 : n -= t * Math.trunc(n / (t - 1))), a(0, n, t - 1);
      }(e, t);

    case "nearest":
      return function (e, t) {
        return a(0, e, t - 1);
      }(e, t);

    case "constant":
    default:
      return function (e, t) {
        return e;
      }(e);
  }
}

function Cy(e, t, n, s, r, a, i, o, l, u, c) {
  return 0 <= o && o < t && 0 <= l && l < n ? e[i * s + o * r + l * a + u] : c;
}

function Sy(e, t, n, s, r, a, i, o, l, u, c) {
  return Cy(e, t, n, s, r, a, i, Math.round(o), Math.round(l), u, c);
}

function Ty(e, t, n, s, r, a, i, o, l, u, c) {
  var h = Math.floor(o),
      d = Math.floor(l),
      p = h + 1,
      f = d + 1;
  return (p - o) * ((f - l) * Cy(e, t, n, s, r, a, i, h, d, u, c) + (l - d) * Cy(e, t, n, s, r, a, i, h, f, u, c)) + (o - h) * ((f - l) * Cy(e, t, n, s, r, a, i, p, d, u, c) + (l - d) * Cy(e, t, n, s, r, a, i, p, f, u, c));
}

var Ey = [Vm, Uf, Gm, Hm, sg, jm, qm, Km, Xm, Ym, Jm, Zm, Qm, eb, tb, ab, ib, ob, lb, Um, ub, cb, hb, Zf, cg, db, Hf, pb, bb, kb, wb, yb, Ib, $b, vb, Nb, Cb, Sb, Tb, Eb, Rb, Fb, Db, _b, Ob, Mb, zb, Lb, qb, Wb, Cm, Ub, fg, Vb, bg, Hb, yg, Jb, Qb, ex, wg, tx, nx, sx, rx, ax, Ng, Sg, Kf, ix, gb, ox, lx, ux, Tm, Eg, Ag, cx, _g, hx, dx, px, fx, gx, mx, Lg, yx, kx, wx, vx, Ix, xx, $x, Nx, Bg, Cx, Sx, Rx, Vg, Hg, Fx, _x, Mx, qg, Lx, Px, Ux, Vx, Gx, Am, Zg, Hx, Yf, jx, Dm, Om, Pm, qx, Kx, Xx, Yx, Jx, Zx, Qx, tm, ty, ny, sy, Lm, ry, ay, iy, rm, Ex, ly, uy, cy, hy, dy, py, fy, gy, my, by, um, xy, yy, ky, wy, vy, xm, Pb, Iy, {
  kernelName: "Tanh",
  backendName: "cpu",
  kernelFunc: $y
}, {
  kernelName: "Tile",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.reps;
    zf(r, "tile");
    var i = ym(n.bufferSync(r), a);
    return n.makeTensorInfo(i.shape, i.dtype, i.values);
  }
}, {
  kernelName: "TopK",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.k,
        i = s.sorted;
    zf(r, "topk");

    var o = n.data.get(r.dataId).values,
        _vm = vm(o, r.shape, r.dtype, a, i),
        _vm2 = _slicedToArray(_vm, 2),
        l = _vm2[0],
        u = _vm2[1];

    return [n.makeTensorInfo(l.shape, l.dtype, l.values), n.makeTensorInfo(u.shape, u.dtype, u.values)];
  }
}, Yg, {
  kernelName: "Transform",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.attrs,
        s = e.backend,
        r = t.image,
        a = t.transforms,
        i = n.interpolation,
        o = n.fillMode,
        l = n.fillValue,
        u = n.outputShape,
        _r$shape6 = _slicedToArray(r.shape, 4),
        c = _r$shape6[0],
        h = _r$shape6[1],
        p = _r$shape6[2],
        f = _r$shape6[3],
        _ref38 = null != u ? u : [h, p],
        _ref39 = _slicedToArray(_ref38, 2),
        g = _ref39[0],
        m = _ref39[1],
        b = [c, g, m, f],
        x = A(r.shape),
        y = x[0],
        k = x[1],
        v = x[2],
        I = w(r.dtype, d(b));

    I.fill(l);
    var $ = s.data.get(r.dataId).values,
        N = s.data.get(a.dataId).values;

    for (var _e421 = 0; _e421 < c; ++_e421) {
      var _t393 = 1 === a.shape[0] ? N : N.subarray(8 * _e421, 8 * _e421 + 8);

      for (var _n266 = 0; _n266 < g; ++_n266) {
        for (var _s206 = 0; _s206 < m; ++_s206) {
          for (var _r154 = 0; _r154 < f; ++_r154) {
            var _a107 = void 0;

            var _u31 = _t393[6] * _s206 + _t393[7] * _n266 + 1;

            if (0 === _u31) continue;

            var _c25 = (_t393[3] * _s206 + _t393[4] * _n266 + _t393[5]) / _u31,
                _d23 = Ny((_t393[0] * _s206 + _t393[1] * _n266 + _t393[2]) / _u31, p, o),
                _f10 = Ny(_c25, h, o);

            switch (i) {
              case "nearest":
                _a107 = Sy($, h, p, y, k, v, _e421, _f10, _d23, _r154, l);
                break;

              case "bilinear":
                _a107 = Ty($, h, p, y, k, v, _e421, _f10, _d23, _r154, l);
                break;

              default:
                throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got ".concat(i));
            }

            I[_e421 * y + _n266 * k + _s206 * v + _r154] = _a107;
          }
        }
      }

      return s.makeTensorInfo(b, r.dtype, I);
    }

    return {
      dataId: s.write(I, b, r.dtype),
      shape: r.shape,
      dtype: r.dtype
    };
  }
}, {
  kernelName: "Unique",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.attrs,
        s = e.backend,
        r = n.axis,
        a = t.x;
    zf(a, "unique");

    var i = s.data.get(a.dataId).values,
        _Im = Im(i, r, a.shape, a.dtype),
        o = _Im.outputValues,
        l = _Im.outputShape,
        u = _Im.indices;

    return [s.makeTensorInfo(l, a.dtype, o), s.makeTensorInfo([u.length], "int32", u)];
  }
}, {
  kernelName: "Unpack",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.value;
    var a = s.axis;
    a < 0 && (a += r.shape.length);
    var i = r.shape.length,
        o = r.shape[a],
        l = new Array(i - 1);
    var u = 0;

    for (var _e422 = 0; _e422 < i; _e422++) {
      _e422 !== a && (l[u++] = r.shape[_e422]);
    }

    var c = new Array(i).fill(0),
        h = r.shape.slice();
    h[a] = 1;
    var d = new Array(o);

    for (var _e423 = 0; _e423 < d.length; _e423++) {
      c[a] = _e423;

      var _t394 = sm({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: c,
          size: h
        }
      });

      d[_e423] = Bm({
        inputs: {
          x: _t394
        },
        backend: n,
        attrs: {
          shape: l
        }
      }), n.disposeIntermediateTensorInfo(_t394);
    }

    return d;
  }
}, {
  kernelName: "UnsortedSegmentSum",
  backendName: "cpu",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.segmentIds,
        i = s.numSegments;
    zf(r, "unsortedSegmentSum");
    var o = [],
        l = [],
        u = r.shape.length - a.shape.length;
    var c = a;

    for (var _e424 = 0; _e424 < u; ++_e424) {
      var _t395 = Gb({
        inputs: {
          input: c
        },
        backend: n,
        attrs: {
          dim: _e424 + 1
        }
      });

      c = _t395, l.push(_t395);
    }

    for (var _e425 = 0; _e425 < i; ++_e425) {
      var _t396 = We(_e425, "int32"),
          _s207 = n.makeTensorInfo([], "int32", _t396),
          _a108 = pg({
        inputs: {
          a: _s207,
          b: c
        },
        backend: n
      }),
          _i95 = Jf({
        inputs: {
          x: _a108
        },
        backend: n,
        attrs: {
          dtype: "float32"
        }
      }),
          _u32 = Ug({
        inputs: {
          a: _i95,
          b: r
        },
        backend: n
      }),
          _h14 = Bb({
        inputs: {
          x: _u32
        },
        backend: n,
        attrs: {
          axis: 0,
          keepDims: !1
        }
      });

      o.push(_h14), l.push(_s207), l.push(_a108), l.push(_i95), l.push(_u32), l.push(_h14);
    }

    var h = Wx({
      inputs: o,
      backend: n,
      attrs: {
        axis: 0
      }
    });
    return l.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), h;
  }
}, Bx];

for (var _i96 = 0, _Ey = Ey; _i96 < _Ey.length; _i96++) {
  var _e426 = _Ey[_i96];
  Q(_e426);
}

var Ry = {},
    Ay = {
  alpha: !1,
  antialias: !1,
  premultipliedAlpha: !1,
  preserveDrawingBuffer: !1,
  depth: !1,
  stencil: !1,
  failIfMajorPerformanceCaveat: !0
};

function Fy(e) {
  if (!(e in Ry)) {
    var _t397 = function (e) {
      if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");

      var t = function (e) {
        if ("undefined" != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150);
        if ("undefined" != typeof document) return document.createElement("canvas");
        throw new Error("Cannot create a canvas in this context");
      }(e);

      return t.addEventListener("webglcontextlost", function (t) {
        t.preventDefault(), delete Ry[e];
      }, !1), 1 === e ? t.getContext("webgl", Ay) || t.getContext("experimental-webgl", Ay) : t.getContext("webgl2", Ay);
    }(e);

    if (null === _t397) return console.log("Could not get context for WebGL version", e), null;
    Ry[e] = _t397;
  }

  var t = Ry[e];
  return t.isContextLost() ? (delete Ry[e], Fy(e)) : (t.disable(t.DEPTH_TEST), t.disable(t.STENCIL_TEST), t.disable(t.BLEND), t.disable(t.DITHER), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SAMPLE_COVERAGE), t.enable(t.SCISSOR_TEST), t.enable(t.CULL_FACE), t.cullFace(t.BACK), Ry[e]);
}

var Dy, _y, Oy;

function My(e, t) {
  return [t, e];
}

function Ly(e) {
  var t = d(e);
  return g(Math.ceil(t / 4));
}

function zy(e, t) {
  return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))];
}

function By(e, t) {
  var n = e;
  var s, r, a, i, o, l, u, c, h, d;
  return 2 === V().getNumber("WEBGL_VERSION") ? (s = n.R32F, r = n.R16F, a = n.RGBA16F, i = n.RGBA32F, o = n.RED, u = 4, c = 1, h = n.HALF_FLOAT, d = n.FLOAT) : (s = e.RGBA, r = e.RGBA, a = e.RGBA, i = n.RGBA, o = e.RGBA, u = 4, c = 4, h = null != t ? t.HALF_FLOAT_OES : null, d = e.FLOAT), l = e.RGBA, {
    internalFormatFloat: s,
    internalFormatHalfFloat: r,
    internalFormatPackedHalfFloat: a,
    internalFormatPackedFloat: i,
    textureFormatFloat: o,
    downloadTextureFormat: l,
    downloadUnpackNumChannels: u,
    defaultNumChannels: c,
    textureTypeHalfFloat: h,
    textureTypeFloat: d
  };
}

function Py(e, t) {
  var n = t();
  return V().getBool("DEBUG") && function (e) {
    var t = e.getError();
    if (t !== e.NO_ERROR) throw new Error("WebGL Error: " + function (e, t) {
      switch (t) {
        case e.NO_ERROR:
          return "NO_ERROR";

        case e.INVALID_ENUM:
          return "INVALID_ENUM";

        case e.INVALID_VALUE:
          return "INVALID_VALUE";

        case e.INVALID_OPERATION:
          return "INVALID_OPERATION";

        case e.INVALID_FRAMEBUFFER_OPERATION:
          return "INVALID_FRAMEBUFFER_OPERATION";

        case e.OUT_OF_MEMORY:
          return "OUT_OF_MEMORY";

        case e.CONTEXT_LOST_WEBGL:
          return "CONTEXT_LOST_WEBGL";

        default:
          return "Unknown error code ".concat(t);
      }
    }(e, t));
  }(e), n;
}

function Wy(e) {
  return !!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e || 5.96e-8 < Math.abs(e) && Math.abs(e) < 65504);
}

function Uy(e, t) {
  return Xy(e, function () {
    return e.getExtension(t);
  }, 'Extension "' + t + '" not supported on this browser.');
}

!function (e) {
  e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Dy || (Dy = {})), function (e) {
  e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD";
}(_y || (_y = {})), function (e) {
  e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Oy || (Oy = {}));
var Vy = /ERROR: [0-9]+:([0-9]+):/g;

function Gy(e, t) {
  if (Py(e, function () {
    return e.validateProgram(t);
  }), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}

function Hy(e, t, n, s, r, a, i) {
  var o = e.getAttribLocation(t, n);
  return -1 !== o && (Py(e, function () {
    return e.bindBuffer(e.ARRAY_BUFFER, s);
  }), Py(e, function () {
    return e.vertexAttribPointer(o, r, e.FLOAT, !1, a, i);
  }), Py(e, function () {
    return e.enableVertexAttribArray(o);
  }), !0);
}

function jy(e, t, n) {
  Py(e, function () {
    return e.bindFramebuffer(e.FRAMEBUFFER, n);
  }), Py(e, function () {
    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
  });
}

function qy(e, t) {
  Py(e, function () {
    return e.bindFramebuffer(e.FRAMEBUFFER, t);
  }), Py(e, function () {
    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0);
  });
}

function Ky(e) {
  var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
  if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + function (e, t) {
    switch (t) {
      case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

      case e.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";

      default:
        return "unknown error ".concat(t);
    }
  }(e, t));
}

function Xy(e, t, n) {
  var s = Py(e, function () {
    return t();
  });
  if (null == s) throw new Error(n);
  return s;
}

function Yy(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return d(e.slice(0, e.length - t));
}

function Jy(e) {
  if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
}

function Zy(e) {
  var t = [1, 1, 1];
  return 0 === e.length || 1 === e.length && 1 === e[0] || (t = [Yy(e)].concat(_toConsumableArray(Jy(e)))), t;
}

function Qy(e) {
  return e % 2 == 0;
}

function ek(e, t) {
  if (p(e = e.slice(-2), t = t.slice(-2))) return !0;
  if (!e.length || !t.length) return !0;
  if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;

  if (e.length !== t.length) {
    var _n267 = e.slice(-1)[0],
        _s208 = t.slice(-1)[0];
    if (_n267 === _s208) return !0;
    if (Qy(_n267) && Qy(_s208) && (1 === e[0] || 1 === t[0])) return !0;
  }

  return e[1] === t[1] && Qy(e[0]) && Qy(t[0]);
}

var tk, nk;

function sk(e, t) {
  return null != e.getExtension(t);
}

function rk(e) {
  try {
    if (null != Fy(e)) return !0;
  } catch (e) {
    return console.log("Error when getting WebGL context: ", e), !1;
  }

  return !1;
}

function ak(e) {
  var t = By(e),
      n = e.createTexture();
  e.bindTexture(e.TEXTURE_2D, n), e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
  var s = e.createFramebuffer();
  e.bindFramebuffer(e.FRAMEBUFFER, s), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
  var r = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(s), r;
}

function ik(e, t) {
  Array.isArray(e) || (e = [e]), e.forEach(function (e) {
    null != e && l("complex64" !== e.dtype, function () {
      return "".concat(t, " does not support complex64 tensors in the WebGL backend.");
    });
  });
}

var ok = V();

function lk() {
  var e, t, n, s, r, a, i, o, l, u;
  return 2 === V().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", t = "in", n = "out", s = "in", r = "texture", a = "outputColor", i = "out vec4 outputColor;", o = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", l = "", u = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", t = "attribute", n = "varying", s = "varying", r = "texture2D", a = "gl_FragColor", i = "", o = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", l = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", u = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
    version: e,
    attribute: t,
    varyingVs: n,
    varyingFs: s,
    texture2D: r,
    output: a,
    defineOutput: i,
    defineSpecialNaN: o,
    defineSpecialInf: l,
    defineRound: u
  };
}

function uk(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";
  var s = A(t);
  return s.map(function (t, r) {
    return "int ".concat(e[r], " = ").concat(n, " / ").concat(t, "; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * ").concat(t) : "index -= ".concat(e[r], " * ").concat(t), ";");
  }).join("");
}

function ck(e, t) {
  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "index";
  var s = A(t);
  return s.map(function (t, r) {
    return "int ".concat(e[r], " = ").concat(n, " / outShapeStrides[").concat(r, "]; ").concat(r === s.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * outShapeStrides[").concat(r, "]") : "index -= ".concat(e[r], " * outShapeStrides[").concat(r, "]"), ";");
  }).join("");
}

function hk(e) {
  var t = A(e).map(function (e) {
    return e.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0], " + coords.y * ").concat(t[1], " + coords.z;\n  }\n");
}

ok.registerFlag("HAS_WEBGL", function () {
  return ok.getNumber("WEBGL_VERSION") > 0;
}), ok.registerFlag("WEBGL_VERSION", function () {
  return rk(2) ? 2 : rk(1) ? 1 : 0;
}), ok.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", function () {
  return !1;
}), ok.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
  return 2 === ok.get("WEBGL_VERSION");
}), ok.registerFlag("WEBGL_CPU_FORWARD", function () {
  return !0;
}), ok.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
  return !1;
}), ok.registerFlag("WEBGL_PACK", function () {
  return ok.getBool("HAS_WEBGL");
}), ok.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_CLIP", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_PACK_REDUCE", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_LAZILY_UNPACK", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_CONV_IM2COL", function () {
  return ok.getBool("WEBGL_PACK");
}), ok.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
  return function (e) {
    if (null == tk) {
      var _t398 = Fy(e);

      tk = _t398.getParameter(_t398.MAX_TEXTURE_SIZE);
    }

    return tk;
  }(ok.getNumber("WEBGL_VERSION"));
}), ok.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
  return function (e) {
    if (null == nk) {
      var _t399 = Fy(e);

      nk = _t399.getParameter(_t399.MAX_TEXTURE_IMAGE_UNITS);
    }

    return Math.min(16, nk);
  }(ok.getNumber("WEBGL_VERSION"));
}), ok.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
  var e = ok.getNumber("WEBGL_VERSION");
  return 0 === e ? 0 : function (e) {
    if (0 === e) return 0;
    var t;
    var n = Fy(e);
    return t = sk(n, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : sk(n, "EXT_disjoint_timer_query") ? 1 : 0, t;
  }(e);
}), ok.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
  return ok.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !It();
}), ok.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
  return function (e) {
    if (0 === e) return !1;
    var t = Fy(e);

    if (1 === e) {
      if (!sk(t, "OES_texture_float")) return !1;
    } else if (!sk(t, "EXT_color_buffer_float")) return !1;

    return ak(t);
  }(ok.getNumber("WEBGL_VERSION"));
}), ok.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
  return !ok.getBool("WEBGL_FORCE_F16_TEXTURES") && ok.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), ok.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
  return function (e) {
    if (0 === e) return !1;
    var t = Fy(e);

    if (1 !== e) {
      if (sk(t, "EXT_color_buffer_float")) return ak(t);
      var _e427 = "EXT_color_buffer_half_float";

      if (sk(t, _e427)) {
        var _n268 = t.getExtension(_e427);

        return function (e, t) {
          var n = By(e, t),
              s = e.createTexture();
          e.bindTexture(e.TEXTURE_2D, s), e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
          var r = e.createFramebuffer();
          e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, s, 0);
          var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
          return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(s), e.deleteFramebuffer(r), a;
        }(t, _n268);
      }

      return !1;
    }

    return !!sk(t, "OES_texture_float") && !!sk(t, "WEBGL_color_buffer_float") && ak(t);
  }(ok.getNumber("WEBGL_VERSION"));
}), ok.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
  return 2 === (e = ok.getNumber("WEBGL_VERSION")) && null != Fy(e).fenceSync;
  var e;
}), ok.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
  return ok.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), ok.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", function () {
  return -1;
}, function (e) {
  if (e < 0 && -1 !== e) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ".concat(e, "."));
}), ok.registerFlag("WEBGL_FLUSH_THRESHOLD", function () {
  return It() && ok.getBool("IS_CHROME") ? 1 : -1;
}, function (e) {
  if (e < 0 && -1 !== e) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ".concat(e, "."));
}), ok.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", function () {
  return 128;
}), ok.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", function () {
  return !1;
}), ok.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", function () {
  return 1e5;
}), ok.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", function () {
  return 128;
});
var dk = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";

var pk = function pk(e) {
  "use strict";

  _classCallCheck(this, pk);

  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Dy.DENSE;
  var t = Ly(e),
      n = lk();
  this.outputShape = e, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(uk(["r", "c", "d"], e), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(").concat(t[0], ", ").concat(t[1], "));\n        int index = 4 * (resTexRC.x * ").concat(t[1], " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ");
};

var fk = function fk(e) {
  "use strict";

  _classCallCheck(this, fk);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Dy.DENSE;
  var t = Ly(e),
      n = lk();
  this.outputShape = e, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(uk(["r", "c", "d"], e), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(").concat(t[0], ", ").concat(t[1], "));\n        int index = 4 * (resTexRC.x * ").concat(t[1], " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ");
};

var gk = function gk(e) {
  "use strict";

  _classCallCheck(this, gk);

  this.variableNames = ["A"], this.outTexUsage = _y.DOWNLOAD;
  var t = lk();
  this.outputShape = e, this.userCode = "\n      ".concat(dk, "\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output, " = encode_float(x);\n      }\n    ");
};

var mk = function mk(e) {
  "use strict";

  _classCallCheck(this, mk);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = _y.DOWNLOAD;
  var t = lk();
  this.outputShape = e, this.userCode = "\n      ".concat(dk, "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output, " = encode_float(x);\n      }\n    ");
};

var bk = /*#__PURE__*/function () {
  "use strict";

  function bk(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;

    _classCallCheck(this, bk);

    this.variableNames = ["A"];

    var s = lk(),
        _t400 = _slicedToArray(t, 2),
        r = _t400[0],
        a = _t400[1];

    this.outputShape = e;
    var i = "result";
    n && (i = "floor(result * 255. + 0.5)"), this.userCode = "\n      ".concat(hk(e), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ").concat(a, ";\n        int c = imod(flatIndex, ").concat(a, ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(").concat(a, ".0, ").concat(r, ".0);\n        vec4 values = ").concat(s.texture2D, "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ").concat(s.output, " = vec4(").concat(i, ", 0., 0., 0.);\n      }\n    ");
  }

  return bk;
}();

var xk = /*#__PURE__*/function () {
  "use strict";

  function xk(e, t) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;

    _classCallCheck(this, xk);

    this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;

    var s = lk(),
        _t401 = _slicedToArray(t, 2),
        r = _t401[0],
        a = _t401[1];

    this.outputShape = e;
    var i = "",
        o = "result";
    n && (o = "floor(result * 255. + 0.5)");

    for (var _t402 = 0; _t402 <= 1; _t402++) {
      for (var _n269 = 0; _n269 <= 1; _n269++) {
        var _o62 = 2 * _t402 + _n269;

        i += "\n          localCoords = coords;\n          if(localCoords[2] + ".concat(_n269, " < ").concat(e[2], ") {\n            localCoords[2] += ").concat(_n269, ";\n            if(localCoords[1] + ").concat(_t402, " < ").concat(e[1], ") {\n              localCoords[1] += ").concat(_t402, ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ").concat(a, ";\n              c = imod(flatIndex, ").concat(a, ");\n              uv = (vec2(c, r) + halfCR) / vec2(").concat(a, ".0, ").concat(r, ".0);\n              values = ").concat(s.texture2D, "(A, uv);\n\n              if(offset == 0) {\n                result[").concat(_o62, "] = values[0];\n              } else if(offset == 1) {\n                result[").concat(_o62, "] = values[1];\n              } else if(offset == 2) {\n                result[").concat(_o62, "] = values[2];\n              } else {\n                result[").concat(_o62, "] = values[3];\n              }\n            }\n          }\n        ");
      }
    }

    this.userCode = "\n      ".concat(hk(e), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ").concat(i, "\n\n        ").concat(s.output, " = ").concat(o, ";\n      }\n    ");
  }

  return xk;
}();

function yk(e, t, n, s, r, a) {
  !function (e, t) {
    var n = V().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e <= 0 || t <= 0) throw new Error("Requested texture size [".concat(e, "x").concat(t, "] is invalid."));
    if (e > n || t > n) throw new Error("Requested texture size [".concat(e, "x").concat(t, "] greater than WebGL maximum on this browser / GPU [").concat(n, "x").concat(n, "]."));
  }(t, n);

  var i = function (e) {
    return Xy(e, function () {
      return e.createTexture();
    }, "Unable to create WebGLTexture.");
  }(e),
      o = e.TEXTURE_2D;

  return Py(e, function () {
    return e.bindTexture(o, i);
  }), Py(e, function () {
    return e.texParameteri(o, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);
  }), Py(e, function () {
    return e.texParameteri(o, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
  }), Py(e, function () {
    return e.texParameteri(o, e.TEXTURE_MIN_FILTER, e.NEAREST);
  }), Py(e, function () {
    return e.texParameteri(o, e.TEXTURE_MAG_FILTER, e.NEAREST);
  }), Py(e, function () {
    return e.texImage2D(o, 0, s, t, n, 0, r, a, null);
  }), Py(e, function () {
    return e.bindTexture(e.TEXTURE_2D, null);
  }), i;
}

function kk(e) {
  return e.internalFormatFloat;
}

function wk(e) {
  return e.internalFormatHalfFloat;
}

function vk(e) {
  return e.downloadTextureFormat;
}

function Ik(e) {
  return e.internalFormatPackedFloat;
}

function $k(e) {
  return e.internalFormatPackedHalfFloat;
}

var Nk = /*#__PURE__*/function () {
  "use strict";

  function Nk(e) {
    _classCallCheck(this, Nk);

    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var t = V().getNumber("WEBGL_VERSION");
    null != e ? (this.gl = e, function (e, t) {
      Ry[e] = t;
    }(t, e)) : this.gl = Fy(t);
    var n = "WEBGL_color_buffer_float";
    var s = "EXT_color_buffer_half_float";

    if (1 === V().getNumber("WEBGL_VERSION")) {
      var _e428 = "OES_texture_half_float";
      if (this.textureFloatExtension = Uy(this.gl, "OES_texture_float"), sk(this.gl, _e428)) this.textureHalfFloatExtension = Uy(this.gl, _e428);else if (V().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n), sk(this.gl, s)) this.colorBufferHalfFloatExtension = Uy(this.gl, s);else if (V().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n = "EXT_color_buffer_float", sk(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);else {
      if (!sk(this.gl, s)) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension(s);
    }

    this.vertexBuffer = function (e) {
      return function (e, t) {
        var n = Xy(e, function () {
          return e.createBuffer();
        }, "Unable to create WebGLBuffer");
        return Py(e, function () {
          return e.bindBuffer(e.ARRAY_BUFFER, n);
        }), Py(e, function () {
          return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
        }), n;
      }(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
    }(this.gl), this.indexBuffer = function (e) {
      return function (e, t) {
        var n = Xy(e, function () {
          return e.createBuffer();
        }, "Unable to create WebGLBuffer");
        return Py(e, function () {
          return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n);
        }), Py(e, function () {
          return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW);
        }), n;
      }(e, new Uint16Array([0, 1, 2, 2, 1, 3]));
    }(this.gl), this.framebuffer = function (e) {
      return Xy(e, function () {
        return e.createFramebuffer();
      }, "Unable to create WebGLFramebuffer.");
    }(this.gl), this.textureConfig = By(this.gl, this.textureHalfFloatExtension);
  }

  _createClass(Nk, [{
    key: "debug",
    get: function get() {
      return V().getBool("DEBUG");
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var _this185 = this;

      if (this.disposed) return;
      null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var e = this.gl;
      Py(e, function () {
        return e.finish();
      }), Py(e, function () {
        return e.bindFramebuffer(e.FRAMEBUFFER, null);
      }), Py(e, function () {
        return e.deleteFramebuffer(_this185.framebuffer);
      }), Py(e, function () {
        return e.bindBuffer(e.ARRAY_BUFFER, null);
      }), Py(e, function () {
        return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);
      }), Py(e, function () {
        return e.deleteBuffer(_this185.indexBuffer);
      }), this.disposed = !0;
    }
  }, {
    key: "createFloat32MatrixTexture",
    value: function createFloat32MatrixTexture(e, t) {
      return this.throwIfDisposed(), function (e, t, n, s) {
        var _My = My(t, n),
            _My2 = _slicedToArray(_My, 2),
            r = _My2[0],
            a = _My2[1];

        return yk(e, r, a, kk(s), s.textureFormatFloat, e.FLOAT);
      }(this.gl, e, t, this.textureConfig);
    }
  }, {
    key: "createFloat16MatrixTexture",
    value: function createFloat16MatrixTexture(e, t) {
      return this.throwIfDisposed(), function (e, t, n, s) {
        var _My3 = My(t, n),
            _My4 = _slicedToArray(_My3, 2),
            r = _My4[0],
            a = _My4[1];

        return yk(e, r, a, wk(s), s.textureFormatFloat, s.textureTypeHalfFloat);
      }(this.gl, e, t, this.textureConfig);
    }
  }, {
    key: "createUnsignedBytesMatrixTexture",
    value: function createUnsignedBytesMatrixTexture(e, t) {
      return this.throwIfDisposed(), function (e, t, n, s) {
        var _My5 = My(t, n),
            _My6 = _slicedToArray(_My5, 2),
            r = _My6[0],
            a = _My6[1];

        return yk(e, r, a, vk(s), e.RGBA, e.UNSIGNED_BYTE);
      }(this.gl, e, t, this.textureConfig);
    }
  }, {
    key: "uploadPixelDataToTexture",
    value: function uploadPixelDataToTexture(e, t) {
      this.throwIfDisposed(), function (e, t, n) {
        Py(e, function () {
          return e.bindTexture(e.TEXTURE_2D, t);
        }), n.data instanceof Uint8Array ? Py(e, function () {
          return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data);
        }) : Py(e, function () {
          return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n);
        }), Py(e, function () {
          return e.bindTexture(e.TEXTURE_2D, null);
        });
      }(this.gl, e, t);
    }
  }, {
    key: "uploadDenseMatrixToTexture",
    value: function uploadDenseMatrixToTexture(e, t, n, s) {
      this.throwIfDisposed(), function (e, t, n, s, r, a) {
        var i, o, l;
        Py(e, function () {
          return e.bindTexture(e.TEXTURE_2D, t);
        }), r instanceof Uint8Array ? (i = new Uint8Array(n * s * 4), o = e.UNSIGNED_BYTE, l = e.RGBA) : (i = new Float32Array(n * s * 4), o = e.FLOAT, l = a.internalFormatPackedFloat), i.set(r), Py(e, function () {
          return e.texImage2D(e.TEXTURE_2D, 0, l, n, s, 0, e.RGBA, o, i);
        }), Py(e, function () {
          return e.bindTexture(e.TEXTURE_2D, null);
        });
      }(this.gl, e, t, n, s, this.textureConfig);
    }
  }, {
    key: "createFloat16PackedMatrixTexture",
    value: function createFloat16PackedMatrixTexture(e, t) {
      return this.throwIfDisposed(), function (e, t, n, s) {
        var _zy = zy(t, n),
            _zy2 = _slicedToArray(_zy, 2),
            r = _zy2[0],
            a = _zy2[1];

        return yk(e, r, a, $k(s), e.RGBA, s.textureTypeHalfFloat);
      }(this.gl, e, t, this.textureConfig);
    }
  }, {
    key: "createPackedMatrixTexture",
    value: function createPackedMatrixTexture(e, t) {
      return this.throwIfDisposed(), function (e, t, n, s) {
        var _zy3 = zy(t, n),
            _zy4 = _slicedToArray(_zy3, 2),
            r = _zy4[0],
            a = _zy4[1];

        return yk(e, r, a, Ik(s), e.RGBA, e.FLOAT);
      }(this.gl, e, t, this.textureConfig);
    }
  }, {
    key: "deleteMatrixTexture",
    value: function deleteMatrixTexture(e) {
      var _this186 = this;

      this.throwIfDisposed(), this.outputTexture === e && (qy(this.gl, this.framebuffer), this.outputTexture = null), Py(this.gl, function () {
        return _this186.gl.deleteTexture(e);
      });
    }
  }, {
    key: "downloadByteEncodedFloatMatrixFromOutputTexture",
    value: function downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n) {
      var _this187 = this;

      return this.downloadMatrixDriver(e, function () {
        return function (e, t, n, s) {
          var _My7 = My(t, n),
              _My8 = _slicedToArray(_My7, 2),
              r = _My8[0],
              a = _My8[1],
              i = new Uint8Array(t * n * 4);

          return Py(e, function () {
            return e.readPixels(0, 0, r, a, s.downloadTextureFormat, e.UNSIGNED_BYTE, i);
          }), new Float32Array(i.buffer);
        }(_this187.gl, t, n, _this187.textureConfig);
      });
    }
  }, {
    key: "downloadPackedMatrixFromBuffer",
    value: function downloadPackedMatrixFromBuffer(e, t, n, s, r, a) {
      return function (e, t, n, s, r, a, i, o) {
        var l = e,
            u = new Float32Array(function (e, t) {
          var _zy5 = zy(e, t),
              _zy6 = _slicedToArray(_zy5, 2),
              n = _zy6[0],
              s = _zy6[1];

          return n * s * 4;
        }(a, i));
        return l.bindBuffer(l.PIXEL_PACK_BUFFER, t), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, u), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), u;
      }(this.gl, e, 0, 0, 0, r, a);
    }
  }, {
    key: "downloadFloat32MatrixFromBuffer",
    value: function downloadFloat32MatrixFromBuffer(e, t) {
      return function (e, t, n) {
        var s = e,
            r = new Float32Array(n);
        return s.bindBuffer(s.PIXEL_PACK_BUFFER, t), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, r), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), r;
      }(this.gl, e, t);
    }
  }, {
    key: "createBufferFromTexture",
    value: function createBufferFromTexture(e, t, n) {
      this.bindTextureToFrameBuffer(e);

      var s = function (e, t, n, s) {
        var r = e.createBuffer();
        Py(e, function () {
          return e.bindBuffer(e.PIXEL_PACK_BUFFER, r);
        });
        var a = 16 * t * n;
        return Py(e, function () {
          return e.bufferData(e.PIXEL_PACK_BUFFER, a, e.STREAM_READ);
        }), Py(e, function () {
          return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0);
        }), Py(e, function () {
          return e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
        }), r;
      }(this.gl, t, n);

      return this.unbindTextureToFrameBuffer(), s;
    }
  }, {
    key: "createAndWaitForFence",
    value: function createAndWaitForFence() {
      var e = this.createFence(this.gl);
      return this.pollFence(e);
    }
  }, {
    key: "createFence",
    value: function createFence(e) {
      var _this188 = this;

      var t, n;

      if (V().getBool("WEBGL_FENCE_API_ENABLED")) {
        var _s209 = e,
            _r155 = _s209.fenceSync(_s209.SYNC_GPU_COMMANDS_COMPLETE, 0);

        e.flush(), n = function n() {
          var e = _s209.clientWaitSync(_r155, 0, 0);

          return e === _s209.ALREADY_SIGNALED || e === _s209.CONDITION_SATISFIED;
        }, t = _r155;
      } else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n = function n() {
        return _this188.isQueryAvailable(t, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      }) : n = function n() {
        return !0;
      };

      return {
        query: t,
        isFencePassed: n
      };
    }
  }, {
    key: "downloadMatrixFromPackedTexture",
    value: function downloadMatrixFromPackedTexture(e, t, n) {
      var _this189 = this;

      return this.downloadMatrixDriver(e, function () {
        return function (e, t, n) {
          var s = new Float32Array(t * n * 4);
          return Py(e, function () {
            return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, s);
          }), s;
        }(_this189.gl, t, n);
      });
    }
  }, {
    key: "createProgram",
    value: function createProgram(e) {
      var _this190 = this;

      this.throwIfDisposed();

      var t = this.gl,
          n = function (e, t) {
        var n = Xy(e, function () {
          return e.createShader(e.FRAGMENT_SHADER);
        }, "Unable to create fragment WebGLShader.");
        if (Py(e, function () {
          return e.shaderSource(n, t);
        }), Py(e, function () {
          return e.compileShader(n);
        }), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw function (e, t) {
          var n = Vy.exec(t);
          if (null == n) return console.log("Couldn't parse line number in error: ".concat(t)), void console.log(e);
          var s = +n[1],
              r = e.split("\n"),
              a = r.length.toString().length + 2,
              i = r.map(function (e, t) {
            return m((t + 1).toString(), a) + e;
          });
          var o = 0;

          for (var _e429 = 0; _e429 < i.length; _e429++) {
            o = Math.max(i[_e429].length, o);
          }

          var l = i.slice(0, s - 1),
              u = i.slice(s - 1, s),
              c = i.slice(s);
          console.log(l.join("\n")), console.log(t.split("\n")[0]), console.log("%c ".concat(m(u[0], o)), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join("\n"));
        }(t, e.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
        return n;
      }(t, e);

      null == this.vertexShader && (this.vertexShader = function (e) {
        var t = lk();
        return function (e, t) {
          var n = Xy(e, function () {
            return e.createShader(e.VERTEX_SHADER);
          }, "Unable to create vertex WebGLShader.");
          if (Py(e, function () {
            return e.shaderSource(n, t);
          }), Py(e, function () {
            return e.compileShader(n);
          }), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
          return n;
        }(e, "".concat(t.version, "\n    precision highp float;\n    ").concat(t.attribute, " vec3 clipSpacePos;\n    ").concat(t.attribute, " vec2 uv;\n    ").concat(t.varyingVs, " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"));
      }(t));

      var s = function (e) {
        return Xy(e, function () {
          return e.createProgram();
        }, "Unable to create WebGLProgram.");
      }(t);

      return Py(t, function () {
        return t.attachShader(s, _this190.vertexShader);
      }), Py(t, function () {
        return t.attachShader(s, n);
      }), function (e, t) {
        if (Py(e, function () {
          return e.linkProgram(t);
        }), !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
      }(t, s), this.debug && Gy(t, s), this.vertexAttrsAreBound || (this.setProgram(s), this.vertexAttrsAreBound = function (e, t, n) {
        return Py(e, function () {
          return e.bindBuffer(e.ARRAY_BUFFER, n);
        }), Hy(e, t, "clipSpacePos", n, 3, 20, 0) && Hy(e, t, "uv", n, 2, 20, 12);
      }(t, this.program, this.vertexBuffer)), s;
    }
  }, {
    key: "deleteProgram",
    value: function deleteProgram(e) {
      var _this191 = this;

      this.throwIfDisposed(), e === this.program && (this.program = null), null != e && Py(this.gl, function () {
        return _this191.gl.deleteProgram(e);
      });
    }
  }, {
    key: "setProgram",
    value: function setProgram(e) {
      var _this192 = this;

      this.throwIfDisposed(), this.program = e, null != this.program && this.debug && Gy(this.gl, this.program), Py(this.gl, function () {
        return _this192.gl.useProgram(e);
      });
    }
  }, {
    key: "getUniformLocation",
    value: function getUniformLocation(e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      return this.throwIfDisposed(), n ? function (e, t, n) {
        return Xy(e, function () {
          return e.getUniformLocation(t, n);
        }, 'uniform "' + n + '" not present in program.');
      }(this.gl, e, t) : function (e, t, n) {
        return e.getUniformLocation(t, n);
      }(this.gl, e, t);
    }
  }, {
    key: "getAttributeLocation",
    value: function getAttributeLocation(e, t) {
      var _this193 = this;

      return this.throwIfDisposed(), Py(this.gl, function () {
        return _this193.gl.getAttribLocation(e, t);
      });
    }
  }, {
    key: "getUniformLocationNoThrow",
    value: function getUniformLocationNoThrow(e, t) {
      return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
    }
  }, {
    key: "setInputMatrixTexture",
    value: function setInputMatrixTexture(e, t, n) {
      this.throwIfDisposed(), this.throwIfNoProgram(), function (e, t, n, s) {
        Py(e, function () {
          return function (e, t, n) {
            !function (e, t) {
              var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
                  s = t + e.TEXTURE0;
              if (s < e.TEXTURE0 || s > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE".concat(n, "]."));
            }(e, n), Py(e, function () {
              return e.activeTexture(e.TEXTURE0 + n);
            }), Py(e, function () {
              return e.bindTexture(e.TEXTURE_2D, t);
            });
          }(e, t, s);
        }), Py(e, function () {
          return e.uniform1i(n, s);
        });
      }(this.gl, e, t, n);
    }
  }, {
    key: "setOutputMatrixTexture",
    value: function setOutputMatrixTexture(e, t, n) {
      this.setOutputMatrixTextureDriver(e, n, t);
    }
  }, {
    key: "setOutputPackedMatrixTexture",
    value: function setOutputPackedMatrixTexture(e, t, n) {
      this.throwIfDisposed();

      var _zy7 = zy(t, n),
          _zy8 = _slicedToArray(_zy7, 2),
          s = _zy8[0],
          r = _zy8[1];

      this.setOutputMatrixTextureDriver(e, s, r);
    }
  }, {
    key: "setOutputMatrixWriteRegion",
    value: function setOutputMatrixWriteRegion(e, t, n, s) {
      this.setOutputMatrixWriteRegionDriver(n, e, s, t);
    }
  }, {
    key: "setOutputPackedMatrixWriteRegion",
    value: function setOutputPackedMatrixWriteRegion(e, t, n, s) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
  }, {
    key: "debugValidate",
    value: function debugValidate() {
      null != this.program && Gy(this.gl, this.program), Ky(this.gl);
    }
  }, {
    key: "executeProgram",
    value: function executeProgram() {
      this.throwIfDisposed(), this.throwIfNoProgram();
      var e = this.gl;
      this.debug && this.debugValidate(), Py(e, function () {
        return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0);
      });
    }
  }, {
    key: "blockUntilAllProgramsCompleted",
    value: function blockUntilAllProgramsCompleted() {
      var _this194 = this;

      this.throwIfDisposed(), Py(this.gl, function () {
        return _this194.gl.finish();
      });
    }
  }, {
    key: "getQueryTimerExtension",
    value: function getQueryTimerExtension() {
      return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Uy(this.gl, 2 === V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }
  }, {
    key: "getQueryTimerExtensionWebGL2",
    value: function getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
  }, {
    key: "getQueryTimerExtensionWebGL1",
    value: function getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
  }, {
    key: "beginQuery",
    value: function beginQuery() {
      if (2 === V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
        var _e430 = this.gl,
            _t403 = this.getQueryTimerExtensionWebGL2(),
            _n270 = _e430.createQuery();

        return _e430.beginQuery(_t403.TIME_ELAPSED_EXT, _n270), _n270;
      }

      var e = this.getQueryTimerExtensionWebGL1(),
          t = e.createQueryEXT();
      return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t;
    }
  }, {
    key: "endQuery",
    value: function endQuery() {
      if (2 === V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
        var _e431 = this.gl,
            _t404 = this.getQueryTimerExtensionWebGL2();

        return void _e431.endQuery(_t404.TIME_ELAPSED_EXT);
      }

      var e = this.getQueryTimerExtensionWebGL1();
      e.endQueryEXT(e.TIME_ELAPSED_EXT);
    }
  }, {
    key: "waitForQueryAndGetTime",
    value: function () {
      var _waitForQueryAndGetTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee87(e) {
        var _this195 = this;

        return _regeneratorRuntime.wrap(function _callee87$(_context90) {
          while (1) {
            switch (_context90.prev = _context90.next) {
              case 0:
                _context90.next = 2;
                return b(function () {
                  return _this195.disposed || _this195.isQueryAvailable(e, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
                });

              case 2:
                return _context90.abrupt("return", this.getQueryTime(e, V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));

              case 3:
              case "end":
                return _context90.stop();
            }
          }
        }, _callee87, this);
      }));

      function waitForQueryAndGetTime(_x140) {
        return _waitForQueryAndGetTime.apply(this, arguments);
      }

      return waitForQueryAndGetTime;
    }()
  }, {
    key: "getQueryTime",
    value: function getQueryTime(e, t) {
      if (0 === t) return null;

      if (2 === t) {
        var _t405 = this.gl;
        return _t405.getQueryParameter(e, _t405.QUERY_RESULT) / 1e6;
      }

      {
        var _t406 = this.getQueryTimerExtensionWebGL1();

        return _t406.getQueryObjectEXT(e, _t406.QUERY_RESULT_EXT) / 1e6;
      }
    }
  }, {
    key: "isQueryAvailable",
    value: function isQueryAvailable(e, t) {
      if (0 === t) return !0;

      if (2 === t) {
        var _t407 = this.gl,
            _n271 = this.getQueryTimerExtensionWebGL2(),
            _s210 = _t407.getQueryParameter(e, _t407.QUERY_RESULT_AVAILABLE);

        return null == this.disjoint && (this.disjoint = this.gl.getParameter(_n271.GPU_DISJOINT_EXT)), _s210 && !this.disjoint;
      }

      {
        var _t408 = this.getQueryTimerExtensionWebGL1(),
            _n272 = _t408.getQueryObjectEXT(e, _t408.QUERY_RESULT_AVAILABLE_EXT);

        return null == this.disjoint && (this.disjoint = this.gl.getParameter(_t408.GPU_DISJOINT_EXT)), _n272 && !this.disjoint;
      }
    }
  }, {
    key: "pollFence",
    value: function pollFence(e) {
      var _this196 = this;

      return new Promise(function (t) {
        _this196.addItemToPoll(function () {
          return e.isFencePassed();
        }, function () {
          return t();
        });
      });
    }
  }, {
    key: "pollItems",
    value: function pollItems() {
      var e = function (e) {
        var t = 0;

        for (; t < e.length && e[t](); ++t) {
          ;
        }

        return t - 1;
      }(this.itemsToPoll.map(function (e) {
        return e.isDoneFn;
      }));

      for (var _t409 = 0; _t409 <= e; ++_t409) {
        var _e432 = this.itemsToPoll[_t409].resolveFn;

        _e432();
      }

      this.itemsToPoll = this.itemsToPoll.slice(e + 1);
    }
  }, {
    key: "addItemToPoll",
    value: function addItemToPoll(e, t) {
      var _this197 = this;

      this.itemsToPoll.push({
        isDoneFn: e,
        resolveFn: t
      }), this.itemsToPoll.length > 1 || b(function () {
        return _this197.pollItems(), 0 === _this197.itemsToPoll.length;
      });
    }
  }, {
    key: "bindTextureToFrameBuffer",
    value: function bindTextureToFrameBuffer(e) {
      this.throwIfDisposed(), jy(this.gl, e, this.framebuffer), this.debug && Ky(this.gl);
    }
  }, {
    key: "unbindTextureToFrameBuffer",
    value: function unbindTextureToFrameBuffer() {
      null != this.outputTexture ? (jy(this.gl, this.outputTexture, this.framebuffer), this.debug && Ky(this.gl)) : qy(this.gl, this.framebuffer);
    }
  }, {
    key: "downloadMatrixDriver",
    value: function downloadMatrixDriver(e, t) {
      this.bindTextureToFrameBuffer(e);
      var n = t();
      return this.unbindTextureToFrameBuffer(), n;
    }
  }, {
    key: "setOutputMatrixTextureDriver",
    value: function setOutputMatrixTextureDriver(e, t, n) {
      this.throwIfDisposed();
      var s = this.gl;
      jy(s, e, this.framebuffer), this.debug && Ky(s), this.outputTexture = e, Py(s, function () {
        return s.viewport(0, 0, t, n);
      }), Py(s, function () {
        return s.scissor(0, 0, t, n);
      });
    }
  }, {
    key: "setOutputMatrixWriteRegionDriver",
    value: function setOutputMatrixWriteRegionDriver(e, t, n, s) {
      var _this198 = this;

      this.throwIfDisposed(), Py(this.gl, function () {
        return _this198.gl.scissor(e, t, n, s);
      });
    }
  }, {
    key: "throwIfDisposed",
    value: function throwIfDisposed() {
      if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }
  }, {
    key: "throwIfNoProgram",
    value: function throwIfNoProgram() {
      if (null == this.program) throw new Error("No GPU program is currently set.");
    }
  }]);

  return Nk;
}();

var Ck = sl.getBroadcastDims;

function Sk(e, t, n) {
  var s = [];

  if (e.forEach(function (e) {
    var t = d(e.shapeInfo.logicalShape);

    if (e.shapeInfo.isUniform ? s.push("uniform float ".concat(e.name).concat(t > 1 ? "[".concat(t, "]") : "", ";")) : (s.push("uniform sampler2D ".concat(e.name, ";")), s.push("uniform int offset".concat(e.name, ";"))), n.enableShapeUniforms) {
      var _Lk = Lk(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape),
          _t410 = _Lk.uniformShape;

      switch (_t410.length) {
        case 1:
          s.push("uniform int ".concat(e.name, "Shape;"));
          break;

        case 2:
          s.push("uniform ivec2 ".concat(e.name, "Shape;"));
          break;

        case 3:
          s.push("uniform ivec3 ".concat(e.name, "Shape;"));
          break;

        case 4:
          s.push("uniform ivec4 ".concat(e.name, "Shape;"));
      }

      s.push("uniform ivec2 ".concat(e.name, "TexShape;"));
    }
  }), n.enableShapeUniforms) {
    switch (t.logicalShape.length) {
      case 1:
        s.push("uniform int outShape;");
        break;

      case 2:
        s.push("uniform ivec2 outShape;"), s.push("uniform int outShapeStrides;");
        break;

      case 3:
        s.push("uniform ivec3 outShape;"), s.push("uniform ivec2 outShapeStrides;");
        break;

      case 4:
        s.push("uniform ivec4 outShape;"), s.push("uniform ivec3 outShapeStrides;");
    }

    s.push("uniform ivec2 outTexShape;");
  }

  n.customUniforms && n.customUniforms.forEach(function (e) {
    s.push("uniform ".concat(e.type, " ").concat(e.name).concat(e.arrayIndex ? "[".concat(e.arrayIndex, "]") : "", ";"));
  });

  var r = s.join("\n"),
      a = e.map(function (e) {
    return function (e, t) {
      var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      var s = arguments.length > 3 ? arguments[3] : undefined;
      var r = "";
      return r += n ? Ek(e, s) : Tk(e, s), e.shapeInfo.logicalShape.length <= t.logicalShape.length && (r += n ? function (e, t) {
        var n = e.name,
            s = n.charAt(0).toUpperCase() + n.slice(1),
            r = "get" + s + "AtOutCoords",
            a = e.shapeInfo.logicalShape.length,
            i = t.logicalShape.length,
            o = Ck(e.shapeInfo.logicalShape, t.logicalShape),
            l = Mk(i),
            u = i - a;
        var c;
        var h = ["x", "y", "z", "w", "u", "v"];
        c = 0 === a ? "" : i < 2 && o.length >= 1 ? "coords = 0;" : o.map(function (e) {
          return "coords.".concat(h[e + u], " = 0;");
        }).join("\n");
        var p = "";
        p = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map(function (e, t) {
          return "coords.".concat(h[t + u]);
        }).join(", ");
        var f = "return outputValue;";
        var g = 1 === d(e.shapeInfo.logicalShape),
            m = 1 === d(t.logicalShape);

        if (1 !== a || g || m) {
          if (g && !m) f = 1 === i ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";else if (o.length) {
            var _e433 = a - 2,
                _t411 = a - 1;

            o.indexOf(_e433) > -1 && o.indexOf(_t411) > -1 ? f = "return vec4(outputValue.x);" : o.indexOf(_e433) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o.indexOf(_t411) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";

        return "\n    vec4 ".concat(r, "() {\n      ").concat(l, " coords = getOutputCoords();\n      ").concat(c, "\n      vec4 outputValue = get").concat(s, "(").concat(p, ");\n      ").concat(f, "\n    }\n  ");
      }(e, t) : function (e, t) {
        var n = e.name,
            s = n.charAt(0).toUpperCase() + n.slice(1),
            r = "get" + s + "AtOutCoords",
            a = e.shapeInfo.logicalShape.length,
            i = t.logicalShape.length;
        if (!e.shapeInfo.isUniform && a === i && null == e.shapeInfo.flatOffset && p(e.shapeInfo.texShape, t.texShape)) return "\n      float ".concat(r, "() {\n        return sampleTexture(").concat(n, ", resultUV);\n      }\n    ");
        var o = Mk(i),
            l = Ck(e.shapeInfo.logicalShape, t.logicalShape),
            u = i - a;
        var c;
        var h = ["x", "y", "z", "w", "u", "v"];
        c = 0 === a ? "" : i < 2 && l.length >= 1 ? "coords = 0;" : l.map(function (e) {
          return "coords.".concat(h[e + u], " = 0;");
        }).join("\n");
        var d = "";
        return d = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map(function (e, t) {
          return "coords.".concat(h[t + u]);
        }).join(", "), "\n    float ".concat(r, "() {\n      ").concat(o, " coords = getOutputCoords();\n      ").concat(c, "\n      return get").concat(s, "(").concat(d, ");\n    }\n  ");
      }(e, t)), r;
    }(e, t, n.packedInputs, n.enableShapeUniforms);
  }).join("\n"),
      i = t.texShape,
      o = lk(),
      l = function (e) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D, "(textureSampler, uv).r;\n    }\n  ");
  }(o);

  var u,
      c,
      h = function (e) {
    return "".concat(e.version, "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs, " vec2 resultUV;\n    ").concat(e.defineOutput, "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN, "\n    ").concat(e.defineSpecialInf, "\n    ").concat(e.defineRound, "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(Rk, "\n    ").concat(Ak, "\n    ").concat(Fk, "\n  ");
  }(o);

  return t.isPacked ? (u = function (e, t, n) {
    switch (e.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (e, t, n) {
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
          return 1 === s[0] ? n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(s[1], ".0);\n      }\n    ") : 1 === s[1] ? n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(s[0], ".0);\n      }\n    ") : n ? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n      return 2 * (resTexRC.x * ").concat(s[1], " + resTexRC.y);\n    }\n  ");
        }(0, t, n);

      case 2:
        return function (e, t, n) {
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
          if (p(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(s[0], ", ").concat(s[1], "));\n      }\n    ");
          var r = Math.ceil(e[1] / 2);
          return n ? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec2(r, c);\n    }\n  ");
        }(e, t, n);

      case 3:
        return function (e, t, n) {
          if (n) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
              r = Math.ceil(e[2] / 2),
              a = r * Math.ceil(e[1] / 2);
          return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(s[0], ", ").concat(s[1], "));\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n\n      int b = index / ").concat(a, ";\n      index -= b * ").concat(a, ";\n\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ");
        }(e, t, n);

      default:
        return function (e, t, n) {
          if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
          var s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
              r = Math.ceil(e[e.length - 1] / 2),
              a = r * Math.ceil(e[e.length - 2] / 2);
          var i = a,
              o = "",
              l = "b, r, c";

          for (var _t412 = 2; _t412 < e.length - 1; _t412++) {
            i *= e[e.length - _t412 - 1], o = "\n      int b".concat(_t412, " = index / ").concat(i, ";\n      index -= b").concat(_t412, " * ").concat(i, ";\n    ") + o, l = "b".concat(_t412, ", ") + l;
          }

          return "\n    ivec".concat(e.length, " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(s[0], ", ").concat(s[1], "));\n      int index = resTexRC.x * ").concat(s[1], " + resTexRC.y;\n\n      ").concat(o, "\n\n      int b = index / ").concat(a, ";\n      index -= b * ").concat(a, ";\n\n      int r = 2 * (index / ").concat(r, ");\n      int c = imod(index, ").concat(r, ") * 2;\n\n      return ivec").concat(e.length, "(").concat(l, ");\n    }\n  ");
        }(e, t, n);
    }
  }(t.logicalShape, i, n.enableShapeUniforms), c = function (e) {
    return "\n    void setOutput(vec4 val) {\n      ".concat(e.output, " = val;\n    }\n  ");
  }(o)) : (u = function (e, t, n) {
    switch (e.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";

      case 1:
        return function (e, t, n) {
          return 1 === t[0] ? n ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1], ".0);\n      }\n    ") : 1 === t[1] ? n ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0], ".0);\n      }\n    ") : n ? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      return resTexRC.x * ").concat(t[1], " + resTexRC.y;\n    }\n  ");
        }(0, t, n);

      case 2:
        return function (e, t, n) {
          return p(e, t) ? n ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0], ", ").concat(t[1], "));\n      }\n    ") : 1 === e[1] ? n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ") : 1 === e[0] ? n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ") : n ? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      int r = index / ").concat(e[1], ";\n      int c = index - r * ").concat(e[1], ";\n      return ivec2(r, c);\n    }\n  ");
        }(e, t, n);

      case 3:
        return function (e, t, n) {
          if (n) return "\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(ck(["r", "c", "d"], e), "\n    return ivec3(r, c, d);\n  }\n");
          var s = uk(["r", "c", "d"], e);
          return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(s, "\n      return ivec3(r, c, d);\n    }\n  ");
        }(e, t, n);

      case 4:
        return function (e, t, n) {
          if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(ck(["r", "c", "d", "d2"], e), "\n      return ivec4(r, c, d, d2);\n    }\n  ");
          var s = uk(["r", "c", "d", "d2"], e);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(s, "\n      return ivec4(r, c, d, d2);\n    }\n  ");
        }(e, t, n);

      case 5:
        return function (e, t) {
          var n = uk(["r", "c", "d", "d2", "d3"], e);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0], ",\n                             ").concat(t[1], "));\n\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ");
        }(e, t);

      case 6:
        return function (e, t) {
          var n = uk(["r", "c", "d", "d2", "d3", "d4"], e);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ");
        }(e, t);

      default:
        throw new Error("".concat(e.length, "-D output sampling is not yet supported"));
    }
  }(t.logicalShape, i, n.enableShapeUniforms), c = function (e) {
    return "\n    void setOutput(float val) {\n      ".concat(e.output, " = vec4(val, 0, 0, 0);\n    }\n  ");
  }(o)), n.packedInputs && (h += Dk), [h, l, c, r, u, a, n.userCode].join("\n");
}

function Tk(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  var n = e.shapeInfo.logicalShape;

  switch (n.length) {
    case 0:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "float ".concat(s, "() {return ").concat(n, ";}");

        var _e$shapeInfo$texShape = _slicedToArray(e.shapeInfo.texShape, 2),
            r = _e$shapeInfo$texShape[0],
            a = _e$shapeInfo$texShape[1];

        if (1 === r && 1 === a) return "\n      float ".concat(s, "() {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");

        var i = _k(n);

        if (t) return "\n    float ".concat(s, "() {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], ").concat(i, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");

        var _e$shapeInfo$texShape2 = _slicedToArray(e.shapeInfo.texShape, 2),
            o = _e$shapeInfo$texShape2[0],
            l = _e$shapeInfo$texShape2[1];

        return "\n    float ".concat(s, "() {\n      vec2 uv = uvFromFlat(").concat(o, ", ").concat(l, ", ").concat(i, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 1:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int index) {\n        ").concat(Ok(e), "\n      }\n    ");
        var r = e.shapeInfo.texShape,
            a = r[0],
            i = r[1];
        if (1 === i && 1 === a) return "\n      float ".concat(s, "(int index) {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");

        var o = _k(n);

        return 1 === i ? t ? "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o, ") + 0.5) / float(").concat(n, "TexShape[0]));\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(o, ") + 0.5) / ").concat(a, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : 1 === a ? t ? "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(o, ") + 0.5) / float(").concat(n, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(s, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(o, ") + 0.5) / ").concat(i, ".0, 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : t ? "\n    float ".concat(s, "(int index) {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], index + ").concat(o, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ") : "\n    float ".concat(s, "(int index) {\n      vec2 uv = uvFromFlat(").concat(a, ", ").concat(i, ", index + ").concat(o, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 2:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape;
        if (null != a && p(n, a)) return t ? "\n      float ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a[1], ".0, ").concat(a[0], ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");

        var _k9 = k(n),
            i = _k9.newShape,
            o = _k9.keptDims;

        if (i.length < n.length) {
          var _n273 = ["row", "col"];
          return "\n      ".concat(Tk(zk(e, i), t), "\n      float ").concat(r, "(int row, int col) {\n        return ").concat(r, "(").concat(Bk(_n273, o), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1], ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");

        var l = a[0],
            u = a[1],
            c = _k(s);

        return 1 === u ? t ? "\n      float ".concat(r, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(s, "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(s, "TexShape[0]));\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l, ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : 1 === l ? t ? "\n      float ".concat(r, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(s, "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(s, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(c, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u, ".0, 0.5);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : t ? "\n      float ".concat(r, "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s, "Shape[1] + col + ").concat(c, ";\n        vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n  float ".concat(r, "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1], " + col + ").concat(c, ";\n    vec2 uv = uvFromFlat(").concat(l, ", ").concat(u, ", index);\n    return sampleTexture(").concat(s, ", uv);\n  }\n");
      }(e, t);

    case 3:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = n[1] * n[2],
            i = n[2],
            _k10 = k(n),
            o = _k10.newShape,
            l = _k10.keptDims;

        if (o.length < n.length) {
          var _n274 = ["row", "col", "depth"];
          return "\n        ".concat(Tk(zk(e, o), t), "\n        float ").concat(r, "(int row, int col, int depth) {\n          return ").concat(r, "(").concat(Bk(_n274, l), ");\n        }\n      ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(a, ", ").concat(i, ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");
        var u = e.shapeInfo.texShape,
            c = u[0],
            h = u[1],
            d = e.shapeInfo.flatOffset;
        if (h === a && null == d) return t ? "\n      float ".concat(r, "(int row, int col, int depth) {\n        int stride1 = ").concat(s, "Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n        float ".concat(r, "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i, ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h, ".0, ").concat(c, ".0);\n          return sampleTexture(").concat(s, ", uv);\n        }\n      ");
        if (h === i && null == d) return t ? "\n      float ".concat(r, "(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(s, "Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n    float ".concat(r, "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1], ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h, ".0, ").concat(c, ".0);\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");

        var p = _k(s);

        return t ? "\n    float ".concat(r, "(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(s, "Shape[1] * ").concat(s, "Shape[2];\n      int stride1 = ").concat(s, "Shape[2];\n      int index = row * ").concat(a, " + col * ").concat(i, " + depth + ").concat(p, ";\n      vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index);\n      return sampleTexture(").concat(s, ", uv);\n    }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a, " + col * ").concat(i, " + depth + ").concat(p, ";\n        vec2 uv = uvFromFlat(").concat(c, ", ").concat(h, ", index);\n        return sampleTexture(").concat(s, ", uv);\n      }\n  ");
      }(e, t);

    case 4:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = n[3],
            i = n[2] * a,
            o = n[1] * i,
            _k11 = k(n),
            l = _k11.newShape,
            u = _k11.keptDims;

        if (l.length < n.length) {
          var _n275 = ["row", "col", "depth", "depth2"];
          return "\n      ".concat(Tk(zk(e, l), t), "\n      float ").concat(r, "(int row, int col, int depth, int depth2) {\n        return ").concat(r, "(").concat(Bk(_n275, u), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");
        var c = e.shapeInfo.flatOffset,
            h = e.shapeInfo.texShape,
            d = h[0],
            p = h[1],
            f = "int stride2 = ".concat(s, "Shape[3];"),
            g = "int stride1 = ".concat(s, "Shape[2] * stride2;"),
            m = "int stride0 = ".concat(s, "Shape[1] * stride1;");
        if (p === o && null == c) return t ? "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        ").concat(f, "\n        ").concat(g, "\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i, ", ").concat(a, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ");
        if (p === a && null == c) return t ? "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(s, "Shape[1] * ").concat(s, "Shape[2], ").concat(s, "Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1] * n[2], ", ").concat(n[2], ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(s, ", uv);\n      }\n    ");

        var b = _k(s);

        return t ? "\n    float ".concat(r, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f, "\n      ").concat(g, "\n      ").concat(m, "\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(s, "TexShape[0], ").concat(s, "TexShape[1], index + ").concat(b, ");\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ") : "\n    float ".concat(r, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o, " + col * ").concat(i, " +\n          depth * ").concat(a, " + depth2;\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(p, ", index + ").concat(b, ");\n      return sampleTexture(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    case 5:
      return function (e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = t[4],
            a = t[3] * r,
            i = t[2] * a,
            o = t[1] * i,
            _k12 = k(t),
            l = _k12.newShape,
            u = _k12.keptDims;

        if (l.length < t.length) {
          var _t413 = ["row", "col", "depth", "depth2", "depth3"];
          return "\n      ".concat(Tk(zk(e, l)), "\n      float ").concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(s, "(").concat(Bk(_t413, u), ");\n      }\n    ");
        }

        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", ").concat(r, ")) +\n          depth3;\n        ").concat(Ok(e), "\n      }\n    ");
        var c = e.shapeInfo.flatOffset,
            h = e.shapeInfo.texShape,
            d = h[0],
            p = h[1];
        return p === o && null == c ? "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i, ", ").concat(a, ", ").concat(r, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : p === r && null == c ? "\n      float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3], ",\n               ").concat(t[2] * t[3], ", ").concat(t[3], ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n    float ".concat(s, "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(o, " + col * ").concat(i, " + depth * ").concat(a, " +\n          depth2 * ").concat(r, " + depth3 + ").concat(_k(n), ";\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(p, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e);

    case 6:
      return function (e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            _k13 = k(t),
            r = _k13.newShape,
            a = _k13.keptDims;

        if (r.length < t.length) {
          var _t414 = ["row", "col", "depth", "depth2", "depth3", "depth4"];
          return "\n      ".concat(Tk(zk(e, r)), "\n      float ").concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(s, "(").concat(Bk(_t414, a), ");\n      }\n    ");
        }

        var i = t[5],
            o = t[4] * i,
            l = t[3] * o,
            u = t[2] * l,
            c = t[1] * u;
        if (e.shapeInfo.isUniform) return "\n      float ".concat(s, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(c, ", ").concat(u, ", ").concat(l, ", ").concat(o, ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i, ", 1)));\n        ").concat(Ok(e), "\n      }\n    ");
        var h = e.shapeInfo.flatOffset,
            d = e.shapeInfo.texShape,
            p = d[0],
            f = d[1];
        return f === c && null == h ? "\n      float ".concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(u, ", ").concat(l, ", ").concat(o, ", ").concat(i, ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f, ".0, ").concat(p, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : f === i && null == h ? "\n      float ".concat(s, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3] * t[4], ",\n               ").concat(t[2] * t[3] * t[4], ",\n               ").concat(t[3] * t[4], ",\n               ").concat(t[4], ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f, ".0, ").concat(p, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n    float ".concat(s, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c, " + col * ").concat(u, " + depth * ").concat(l, " +\n          depth2 * ").concat(o, " + depth3 * ").concat(i, " + depth4 + ").concat(_k(n), ";\n      vec2 uv = uvFromFlat(").concat(p, ", ").concat(f, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
      }(e);

    default:
      throw new Error("".concat(n.length, "-D input sampling is not yet supported"));
  }
}

function Ek(e, t) {
  switch (e.shapeInfo.logicalShape.length) {
    case 0:
      return function (e) {
        var t = e.name;
        return "\n    vec4 ".concat("get" + t.charAt(0).toUpperCase() + t.slice(1), "() {\n      return ").concat(lk().texture2D, "(").concat(t, ", halfCR);\n    }\n  ");
      }(e);

    case 1:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = e.shapeInfo.texShape,
            a = lk();
        if (t) return "\n    vec4 ".concat(s, "(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
        var i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
        return "\n    vec4 ".concat(s, "(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0], ", ").concat(i[1], ", index);\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
      }(e, t);

    case 2:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape,
            i = a[0],
            o = a[1],
            l = lk();
        if (null != a && p(n, a)) return t ? "\n      vec4 ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, "TexShape[1], ").concat(s, "TexShape[0]);\n\n        return ").concat(l.texture2D, "(").concat(s, ", uv);\n      }\n    ") : "\n      vec4 ".concat(r, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(o, ".0, ").concat(i, ".0);\n\n        return ").concat(l.texture2D, "(").concat(s, ", uv);\n      }\n    ");
        if (t) return "\n    vec4 ".concat(r, "(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(s, "TexShape[0]) / 2.0), ceil(float(").concat(s, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(s, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(l.texture2D, "(").concat(s, ", uv);\n    }\n  ");
        var u = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
        return "\n    vec4 ".concat(r, "(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(Math.ceil(n[1] / 2), ", ").concat(u[0], ", ").concat(u[1], ", row, col);\n      return ").concat(l.texture2D, "(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    case 3:
      return function (e, t) {
        var n = e.shapeInfo.logicalShape,
            s = e.name,
            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
            a = e.shapeInfo.texShape,
            i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];

        if (1 === n[0]) {
          var _s211 = [1, 2],
              _a109 = ["b", "row", "col"];
          return "\n        ".concat(Ek(zk(e, n.slice(1)), t), "\n        vec4 ").concat(r, "(int b, int row, int col) {\n          return ").concat(r, "(").concat(Bk(_a109, _s211), ");\n        }\n      ");
        }

        var o = lk();
        if (t) return "\n    vec4 ".concat(r, "(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(s, "TexShape[0]) / 2.0), ceil(float(").concat(s, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(s, "Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(s, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(o.texture2D, "(").concat(s, ", uv);\n    }\n  ");
        var l = i[0],
            u = i[1],
            c = Math.ceil(n[2] / 2);
        return "\n    vec4 ".concat(r, "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(l, ", ").concat(u, ", ").concat(c * Math.ceil(n[1] / 2), ", ").concat(c, ", b, row, col);\n      return ").concat(o.texture2D, "(").concat(s, ", uv);\n    }\n  ");
      }(e, t);

    default:
      return function (e, t) {
        var n = e.name,
            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            r = lk();
        if (t) return "\n    vec4 ".concat(s, "(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n, "Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n, "Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n, "Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D, "(").concat(n, ", uv);\n    }\n  ");
        var a = e.shapeInfo.logicalShape,
            i = a.length,
            o = e.shapeInfo.texShape,
            l = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
            u = l[0],
            c = l[1],
            h = Math.ceil(a[i - 1] / 2);
        var d = h * Math.ceil(a[i - 2] / 2),
            p = "int b, int row, int col",
            f = "b * ".concat(d, " + (row / 2) * ").concat(h, " + (col / 2)");

        for (var _e434 = 2; _e434 < i - 1; _e434++) {
          p = "int b".concat(_e434, ", ") + p, d *= a[i - _e434 - 1], f = "b".concat(_e434, " * ").concat(d, " + ") + f;
        }

        return "\n    vec4 ".concat(s, "(").concat(p, ") {\n      int index = ").concat(f, ";\n      int texR = index / ").concat(c, ";\n      int texC = index - texR * ").concat(c, ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(c, ", ").concat(u, ");\n      return ").concat(r.texture2D, "(").concat(n, ", uv);\n    }\n  ");
      }(e, t);
  }
}

var Rk = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Ak = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Fk = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Dk = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

function _k(e) {
  return "offset".concat(e);
}

function Ok(e) {
  var t = e.name,
      n = d(e.shapeInfo.logicalShape);
  return n < 2 ? "return ".concat(t, ";") : "\n    for (int i = 0; i < ".concat(n, "; i++) {\n      if (i == index) {\n        return ").concat(t, "[i];\n      }\n    }\n  ");
}

function Mk(e) {
  if (e <= 1) return "int";
  if (2 === e) return "ivec2";
  if (3 === e) return "ivec3";
  if (4 === e) return "ivec4";
  if (5 === e) return "ivec5";
  if (6 === e) return "ivec6";
  throw Error("GPU for rank ".concat(e, " is not yet supported"));
}

function Lk(e, t, n) {
  var _k14 = k(t),
      s = _k14.newShape,
      r = t.length,
      a = e && 3 === r && 1 === t[0],
      i = a ? t.slice(1) : s,
      o = !e && r > 1 && !p(t, n) && s.length < r || a;

  return {
    useSqueezeShape: o,
    uniformShape: o ? i : t
  };
}

function zk(e, t) {
  var n = JSON.parse(JSON.stringify(e));
  return n.shapeInfo.logicalShape = t, n;
}

function Bk(e, t) {
  return t.map(function (t) {
    return e[t];
  }).join(", ");
}

function Pk(e, t) {
  if (e.length !== t.length) throw Error("Binary was compiled with ".concat(e.length, " inputs, but was executed with ").concat(t.length, " inputs"));
  e.forEach(function (e, n) {
    var s = e.logicalShape,
        r = t[n],
        a = r.shape;
    if (!p(s, a)) throw Error("Binary was compiled with different shapes than the current args. Shapes ".concat(s, " and ").concat(a, " must match"));
    if (e.isUniform && r.isUniform) return;
    var i = e.texShape,
        o = r.isUniform ? null : r.texData.texShape;
    if (!p(i, o)) throw Error("Binary was compiled with different texture shapes than the current args. Shape ".concat(i, " and ").concat(o, " must match"));
  });
}

function Wk(e) {
  return V().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
}

var Uk = $m.addImpl,
    Vk = $m.bincountImpl,
    Gk = $m.bincountReduceImpl,
    Hk = $m.ceilImpl,
    jk = $m.concatImpl,
    qk = $m.equalImpl,
    Kk = $m.expImpl,
    Xk = $m.expm1Impl,
    Yk = $m.floorImpl,
    Jk = $m.gatherNdImpl,
    Zk = $m.gatherV2Impl,
    Qk = $m.greaterImpl,
    ew = $m.greaterEqualImpl,
    tw = $m.lessImpl,
    nw = $m.lessEqualImpl,
    sw = $m.linSpaceImpl,
    rw = $m.logImpl,
    aw = $m.maxImpl,
    iw = $m.maximumImpl,
    ow = $m.minimumImpl,
    lw = $m.multiplyImpl,
    uw = $m.negImpl,
    cw = $m.notEqualImpl,
    hw = $m.prodImpl,
    dw = $m.rangeImpl,
    pw = $m.rsqrtImpl,
    fw = $m.simpleAbsImpl,
    gw = $m.sliceImpl,
    mw = $m.sparseFillEmptyRowsImpl,
    bw = $m.sparseReshapeImpl,
    xw = $m.sparseSegmentReductionImpl,
    yw = $m.stridedSliceImpl,
    kw = $m.stringNGramsImpl,
    ww = $m.stringSplitImpl,
    vw = $m.stringToHashBucketFastImpl,
    Iw = $m.subImpl,
    $w = $m.tileImpl,
    Nw = $m.topKImpl,
    Cw = $m.transposeImpl,
    Sw = $m.uniqueImpl;

function Tw(e, t) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(function (t) {
    return "".concat(e, ".").concat(t);
  });
}

function Ew(e, t) {
  return 1 === t ? [e] : Tw(e, t);
}

var Rw = function Rw(e) {
  "use strict";

  _classCallCheck(this, Rw);

  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e;
  var t = e.length;
  if (0 === t) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else {
    var _n276 = Ew("rc", t),
        _s212 = Mk(t),
        _r156 = function (e, t, n) {
      if (1 === e) return "rc > ".concat(t[0]);
      var s = "";

      for (var _r157 = e - 2; _r157 < e; _r157++) {
        s += "".concat(n[_r157], " >= ").concat(t[_r157]), _r157 < e - 1 && (s += "||");
      }

      return s;
    }(t, e, _n276),
        a = function (e, t, n, s) {
      if (1 === e) return "";
      var r = s.slice(-2);
      return "\n    int r = ".concat(r[0], ";\n    int c = ").concat(r[1], ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ").concat(t, ";\n    bool rEdge = rp1 >= ").concat(n, ";\n  ");
    }(t, e[e.length - 1], e[e.length - 2], _n276),
        i = function (e, t) {
      var n = e.length,
          s = function (e, t) {
        var n = [];

        for (var _s213 = 0; _s213 <= 1; _s213++) {
          for (var _r158 = 0; _r158 <= 1; _r158++) {
            var _a110 = "".concat(0 === _s213 ? "r" : "rp1", ", ").concat(0 === _r158 ? "c" : "cp1");

            for (var _n277 = 2; _n277 < e; _n277++) {
              _a110 = "".concat(t[t.length - 1 - _n277], ",") + _a110;
            }

            n.push(_a110);
          }
        }

        return n;
      }(n, t);

      return 1 === n ? "getA(rc),\n            rc + 1 >= ".concat(e[0], " ? 0. : getA(rc + 1),\n            0, 0") : "getA(".concat(s[0], "),\n          cEdge ? 0. : getA(").concat(s[1], "),\n          rEdge ? 0. : getA(").concat(s[2], "),\n          rEdge || cEdge ? 0. : getA(").concat(s[3], ")");
    }(e, _n276);

    this.userCode = "\n        void main() {\n          ".concat(_s212, " rc = getOutputCoords();\n\n          if(").concat(_r156, ") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a, "\n\n            setOutput(vec4(").concat(i, "));\n          }\n        }\n      ");
  }
};

var Aw = function Aw(e, t) {
  "use strict";

  _classCallCheck(this, Aw);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  var n = "";

  for (var _e435 = 0; _e435 < 4; _e435++) {
    var _t415 = "thisRC = rc;";
    _e435 % 2 == 1 && (_t415 += "thisRC.z += 1;"), _e435 > 1 && (_t415 += "thisRC.y += 1;"), n += "\n        ".concat(_t415, "\n        ").concat(_e435 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "", "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(_e435, "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(_e435 > 0 ? "}" : "", "\n      ");
  }

  var s;
  this.userCode = "\n      ".concat((s = t, "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(uk(["r", "c", "d"], s), "\n      return ivec3(r, c, d);\n    }\n  ")), "\n      ").concat(hk(e), "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(e[1], ";\n        int cols = ").concat(e[2], ";\n\n        ").concat(n, "\n\n        setOutput(result);\n      }\n    ");
};

var Fw = /*#__PURE__*/function () {
  "use strict";

  function Fw(e) {
    _classCallCheck(this, Fw);

    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }

  _createClass(Fw, [{
    key: "acquireTexture",
    value: function acquireTexture(e, t, n) {
      var s = _w(t, n),
          r = Ow(e, s, n);

      r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
      var a = Dw(e, s, this.gpgpu.gl, this.gpgpu.textureConfig, n);

      if (this.freeTextures[r].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= a, this.log();

        var _e436 = this.freeTextures[r].shift();

        return this.usedTextures[r].push(_e436), _e436;
      }

      var i;
      return s === Oy.PACKED_2X2_FLOAT32 ? i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : s === Oy.PACKED_2X2_FLOAT16 ? i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : s === Oy.UNPACKED_FLOAT32 ? i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : s === Oy.UNPACKED_FLOAT16 ? i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : s === Oy.PACKED_4X1_UNSIGNED_BYTE && (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[r].push(i), this.numUsedTextures++, this._numBytesAllocated += a, this.log(), i;
    }
  }, {
    key: "releaseTexture",
    value: function releaseTexture(e, t, n, s) {
      if (null == this.freeTextures) return;

      var r = _w(n, s),
          a = Ow(t, r, s);

      a in this.freeTextures || (this.freeTextures[a] = []);
      var i = Dw(t, r, this.gpgpu.gl, this.gpgpu.textureConfig, s),
          o = V().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
      -1 !== o && this._numBytesAllocated > o ? (this.gpgpu.deleteMatrixTexture(e), this._numBytesAllocated -= i) : (this.freeTextures[a].push(e), this.numFreeTextures++, this._numBytesFree += i), this.numUsedTextures--;
      var l = this.usedTextures[a],
          u = l.indexOf(e);
      if (u < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      l.splice(u, 1), this.log();
    }
  }, {
    key: "log",
    value: function log() {
      if (!this.logEnabled) return;
      console.log("Free/Used", "".concat(this.numFreeTextures, " / ").concat(this.numUsedTextures), "(".concat(this.numFreeTextures + this.numUsedTextures, ")"));
      var e = this._numBytesFree / this._numBytesAllocated;
      console.log("Bytes allocated: ".concat(this._numBytesAllocated)), console.log("Bytes unused: ".concat(this._numBytesFree, " (").concat(Math.round(100 * e), "%)"));
    }
  }, {
    key: "numBytesAllocated",
    get: function get() {
      return this._numBytesAllocated;
    }
  }, {
    key: "numBytesFree",
    get: function get() {
      return this._numBytesFree;
    }
  }, {
    key: "getNumUsedTextures",
    value: function getNumUsedTextures() {
      return this.numUsedTextures;
    }
  }, {
    key: "getNumFreeTextures",
    value: function getNumFreeTextures() {
      return this.numFreeTextures;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var _this199 = this;

      if (null != this.freeTextures) {
        for (var _e437 in this.freeTextures) {
          this.freeTextures[_e437].forEach(function (e) {
            _this199.gpgpu.deleteMatrixTexture(e);
          });
        }

        for (var _e438 in this.usedTextures) {
          this.usedTextures[_e438].forEach(function (e) {
            _this199.gpgpu.deleteMatrixTexture(e);
          });
        }

        this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
      }
    }
  }]);

  return Fw;
}();

function Dw(e, t, n, s, r) {
  var a = function (e, t) {
    switch (e) {
      case Oy.PACKED_2X2_FLOAT32:
        return Ik(t);

      case Oy.PACKED_2X2_FLOAT16:
        return $k(t);

      case Oy.UNPACKED_FLOAT32:
        return kk(t);

      case Oy.UNPACKED_FLOAT16:
        return wk(t);

      case Oy.PACKED_4X1_UNSIGNED_BYTE:
        return vk(t);

      default:
        throw new Error("Unknown physical texture type ".concat(e));
    }
  }(t, s);

  var i;

  if (r) {
    var _zy9 = zy(e[0], e[1]),
        _zy10 = _slicedToArray(_zy9, 2),
        _t416 = _zy10[0],
        _n278 = _zy10[1];

    i = _t416 * _n278;
  } else {
    var _My9 = My(e[0], e[1]),
        _My10 = _slicedToArray(_My9, 2),
        _t417 = _My10[0],
        _n279 = _My10[1];

    i = _t417 * _n279;
  }

  return i * function (e, t) {
    if (t === e.R32F) return 4;
    if (t === e.R16F) return 2;
    if (t === e.RGBA32F) return 16;
    if (t === e.RGBA) return 16;
    if (t === e.RGBA16F) return 8;
    throw new Error("Unknown internal format ".concat(t));
  }(n, a);
}

function _w(e, t) {
  if (e === _y.UPLOAD) return Oy.PACKED_2X2_FLOAT32;
  if (e === _y.RENDER || null == e) return function (e) {
    return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? Oy.PACKED_2X2_FLOAT32 : Oy.UNPACKED_FLOAT32 : e ? Oy.PACKED_2X2_FLOAT16 : Oy.UNPACKED_FLOAT16;
  }(t);
  if (e === _y.DOWNLOAD || e === _y.PIXELS) return Oy.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type ".concat(e));
}

function Ow(e, t, n) {
  return "".concat(e[0], "_").concat(e[1], "_").concat(t, "_").concat(n);
}

var Mw = function Mw(e, t) {
  "use strict";

  _classCallCheck(this, Mw);

  this.variableNames = ["A"], this.outputShape = e, this.enableShapeUniforms = Wk(this.outputShape.length), this.userCode = "\n      float unaryOperation(float x) {\n        ".concat(t, "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
};

var Lw = "return x;";

var zw = function zw(e, t) {
  "use strict";

  _classCallCheck(this, zw);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.enableShapeUniforms = Wk(this.outputShape.length), this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t, "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ");
};

var Bw = function Bw(e) {
  "use strict";

  _classCallCheck(this, Bw);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e;

  var t = e.length,
      n = Ew("rc", t),
      s = Mk(t),
      r = function (e, t) {
    if (1 === e) return "rc";
    var n = "";

    for (var _s214 = 0; _s214 < e; _s214++) {
      n += t[_s214], _s214 < e - 1 && (n += ",");
    }

    return n;
  }(t, n),
      a = n.slice(-2),
      i = t <= 1 ? "rc" : "vec2(".concat(a.join(","), ")");

  this.userCode = "\n      void main() {\n        ".concat(s, " rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r, ");\n\n        setOutput(getChannel(packedInput, ").concat(i, "));\n      }\n    ");
};

var Pw = Ii,
    Ww = {},
    Uw = V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");

var Vw = /*#__PURE__*/function (_n280) {
  "use strict";

  _inherits(Vw, _n280);

  var _super137 = _createSuper(Vw);

  function Vw(e) {
    var _this200;

    _classCallCheck(this, Vw);

    if (_this200 = _super137.call(this), _this200.pendingRead = new WeakMap(), _this200.pendingDisposal = new WeakSet(), _this200.dataRefCount = new WeakMap(), _this200.numBytesInGPU = 0, _this200.uploadWaitMs = 0, _this200.downloadWaitMs = 0, _this200.lastGlFlushTime = 0, _this200.warnedAboutMemory = !1, _this200.pendingDeletes = 0, _this200.disposed = !1, !V().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");

    if (null == e) {
      var _e439 = Fy(V().getNumber("WEBGL_VERSION"));

      _this200.binaryCache = ((n = V().getNumber("WEBGL_VERSION")) in Ww || (Ww[n] = {}), Ww[n]), _this200.gpgpu = new Nk(_e439), _this200.canvas = _e439.canvas, _this200.gpgpuCreatedLocally = !0;
    } else _this200.gpgpu = e, _this200.binaryCache = {}, _this200.gpgpuCreatedLocally = !1, _this200.canvas = e.gl.canvas;

    var n;
    _this200.textureManager = new Fw(_this200.gpgpu), _this200.numMBBeforeWarning = null == V().global.screen ? 1024 : V().global.screen.height * V().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, _this200.texData = new t(_assertThisInitialized(_this200), Kn());
    return _possibleConstructorReturn(_this200);
  }

  _createClass(Vw, [{
    key: "nextDataId",
    value: function nextDataId() {
      return Vw.nextDataId++;
    }
  }, {
    key: "numDataIds",
    value: function numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
  }, {
    key: "write",
    value: function write(e, t, n) {
      if ((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || V().getBool("DEBUG")) && this.checkNumericalProblems(e), "complex64" === n && null != e) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      var s = {
        id: this.nextDataId()
      };
      return this.texData.set(s, {
        shape: t,
        dtype: n,
        values: e,
        usage: _y.UPLOAD,
        refCount: 1
      }), s;
    }
  }, {
    key: "refCount",
    value: function refCount(e) {
      return this.texData.has(e) ? this.texData.get(e).refCount : 0;
    }
  }, {
    key: "incRef",
    value: function incRef(e) {
      this.texData.get(e).refCount++;
    }
  }, {
    key: "decRef",
    value: function decRef(e) {
      this.texData.has(e) && this.texData.get(e).refCount--;
    }
  }, {
    key: "move",
    value: function move(e, t, n, s, r) {
      if (V().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === s) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.texData.set(e, {
        shape: n,
        dtype: s,
        values: t,
        usage: _y.UPLOAD,
        refCount: r
      });
    }
  }, {
    key: "disposeIntermediateTensorInfo",
    value: function disposeIntermediateTensorInfo(e) {
      this.disposeData(e.dataId);
    }
  }, {
    key: "readSync",
    value: function readSync(e) {
      var t = this.texData.get(e),
          n = t.values,
          s = t.dtype,
          r = t.complexTensorInfos,
          a = t.slice,
          i = t.shape,
          o = t.isPacked;

      if (null != a) {
        var _t418;

        _t418 = o ? new zw(i, Lw) : new Mw(i, Lw);

        var _n281 = this.runWebGLProgram(_t418, [{
          dataId: e,
          shape: i,
          dtype: s
        }], s),
            _r159 = this.readSync(_n281.dataId);

        return this.disposeIntermediateTensorInfo(_n281), _r159;
      }

      if (null != n) return this.convertAndCacheOnCPU(e);
      if ("string" === s) return n;
      var l = null != this.activeTimers;
      var u, c;
      return l && (u = Ve()), c = "complex64" === s ? Mo(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.getValuesFromTexture(e), l && (this.downloadWaitMs += Ve() - u), this.convertAndCacheOnCPU(e, c);
    }
  }, {
    key: "read",
    value: function () {
      var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee88(e) {
        var _t419, t, n, s, r, a, i, o, _t420, _n282, _r160, l, u, c, _this$gpgpu, _t421, _e440, _e441, _e442, h, p;

        return _regeneratorRuntime.wrap(function _callee88$(_context91) {
          while (1) {
            switch (_context91.prev = _context91.next) {
              case 0:
                if (!this.pendingRead.has(e)) {
                  _context91.next = 3;
                  break;
                }

                _t419 = this.pendingRead.get(e);
                return _context91.abrupt("return", new Promise(function (e) {
                  return _t419.push(e);
                }));

              case 3:
                t = this.texData.get(e), n = t.values, s = t.shape, r = t.slice, a = t.dtype, i = t.complexTensorInfos, o = t.isPacked;

                if (!(null != r)) {
                  _context91.next = 8;
                  break;
                }

                _t420 = o ? new zw(s, Lw) : new Mw(s, Lw);
                _n282 = this.runWebGLProgram(_t420, [{
                  dataId: e,
                  shape: s,
                  dtype: a
                }], a), _r160 = this.read(_n282.dataId);
                return _context91.abrupt("return", (this.disposeIntermediateTensorInfo(_n282), _r160));

              case 8:
                if (!(null != n)) {
                  _context91.next = 10;
                  break;
                }

                return _context91.abrupt("return", this.convertAndCacheOnCPU(e));

              case 10:
                if (!(!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === V().getNumber("WEBGL_VERSION"))) {
                  _context91.next = 12;
                  break;
                }

                throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");

              case 12:
                c = null;

                if ("complex64" !== a && V().get("WEBGL_BUFFER_SUPPORTED")) {
                  l = this.decode(e);
                  _t421 = this.texData.get(l.dataId);
                  c = (_this$gpgpu = this.gpgpu).createBufferFromTexture.apply(_this$gpgpu, [_t421.texture].concat(_toConsumableArray(Ly(s))));
                }

                this.pendingRead.set(e, []);
                _context91.t0 = "complex64" !== a;

                if (!_context91.t0) {
                  _context91.next = 19;
                  break;
                }

                _context91.next = 19;
                return this.gpgpu.createAndWaitForFence();

              case 19:
                if (!("complex64" === a)) {
                  _context91.next = 26;
                  break;
                }

                _context91.next = 22;
                return Promise.all([this.read(i.real.dataId), this.read(i.imag.dataId)]);

              case 22:
                _e440 = _context91.sent;
                u = Mo(_e440[0], _e440[1]);
                _context91.next = 27;
                break;

              case 26:
                if (null == c) u = this.getValuesFromTexture(e);else {
                  _e441 = d(s);
                  u = this.gpgpu.downloadFloat32MatrixFromBuffer(c, _e441);
                }

              case 27:
                if (null != l && this.disposeIntermediateTensorInfo(l), null != c) {
                  _e442 = this.gpgpu.gl;
                  Py(_e442, function () {
                    return _e442.deleteBuffer(c);
                  });
                }

                h = this.convertAndCacheOnCPU(e, u), p = this.pendingRead.get(e);
                return _context91.abrupt("return", (this.pendingRead.delete(e), p.forEach(function (e) {
                  return e(h);
                }), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e) && Kn().removeDataId(e, this), this.pendingDeletes--), h));

              case 30:
              case "end":
                return _context91.stop();
            }
          }
        }, _callee88, this);
      }));

      function read(_x141) {
        return _read2.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "bufferSync",
    value: function bufferSync(e) {
      var t = this.readSync(e.dataId);
      var n = t;
      if ("string" === e.dtype) try {
        n = t.map(function (e) {
          return He(e);
        });
      } catch (e) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return dn(e.shape, e.dtype, n);
    }
  }, {
    key: "checkNumericalProblems",
    value: function checkNumericalProblems(e) {
      if (null != e) for (var _t422 = 0; _t422 < e.length; _t422++) {
        var _n283 = e[_t422];

        if (!Wy(_n283)) {
          if (V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value ".concat(_n283, " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"));
          throw Error("The value ".concat(_n283, " cannot be represented on this device."));
        }
      }
    }
  }, {
    key: "getValuesFromTexture",
    value: function getValuesFromTexture(e) {
      var _this$texData$get = this.texData.get(e),
          t = _this$texData$get.shape,
          n = _this$texData$get.dtype,
          s = _this$texData$get.isPacked,
          r = d(t);

      if (V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        var _this$gpgpu2;

        var _n284 = this.decode(e),
            _s215 = this.texData.get(_n284.dataId),
            _a111 = (_this$gpgpu2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(_this$gpgpu2, [_s215.texture].concat(_toConsumableArray(Ly(t)))).subarray(0, r);

        return this.disposeIntermediateTensorInfo(_n284), _a111;
      }

      var a = V().getBool("WEBGL_PACK") && !0 === s,
          i = a ? Zy(t) : t,
          o = a ? new mk(i) : new gk(i),
          l = this.runWebGLProgram(o, [{
        shape: i,
        dtype: n,
        dataId: e
      }], "float32"),
          u = this.texData.get(l.dataId),
          c = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture, u.texShape[0], u.texShape[1]).subarray(0, r);
      return this.disposeIntermediateTensorInfo(l), c;
    }
  }, {
    key: "timerAvailable",
    value: function timerAvailable() {
      return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
  }, {
    key: "time",
    value: function () {
      var _time3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee89(e) {
        var t, n, s, r, a, i, _e443;

        return _regeneratorRuntime.wrap(function _callee89$(_context92) {
          while (1) {
            switch (_context92.prev = _context92.next) {
              case 0:
                t = this.activeTimers, n = [];
                s = !1;
                null == this.programTimersStack ? (this.programTimersStack = n, s = !0) : this.activeTimers.push(n), this.activeTimers = n, e();
                r = h(this.activeTimers.map(function (e) {
                  return e.query;
                })).filter(function (e) {
                  return null != e;
                }), a = h(this.activeTimers.map(function (e) {
                  return e.name;
                })).filter(function (e) {
                  return null != e;
                });
                this.activeTimers = t, s && (this.programTimersStack = null);
                i = {
                  uploadWaitMs: this.uploadWaitMs,
                  downloadWaitMs: this.downloadWaitMs,
                  kernelMs: null,
                  wallMs: null
                };

                if (!(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                  _context92.next = 13;
                  break;
                }

                _context92.next = 9;
                return Promise.all(r);

              case 9:
                _e443 = _context92.sent;
                i.kernelMs = function (e) {
                  var t = 0;

                  for (var _n285 = 0; _n285 < e.length; _n285++) {
                    t += e[_n285];
                  }

                  return t;
                }(_e443), i.getExtraProfileInfo = function () {
                  return _e443.map(function (e, t) {
                    return {
                      name: a[t],
                      ms: e
                    };
                  }).map(function (e) {
                    return "".concat(e.name, ": ").concat(e.ms);
                  }).join(", ");
                };
                _context92.next = 14;
                break;

              case 13:
                i.kernelMs = {
                  error: "WebGL query timers are not supported in this environment."
                };

              case 14:
                return _context92.abrupt("return", (this.uploadWaitMs = 0, this.downloadWaitMs = 0, i));

              case 15:
              case "end":
                return _context92.stop();
            }
          }
        }, _callee89, this);
      }));

      function time(_x142) {
        return _time3.apply(this, arguments);
      }

      return time;
    }()
  }, {
    key: "memory",
    value: function memory() {
      return {
        unreliable: !1,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
  }, {
    key: "startTimer",
    value: function startTimer() {
      return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
        startMs: Ve(),
        endMs: null
      };
    }
  }, {
    key: "endTimer",
    value: function endTimer(e) {
      return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = Ve(), e);
    }
  }, {
    key: "getQueryTime",
    value: function () {
      var _getQueryTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee90(e) {
        return _regeneratorRuntime.wrap(function _callee90$(_context93) {
          while (1) {
            switch (_context93.prev = _context93.next) {
              case 0:
                return _context93.abrupt("return", V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.waitForQueryAndGetTime(e) : e.endMs - e.startMs);

              case 1:
              case "end":
                return _context93.stop();
            }
          }
        }, _callee90, this);
      }));

      function getQueryTime(_x143) {
        return _getQueryTime.apply(this, arguments);
      }

      return getQueryTime;
    }()
  }, {
    key: "disposeData",
    value: function disposeData(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      if (this.pendingDisposal.has(e)) return !1;
      if (!this.texData.has(e)) return !0;
      if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return !1;
      if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
      this.releaseGPUData(e);

      var _this$texData$get2 = this.texData.get(e),
          n = _this$texData$get2.complexTensorInfos;

      return null != n && (this.disposeData(n.real.dataId, t), this.disposeData(n.imag.dataId, t)), this.texData.delete(e), !0;
    }
  }, {
    key: "releaseGPUData",
    value: function releaseGPUData(e) {
      var _this$texData$get3 = this.texData.get(e),
          t = _this$texData$get3.texture,
          n = _this$texData$get3.dtype,
          s = _this$texData$get3.texShape,
          r = _this$texData$get3.usage,
          a = _this$texData$get3.isPacked,
          i = _this$texData$get3.slice,
          o = i && i.origDataId || e,
          l = this.dataRefCount.get(o);

      l > 1 ? this.dataRefCount.set(o, l - 1) : (this.dataRefCount.delete(o), null != t && (this.numBytesInGPU -= this.computeBytes(s, n), this.textureManager.releaseTexture(t, s, r, a)));
      var u = this.texData.get(e);
      u.texture = null, u.texShape = null, u.isPacked = !1, u.slice = null;
    }
  }, {
    key: "getTexture",
    value: function getTexture(e) {
      return this.uploadToGPU(e), this.texData.get(e).texture;
    }
  }, {
    key: "getDataInfo",
    value: function getDataInfo(e) {
      return this.texData.get(e);
    }
  }, {
    key: "shouldExecuteOnCPU",
    value: function shouldExecuteOnCPU(e) {
      var _this201 = this;

      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Uw;
      return V().getBool("WEBGL_CPU_FORWARD") && e.every(function (e) {
        return null == _this201.texData.get(e.dataId).texture && d(e.shape) < t;
      });
    }
  }, {
    key: "getGPGPUContext",
    value: function getGPGPUContext() {
      return this.gpgpu;
    }
  }, {
    key: "where",
    value: function where(e) {
      Oo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      var t = e.dataSync();
      return Pw(e.shape, t);
    }
  }, {
    key: "packedUnaryOp",
    value: function packedUnaryOp(e, t, n) {
      var s = new zw(e.shape, t),
          r = this.compileAndRun(s, [e], n);
      return Kn().makeTensorFromDataId(r.dataId, r.shape, r.dtype);
    }
  }, {
    key: "abs",
    value: function abs(e) {
      if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
        var _t423 = fw(this.texData.get(e.dataId).values);

        return this.makeOutput(e.shape, e.dtype, _t423);
      }

      if (V().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, "return abs(x);", e.dtype);
      var t = new Mw(e.shape, "return abs(x);"),
          n = this.compileAndRun(t, [e]);
      return Kn().makeTensorFromDataId(n.dataId, n.shape, n.dtype);
    }
  }, {
    key: "makeTensorInfo",
    value: function makeTensorInfo(e, t, n) {
      var s;

      if ("string" === t && null != n && n.length > 0 && C(n[0])) {
        var _r161 = n.map(function (e) {
          return Ge(e);
        });

        s = this.write(_r161, e, t);
      } else s = this.write(n, e, t);

      return this.texData.get(s).usage = null, {
        dataId: s,
        shape: e,
        dtype: t
      };
    }
  }, {
    key: "makeOutput",
    value: function makeOutput(e, t, n) {
      var _this$makeTensorInfo = this.makeTensorInfo(e, t, n),
          s = _this$makeTensorInfo.dataId;

      return Kn().makeTensorFromDataId(s, e, t, this);
    }
  }, {
    key: "unpackTensor",
    value: function unpackTensor(e) {
      var t = new Bw(e.shape);
      return this.runWebGLProgram(t, [e], e.dtype);
    }
  }, {
    key: "packTensor",
    value: function packTensor(e) {
      var t = new Rw(e.shape);
      return this.runWebGLProgram(t, [e], e.dtype, null, !0);
    }
  }, {
    key: "packedReshape",
    value: function packedReshape(e, t) {
      var n = [Yy(e.shape)].concat(_toConsumableArray(Jy(e.shape))),
          s = {
        dtype: e.dtype,
        shape: n,
        dataId: e.dataId
      },
          r = [Yy(t)].concat(_toConsumableArray(Jy(t))),
          a = new Aw(r, n),
          i = this.runWebGLProgram(a, [s], e.dtype, null, !0);
      return {
        dataId: i.dataId,
        shape: t,
        dtype: i.dtype
      };
    }
  }, {
    key: "decode",
    value: function decode(e) {
      var t = this.texData.get(e),
          n = t.isPacked,
          s = t.shape,
          r = t.dtype,
          a = Zy(s);
      var i;
      return i = n ? new fk(a) : new pk(a), {
        dtype: r,
        shape: s,
        dataId: this.runWebGLProgram(i, [{
          shape: a,
          dtype: r,
          dataId: e
        }], r, null, !0).dataId
      };
    }
  }, {
    key: "runWebGLProgram",
    value: function runWebGLProgram(e, t, n, s) {
      var _this202 = this;

      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      var a = this.makeTensorInfo(e.outputShape, n),
          i = this.texData.get(a.dataId);

      if (e.packedOutput && (i.isPacked = !0), e.outPackingScheme === Dy.DENSE) {
        var _t424 = Ly(e.outputShape);

        i.texShape = _t424.map(function (e) {
          return 2 * e;
        });
      }

      if (null != e.outTexUsage && (i.usage = e.outTexUsage), 0 === d(a.shape)) return i.values = w(a.dtype, 0), a;
      var o = [],
          l = t.map(function (t) {
        if ("complex64" === t.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");

        var n = _this202.texData.get(t.dataId);

        if (null == n.texture) {
          if (!e.packedInputs && d(t.shape) <= V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
            shape: t.shape,
            texData: null,
            isUniform: !0,
            uniformValues: n.values
          };
          e.packedInputs && (n.isPacked = !0, n.shape = t.shape);
        } else if (!!n.isPacked != !!e.packedInputs) t = n.isPacked ? _this202.unpackTensor(t) : _this202.packTensor(t), o.push(t), n = _this202.texData.get(t.dataId);else if (n.isPacked && !ek(n.shape, t.shape)) {
          var _e444 = t,
              _s216 = t.shape;
          t.shape = n.shape, t = _this202.packedReshape(t, _s216), o.push(t), n = _this202.texData.get(t.dataId), _e444.shape = _s216;
        }

        return _this202.uploadToGPU(t.dataId), {
          shape: t.shape,
          texData: n,
          isUniform: !1
        };
      });
      this.uploadToGPU(a.dataId);

      var u = {
        shape: a.shape,
        texData: i,
        isUniform: !1
      },
          c = function (e, t, n) {
        var s = "";
        t.concat(n).forEach(function (t) {
          var r = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0;

          if (e.enableShapeUniforms && !t.isUniform) {
            var _a112 = t.texData.texShape,
                _Lk2 = Lk(e.packedInputs, t.shape, _a112),
                _i97 = _Lk2.useSqueezeShape,
                _o63 = _Lk2.uniformShape;

            var _l45 = "",
                _u33 = "",
                _c26 = "";

            if (1 === _o63.length && e.packedInputs) {
              var _e445 = [Math.ceil(_a112[0] / 2), Math.ceil(_a112[1] / 2)];
              _l45 = "".concat(_e445[0] > 1, "_").concat(_e445[1] > 1);
            } else if (2 !== _o63.length || e.packedInputs) {
              if (_o63.length > 2 && !e.packedInputs) {
                var _e446 = A(_o63);

                _c26 = "".concat(_e446[0] === _a112[1], "_").concat(_e446[_e446.length - 1] === _a112[1]);
              }
            } else _u33 = "".concat(_o63[0] > 1, "_").concat(_o63[1] > 1);

            var _h15 = t.shape.length,
                _f11 = 2 === _h15 && p(t.shape, _a112),
                _g21 = 1 === d(t.shape),
                _m13 = lr(t.shape, n.shape),
                _b14 = !e.packedInputs && _h15 === n.shape.length && p(_a112, n.texData.texShape);

            s += "".concat(_h15, "_").concat(_b14, "_").concat(_i97, "_").concat(_o63.length, "_").concat(_g21, "_").concat(_m13, "_").concat(_f11, "_").concat(_l45, "_").concat(_u33, "_").concat(_c26, "_").concat(e.packedInputs || _h15 > 2 ? "" : "".concat(_a112[0] > 1, "_").concat(_a112[1] > 1), "_").concat(r);
          } else s += "".concat(t.shape, "_").concat(t.isUniform ? "uniform" : t.texData.texShape, "_").concat(r);
        });
        var r = e.constructor.name;
        return r += "_" + s + "_" + e.userCode + "".concat(V().getNumber("WEBGL_VERSION")), r;
      }(e, l, u),
          h = this.getAndSaveBinary(c, function () {
        return function (e, t, n, s) {
          var r = n.map(function (e, n) {
            var s = {
              logicalShape: e.shape,
              texShape: e.isUniform ? null : e.texData.texShape,
              isUniform: e.isUniform,
              isPacked: !e.isUniform && e.texData.isPacked,
              flatOffset: null
            };
            return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (s.flatOffset = e.texData.slice.flatOffset), {
              name: t.variableNames[n],
              shapeInfo: s
            };
          }),
              a = r.map(function (e) {
            return e.shapeInfo;
          }),
              i = {
            logicalShape: s.shape,
            texShape: s.texData.texShape,
            isUniform: !1,
            isPacked: s.texData.isPacked,
            flatOffset: null
          },
              o = Sk(r, i, t),
              l = e.createProgram(o);
          var u = null;
          var c = e.getUniformLocation(l, "NAN", !1);
          1 === V().getNumber("WEBGL_VERSION") && (u = e.getUniformLocation(l, "INFINITY", !1));
          var h = !1,
              d = {},
              p = {},
              f = {};

          for (var _n286 = 0; _n286 < t.variableNames.length; _n286++) {
            var _s217 = t.variableNames[_n286];
            d[_s217] = e.getUniformLocation(l, _s217, h), d["offset".concat(_s217)] = e.getUniformLocation(l, "offset".concat(_s217), h), t.enableShapeUniforms && (p["".concat(_s217, "Shape")] = e.getUniformLocation(l, "".concat(_s217, "Shape"), h), f["".concat(_s217, "TexShape")] = e.getUniformLocation(l, "".concat(_s217, "TexShape"), h));
          }

          var g, m, b;
          t.enableShapeUniforms && (g = e.getUniformLocation(l, "outShape", h), b = e.getUniformLocation(l, "outShapeStrides", h), m = e.getUniformLocation(l, "outTexShape", h));
          var x = [];
          return t.customUniforms && t.customUniforms.forEach(function (t, n) {
            x[n] = e.getUniformLocation(l, t.name, h);
          }), {
            program: t,
            source: o,
            webGLProgram: l,
            uniformLocations: d,
            customUniformLocations: x,
            inShapeInfos: a,
            outShapeInfo: i,
            infLoc: u,
            nanLoc: c,
            inShapesLocations: p,
            inTexShapesLocations: f,
            outShapeLocation: g,
            outShapeStridesLocation: b,
            outTexShapeLocation: m
          };
        }(_this202.gpgpu, e, l, u);
      }),
          f = null != this.activeTimers;

      var g;
      f && (g = this.startTimer()), function (e, t, n, s, r) {
        t.program.enableShapeUniforms || (Pk(t.inShapeInfos, n), Pk([t.outShapeInfo], [s]));
        var a = s.texData.texture,
            i = s.texData.texShape;
        s.texData.isPacked ? e.setOutputPackedMatrixTexture(a, i[0], i[1]) : e.setOutputMatrixTexture(a, i[0], i[1]), e.setProgram(t.webGLProgram), 1 === V().getNumber("WEBGL_VERSION") && null !== t.infLoc && e.gl.uniform1f(t.infLoc, Infinity), null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN), n.forEach(function (n, s) {
          var r = t.program.variableNames[s],
              a = t.uniformLocations[r],
              i = t.uniformLocations["offset".concat(r)],
              o = t.inShapesLocations["".concat(r, "Shape")],
              l = t.inTexShapesLocations["".concat(r, "TexShape")];

          if (o) {
            var _Lk3 = Lk(t.program.packedInputs, n.shape, n.texData.texShape),
                _s218 = _Lk3.uniformShape;

            switch (_s218.length) {
              case 1:
                e.gl.uniform1iv(o, new Int32Array(_s218));
                break;

              case 2:
                e.gl.uniform2iv(o, new Int32Array(_s218));
                break;

              case 3:
                e.gl.uniform3iv(o, new Int32Array(_s218));
                break;

              case 4:
                e.gl.uniform4iv(o, new Int32Array(_s218));
            }
          }

          if (l && e.gl.uniform2i(l, n.texData.texShape[0], n.texData.texShape[1]), null != a) if (n.isUniform) {
            if (d(n.shape) < 2) e.gl.uniform1f(a, n.uniformValues[0]);else {
              var _t425 = n.uniformValues;
              _t425 instanceof Float32Array || (_t425 = new Float32Array(_t425)), e.gl.uniform1fv(a, _t425);
            }
          } else null != n.texData.slice && null != i && e.gl.uniform1i(i, n.texData.slice.flatOffset), e.setInputMatrixTexture(n.texData.texture, a, s);
        });
        var o = t.outShapeLocation;
        if (o) switch (s.shape.length) {
          case 1:
            e.gl.uniform1iv(o, new Int32Array(s.shape));
            break;

          case 2:
            e.gl.uniform2iv(o, new Int32Array(s.shape));
            break;

          case 3:
            e.gl.uniform3iv(o, new Int32Array(s.shape));
            break;

          case 4:
            e.gl.uniform4iv(o, new Int32Array(s.shape));
        }

        if (t.outShapeStridesLocation) {
          var _n287 = A(s.shape);

          switch (s.shape.length) {
            case 2:
              e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(_n287));
              break;

            case 3:
              e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(_n287));
              break;

            case 4:
              e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(_n287));
          }
        }

        t.outTexShapeLocation && e.gl.uniform2i(t.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]), t.program.customUniforms && r && t.program.customUniforms.forEach(function (n, s) {
          var a = t.customUniformLocations[s],
              i = r[s];
          if ("float" === n.type) e.gl.uniform1fv(a, i);else if ("vec2" === n.type) e.gl.uniform2fv(a, i);else if ("vec3" === n.type) e.gl.uniform3fv(a, i);else if ("vec4" === n.type) e.gl.uniform4fv(a, i);else if ("int" === n.type) e.gl.uniform1iv(a, i);else if ("ivec2" === n.type) e.gl.uniform2iv(a, i);else if ("ivec3" === n.type) e.gl.uniform3iv(a, i);else {
            if ("ivec4" !== n.type) throw Error("uniform type ".concat(n.type, " is not supported yet."));
            e.gl.uniform4iv(a, i);
          }
        }), e.executeProgram();
      }(this.gpgpu, h, l, u, s), o.forEach(function (e) {
        return _this202.disposeIntermediateTensorInfo(e);
      }), f && (g = this.endTimer(g), this.activeTimers.push({
        name: e.constructor.name,
        query: this.getQueryTime(g)
      }));
      var m = V().get("WEBGL_FLUSH_THRESHOLD");

      if (m > 0) {
        var _e447 = Ve();

        _e447 - this.lastGlFlushTime > m && (this.gpgpu.gl.flush(), this.lastGlFlushTime = _e447);
      }

      if (!V().getBool("WEBGL_LAZILY_UNPACK") && i.isPacked && !1 === r) {
        var _e448 = this.unpackTensor(a);

        return this.disposeIntermediateTensorInfo(a), _e448;
      }

      return a;
    }
  }, {
    key: "compileAndRun",
    value: function compileAndRun(e, t, n, s) {
      var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      return this.runWebGLProgram(e, t, n = n || t[0].dtype, s, r);
    }
  }, {
    key: "getAndSaveBinary",
    value: function getAndSaveBinary(e, t) {
      return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];
    }
  }, {
    key: "getTextureManager",
    value: function getTextureManager() {
      return this.textureManager;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var _this203 = this;

      this.disposed || (V().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(function (e) {
        _this203.gpgpu.deleteProgram(_this203.binaryCache[e].webGLProgram), delete _this203.binaryCache[e];
      }), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
    }
  }, {
    key: "floatPrecision",
    value: function floatPrecision() {
      var _this204 = this;

      return null == this.floatPrecisionValue && (this.floatPrecisionValue = Yn(function () {
        if (!V().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          var _e449 = V().getBool("DEBUG");

          V().set("DEBUG", !1);

          var _t426 = _this204.abs(qa(1e-8)).dataSync()[0];

          if (V().set("DEBUG", _e449), _t426 > 0) return 32;
        }

        return 16;
      })), this.floatPrecisionValue;
    }
  }, {
    key: "epsilon",
    value: function epsilon() {
      return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
    }
  }, {
    key: "uploadToGPU",
    value: function uploadToGPU(e) {
      var t = this.texData.get(e),
          n = t.shape,
          s = t.dtype,
          r = t.values,
          a = t.texture,
          o = t.usage,
          l = t.isPacked;
      if (null != a) return;
      var u = null != this.activeTimers;
      var c;
      u && (c = Ve());
      var h = t.texShape;

      if (null == h && (h = function (e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var n = V().getNumber("WEBGL_MAX_TEXTURE_SIZE");

        if (t && (n *= 2, 1 === (e = e.map(function (t, n) {
          return n >= e.length - 2 ? i(e[n]) : e[n];
        })).length && (e = [2, e[0]])), 2 !== e.length) {
          var _t427 = k(e);

          e = _t427.newShape;
        }

        var s = d(e);
        if (e.length <= 1 && s <= n) return [1, s];
        if (2 === e.length && e[0] <= n && e[1] <= n) return e;
        if (3 === e.length && e[0] * e[1] <= n && e[2] <= n) return [e[0] * e[1], e[2]];
        if (3 === e.length && e[0] <= n && e[1] * e[2] <= n) return [e[0], e[1] * e[2]];
        if (4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n) return [e[0] * e[1] * e[2], e[3]];
        if (4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n) return [e[0], e[1] * e[2] * e[3]];

        if (t) {
          var _Jy, _Jy2;

          var _t428 = Yy(e);

          var _n288 = 2,
              _r162 = 2;
          return e.length && (_Jy = Jy(e), _Jy2 = _slicedToArray(_Jy, 2), _n288 = _Jy2[0], _r162 = _Jy2[1], _Jy), s = _t428 * (_n288 / 2) * (_r162 / 2), g(s).map(function (e) {
            return 2 * e;
          });
        }

        return g(s);
      }(n, l), t.texShape = h), null != r) {
        var _zy11, _zy12;

        var _e450 = Zy(n);

        var _a113,
            _i98 = h[1],
            _o64 = h[0];

        var _d24 = r instanceof Uint8Array;

        l ? ((_zy11 = zy(h[0], h[1]), _zy12 = _slicedToArray(_zy11, 2), _i98 = _zy12[0], _o64 = _zy12[1], _zy11), _a113 = new xk(_e450, [_o64, _i98], _d24)) : _a113 = new bk(_e450, [_o64, _i98], _d24);

        var _p15 = this.makeTensorInfo([_o64, _i98], s);

        this.texData.get(_p15.dataId).usage = _d24 ? _y.PIXELS : _y.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_p15.dataId), _i98, _o64, r);

        var _f12 = this.runWebGLProgram(_a113, [_p15], s, null, !0),
            _g22 = this.texData.get(_f12.dataId);

        t.texture = _g22.texture, t.texShape = _g22.texShape, t.isPacked = _g22.isPacked, t.usage = _g22.usage, this.disposeIntermediateTensorInfo(_p15), this.texData.delete(_f12.dataId), t.values = null, u && (this.uploadWaitMs += Ve() - c);
      } else {
        var _e451 = this.acquireTexture(h, o, s, l);

        t.texture = _e451;
      }
    }
  }, {
    key: "convertAndCacheOnCPU",
    value: function convertAndCacheOnCPU(e, t) {
      var n = this.texData.get(e),
          s = n.dtype;
      return this.releaseGPUData(e), null != t && (n.values = function (e, t) {
        if ("float32" === t || "complex64" === t) return e;

        if ("int32" === t || "bool" === t) {
          var _n289 = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length);

          for (var _t429 = 0; _t429 < _n289.length; ++_t429) {
            _n289[_t429] = Math.round(e[_t429]);
          }

          return _n289;
        }

        throw new Error("Unknown dtype ".concat(t));
      }(t, s)), n.values;
    }
  }, {
    key: "acquireTexture",
    value: function acquireTexture(e, t, n, s) {
      if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
        var _e452 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);

        this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: ".concat(_e452, " MB, most likely due to a memory leak"));
      }

      return this.textureManager.acquireTexture(e, t, s);
    }
  }, {
    key: "computeBytes",
    value: function computeBytes(e, t) {
      return e[0] * e[1] * N(t);
    }
  }]);

  return Vw;
}(n);

Vw.nextDataId = 0, $t() && Qn("webgl", function () {
  return new Vw();
}, 2);

var Gw = function Gw(e, t, n) {
  "use strict";

  _classCallCheck(this, Gw);

  this.variableNames = ["A", "B"], this.outputShape = cr(t, n), this.enableShapeUniforms = Wk(this.outputShape.length), this.userCode = "\n      float binaryOperation(float a, float b) {\n        ".concat(e, "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ");
};

var Hw = /*#__PURE__*/function () {
  "use strict";

  function Hw(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;

    _classCallCheck(this, Hw);

    this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = cr(t, n);
    var r = this.outputShape.length;
    this.enableShapeUniforms = Wk(r);
    var a = "";
    if (s) if (0 === r || 1 === d(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if (a = "\n          ".concat(Mk(r), " coords = getOutputCoords();\n        "), 1 === r) a += this.enableShapeUniforms ? "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : "\n            result.y = (coords + 1) >= ".concat(this.outputShape[0], " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else {
      var _e453 = Ew("coords", r);

      a += this.enableShapeUniforms ? "\n            bool nextRowOutOfBounds =\n              (".concat(_e453[r - 2], " + 1) >= outShape[").concat(r, " - 2];\n            bool nextColOutOfBounds =\n              (").concat(_e453[r - 1], " + 1) >= outShape[").concat(r, " - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ") : "\n            bool nextRowOutOfBounds =\n              (".concat(_e453[r - 2], " + 1) >= ").concat(this.outputShape[r - 2], ";\n            bool nextColOutOfBounds =\n              (").concat(_e453[r - 1], " + 1) >= ").concat(this.outputShape[r - 1], ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ");
    }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e, "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(a, "\n\n        setOutput(result);\n      }\n    ");
  }

  return Hw;
}();

function jw(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.x;
  return n.incRef(s.dataId), {
    dataId: s.dataId,
    shape: s.shape,
    dtype: s.dtype
  };
}

var qw = {
  kernelName: "Identity",
  backendName: "webgl",
  kernelFunc: jw
};

function Kw(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.real,
      r = t.imag,
      a = n.makeTensorInfo(s.shape, "complex64"),
      i = n.texData.get(a.dataId),
      o = jw({
    inputs: {
      x: s
    },
    backend: n
  }),
      l = jw({
    inputs: {
      x: r
    },
    backend: n
  });
  return i.complexTensorInfos = {
    real: o,
    imag: l
  }, a;
}

var Xw = {
  kernelName: "Complex",
  backendName: "webgl",
  kernelFunc: Kw
},
    Yw = "return (a < 0.) ? b * a : a;",
    Jw = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    Zw = {
  kernelName: "LeakyRelu",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.alpha,
        i = n.makeTensorInfo([], "float32", We(a, "float32")),
        o = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw(Jw, r.shape, i.shape) : new Gw(Yw, r.shape, i.shape),
        l = n.runWebGLProgram(o, [r, i], r.dtype);
    return n.disposeIntermediateTensorInfo(i), l;
  }
},
    Qw = "return (a < 0.) ? b * a : a;",
    ev = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    tv = {
  kernelName: "Prelu",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x,
        r = t.alpha,
        a = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw(ev, s.shape, r.shape) : new Gw(Qw, s.shape, r.shape);
    return n.runWebGLProgram(a, [s, r], s.dtype);
  }
};

function nv(_ref40) {
  var e = _ref40.opSnippet,
      t = _ref40.packedOpSnippet,
      n = _ref40.cpuKernelImpl,
      s = _ref40.dtype;
  return function (_ref41) {
    var r = _ref41.inputs,
        a = _ref41.backend;
    var i = r.x,
        o = a,
        l = s || i.dtype;

    if (o.shouldExecuteOnCPU([i]) && null != n) {
      var _e454 = o.texData.get(i.dataId),
          _t430 = n(_e454.values, l);

      return o.makeTensorInfo(i.shape, l, _t430);
    }

    var u;
    return u = V().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != t ? new zw(i.shape, t) : new Mw(i.shape, e), o.runWebGLProgram(u, [i], l);
  };
}

function sv(_ref42) {
  var e = _ref42.opSnippet,
      t = _ref42.packedOpSnippet,
      _ref42$checkOutOfBoun = _ref42.checkOutOfBounds,
      n = _ref42$checkOutOfBoun === void 0 ? !1 : _ref42$checkOutOfBoun,
      _ref42$supportsComple = _ref42.supportsComplex,
      s = _ref42$supportsComple === void 0 ? !1 : _ref42$supportsComple,
      r = _ref42.cpuKernelImpl,
      a = _ref42.dtype;
  return function (_ref43) {
    var i = _ref43.inputs,
        o = _ref43.backend;
    var l = i.a,
        u = i.b,
        c = o;

    if (s && "complex64" === l.dtype) {
      var _t431 = c.texData.get(l.dataId),
          _n290 = c.texData.get(u.dataId),
          _map = [[_t431.complexTensorInfos.real, _n290.complexTensorInfos.real], [_t431.complexTensorInfos.imag, _n290.complexTensorInfos.imag]].map(function (t) {
        var _t432 = _slicedToArray(t, 2),
            n = _t432[0],
            s = _t432[1],
            r = {
          dataId: n.dataId,
          dtype: n.dtype,
          shape: l.shape
        },
            a = {
          dataId: s.dataId,
          dtype: s.dtype,
          shape: u.shape
        },
            i = new Gw(e, l.shape, u.shape);

        return c.runWebGLProgram(i, [r, a], dt(n.dtype, s.dtype));
      }),
          _map2 = _slicedToArray(_map, 2),
          _s219 = _map2[0],
          _r163 = _map2[1],
          _a114 = Kw({
        inputs: {
          real: _s219,
          imag: _r163
        },
        backend: c
      });

      return c.disposeIntermediateTensorInfo(_s219), c.disposeIntermediateTensorInfo(_r163), _a114;
    }

    var h = a || dt(l.dtype, u.dtype);

    if (("string" === l.dtype || "string" === u.dtype || c.shouldExecuteOnCPU([l, u])) && null != r) {
      var _e455 = c.texData.get(l.dataId).values,
          _t433 = c.texData.get(u.dataId).values,
          _n291 = "string" === l.dtype ? tl(_e455) : _e455,
          _s220 = "string" === l.dtype ? tl(_t433) : _t433,
          _r164 = r(l.shape, u.shape, _n291, _s220, h),
          _r165 = _slicedToArray(_r164, 2),
          _a115 = _r165[0],
          _i99 = _r165[1],
          _o65 = c.makeTensorInfo(_i99, h);

      return c.texData.get(_o65.dataId).values = _a115, _o65;
    }

    var d;
    return d = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != t ? new Hw(t, l.shape, u.shape, n) : new Gw(e, l.shape, u.shape), c.runWebGLProgram(d, [l, u], h);
  };
}

function rv(e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  if ("linear" === e) return "return x;";
  if ("relu" === e) return t ? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";
  if ("elu" === e) return t ? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" : "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  if ("relu6" === e) return t ? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
  if ("prelu" === e) return t ? ev : Qw;
  if ("leakyrelu" === e) return t ? Jw : Yw;
  if ("sigmoid" === e) return "return 1.0 / (1.0 + exp(-1.0 * x));";
  throw new Error("Activation ".concat(e, " has not been implemented for the WebGL backend."));
}

var av = /*#__PURE__*/function () {
  "use strict";

  function av(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var o = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : !1;
    var l = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : !1;

    _classCallCheck(this, av);

    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n;
    var u = Math.ceil((s ? e[1] : e[2]) / 2),
        c = s ? "i * 2, rc.y" : "rc.y, i * 2",
        h = r ? "rc.z, i * 2" : "i * 2, rc.z",
        d = s ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
        p = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    var f = "",
        g = "";
    i && (f = o ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i, "\n        }") : l ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(i, "\n        }"), g = "result = activation(result);");
    var m = a ? "result += getBiasAtOutCoords();" : "";
    a && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), l && this.variableNames.push("leakyreluAlpha");
    var b = "rc.x",
        x = "rc.x";
    e[0] < t[0] ? b = "int(min(float(rc.x), ".concat(e[0] - 1, ".))") : t[0] < e[0] && (x = "int(min(float(rc.x), ".concat(t[0] - 1, ".))")), this.userCode = "\n      ".concat(f, "\n\n      const float sharedDimension = ").concat(u, ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ").concat(u, "; i++) {\n          int batchA = ").concat(b, ";\n          int batchB = ").concat(x, ";\n          vec4 a = getMatrixA(batchA, ").concat(c, ");\n          vec4 b = getMatrixB(batchB, ").concat(h, ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(d[0], " * ").concat(p[0], ");\n          result += (").concat(d[1], " * ").concat(p[1], ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(m, "\n\n        ").concat(g, "\n\n        setOutput(result);\n      }\n    ");
  }

  return av;
}();

var iv = function iv(e, t, n) {
  "use strict";

  _classCallCheck(this, iv);

  this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = cr(t, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e, "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ");
};

var ov = "return a * b;";

function lv(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.a,
      r = t.b,
      a = dt(s.dtype, r.dtype);

  if ("complex64" === s.dtype) {
    var _e456 = n.texData.get(s.dataId),
        _t434 = n.texData.get(r.dataId),
        _a116 = new iv("return areal * breal - aimag * bimag;", s.shape, r.shape),
        _i100 = new iv("return areal * bimag + aimag * breal;", s.shape, r.shape),
        _o66 = [{
      dataId: _e456.complexTensorInfos.real.dataId,
      dtype: _e456.complexTensorInfos.real.dtype,
      shape: s.shape
    }, {
      dataId: _e456.complexTensorInfos.imag.dataId,
      dtype: _e456.complexTensorInfos.imag.dtype,
      shape: s.shape
    }, {
      dataId: _t434.complexTensorInfos.real.dataId,
      dtype: _t434.complexTensorInfos.real.dtype,
      shape: r.shape
    }, {
      dataId: _t434.complexTensorInfos.imag.dataId,
      dtype: _t434.complexTensorInfos.imag.dtype,
      shape: r.shape
    }],
        _l46 = n.runWebGLProgram(_a116, _o66, "float32"),
        u = n.runWebGLProgram(_i100, _o66, "float32"),
        c = Kw({
      inputs: {
        real: _l46,
        imag: u
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_l46), n.disposeIntermediateTensorInfo(u), c;
  }

  if (n.shouldExecuteOnCPU([s, r])) {
    var _e457 = n.texData.get(s.dataId),
        _t435 = n.texData.get(r.dataId),
        _lw = lw(s.shape, r.shape, _e457.values, _t435.values, a),
        _lw2 = _slicedToArray(_lw, 2),
        _i101 = _lw2[0],
        _o67 = _lw2[1],
        _l47 = n.makeTensorInfo(_o67, a);

    return n.texData.get(_l47.dataId).values = _i101, _l47;
  }

  var i;
  return i = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw(ov, s.shape, r.shape) : new Gw(ov, s.shape, r.shape), n.runWebGLProgram(i, [s, r], a);
}

var uv = {
  kernelName: "Multiply",
  backendName: "webgl",
  kernelFunc: lv
};

function cv(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.shape,
      i = n,
      o = d(r.shape),
      u = x(a, o),
      c = d(u);
  l(o === c, function () {
    return "The new shape (".concat(u, ") has ").concat(c, " elements and the old shape (").concat(r.shape, ") has ").concat(o, " elements. The new shape and old shape must have the same number of elements.");
  });
  var h = i.texData.get(r.dataId);
  return !h.isPacked || ek(r.shape, u) || null !== h.texture && ek(h.shape, u) ? (i.incRef(r.dataId), {
    dataId: r.dataId,
    shape: u,
    dtype: r.dtype
  }) : function (e, t, n) {
    var s = [Yy(e.shape)].concat(_toConsumableArray(Jy(e.shape))),
        r = {
      dtype: e.dtype,
      shape: s,
      dataId: e.dataId
    },
        a = [Yy(t)].concat(_toConsumableArray(Jy(t))),
        i = new Aw(a, s),
        o = n.runWebGLProgram(i, [r], e.dtype, null, !0);
    return {
      dataId: o.dataId,
      shape: t,
      dtype: o.dtype
    };
  }(r, u, i);
}

var hv = {
  kernelName: "Reshape",
  backendName: "webgl",
  kernelFunc: cv
};

var dv = function dv(e, t) {
  "use strict";

  _classCallCheck(this, dv);

  this.variableNames = ["x"];
  var n = e.windowSize,
      s = e.batchSize,
      r = e.inSize,
      a = e.outSize;
  this.outputShape = [s, a];
  var i = 4 * Math.floor(n / 4),
      o = n % 4;
  var l = "sumValue += dot(values, ones);";

  if (null != t) {
    var _e458 = 1 / t;

    l = "sumValue += dot(values * ".concat(f(_e458) ? _e458.toPrecision(2) : _e458, ", ones);");
  }

  var u = "";
  r % n > 0 && (u = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return 0.0;\n        }\n      ")), this.userCode = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(u, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n, ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l, "\n        }\n\n        int inIdx = inOffset + ").concat(i, ";\n        if (").concat(1 === o, ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l, "\n        } else if (").concat(2 === o, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l, "\n        } else if (").concat(3 === o, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l, "\n        }\n        setOutput(sumValue);\n      }\n    ");
};

var pv = function pv(e, t) {
  "use strict";

  _classCallCheck(this, pv);

  this.variableNames = ["x"];
  var n = e.windowSize,
      s = e.batchSize,
      r = e.inSize,
      a = e.outSize;
  this.outputShape = [s, a];
  var i = "0.0",
      o = "";
  "prod" === t ? i = "1.0" : "min" === t ? (i = "1.0 / 1e-20", o = "min") : "max" === t && (i = "-1.0 / 1e-20", o = "max");
  var l = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
  "sum" === t ? l = "sumValue" : "prod" === t ? l = "prodValue" : "all" === t ? l = "allValue" : "any" === t && (l = "anyValue");
  var u = 4 * Math.floor(n / 4),
      c = n % 4;
  var h = "\n      if (".concat("sum" === t, ") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod" === t, ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(o, "(values, minMaxValue);\n        if (").concat("min" === t, " || ").concat("max" === t, ") {\n          minMaxValue = ").concat(o, "(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),
      d = "vec4";
  "all" === t ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", d = "bvec4") : "any" === t && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", d = "bvec4");
  var p = "";
  r % n > 0 && (p = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return initializationValue;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat(i, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n, ";\n\n        vec4 minMaxValue = vec4(").concat(i, ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(u, "; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h, "\n        }\n\n        int inIdx = inOffset + ").concat(u, ";\n        if (").concat(1 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h, "\n        } else if (").concat(2 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h, "\n        } else if (").concat(3 === c, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h, "\n        }\n        setOutput(").concat(l, ");\n      }\n    ");
};

function fv(e, t, n, s) {
  var r = function (e) {
    var t = [];

    for (; 0 === t.length || 1 !== t[t.length - 1].outSize;) {
      var _n292 = t.length ? t[t.length - 1].outSize : e[1],
          _s221 = To(_n292);

      t.push({
        inSize: _n292,
        windowSize: _s221,
        outSize: Math.ceil(_n292 / _s221)
      });
    }

    return t;
  }(e.shape);

  var a = e;

  for (var _i102 = 0; _i102 < r.length; _i102++) {
    var _r$_i = r[_i102],
        _o68 = _r$_i.inSize,
        _l48 = _r$_i.windowSize,
        u = _r$_i.outSize;

    var c = void 0,
        _h16 = void 0;

    c = "mean" === n ? 0 === _i102 ? new dv({
      windowSize: _l48,
      inSize: _o68,
      batchSize: e.shape[0],
      outSize: u
    }, _o68) : new dv({
      windowSize: _l48,
      inSize: _o68,
      batchSize: e.shape[0],
      outSize: u
    }) : new pv({
      windowSize: _l48,
      inSize: _o68,
      batchSize: e.shape[0],
      outSize: u
    }, n), _h16 = a, a = s.runWebGLProgram(c, [a], t), _h16.dataId !== e.dataId && s.disposeIntermediateTensorInfo(_h16);
  }

  return a;
}

var gv = function gv(e, t) {
  "use strict";

  _classCallCheck(this, gv);

  this.variableNames = ["A"];
  var n = new Array(e.length);

  for (var _s222 = 0; _s222 < n.length; _s222++) {
    n[_s222] = e[t[_s222]];
  }

  this.outputShape = n, this.rank = n.length;

  var s = Mk(this.rank),
      r = function (e) {
    var t = e.length;
    if (t > 6) throw Error("Transpose for rank ".concat(t, " is not yet supported"));
    var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"],
        s = new Array(t);

    for (var _t436 = 0; _t436 < e.length; _t436++) {
      s[e[_t436]] = n[_t436];
    }

    return s.join();
  }(t);

  this.userCode = "\n    void main() {\n      ".concat(s, " resRC = getOutputCoords();\n      setOutput(getA(").concat(r, "));\n    }\n    ");
};

var mv = function mv(e, t) {
  "use strict";

  _classCallCheck(this, mv);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
  var n = new Array(e.length);

  for (var _s223 = 0; _s223 < n.length; _s223++) {
    n[_s223] = e[t[_s223]];
  }

  if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank ".concat(this.rank, " is not yet supported."));
  var s = Mk(this.rank),
      r = Tw("rc", this.rank),
      a = new Array(this.rank);

  for (var _e459 = 0; _e459 < t.length; _e459++) {
    a[t[_e459]] = r[_e459];
  }

  var i = "vec2(".concat(a.slice(-2).join(), ")"),
      o = "++".concat(r[this.rank - 1], " < ").concat(n[this.rank - 1]),
      l = "getChannel(getA(".concat(a.join(), "), ").concat(i, ")");
  this.userCode = "\n    void main() {\n      ".concat(s, " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(l, ";\n      if(").concat(o, ") {\n        result[1] = ").concat(l, ";\n      }\n      --").concat(r[this.rank - 1], ";\n      if(++").concat(r[this.rank - 2], " < ").concat(n[this.rank - 2], ") {\n        result[2] = ").concat(l, ";\n        if(").concat(o, ") {\n          result[3] = ").concat(l, ";\n        }\n      }\n      setOutput(result);\n    }\n    ");
};

function bv(e, t, n) {
  var s = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new mv(e.shape, t) : new gv(e.shape, t);
  return n.runWebGLProgram(s, [e], e.dtype);
}

function xv(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.axis,
      i = s.keepDims;
  return function (e, t, n, s) {
    var r = e.shape.length,
        a = y(t, e.shape);
    var i = a;
    var o = Jr(i, r),
        l = null != o;
    var u = e;
    l && (u = bv(e, o, s), i = Qr(i.length, r)), Yr("sum", i, r);

    var _Kr17 = Kr(u.shape, i),
        _Kr18 = _slicedToArray(_Kr17, 2),
        c = _Kr18[0],
        h = _Kr18[1];

    var p = c;
    n && (p = Xr(c, a));
    var f = d(h),
        g = cv({
      inputs: {
        x: u
      },
      attrs: {
        shape: [d(e.shape) / f, f]
      },
      backend: s
    }),
        m = fv(g, pt(e.dtype), "sum", s),
        b = cv({
      inputs: {
        x: m
      },
      attrs: {
        shape: p
      },
      backend: s
    });
    return s.disposeIntermediateTensorInfo(g), s.disposeIntermediateTensorInfo(m), l && s.disposeIntermediateTensorInfo(u), b;
  }(r, a, i, n);
}

var yv = {
  kernelName: "Sum",
  backendName: "webgl",
  kernelFunc: xv
};

function kv(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.perm,
      i = n,
      o = new Array(r.shape.length);

  for (var _e460 = 0; _e460 < o.length; _e460++) {
    o[_e460] = r.shape[a[_e460]];
  }

  var l;

  if (i.shouldExecuteOnCPU([r])) {
    var _e461 = i.texData.get(r.dataId),
        _t437 = Cw(_e461.values, r.shape, r.dtype, a, o);

    l = i.makeTensorInfo(o, r.dtype), i.texData.get(l.dataId).values = _t437;
  } else l = bv(r, a, i);

  return l;
}

var wv = {
  kernelName: "Transpose",
  backendName: "webgl",
  kernelFunc: kv
};

function vv(_ref44) {
  var e = _ref44.a,
      t = _ref44.b,
      n = _ref44.transposeA,
      s = _ref44.transposeB,
      r = _ref44.backend,
      _ref44$bias = _ref44.bias,
      a = _ref44$bias === void 0 ? null : _ref44$bias,
      _ref44$preluActivatio = _ref44.preluActivationWeights,
      i = _ref44$preluActivatio === void 0 ? null : _ref44$preluActivatio,
      _ref44$leakyreluAlpha = _ref44.leakyreluAlpha,
      o = _ref44$leakyreluAlpha === void 0 ? 0 : _ref44$leakyreluAlpha,
      _ref44$activation = _ref44.activation,
      u = _ref44$activation === void 0 ? null : _ref44$activation;
  var c = e.shape.length,
      h = t.shape.length,
      p = n ? e.shape[c - 2] : e.shape[c - 1],
      f = s ? t.shape[h - 1] : t.shape[h - 2],
      g = n ? e.shape[c - 1] : e.shape[c - 2],
      m = s ? t.shape[h - 2] : t.shape[h - 1],
      b = e.shape.slice(0, -2),
      x = t.shape.slice(0, -2),
      y = d(b),
      k = d(x);
  l(c >= 2 && h >= 2 && (y === k || 1 === y || 1 === k), function () {
    return "Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (".concat(b, ") and (").concat(x, ").");
  });
  var w = (y > k ? e.shape.slice(0, -2) : t.shape.slice(0, -2)).concat([g, m]);
  l(p === f, function () {
    return "Error in matMul: inner shapes (".concat(p, ") and (").concat(f, ") of Tensors with shapes ").concat(e.shape, " and ").concat(t.shape, " and transposeA=").concat(n, " and transposeB=").concat(s, " must match.");
  });
  var v = n ? [y, p, g] : [y, g, p],
      I = s ? [k, m, f] : [k, f, m],
      $ = cv({
    inputs: {
      x: e
    },
    backend: r,
    attrs: {
      shape: v
    }
  }),
      N = cv({
    inputs: {
      x: t
    },
    backend: r,
    attrs: {
      shape: I
    }
  }),
      C = [$, N],
      S = Math.max(y, k),
      T = n ? $.shape[1] : $.shape[2],
      E = null != a,
      R = null != i,
      A = "leakyrelu" === u,
      F = null != u ? rv(u, !0) : null;
  var D;

  if ((1 === g || 1 === m) && T > 1e3 && !1 === (E || R || A || null != F)) {
    var _e462 = $,
        _t438 = N;
    n && (_e462 = kv({
      inputs: {
        x: $
      },
      backend: r,
      attrs: {
        perm: [0, 2, 1]
      }
    }), C.push(_e462)), s && (_t438 = kv({
      inputs: {
        x: N
      },
      backend: r,
      attrs: {
        perm: [0, 2, 1]
      }
    }), C.push(_t438));

    var _a117 = 1 === m;

    var _i103 = _e462;
    1 !== m && (_i103 = cv({
      inputs: {
        x: _e462
      },
      backend: r,
      attrs: {
        shape: [S, T, 1]
      }
    }), C.push(_i103));

    var _o69 = 1 === m ? 2 : 1;

    var _l49 = _t438;
    _a117 && (_l49 = cv({
      inputs: {
        x: _t438
      },
      backend: r,
      attrs: {
        shape: [S, 1, T]
      }
    }), C.push(_l49));

    var _u34 = lv({
      inputs: {
        a: _i103,
        b: _l49
      },
      backend: r
    });

    D = xv({
      inputs: {
        x: _u34
      },
      backend: r,
      attrs: {
        axis: _o69,
        keepDims: !0
      }
    }), C.push(_u34);
  } else {
    var _l50 = dt(e.dtype, t.dtype),
        _u35 = new av(v, I, [S, g, m], n, s, E, F, R, A),
        _c27 = [$, N];

    if (null != a && _c27.push(a), R && _c27.push(i), A) {
      var _e463 = r.makeTensorInfo([], "float32", We(o, "float32"));

      _c27.push(_e463), C.push(_e463);
    }

    D = r.runWebGLProgram(_u35, _c27, _l50);
  }

  var _ = cv({
    inputs: {
      x: D
    },
    backend: r,
    attrs: {
      shape: w
    }
  });

  C.push(D);

  for (var _i104 = 0, _C3 = C; _i104 < _C3.length; _i104++) {
    var _e464 = _C3[_i104];
    r.disposeIntermediateTensorInfo(_e464);
  }

  return _;
}

var Iv = {
  kernelName: "_FusedMatMul",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.a,
        a = t.b,
        i = t.bias,
        o = t.preluActivationWeights,
        l = s.transposeA,
        u = s.transposeB,
        c = s.activation,
        h = s.leakyreluAlpha;
    return vv({
      a: r,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: n,
      bias: i,
      preluActivationWeights: o,
      leakyreluAlpha: h,
      activation: c
    });
  }
},
    $v = "return abs(x);",
    Nv = {
  kernelName: "Abs",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x;

    if (n.shouldExecuteOnCPU([s]) && "complex64" !== s.dtype) {
      var _e465 = n.texData.get(s.dataId),
          _t439 = fw(_e465.values);

      return n.makeTensorInfo(s.shape, s.dtype, _t439);
    }

    var r;
    return r = V().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new zw(s.shape, $v) : new Mw(s.shape, $v), n.runWebGLProgram(r, [s], s.dtype);
  }
},
    Cv = {
  kernelName: "Acos",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
  })
},
    Sv = {
  kernelName: "Acosh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
  })
},
    Tv = "return a + b;",
    Ev = {
  kernelName: "Add",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: Tv,
    packedOpSnippet: Tv,
    supportsComplex: !0,
    cpuKernelImpl: Uk
  })
};

var Rv = function Rv(e, t) {
  "use strict";

  _classCallCheck(this, Rv);

  this.outputShape = [], this.outputShape = e, this.variableNames = t.map(function (e, t) {
    return "T".concat(t);
  });
  var n = [];
  this.variableNames.forEach(function (e) {
    n.push("float v".concat(e, " = get").concat(e, "AtOutCoords();"));
  });
  var s = this.variableNames.map(function (e) {
    return "v".concat(e);
  }).join(" + ");
  this.userCode = "\n      void main() {\n        ".concat(n.join("\n        "), "\n\n        float result = ").concat(s, ";\n        setOutput(result);\n      }\n    ");
};

var Av = function Av(e, t) {
  "use strict";

  _classCallCheck(this, Av);

  this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = t.map(function (e, t) {
    return "T".concat(t);
  });
  var n = [];
  this.variableNames.forEach(function (e) {
    n.push("vec4 v".concat(e, " = get").concat(e, "AtOutCoords();"));
  });
  var s = this.variableNames.map(function (e) {
    return "v".concat(e);
  }).join(" + ");
  this.userCode = "\n      void main() {\n        ".concat(n.join("\n        "), "\n\n        vec4 result = ").concat(s, ";\n        setOutput(result);\n      }\n    ");
};

var Fv = {
  kernelName: "AddN",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var n = t.inputs,
        s = t.backend,
        r = n;
    if (1 === r.length) return jw({
      inputs: {
        x: r[0]
      },
      backend: s
    });

    if (r.length > V().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var _t440 = Math.floor(r.length / 2),
          _n293 = e({
        inputs: r.slice(0, _t440),
        backend: s
      }),
          _a118 = e({
        inputs: r.slice(_t440),
        backend: s
      });

      return e({
        inputs: [_n293, _a118],
        backend: s
      });
    }

    var a = r.map(function (e) {
      return e.dtype;
    }).reduce(function (e, t) {
      return dt(e, t);
    }),
        i = r.map(function (e) {
      return e.shape;
    }),
        o = V().getBool("WEBGL_PACK") ? new Av(r[0].shape, i) : new Rv(r[0].shape, i);
    return s.runWebGLProgram(o, r, a);
  }
},
    Dv = {
  kernelName: "All",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Jr(u, o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = Qr(u.length, o)), Yr("all", u, o);

    var _Kr19 = Kr(h.shape, u),
        _Kr20 = _slicedToArray(_Kr19, 2),
        p = _Kr20[0],
        f = _Kr20[1],
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = fv(g, g.dtype, "all", n);

    var b;
    return b = cv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
},
    _v = {
  kernelName: "Any",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Jr(u, o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = Qr(u.length, o)), Yr("any", u, o);

    var _Kr21 = Kr(h.shape, u),
        _Kr22 = _slicedToArray(_Kr21, 2),
        p = _Kr22[0],
        f = _Kr22[1],
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = fv(g, g.dtype, "any", n);

    var b;
    return b = cv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
};

var Ov = function Ov(e, t, n) {
  "use strict";

  _classCallCheck(this, Ov);

  this.variableNames = ["A"];
  var s = e.windowSize,
      r = e.batchSize,
      a = e.outSize;
  n || this.variableNames.push("bestIndicesA"), this.outputShape = [r, a], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(s, ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(s, "; i++) {\n          int inIdx = ").concat(n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));", ";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat("max" === t ? ">" : "<", " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ");
};

var Mv = function Mv(e, t, n, s) {
  "use strict";

  _classCallCheck(this, Mv);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, l(e.length > 2, function () {
    return "Packed arg".concat(n.charAt(0).toUpperCase() + n.slice(1), " supports only inputs with rank above 2.");
  });
  var r = Math.ceil(e[e.length - 1] / t);
  this.outputShape = e.slice(0, -1), r > 1 && this.outputShape.push(r), s || this.variableNames.push("bestIndicesA");
  var a = this.outputShape,
      i = a.length,
      o = Mk(i),
      u = Ew("coords", i);
  var c, h;

  if (1 === r) {
    h = i + 1;

    var _e466 = Mk(h);

    c = "\n        ".concat(_e466, " sourceLocR = ").concat(_e466, "(").concat(u.join(), ", 0);\n        ++").concat(u[i - 1], ";\n        ").concat(_e466, " sourceLocG = ").concat(_e466, "(").concat(u.join(), ", 0);\n        ++").concat(u[i - 2], ";\n        ").concat(_e466, " sourceLocA = ").concat(_e466, "(").concat(u.join(), ", 0);\n        --").concat(u[i - 1], ";\n        ").concat(_e466, " sourceLocB = ").concat(_e466, "(").concat(u.join(), ", 0);\n        --").concat(u[i - 2], ";");
  } else h = i, c = "\n        ".concat(o, " sourceLocR = coords;\n        ++").concat(u[i - 1], ";\n        ").concat(o, " sourceLocG = coords;\n        ++").concat(u[i - 2], ";\n        ").concat(o, " sourceLocA = coords;\n        --").concat(u[i - 1], ";\n        ").concat(o, " sourceLocB = coords;\n        --").concat(u[i - 2], ";");

  var d = ["x", "y", "z", "w", "u", "v"].slice(0, h),
      p = "." + d[h - 1],
      f = d.map(function (e) {
    return "int " + e;
  }),
      g = Ew("sourceLocR", h - 1).concat("inIdx.r"),
      m = Ew("sourceLocG", h - 1).concat("inIdx.g"),
      b = Ew("sourceLocB", h - 1).concat("inIdx.b"),
      x = Ew("sourceLocA", h - 1).concat("inIdx.a"),
      y = "max" === n ? "greaterThan" : "lessThan",
      k = s ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(), "),\n                             getBestIndicesAChannel(").concat(m.join(), "),\n                             getBestIndicesAChannel(").concat(b.join(), "),\n                             getBestIndicesAChannel(").concat(x.join(), ")));"),
      w = "vec4(\n            getAChannel(".concat(g.join(), "),\n            hasNextCol ? getAChannel(").concat(m.join(), ") : 0.,\n            hasNextRow ? getAChannel(").concat(b.join(), ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(x.join(), ") : 0.)"),
      v = s ? "" : "\n      float getBestIndicesAChannel(".concat(f.join(), ") {\n        return getChannel(getBestIndicesA(").concat(d.join(), "),\n                                          vec2(").concat(d.slice(-2).join(), "));\n      }");
  this.userCode = "\n      float getAChannel(".concat(f.join(), ") {\n        return getChannel(getA(").concat(d.join(), "),\n                               vec2(").concat(d.slice(-2).join(), "));\n      }\n      ").concat(v, "\n      void main() {\n        ").concat(o, " coords = getOutputCoords();\n        bool hasNextCol = ").concat(u[i - 1], " < ").concat(a[i - 1] - 1, ";\n        bool hasNextRow = ").concat(u[i - 2], " < ").concat(a[i - 2] - 1, ";\n        ").concat(c, "\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p, ", sourceLocG").concat(p, ",\n          sourceLocB").concat(p, ", sourceLocA").concat(p, ") * ").concat(t, ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w, ";\n\n        for (int i = 0; i < ").concat(t, "; i++) {\n          inIdx = srcIdx;\n          ").concat(k, "\n          vec4 candidate = ").concat(w, ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(y, "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ");
};

function Lv(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var r = t.shape[0],
      a = t.shape[1];
  null != s && (r = s.shape[0], a = s.shape[1]);
  var i = To(a),
      o = {
    windowSize: i,
    inSize: a,
    batchSize: r,
    outSize: Math.ceil(a / i)
  },
      l = new Ov(o, n, null == s),
      u = [t];
  null != s && u.push(s);
  var c = e.runWebGLProgram(l, u, "int32");
  if (1 === c.shape[1]) return c;
  var h = Lv(e, t, n, c);
  return e.disposeIntermediateTensorInfo(c), h;
}

function zv(e, t, n) {
  var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var r = null != s ? s.shape : t.shape,
      a = To(r[r.length - 1]),
      i = new Mv(r, a, n, null == s),
      o = e.runWebGLProgram(i, null == s ? [t] : [t, s], "int32");

  if (o.shape.length === t.shape.length) {
    var _s224 = zv(e, t, n, o);

    return e.disposeIntermediateTensorInfo(o), _s224;
  }

  return o;
}

function Bv(e, t, n, s) {
  var r = [n];

  if (Yr("arg" + s.charAt(0).toUpperCase() + s.slice(1), r, t.shape.length), !V().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
    var _n294 = [],
        _Kr23 = Kr(t.shape, r),
        _Kr24 = _slicedToArray(_Kr23, 2),
        a = _Kr24[0],
        _i105 = _Kr24[1],
        _o70 = d(_i105),
        _l51 = cv({
      inputs: {
        x: t
      },
      backend: e,
      attrs: {
        shape: [-1, _o70]
      }
    });

    _n294.push(_l51);

    var u = Lv(e, _l51, s);

    _n294.push(u);

    var c = cv({
      inputs: {
        x: u
      },
      backend: e,
      attrs: {
        shape: a
      }
    });
    return _n294.forEach(function (t) {
      return e.disposeIntermediateTensorInfo(t);
    }), c;
  }

  return zv(e, t, s);
}

var Pv = {
  kernelName: "ArgMax",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis;
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), Yr("argMax", [i[0]], l.shape.length);
    var c = Bv(n, l, i[0], "max");
    return u.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), c;
  }
},
    Wv = {
  kernelName: "ArgMin",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis;
    var i = y(a, r.shape);
    var o = Jr(i, r.shape.length);
    var l = r;
    var u = [];
    null != o && (l = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: o
      }
    }), u.push(l), i = Qr(i.length, l.shape.length)), Yr("argMin", [i[0]], l.shape.length);
    var c = Bv(n, l, i[0], "min");
    return u.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), c;
  }
},
    Uv = {
  kernelName: "Asin",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
  })
},
    Vv = {
  kernelName: "Asinh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
  })
},
    Gv = {
  kernelName: "Atan",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n"
  })
},
    Hv = {
  kernelName: "Atan2",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
    packedOpSnippet: "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
},
    jv = {
  kernelName: "Atanh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
  })
};

var qv = /*#__PURE__*/function () {
  "use strict";

  function qv(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

    _classCallCheck(this, qv);

    if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
    var a = e.filterWidth,
        i = e.strideHeight,
        o = e.strideWidth,
        l = e.dilationHeight,
        u = e.dilationWidth,
        c = e.effectiveFilterHeight,
        h = e.effectiveFilterWidth,
        d = e.padInfo.top,
        p = e.padInfo.left;
    this.outputShape = e.outShape;
    var f = "avg" === t;
    var g = "0.0";
    if (f || (g = "-1.0 / 1e-20"), n) return void (this.userCode = "\n        const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n        const ivec2 pads = ivec2(").concat(d, ", ").concat(p, ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(c, ";\n              wR += ").concat(l, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h, ";\n                wC += ").concat(u, ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(s ? r ? "((batch  * ".concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + d") : "(xR * ".concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + d") : "wR * ".concat(h, " + wC"), ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "));
    var m = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "avg" === t && (m = "avgValue / count");
    var b = 4 * Math.floor(a / 4),
        x = a % 4,
        y = "\n      if (".concat(f, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ");
    this.userCode = "\n      const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n      const ivec2 pads = ivec2(").concat(d, ", ").concat(p, ");\n      const float initializationValue = ").concat(g, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(g, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(c, ";\n            wR += ").concat(l, ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(b, "; wC += 4) {\n            int xC = xCCorner + wC * ").concat(u, ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(u, ", d),\n              getValue(batch, xR, xC + 3 * ").concat(u, ", d)\n            );\n\n            ").concat(y, "\n          }\n\n          int xC = xCCorner + ").concat(b, ";\n          if (").concat(1 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y, "\n          } else if (").concat(2 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(y, "\n          } else if (").concat(3 === x, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(u, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(u, ", d),\n              initializationValue\n            );\n\n            ").concat(y, "\n          }\n        }\n        setOutput(").concat(m, ");\n      }\n    ");
  }

  return qv;
}();

var Kv = /*#__PURE__*/function () {
  "use strict";

  function Kv(e, t, n) {
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

    _classCallCheck(this, Kv);

    if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
    var a = e.filterWidth,
        i = e.strideDepth,
        o = e.strideHeight,
        l = e.strideWidth,
        u = e.dilationDepth,
        c = e.dilationHeight,
        h = e.dilationWidth,
        d = e.effectiveFilterDepth,
        p = e.effectiveFilterHeight,
        f = e.effectiveFilterWidth,
        g = e.padInfo.front,
        m = e.padInfo.top,
        b = e.padInfo.left;
    this.outputShape = e.outShape;
    var x = "avg" === t;
    var y = "0.0";
    if (x || (y = "-1.0 / 1e-20"), n) return void (this.userCode = "\n        const ivec3 strides =\n            ivec3(".concat(i, ", ").concat(o, ", ").concat(l, ");\n        const ivec3 pads = ivec3(").concat(g, ", ").concat(m, ", ").concat(b, ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d, ";\n              wD += ").concat(u, ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth, ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p, ";\n                wR += ").concat(c, ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f, ";\n                  wC += ").concat(h, ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(s ? r ? "(((batch * ".concat(e.inDepth, " + xD) * ").concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + ch") : "((xD * ".concat(e.inHeight, " + xR) * ").concat(e.inWidth, " + xC) * ").concat(e.inChannels, " + ch") : "wD * ".concat(p, " * ").concat(f, " +\n                      wR * ").concat(f, " + wC"), ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "));
    var k = "".concat(t, "(").concat(t, "(").concat(t, "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])");
    "avg" === t && (k = "avgValue / count");
    var w = 4 * Math.floor(a / 4),
        v = a % 4,
        I = "\n      if (".concat(x, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ");
    this.userCode = "\n      const ivec3 strides =\n        ivec3(".concat(i, ", ").concat(o, ", ").concat(l, ");\n      const ivec3 pads = ivec3(").concat(g, ", ").concat(m, ", ").concat(b, ");\n      const float initializationValue = ").concat(y, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d, ";\n            wD += ").concat(u, ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p, ";\n            wR += ").concat(c, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w, "; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h, ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h, ", ch)\n              );\n\n              ").concat(I, "\n            }\n\n            int xC = xCCorner + ").concat(w, ";\n            if (").concat(1 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I, "\n            } else if (").concat(2 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(I, "\n            } else if (").concat(3 === v, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h, ", ch),\n                initializationValue\n              );\n\n              ").concat(I, "\n            }\n          }\n          setOutput(").concat(k, ");\n        }\n      }\n    ");
  }

  return Kv;
}();

var Xv = {
  kernelName: "AvgPool",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x;
    ik(r, "avgPool");
    var a = s.filterSize,
        i = s.strides,
        o = s.pad,
        u = s.dimRoundingMode;
    l(Ss(i, 1), function () {
      return "Error in avgPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'");
    });
    var c = bs(r.shape, a, i, 1, o, u);
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) return jw({
      inputs: {
        x: r
      },
      backend: n
    });
    var h = new qv(c, "avg", !1);
    return n.runWebGLProgram(h, [r], "float32");
  }
},
    Yv = {
  kernelName: "AvgPool3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.filterSize,
        i = s.strides,
        o = s.pad,
        l = s.dimRoundingMode,
        u = s.dataFormat,
        c = xs(r.shape, a, i, [1, 1, 1], o, l, u),
        h = new Kv(c, "avg", !1);
    return n.runWebGLProgram(h, [r], "float32");
  }
};

var Jv = function Jv(e) {
  "use strict";

  _classCallCheck(this, Jv);

  this.variableNames = ["dy"], this.outputShape = e.inShape;
  var t = e.effectiveFilterHeight,
      n = e.effectiveFilterWidth;
  this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n      const float avgMultiplier = float(").concat(1 / (e.filterHeight * e.filterWidth), ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, ";\n            wR += ").concat(e.dilationHeight, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(n, ";\n            wC+= ").concat(e.dilationWidth, ") {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var Zv = function Zv(e) {
  "use strict";

  _classCallCheck(this, Zv);

  this.variableNames = ["dy"], this.outputShape = e.inShape;
  var t = e.effectiveFilterDepth,
      n = e.effectiveFilterHeight,
      s = e.effectiveFilterWidth;
  this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n      const float avgMultiplier = float(").concat(1 / (e.filterDepth * e.filterHeight * e.filterWidth), ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(t, ";\n            wD += ").concat(e.dilationDepth, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(e.strideDepth, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(n, ";\n              wR += ").concat(e.dilationHeight, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(s, ";\n                wC += ").concat(e.dilationWidth, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var Qv = {
  kernelName: "AvgPool3DGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = a,
        o = s.filterSize,
        l = s.strides,
        u = s.pad,
        c = s.dimRoundingMode,
        h = xs(i.shape, o, l, [1, 1, 1], u, c),
        d = new Zv(h);
    return n.runWebGLProgram(d, [r], i.dtype);
  }
},
    eI = {
  kernelName: "AvgPoolGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = a;
    ik([r, a], "avgPoolGrad");
    var o = s.filterSize,
        l = s.strides,
        u = s.pad,
        c = bs(i.shape, o, l, 1, u),
        h = new Jv(c);
    return n.runWebGLProgram(h, [r], i.dtype);
  }
},
    tI = {
  kernelName: "BatchMatMul",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.a,
        a = t.b,
        i = s.transposeA,
        o = s.transposeB;
    return vv({
      a: r,
      b: a,
      transposeA: i,
      transposeB: o,
      backend: n
    });
  }
};

var nI = function nI(e, t, n, s, r, a) {
  "use strict";

  _classCallCheck(this, nI);

  this.outputShape = [], this.variableNames = ["x", "mean", "variance"], cr(e, t), cr(e, n);
  var i = "0.0";
  null != s && (cr(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var o = "1.0";
  null != r && (cr(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i, ";\n        float scale = ").concat(o, ";\n        float inv = scale * inversesqrt(variance + float(").concat(a, "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ");
};

var sI = function sI(e, t, n, s, r, a) {
  "use strict";

  _classCallCheck(this, sI);

  this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], cr(e, t), cr(e, n);
  var i = "vec4(0.0)";
  null != s && (cr(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var o = "vec4(1.0)";
  null != r && (cr(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 offset = ".concat(i, ";\n        vec4 scale = ").concat(o, ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(a, "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ");
};

var rI = {
  kernelName: "FusedBatchNorm",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref45) {
    var e = _ref45.inputs,
        t = _ref45.backend,
        n = _ref45.attrs;
    var s = e.x,
        r = e.mean,
        a = e.variance,
        i = e.offset,
        o = e.scale;
    l(r.shape.length === a.shape.length, function () {
      return "Batch normalization gradient requires mean and variance to have equal ranks.";
    }), l(null == i || r.shape.length === i.shape.length, function () {
      return "Batch normalization gradient requires mean and offset to have equal ranks.";
    }), l(null == o || r.shape.length === o.shape.length, function () {
      return "Batch normalization gradient requires mean and scale to have equal ranks.";
    });
    var u = n.varianceEpsilon;
    null == u && (u = .001);
    var c = [s, r, a];
    var h = null;
    null != i && (h = i.shape, c.push(i));
    var d = null;
    null != o && (d = o.shape, c.push(o));
    var p = V().getBool("WEBGL_PACK_NORMALIZATION") ? new sI(s.shape, r.shape, a.shape, h, d, u) : new nI(s.shape, r.shape, a.shape, h, d, u);
    return t.runWebGLProgram(p, c, c[0].dtype);
  }
};

var aI = function aI(e) {
  "use strict";

  _classCallCheck(this, aI);

  this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
  var t = Mk(this.rank);
  this.customUniforms = [{
    name: "start",
    arrayIndex: this.rank,
    type: "int"
  }];

  var n = function (e) {
    if (1 === e) return "sourceLoc";
    if (e <= 6) return iI.slice(0, e).map(function (e) {
      return "sourceLoc." + e;
    }).join(",");
    throw Error("Slicing for rank ".concat(e, " is not yet supported"));
  }(this.rank);

  var s;
  s = "\n        ".concat(t, " sourceLoc;\n        ").concat(t, " coords = getOutputCoords();\n        ").concat(e.map(function (e, t) {
    return "sourceLoc.".concat(iI[t], " = start[").concat(t, "] + coords.").concat(iI[t], ";");
  }).join("\n"), "\n      "), this.userCode = "\n      void main() {\n        ".concat(s, "\n        setOutput(getSource(").concat(n, "));\n      }\n    ");
};

var iI = ["x", "y", "z", "w", "u", "v"];

var oI = function oI(e) {
  "use strict";

  _classCallCheck(this, oI);

  this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.customUniforms = [{
    name: "start",
    arrayIndex: this.rank,
    type: "int"
  }];
  var t = Mk(this.rank),
      n = Ew("coords", this.rank),
      s = Ew("sourceLoc", this.rank),
      r = 1 === this.rank ? "sourceLoc" : "vec2(".concat(s.slice(-2).join(), ")"),
      a = "getChannel(getSource(".concat(s.join(), "), ").concat(r, ")"),
      i = "\n      result.x = ".concat(a, ";\n      if (++").concat(n[this.rank - 1], " < ").concat(e[this.rank - 1], ") {\n        ++").concat(s[this.rank - 1], ";\n        result.y = ").concat(a, ";\n        --").concat(s[this.rank - 1], ";\n      }\n    "),
      o = 1 === this.rank ? "" : "\n      --".concat(n[this.rank - 1], ";\n      if (++").concat(n[this.rank - 2], " < ").concat(e[this.rank - 2], ") {\n        ++").concat(s[this.rank - 2], ";\n        result.z = ").concat(a, ";\n        if (++").concat(n[this.rank - 1], " < ").concat(e[this.rank - 1], ") {\n          ++").concat(s[this.rank - 1], ";\n          result.w = ").concat(a, ";\n        }\n      }\n    "),
      l = this.rank <= 4 ? "sourceLoc = coords +\n            ".concat(t, "(").concat(e.map(function (e, t) {
    return "start[".concat(t, "]");
  }).join(), ");") : e.map(function (e, t) {
    return "".concat(s[t], " = ").concat(n[t], " + start[").concat(t, "];");
  }).join("\n");
  this.userCode = "\n      void main() {\n        ".concat(t, " coords = getOutputCoords();\n        ").concat(t, " sourceLoc;\n        ").concat(l, "\n        vec4 result = vec4(0.);\n        ").concat(i, "\n        ").concat(o, "\n        setOutput(result);\n      }\n    ");
};

function lI(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.begin,
      i = s.size,
      _Un5 = Un(r, a, i),
      _Un6 = _slicedToArray(_Un5, 2),
      o = _Un6[0],
      l = _Un6[1];

  if (Tn(r, o, l), 0 === d(l)) return n.makeTensorInfo(l, r.dtype, []);

  if (n.shouldExecuteOnCPU([r]) || "string" === r.dtype) {
    var _e467 = n.texData.get(r.dataId),
        _t441 = gw(_e467.values, o, l, r.shape, r.dtype);

    return n.makeTensorInfo(l, r.dtype, _t441);
  }

  var _n$texData$get = n.texData.get(r.dataId),
      u = _n$texData$get.isPacked,
      c = Pn(r.shape, o, l);

  if (u || !c) {
    var _e468 = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new oI(l) : new aI(l);

    return n.runWebGLProgram(_e468, [r], r.dtype, [o]);
  }

  return n.uploadToGPU(r.dataId), function (e, t, n, s) {
    var r = s.texData.get(e.dataId),
        a = s.makeTensorInfo(n, e.dtype),
        i = s.texData.get(a.dataId);
    Object.assign(i, r), i.refCount = 1, i.shape = n, i.dtype = e.dtype;
    var o = Wn(t, A(e.shape));
    r.slice && (o += r.slice.flatOffset), i.slice = {
      flatOffset: o,
      origDataId: r.slice && r.slice.origDataId || e.dataId
    };
    var l = s.dataRefCount.get(i.slice.origDataId) || 1;
    return s.dataRefCount.set(i.slice.origDataId, l + 1), a;
  }(r, o, l, n);
}

var uI = {
  kernelName: "Slice",
  backendName: "webgl",
  kernelFunc: lI
},
    cI = {
  kernelName: "BatchToSpaceND",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.blockShape,
        i = s.crops;
    l(r.shape.length <= 4, function () {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });

    var o = a.reduce(function (e, t) {
      return e * t;
    }),
        u = Ro(r.shape, a, o),
        c = Ao(u.length, a.length),
        h = Fo(r.shape, a, o),
        d = Do(i, a.length),
        p = _o(h, i, a.length),
        f = [],
        g = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: u
      }
    }),
        m = kv({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        perm: c
      }
    }),
        b = cv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: h
      }
    }),
        x = lI({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        begin: d,
        size: p
      }
    });

    return f.push(g), f.push(m), f.push(b), f.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), x;
  }
},
    hI = {
  kernelName: "Bincount",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.weights,
        i = s.size,
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        u = Vk(o, l, a.dtype, a.shape, i);
    return n.makeTensorInfo([i], a.dtype, u);
  }
},
    dI = sv({
  opSnippet: "return float(a != b);",
  cpuKernelImpl: cw,
  dtype: "bool"
}),
    pI = {
  kernelName: "NotEqual",
  backendName: "webgl",
  kernelFunc: dI
};

function fI(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.input;
  return jw({
    inputs: {
      x: n.texData.get(s.dataId).complexTensorInfos.real
    },
    backend: n
  });
}

var gI = {
  kernelName: "Real",
  backendName: "webgl",
  kernelFunc: fI
},
    mI = {
  kernelName: "Cast",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var n = t.inputs,
        s = t.backend,
        r = t.attrs,
        a = n.x,
        i = r.dtype;

    if ("complex64" === i) {
      if ("complex64" === a.dtype) return jw({
        inputs: {
          x: a
        },
        backend: s
      });

      var _t442 = ua(a.shape),
          _n295 = e({
        inputs: {
          x: a
        },
        backend: s,
        attrs: {
          dtype: "float32"
        }
      }),
          _r166 = Kw({
        inputs: {
          real: _n295,
          imag: _t442
        },
        backend: s
      });

      return _t442.dispose(), s.disposeIntermediateTensorInfo(_n295), _r166;
    }

    if ("complex64" === a.dtype) {
      var _t443 = fI({
        inputs: {
          input: a
        },
        backend: s
      }),
          _n296 = e({
        inputs: {
          x: _t443
        },
        backend: s,
        attrs: {
          dtype: i
        }
      });

      return s.disposeIntermediateTensorInfo(_t443), _n296;
    }

    if (!I(a.dtype, i)) {
      var _e469 = jw({
        inputs: {
          x: a
        },
        backend: s
      });

      return {
        dataId: _e469.dataId,
        shape: _e469.shape,
        dtype: i
      };
    }

    if ("int32" === i) return function (e, t) {
      var n = new Mw(e.shape, "return float(int(x));"),
          s = t.runWebGLProgram(n, [e], "int32");
      return {
        dataId: s.dataId,
        shape: s.shape,
        dtype: s.dtype
      };
    }(a, s);

    if ("bool" === i) {
      var _e470 = s.makeTensorInfo([], "bool", w("bool", 1)),
          _t444 = dI({
        inputs: {
          a: a,
          b: _e470
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_e470), _t444;
    }

    throw new Error("Error in Cast: failed to cast ".concat(a.dtype, " to ").concat(i));
  }
},
    bI = "return ceil(x);",
    xI = {
  kernelName: "Ceil",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: bI,
    packedOpSnippet: bI,
    cpuKernelImpl: Hk
  })
};

var yI = function yI(e) {
  "use strict";

  _classCallCheck(this, yI);

  this.variableNames = ["A"], this.customUniforms = [{
    name: "minVal",
    type: "float"
  }, {
    name: "maxVal",
    type: "float"
  }], this.outputShape = e, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
};

var kI = function kI(e) {
  "use strict";

  _classCallCheck(this, kI);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
    name: "minVal",
    type: "float"
  }, {
    name: "maxVal",
    type: "float"
  }], this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
};

var wI = {
  kernelName: "ClipByValue",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.clipValueMin,
        i = s.clipValueMax;
    var o;
    return o = V().getBool("WEBGL_PACK_CLIP") ? new kI(r.shape) : new yI(r.shape), n.runWebGLProgram(o, [r], r.dtype, [[a], [i]]);
  }
};

var vI = function vI(e) {
  "use strict";

  _classCallCheck(this, vI);

  this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
};

function II(e, t) {
  return {
    dataId: t.dataId,
    dtype: t.dtype,
    shape: e.shape
  };
}

var $I = {
  kernelName: "ComplexAbs",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x,
        r = n.texData.get(s.dataId),
        a = new vI(s.shape),
        i = [II(s, r.complexTensorInfos.real), II(s, r.complexTensorInfos.imag)];
    return n.runWebGLProgram(a, i, i[0].dtype);
  }
};

var NI = function NI(e) {
  "use strict";

  _classCallCheck(this, NI);

  this.outputShape = [], this.outputShape = So(e, 1), this.variableNames = e.map(function (e, t) {
    return "T".concat(t);
  });
  var t = new Array(e.length - 1);
  t[0] = e[0][1];

  for (var _n297 = 1; _n297 < t.length; _n297++) {
    t[_n297] = t[_n297 - 1] + e[_n297][1];
  }

  var n = ["if (yC < ".concat(t[0], ") setOutput(getT0(yR, yC));")];

  for (var _e471 = 1; _e471 < t.length; _e471++) {
    n.push("else if (yC < ".concat(t[_e471], ") setOutput(getT").concat(_e471, "(yR, yC-").concat(t[_e471 - 1], "));"));
  }

  n.push("else setOutput(getT".concat(t.length, "(yR, yC-").concat(t[t.length - 1], "));")), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "), "\n      }\n    ");
};

var CI = function CI(e, t) {
  "use strict";

  _classCallCheck(this, CI);

  this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = So(e, t);
  var n = this.outputShape,
      s = n.length,
      r = Mk(s),
      a = Ew("coords", s),
      i = ["x", "y", "z", "w", "u", "v"].slice(0, s);
  this.variableNames = e.map(function (e, t) {
    return "T".concat(t);
  });
  var o = new Array(e.length - 1);
  o[0] = e[0][t];

  for (var _n298 = 1; _n298 < o.length; _n298++) {
    o[_n298] = o[_n298 - 1] + e[_n298][t];
  }

  var l = i[t],
      u = i.slice(-2),
      c = i.join();
  var h = "if (".concat(l, " < ").concat(o[0], ") {\n        return getChannel(\n            getT0(").concat(c, "), vec2(").concat(u.join(), "));\n        }");

  for (var _e472 = 1; _e472 < o.length; _e472++) {
    var _t445 = o[_e472 - 1];
    h += "\n        if (".concat(l, " < ").concat(o[_e472], "  && ").concat(l, " >= ").concat(o[_e472 - 1], ") {\n          return getChannel(\n            getT").concat(_e472, "(").concat(SI(i, l, _t445), "),\n            vec2(").concat(SI(u, l, _t445), "));\n        }");
  }

  var d = o[o.length - 1];
  h += "\n        return getChannel(\n          getT".concat(o.length, "(").concat(SI(i, l, d), "),\n          vec2(").concat(SI(u, l, d), "));"), this.userCode = "\n      float getValue(".concat(i.map(function (e) {
    return "int " + e;
  }), ") {\n        ").concat(h, "\n      }\n\n      void main() {\n        ").concat(r, " coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(a, "), 0., 0., 0.);\n\n        ").concat(a[s - 1], " = ").concat(a[s - 1], " + 1;\n        if (").concat(a[s - 1], " < ").concat(n[s - 1], ") {\n          result.g = getValue(").concat(a, ");\n        }\n\n        ").concat(a[s - 2], " = ").concat(a[s - 2], " + 1;\n        if (").concat(a[s - 2], " < ").concat(n[s - 2], ") {\n          result.a = getValue(").concat(a, ");\n        }\n\n        ").concat(a[s - 1], " = ").concat(a[s - 1], " - 1;\n        if (").concat(a[s - 2], " < ").concat(n[s - 2], " &&\n            ").concat(a[s - 1], " < ").concat(n[s - 1], ") {\n          result.b = getValue(").concat(a, ");\n        }\n        setOutput(result);\n      }\n    ");
};

function SI(e, t, n) {
  var s = e.indexOf(t);
  return e.map(function (e, t) {
    return t === s ? "".concat(e, " - ").concat(n) : e;
  }).join();
}

function TI(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.input;
  return jw({
    inputs: {
      x: n.texData.get(s.dataId).complexTensorInfos.imag
    },
    backend: n
  });
}

var EI = {
  kernelName: "Imag",
  backendName: "webgl",
  kernelFunc: TI
};

function RI(e, t, n) {
  var s = e[0].dtype;

  if ("complex64" === s) {
    var _s225 = e.map(function (e) {
      return fI({
        inputs: {
          input: e
        },
        backend: n
      });
    }),
        _r167 = e.map(function (e) {
      return TI({
        inputs: {
          input: e
        },
        backend: n
      });
    }),
        _a119 = RI(_s225, t, n),
        _i106 = RI(_r167, t, n),
        _o71 = Kw({
      inputs: {
        real: _a119,
        imag: _i106
      },
      backend: n
    });

    return _s225.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), _r167.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), n.disposeIntermediateTensorInfo(_a119), n.disposeIntermediateTensorInfo(_i106), _o71;
  }

  var r = n.shouldExecuteOnCPU(e);

  if ("string" === s && (r = !0), r) {
    var _r168 = e.map(function (e) {
      var s = d(e.shape.slice(t));
      return cv({
        inputs: {
          x: e
        },
        backend: n,
        attrs: {
          shape: [-1, s]
        }
      });
    }),
        _a120 = _r168.map(function (e) {
      return {
        vals: n.readSync(e.dataId),
        shape: e.shape
      };
    }),
        _i107 = So(_r168.map(function (e) {
      return e.shape;
    }), 1),
        _o72 = jk(_a120, _i107, s, 1 === _r168[0].shape[0]),
        _l52 = So(e.map(function (e) {
      return e.shape;
    }), t),
        _u36 = n.makeTensorInfo(_l52, s, _o72);

    return _r168.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), _u36;
  }

  if (e.length > V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    var _s226 = Math.floor(e.length / 2),
        _r169 = RI(e.slice(0, _s226), t, n),
        _a121 = RI(e.slice(_s226), t, n),
        _i108 = RI([_r169, _a121], t, n);

    return n.disposeIntermediateTensorInfo(_r169), n.disposeIntermediateTensorInfo(_a121), _i108;
  }

  if (V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && e[0].shape.length > 1) {
    var _r170 = new CI(e.map(function (e) {
      return e.shape;
    }), t);

    return n.runWebGLProgram(_r170, e, s);
  }

  var _ref46 = function (e, t, n) {
    var s = So(e.map(function (e) {
      return e.shape;
    }), t);
    return {
      tensors2D: e.map(function (e) {
        return cv({
          inputs: {
            x: e
          },
          attrs: {
            shape: [-1, d(e.shape.slice(t))]
          },
          backend: n
        });
      }),
      outShape: s
    };
  }(e, t, n),
      a = _ref46.tensors2D,
      i = _ref46.outShape,
      o = new NI(a.map(function (e) {
    return e.shape;
  })),
      l = n.runWebGLProgram(o, a, s);

  a.forEach(function (e) {
    return n.disposeIntermediateTensorInfo(e);
  });
  var u = cv({
    inputs: {
      x: l
    },
    attrs: {
      shape: i
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(l), u;
}

function AI(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = s.axis,
      a = y(r, t[0].shape)[0],
      i = So(t.map(function (e) {
    return e.shape;
  }), a);
  if (0 === d(i)) return n.makeTensorInfo(i, t[0].dtype, []);
  var o = t.filter(function (e) {
    return d(e.shape) > 0;
  });
  return 1 === o.length ? jw({
    inputs: {
      x: o[0]
    },
    backend: n
  }) : (Co(o.map(function (e) {
    return e.shape;
  }), a), RI(o, a, n));
}

var FI = {
  kernelName: "Concat",
  backendName: "webgl",
  kernelFunc: AI
};

var DI = /*#__PURE__*/function () {
  "use strict";

  function DI(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

    _classCallCheck(this, DI);

    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var a = e.padInfo.top,
        i = e.padInfo.left,
        o = e.strideHeight,
        l = e.strideWidth,
        u = e.dilationHeight,
        c = e.dilationWidth,
        h = e.filterHeight,
        d = e.filterWidth,
        p = 4 * Math.floor(e.inChannels / 4),
        f = e.inChannels % 4,
        g = "channelsLast" === e.dataFormat,
        m = g ? 1 : 2,
        b = g ? 2 : 3,
        x = g ? 3 : 1;
    var y = "",
        k = "";
    n && (y = s ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "\n          float activation(float x) {\n            ".concat(n, "\n          }\n        "), k = "result = activation(result);");
    var w = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(y, "\n\n      const ivec2 strides = ivec2(").concat(o, ", ").concat(l, ");\n      const ivec2 pads = ivec2(").concat(a, ", ").concat(i, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(x, "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m, "], coords[").concat(b, "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h, "; wR++) {\n          int xR = xRCorner + wR * ").concat(u, ";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d, "; wC++) {\n            int xC = xCCorner + wC * ").concat(c, ";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p, "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g, ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1 === f, ") {\n\n              if (").concat(g, ") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p, ") *\n                    getW(wR, wC, ").concat(p, ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p, ", xR, xC) *\n                    getW(wR, wC, ").concat(p, ", d2);\n              }\n\n            } else if (").concat(2 === f, ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p, ", d2),\n                getW(wR, wC, ").concat(p, " + 1, d2)\n              );\n\n              if (").concat(g, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p, "),\n                  getX(batch, xR, xC, ").concat(p, " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p, ", xR, xC),\n                  getX(batch, ").concat(p, " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3 === f, ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p, ", d2),\n                getW(wR, wC, ").concat(p, " + 1, d2),\n                getW(wR, wC, ").concat(p, " + 2, d2)\n              );\n\n              if (").concat(g, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p, "),\n                  getX(batch, xR, xC, ").concat(p, " + 1),\n                  getX(batch, xR, xC, ").concat(p, " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p, ", xR, xC),\n                  getX(batch, ").concat(p, " + 1, xR, xC),\n                  getX(batch, ").concat(p, " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w, "\n        ").concat(k, "\n        setOutput(result);\n      }\n    ");
  }

  return DI;
}();

var _I = function _I(e) {
  "use strict";

  _classCallCheck(this, _I);

  this.variableNames = ["x", "W"], this.outputShape = e.outShape;
  var t = e.padInfo.front,
      n = e.padInfo.top,
      s = e.padInfo.left,
      r = e.strideDepth,
      a = e.strideHeight,
      i = e.strideWidth,
      o = e.dilationDepth,
      l = e.dilationHeight,
      u = e.dilationWidth,
      c = e.filterDepth,
      h = e.filterHeight,
      d = e.filterWidth,
      p = 4 * Math.floor(e.inChannels / 4),
      f = e.inChannels % 4;
  this.userCode = "\n      const ivec3 strides = ivec3(".concat(r, ", ").concat(a, ", ").concat(i, ");\n      const ivec3 pads = ivec3(").concat(t, ", ").concat(n, ", ").concat(s, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(c, "; wF++) {\n          int xF = xFCorner + wF * ").concat(o, ";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h, "; wR++) {\n            int xR = xRCorner + wR * ").concat(l, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d, "; wC++) {\n              int xC = xCCorner + wC * ").concat(u, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p, "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1 === f, ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p, ") *\n                  getW(wF, wR, wC, ").concat(p, ", d2);\n              } else if (").concat(2 === f, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p, "),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p, ", d2),\n                  getW(wF, wR, wC, ").concat(p, " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3 === f, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p, "),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 1),\n                  getX(batch, xF, xR, xC, ").concat(p, " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p, ", d2),\n                  getW(wF, wR, wC, ").concat(p, " + 1, d2),\n                  getW(wF, wR, wC, ").concat(p, " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var OI = function OI(e, t, n) {
  "use strict";

  _classCallCheck(this, OI);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  var s = n.filterWidth,
      r = n.inChannels,
      a = n.strideWidth,
      i = n.strideHeight,
      o = n.padInfo,
      l = n.outWidth,
      u = n.dilationWidth,
      c = n.dilationHeight,
      h = n.dataFormat,
      d = o.left,
      p = o.top,
      f = r * s,
      g = lk(),
      m = "channelsLast" === h,
      b = m ? 0 : 1,
      x = m ? 1 : 2;
  var y = "";

  for (var _n299 = 0; _n299 <= 1; _n299++) {
    for (var _s227 = 0; _s227 <= 1; _s227++) {
      y += "\n          blockIndex = rc.y + ".concat(_s227, ";\n          pos = rc.x + ").concat(_n299, ";\n\n          if(blockIndex < ").concat(e[1], " && pos < ").concat(e[0], ") {\n            offsetY = int(blockIndex / (").concat(l, ")) * ").concat(i, " - ").concat(p, ";\n            d0 = offsetY + ").concat(c, " * (pos / ").concat(f, ");\n\n            if(d0 < ").concat(t[b], " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ").concat(l, ".) * ").concat(a, ". - ").concat(d, ".);\n              d1 = offsetX + ").concat(u, " * (int(mod(float(pos), ").concat(f, ".) / ").concat(r, ".));\n\n              if(d1 < ").concat(t[x], " && d1 >= 0) {\n\n                ch = int(mod(float(pos), ").concat(r, ".));\n\n                if (").concat(m, ") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2 * _n299 + _s227, "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2 * _n299 + _s227, "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");
    }
  }

  this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(y, "\n\n        ").concat(g.output, " = result;\n      }\n    ");
};

function MI(_ref47) {
  var e = _ref47.x,
      t = _ref47.filter,
      n = _ref47.convInfo,
      s = _ref47.backend,
      _ref47$bias = _ref47.bias,
      r = _ref47$bias === void 0 ? null : _ref47$bias,
      _ref47$preluActivatio = _ref47.preluActivationWeights,
      a = _ref47$preluActivatio === void 0 ? null : _ref47$preluActivatio,
      _ref47$leakyreluAlpha = _ref47.leakyreluAlpha,
      i = _ref47$leakyreluAlpha === void 0 ? 0 : _ref47$leakyreluAlpha,
      _ref47$activation = _ref47.activation,
      o = _ref47$activation === void 0 ? null : _ref47$activation;
  var u = e.shape,
      c = s.texData.get(e.dataId),
      h = "channelsLast" === n.dataFormat;
  var d;
  var p = [],
      f = u[2] % 2 != 0 && !!c.isPacked;

  if ((1 != u[0] * u[1] * u[2] && 1 !== n.outChannels || !(n.inChannels > 1e3)) && V().getBool("WEBGL_LAZILY_UNPACK") && V().getBool("WEBGL_PACK_BINARY_OPERATIONS") && f) {
    var _f13 = {
      dataId: e.dataId,
      shape: [1, h ? u[0] * u[1] * (u[2] + 1) : u[0] * u[2] * (u[3] + 1), n.inChannels],
      dtype: e.dtype
    },
        _g23 = c.shape;
    c.shape = c.shape.slice(), c.shape[c.shape.length - 2]++, l(ek(c.shape, _f13.shape), function () {
      return "packed reshape ".concat(c.shape, " to ").concat(_f13.shape, " isn't free");
    });

    var _m14 = cv({
      inputs: {
        x: t
      },
      backend: s,
      attrs: {
        shape: [1, n.inChannels, n.outChannels]
      }
    });

    p.push(_m14);

    var _b15 = vv({
      a: _f13,
      b: _m14,
      backend: s,
      transposeA: !1,
      transposeB: !1,
      bias: r,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: i
    }),
        x = s.texData.get(_b15.dataId);

    l(x.isPacked, function () {
      return "batchMatMul result is expected to be packed";
    }), c.shape = _g23, x.shape = n.outShape, d = jw({
      inputs: {
        x: _b15
      },
      backend: s
    }), d.shape = n.outShape, p.push(_b15);
  } else {
    var _l53 = cv({
      inputs: {
        x: e
      },
      backend: s,
      attrs: {
        shape: [1, h ? u[0] * u[1] * u[2] : u[0] * u[2] * u[3], n.inChannels]
      }
    }),
        _c28 = cv({
      inputs: {
        x: t
      },
      backend: s,
      attrs: {
        shape: [1, n.inChannels, n.outChannels]
      }
    }),
        _f14 = vv({
      a: _l53,
      b: _c28,
      transposeA: !1,
      transposeB: !1,
      backend: s,
      bias: r,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: i
    });

    d = cv({
      inputs: {
        x: _f14
      },
      backend: s,
      attrs: {
        shape: n.outShape
      }
    }), p.push(_l53), p.push(_c28), p.push(_f14);
  }

  for (var _i109 = 0, _p16 = p; _i109 < _p16.length; _i109++) {
    var _e473 = _p16[_i109];
    s.disposeIntermediateTensorInfo(_e473);
  }

  return d;
}

function LI(_ref48) {
  var e = _ref48.x,
      t = _ref48.filter,
      n = _ref48.convInfo,
      s = _ref48.backend,
      _ref48$bias = _ref48.bias,
      r = _ref48$bias === void 0 ? null : _ref48$bias,
      _ref48$preluActivatio = _ref48.preluActivationWeights,
      a = _ref48$preluActivatio === void 0 ? null : _ref48$preluActivatio,
      _ref48$leakyreluAlpha = _ref48.leakyreluAlpha,
      i = _ref48$leakyreluAlpha === void 0 ? 0 : _ref48$leakyreluAlpha,
      _ref48$activation = _ref48.activation,
      o = _ref48$activation === void 0 ? null : _ref48$activation;
  var l = n.filterWidth,
      u = n.filterHeight,
      c = n.inChannels,
      h = n.outWidth,
      p = n.outHeight,
      f = n.dataFormat,
      g = "channelsLast" === f,
      m = l * u * c,
      b = p * h,
      x = [m, b],
      y = [],
      k = cv({
    inputs: {
      x: e
    },
    backend: s,
    attrs: {
      shape: e.shape.slice(1)
    }
  }),
      w = cv({
    inputs: {
      x: t
    },
    backend: s,
    attrs: {
      shape: [1, m, d(t.shape) / m]
    }
  });
  y.push(k), y.push(w);
  var v = new OI(x, k.shape, n),
      I = s.runWebGLProgram(v, [k], "float32"),
      $ = cv({
    inputs: {
      x: I
    },
    backend: s,
    attrs: {
      shape: [1, x[0], x[1]]
    }
  });
  y.push(I), y.push($);
  var N = null != r,
      C = null != a,
      S = "leakyrelu" === o,
      T = o ? rv(o, !0) : null,
      E = new av($.shape, w.shape, [1, b, n.outChannels], !0, !1, N, T, C, S),
      R = [$, w];

  if (r && R.push(r), C && R.push(a), S) {
    var _e474 = s.makeTensorInfo([], "float32", We(i, "float32"));

    R.push(_e474), y.push(_e474);
  }

  var A = s.runWebGLProgram(E, R, "float32"),
      F = cv({
    inputs: {
      x: A
    },
    backend: s,
    attrs: {
      shape: g ? [1, p, h, n.outChannels] : [1, n.outChannels, p, h]
    }
  });
  y.push(A);

  for (var _i110 = 0, _y11 = y; _i110 < _y11.length; _i110++) {
    var _e475 = _y11[_i110];
    s.disposeIntermediateTensorInfo(_e475);
  }

  return F;
}

var zI = {
  kernelName: "Conv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = s.strides,
        o = s.pad,
        l = s.dataFormat,
        u = s.dilations,
        c = s.dimRoundingMode,
        h = Ts(l),
        d = ys(r.shape, a.shape, i, u, o, c, !1, h);
    var p;
    if (1 !== d.filterHeight || 1 !== d.filterWidth || 1 !== d.dilationHeight || 1 !== d.dilationWidth || 1 !== d.strideHeight || 1 !== d.strideWidth || "SAME" !== d.padInfo.type && "VALID" !== d.padInfo.type) {
      if (V().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) p = LI({
        x: r,
        filter: a,
        convInfo: d,
        backend: n
      });else {
        var _e476 = new DI(d);

        p = n.runWebGLProgram(_e476, [r, a], "float32");
      }
    } else p = MI({
      x: r,
      filter: a,
      convInfo: d,
      backend: n
    });
    var f = cv({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        shape: d.outShape
      }
    });
    return n.disposeIntermediateTensorInfo(p), f;
  }
};

var BI = function BI(e) {
  "use strict";

  _classCallCheck(this, BI);

  this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              if (").concat("channelsLast" === e.dataFormat, ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var PI = function PI(e) {
  "use strict";

  _classCallCheck(this, PI);

  this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
  var t = e.filterHeight,
      n = e.filterWidth,
      s = "channelsLast" === e.dataFormat;
  this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(s ? 3 : 1, "];\n\n        ivec2 dyCorner = ivec2(coords[").concat(s ? 1 : 2, "], coords[").concat(s ? 2 : 3, "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n, " - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels, "; d2++) {\n\n              if (").concat(s, ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var WI = function WI(e) {
  "use strict";

  _classCallCheck(this, WI);

  this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize, "; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth, "; yF++) {\n            int xF = wF + yF * ").concat(e.strideDepth, " - ").concat(e.padInfo.front, ";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth, ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n              int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n                int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var UI = function UI(e) {
  "use strict";

  _classCallCheck(this, UI);

  this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
  var t = e.filterDepth,
      n = e.filterHeight,
      s = e.filterWidth;
  this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t, "; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(e.strideDepth, ".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth, ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t, " - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n, "; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n, " - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(s, "; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(s, " - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels, "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var VI = {
  kernelName: "Conv2DBackpropFilter",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.dy,
        i = s.strides,
        o = s.pad,
        l = s.dataFormat,
        u = s.dimRoundingMode,
        c = s.filterShape,
        h = Ts(l),
        d = ys(r.shape, c, i, 1, o, u, !1, h),
        p = new BI(d);
    return n.runWebGLProgram(p, [r, a], "float32");
  }
},
    GI = {
  kernelName: "Conv2DBackpropInput",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.filter,
        i = s.inputShape,
        o = s.strides,
        l = s.pad,
        u = s.dataFormat,
        c = s.dimRoundingMode,
        h = Ts(u),
        d = ys(i, a.shape, o, 1, l, c, !1, h),
        p = new PI(d);
    return n.runWebGLProgram(p, [r, a], "float32");
  }
},
    HI = {
  kernelName: "Conv3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = s.strides,
        o = s.pad,
        l = s.dilations,
        u = ks(r.shape, a.shape, i, l, o),
        c = new _I(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    jI = {
  kernelName: "Conv3DBackpropFilterV2",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.dy,
        i = s.strides,
        o = s.pad,
        l = s.filterShape,
        u = ks(r.shape, l, i, 1, o),
        c = new WI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    qI = {
  kernelName: "Conv3DBackpropInputV2",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.filter,
        i = s.pad,
        o = s.strides,
        l = s.inputShape,
        u = ks(l, a.shape, o, 1, i),
        c = new UI(u);
    return n.runWebGLProgram(c, [r, a], "float32");
  }
},
    KI = {
  kernelName: "Cos",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n"
  })
},
    XI = {
  kernelName: "Cosh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
  })
};

var YI = function YI(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, YI);

  this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];

  var _e477 = _slicedToArray(e, 4),
      a = _e477[0],
      i = _e477[1],
      o = _e477[2],
      l = _e477[3],
      _t446 = _slicedToArray(t, 1),
      u = _t446[0],
      _n300 = _slicedToArray(n, 2),
      c = _n300[0],
      h = _n300[1];

  this.outputShape = [u, c, h, l];

  var d = "bilinear" === s ? 1 : 0,
      p = i - 1 + ".0",
      f = o - 1 + ".0",
      _ref49 = c > 1 ? ["" + (i - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*".concat(p, " + float(y)*(height_scale)")] : ["0.0", "0.0", "0.5 * (y1+y2) * ".concat(p)],
      _ref50 = _slicedToArray(_ref49, 3),
      g = _ref50[0],
      m = _ref50[1],
      b = _ref50[2],
      _ref51 = h > 1 ? ["" + (o - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*".concat(f, " + float(x)*(width_scale)")] : ["0.0", "0.0", "0.5 * (x1+x2) * ".concat(f)],
      _ref52 = _slicedToArray(_ref51, 3),
      x = _ref52[0],
      y = _ref52[1],
      k = _ref52[2];

  this.userCode = "\n      const float height_ratio = float(".concat(g, ");\n      const float width_ratio = float(").concat(x, ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(a, ") {\n          return;\n        }\n\n        float height_scale = ").concat(m, ";\n        float width_scale = ").concat(y, ";\n\n        float in_y = ").concat(b, ";\n        if( in_y < 0.0 || in_y > ").concat(p, " ) {\n          setOutput(float(").concat(r, "));\n          return;\n        }\n        float in_x = ").concat(k, ";\n        if( in_x < 0.0 || in_x > ").concat(f, " ) {\n          setOutput(float(").concat(r, "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d, " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ");
};

var JI = {
  kernelName: "CropAndResize",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.image,
        a = t.boxes,
        i = t.boxInd,
        o = s.cropSize,
        l = s.method,
        u = s.extrapolationValue,
        c = new YI(r.shape, a.shape, o, l, u);
    return n.runWebGLProgram(c, [r, a, i], "float32");
  }
};

var ZI = function ZI(e, t, n) {
  "use strict";

  _classCallCheck(this, ZI);

  this.variableNames = ["x"], this.customUniforms = [{
    name: "index",
    type: "float"
  }], this.outputShape = e;
  var s = e.length,
      r = t ? "0.0" : "getX(".concat(QI(s, "coords"), ")"),
      a = e[e.length - 1];
  var i = "",
      o = "";
  t ? (i = n ? "end != " + (a - 1) : "end != 0", o = n ? "end + 1" : "end - 1") : (i = n ? "end + pow2 < ".concat(a) : "end >= pow2", o = n ? "end + pow2" : "end - pow2"), this.userCode = "\n      void main() {\n        ".concat(Mk(s), " coords = getOutputCoords();\n        int end = ").concat(e$(s, "coords"), ";\n        float val = ").concat(r, ";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(i, ") {\n          int idx = ").concat(o, ";\n          ").concat(e$(s, "coords"), " = idx;\n          val += getX(").concat(QI(s, "coords"), ");\n        }\n        setOutput(val);\n      }\n    ");
};

function QI(e, t) {
  if (1 === e) return "".concat(t);
  if (2 === e) return "".concat(t, ".x, ").concat(t, ".y");
  if (3 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z");
  if (4 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z, ").concat(t, ".w");
  throw Error("Cumulative sum for rank ".concat(e, " is not yet supported"));
}

function e$(e, t) {
  if (1 === e) return "".concat(t);
  if (2 === e) return "".concat(t, ".y");
  if (3 === e) return "".concat(t, ".z");
  if (4 === e) return "".concat(t, ".w");
  throw Error("Cumulative sum for rank ".concat(e, " is not yet supported"));
}

var t$ = {
  kernelName: "Cumsum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.exclusive,
        o = s.reverse,
        l = r.shape.length,
        u = Jr([a], l);
    var c = r;
    null != u && (c = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: u
      }
    }));
    var h = Qr(1, l)[0];
    if (h !== l - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=".concat(r.shape.length - 1, " but got axis=").concat(a));
    var d = c.shape[h];
    var p = jw({
      inputs: {
        x: c
      },
      backend: n
    });

    for (var _e478 = 0; _e478 <= Math.ceil(Math.log2(d)) - 1; _e478++) {
      var _t447 = new ZI(c.shape, !1, o),
          _s228 = p;

      p = n.runWebGLProgram(_t447, [p], p.dtype, [[_e478]]), n.disposeIntermediateTensorInfo(_s228);
    }

    if (i) {
      var _e479 = new ZI(c.shape, i, o),
          _t448 = p;

      p = n.runWebGLProgram(_e479, [p], p.dtype), n.disposeIntermediateTensorInfo(_t448);
    }

    if (null != u) {
      var _e480 = kv({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          perm: Zr(u)
        }
      });

      return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(c), _e480;
    }

    return p;
  }
},
    n$ = {
  kernelName: "DenseBincount",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.weights,
        i = s.size,
        o = s.binaryOutput;

    if (1 === r.shape.length) {
      var _e481 = n.readSync(r.dataId),
          _t449 = n.readSync(a.dataId),
          _s229 = Vk(_e481, _t449, a.dtype, a.shape, i);

      return n.makeTensorInfo([i], a.dtype, _s229);
    }

    if (2 === r.shape.length) {
      var _e482 = n.bufferSync(r),
          _t450 = n.bufferSync(a),
          _s230 = Gk(_e482, _t450, i, o);

      return n.makeTensorInfo(_s230.shape, a.dtype, _s230.values);
    }

    throw new Error("Error in denseBincount: input must be at most rank 2, but got rank".concat(r.shape.length, "."));
  }
};

var s$ = /*#__PURE__*/function () {
  "use strict";

  function s$(e, t, n) {
    _classCallCheck(this, s$);

    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(), ";\n      int w = ").concat(this.getWidthCoordString(), ";\n      int d = ").concat(this.getDepthCoordString(), ";\n\n      int in_h = h / ").concat(t, ";\n      int offset_h = imod(h, ").concat(t, ");\n      int in_w = w / ").concat(t, ";\n      int offset_w = imod(w, ").concat(t, ");\n      int offset_d = (offset_h * ").concat(t, " + offset_w) *\n        ").concat(this.getOutputDepthSize(), ";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(), ";\n      setOutput(result);\n    }\n  ");
  }

  _createClass(s$, [{
    key: "getHeightCoordString",
    value: function getHeightCoordString() {
      return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
    }
  }, {
    key: "getWidthCoordString",
    value: function getWidthCoordString() {
      return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
    }
  }, {
    key: "getDepthCoordString",
    value: function getDepthCoordString() {
      return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
    }
  }, {
    key: "getOutputDepthSize",
    value: function getOutputDepthSize() {
      return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
    }
  }, {
    key: "getInputSamplingString",
    value: function getInputSamplingString() {
      return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  }]);

  return s$;
}();

var r$ = {
  kernelName: "DepthToSpace",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.blockSize,
        i = s.dataFormat;
    l(a > 1, function () {
      return "blockSize should be > 1 for depthToSpace, but was: ".concat(a);
    });
    var o = r.shape[0],
        u = ("NHWC" === i ? r.shape[1] : r.shape[2]) * a,
        c = ("NHWC" === i ? r.shape[2] : r.shape[3]) * a,
        h = ("NHWC" === i ? r.shape[3] : r.shape[1]) / (a * a),
        d = new s$("NHWC" === i ? [o, u, c, h] : [o, h, u, c], a, i);
    return n.runWebGLProgram(d, [r], r.dtype);
  }
};

var a$ = /*#__PURE__*/function () {
  "use strict";

  function a$(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

    _classCallCheck(this, a$);

    this.variableNames = ["x", "W"], this.outputShape = e.outShape;
    var a = e.inHeight,
        i = e.inWidth,
        o = e.padInfo.top,
        l = e.padInfo.left,
        u = e.strideHeight,
        c = e.strideWidth,
        h = e.dilationHeight,
        d = e.dilationWidth,
        p = e.filterHeight,
        f = e.filterWidth,
        g = e.outChannels / e.inChannels;
    var m = "",
        b = "";
    n && (m = s ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "\n          float activation(float x) {\n            ".concat(n, "\n          }\n        "), b = "result = activation(result);");
    var x = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(m, "\n\n      const ivec2 strides = ivec2(").concat(u, ", ").concat(c, ");\n      const ivec2 pads = ivec2(").concat(o, ", ").concat(l, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(g, ";\n        int q = d2 - d1 * ").concat(g, ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(p, "; wR++) {\n          int xR = xRCorner + wR * ").concat(h, ";\n\n          if (xR < 0 || xR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(f, "; wC++) {\n            int xC = xCCorner + wC * ").concat(d, ";\n\n            if (xC < 0 || xC >= ").concat(i, ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(x, "\n        ").concat(b, "\n        setOutput(result);\n      }\n    ");
  }

  return a$;
}();

var i$ = /*#__PURE__*/function () {
  "use strict";

  function i$(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;

    _classCallCheck(this, i$);

    this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.outShape;
    var a = e.outChannels / e.inChannels,
        o = e.inHeight,
        l = e.inWidth,
        u = e.padInfo.top,
        c = e.padInfo.left,
        h = e.strideHeight,
        d = e.strideWidth,
        p = e.dilationHeight,
        f = e.dilationWidth,
        g = e.filterHeight,
        m = e.filterWidth,
        b = m;
    var x = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";

    for (var _e483 = 0; _e483 < m; _e483++) {
      x += "\n          vec4 xTexelC".concat(2 * _e483, ";\n          int xTexelC").concat(2 * _e483, "Ready;\n          vec4 xTexelC").concat(2 * _e483 + 1, ";\n          int xTexelC").concat(2 * _e483 + 1, "Ready;\n          vec4 xC").concat(_e483, ";");
    }

    for (var _e484 = 0; _e484 < g; _e484++) {
      for (var _e485 = 0; _e485 < m; _e485++) {
        x += "\n          xTexelC".concat(2 * _e485, " = vec4(0.0);\n          xTexelC").concat(2 * _e485, "Ready = 0;\n          xTexelC").concat(2 * _e485 + 1, " = vec4(0.0);\n          xTexelC").concat(2 * _e485 + 1, "Ready = 0;\n          xC").concat(_e485, " = vec4(0.0);");
      }

      x += "\n        xR = xRCorner + ".concat(_e484 * p, ";\n        if (xR >=0 && xR < ").concat(o, ") {\n      ");

      for (var _t451 = 0; _t451 < (b + 1) / 2; _t451++) {
        var _n301 = 2 * _t451,
            _s231 = _n301 * f;

        if (x += "\n          xC = xCCorner + ".concat(_s231, ";\n          "), 1 === d) {
          if (_n301 < m && (c % 2 == 1 ? (x += "\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ".concat(l, " && xTexelC").concat(_n301, "Ready == 0) {\n                  xTexelC").concat(_n301, " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n301, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n301, "Ready = 1;\n                }\n              "), x += 1 === f && _s231 > 0 ? "\n                xC".concat(_n301, " = vec4(xTexelC").concat(_n301 - 2, ".zw, xTexelC").concat(_n301, ".xy);\n                ") : "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ".concat(l, ") {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ").concat(l, ") {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC").concat(_n301, " = vec4(previous.zw, xTexelC").concat(_n301, ".xy);\n                  } else {\n                    xC").concat(_n301, " = vec4(0.0, 0.0, xTexelC").concat(_n301, ".xy);\n                  }\n                  ")) : x += "\n                if (xC >= 0 && xC < ".concat(l, " && xTexelC").concat(_n301, "Ready == 0) {\n                  xTexelC").concat(_n301, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n301, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n301, "Ready = 1;\n                }\n\n                xC").concat(_n301, " = xTexelC").concat(_n301, ";\n                "), _s231 + 1 < m)) {
            var _e486 = c % 2 == 0 ? i(f) : f;

            f % 2 == 0 && c % 2 == 1 || f % 2 != 0 && c % 2 != 1 ? (x += "\n                  xCOffset = xC + ".concat(c % 2, " + ").concat(_e486, ";\n\n                  if (xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n301 + 1, "Ready == 0) {\n                    xTexelC").concat(_n301 + 1, " = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ").concat(l, ") {\n                      xTexelC").concat(_n301 + 1, ".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(_n301 + 1, "Ready = 1;\n                  }\n                  "), f > 1 && (x += "\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ".concat(l, " && xTexelC").concat(_n301, "Ready == 0) {\n                      xTexelC").concat(_n301, " = getX(batch, xR, xCOffset, d1);\n                      xTexelC").concat(_n301, "Ready = 1;\n                    }\n                    ")), x += "\n                  xC".concat(_n301 + 1, " = vec4(xTexelC").concat(_n301, ".zw, xTexelC").concat(_n301 + 1, ".xy);\n                  ")) : x += 1 === _e486 ? "\n                    xC".concat(_n301 + 1, " = xTexelC").concat(_n301, ";\n                    ") : "\n                    xCOffset = xC + ".concat(_e486, ";\n\n                    if (xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n301 + 1, "Ready == 0) {\n                      xTexelC").concat(_n301 + 1, " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ").concat(l, ") {\n                        xTexelC").concat(_n301 + 1, ".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(_n301 + 1, "Ready = 1;\n                    }\n\n                    xC").concat(_n301 + 1, " = xTexelC").concat(_n301 + 1, ";\n                    ");
          }
        } else _s231 < m && (c % 2 == 1 ? (x += "\n                xCOffset = xC + 1 - ".concat(d, ";\n                if(xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n301, "Ready == 0) {\n                  xTexelC").concat(_n301, " = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n301, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n301, "Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ").concat(l, " && xTexelC").concat(_n301 + 1, "Ready == 0) {\n                  xTexelC").concat(_n301 + 1, " = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ").concat(l, ") {\n                    xTexelC").concat(_n301 + 1, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n301 + 1, "Ready = 1;\n                }\n\n                xC").concat(_n301, " = vec4(xTexelC").concat(_n301, ".zw, xTexelC").concat(_n301 + 1, ".zw);\n              "), _s231 + 1 < m && (x += "\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ".concat(d, ";\n                  if(xCOffset >= 0 && xCOffset < ").concat(l, ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC").concat(_n301 + 1, " = vec4(xTexelC").concat(_n301 + 1, ".xy, final.xy);\n                "))) : (x += "\n                if(xC >= 0 && xC < ".concat(l, " && xTexelC").concat(_n301, "Ready == 0) {\n                  xTexelC").concat(_n301, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n301, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(_n301, "Ready = 1;\n                }\n\n                xCOffset = xC + ").concat(d, ";\n                if(xCOffset >= 0 && xCOffset < ").concat(l, " && xTexelC").concat(_n301 + 1, "Ready == 0) {\n                  xTexelC").concat(_n301 + 1, " = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ").concat(l, ") {\n                    xTexelC").concat(_n301 + 1, ".zw = vec2(0.);\n                  }\n                  xTexelC").concat(_n301 + 1, "Ready = 1;\n                }\n\n                xC").concat(_n301, " = vec4(\n                  xTexelC").concat(_n301, ".xy, xTexelC").concat(_n301 + 1, ".xy);\n              "), _s231 + 1 < m && (x += "\n                  xC".concat(_n301 + 1, " = vec4(xTexelC").concat(_n301, ".zw, xTexelC").concat(_n301 + 1, ".zw);\n                "))));

        _n301 < m && (x += "\n            wTexel = getW(".concat(_e484, ", ").concat(_s231, ", d1, q);\n            dotProd += xC").concat(_n301, " * vec4(wTexel.xz, wTexel.xz);\n          "), _s231 + 1 < m && (x += "\n              wTexel = getW(".concat(_e484, ", ").concat(_s231 + 1, ", d1, q);\n              dotProd += xC").concat(_n301 + 1, " * vec4(wTexel.xz, wTexel.xz);\n            ")));
      }

      x += "\n        }\n      ";
    }

    var y = "",
        k = "";
    n && (y = s ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n, "\n        }") : r ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(n, "\n        }"), k = "result = activation(result);");
    var w = t ? "result += getBiasAtOutCoords();" : "";
    t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(y, "\n\n      const ivec2 strides = ivec2(").concat(h, ", ").concat(d, ");\n      const ivec2 pads = ivec2(").concat(u, ", ").concat(c, ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(a, ";\n        int q = d2 - d1 * ").concat(a, ";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(x, "\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(w, "\n        ").concat(k, "\n        setOutput(result);\n      }\n    ");
  }

  return i$;
}();

var o$ = {
  kernelName: "DepthwiseConv2dNative",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = s.strides,
        o = s.pad,
        u = s.dilations,
        c = s.dimRoundingMode;
    var h = u;
    null == h && (h = [1, 1]), l(Ss(i, h), function () {
      return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '").concat(h, "'");
    });
    var d = ys(r.shape, a.shape, i, h, o, c, !0);
    var p;
    return p = V().getBool("WEBGL_PACK_DEPTHWISECONV") && d.strideWidth <= 2 && d.outChannels / d.inChannels == 1 ? new i$(d) : new a$(d), n.runWebGLProgram(p, [r, a], "float32");
  }
};

var l$ = function l$(e) {
  "use strict";

  _classCallCheck(this, l$);

  this.variableNames = ["x", "dy"], this.outputShape = e.filterShape, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(e.outChannels / e.inChannels, " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(e.strideHeight, " - ").concat(e.padInfo.top, ";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(e.strideWidth, " - ").concat(e.padInfo.left, ";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth, ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var u$ = function u$(e) {
  "use strict";

  _classCallCheck(this, u$);

  this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
  var t = e.filterHeight,
      n = e.filterWidth,
      s = e.outChannels / e.inChannels;
  this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n, " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(s, "; dm++) {\n              int d2 = d1 * ").concat(s, " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var c$ = {
  kernelName: "DepthwiseConv2dNativeBackpropFilter",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.dy,
        i = s.strides,
        o = s.dilations,
        l = s.pad,
        u = s.dimRoundingMode,
        c = s.filterShape,
        h = ys(r.shape, c, i, o, l, u, !0),
        d = new l$(h);
    return n.runWebGLProgram(d, [r, a], "float32");
  }
},
    h$ = {
  kernelName: "DepthwiseConv2dNativeBackpropInput",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.filter,
        i = s.strides,
        o = s.dilations,
        l = s.pad,
        u = s.dimRoundingMode,
        c = s.inputShape,
        h = ys(c, a.shape, i, o, l, u, !0),
        d = new u$(h);
    return n.runWebGLProgram(d, [r, a], "float32");
  }
};

var d$ = function d$(e) {
  "use strict";

  _classCallCheck(this, d$);

  this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
};

var p$ = {
  kernelName: "Diag",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x,
        r = [].concat(_toConsumableArray(s.shape), _toConsumableArray(s.shape)),
        a = d(s.shape),
        i = cv({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [a]
      }
    }),
        o = new d$(a),
        l = n.runWebGLProgram(o, [i], i.dtype),
        u = cv({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        shape: r
      }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), u;
  }
};

var f$ = function f$(e) {
  "use strict";

  _classCallCheck(this, f$);

  this.variableNames = ["x", "W"], this.outputShape = e.outShape;
  var t = e.inHeight,
      n = e.inWidth,
      s = e.padInfo,
      r = e.strideHeight,
      a = e.strideWidth,
      i = e.filterHeight,
      o = e.filterWidth,
      l = e.dilationHeight,
      u = e.dilationWidth,
      c = s.top,
      h = s.left;
  this.userCode = "\n      const ivec2 strides = ivec2(".concat(r, ", ").concat(a, ");\n      const ivec2 pads = ivec2(").concat(c, ", ").concat(h, ");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i, "; h++) {\n          int hIn = hBeg + h * ").concat(l, ";\n\n          if (hIn >= 0 && hIn < ").concat(t, ") {\n            for (int w = 0; w < ").concat(o, "; w++) {\n              int wIn = wBeg + w * ").concat(u, ";\n\n              if (wIn >= 0 && wIn < ").concat(n, ") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ");
};

var g$ = {
  kernelName: "Dilation2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = s.strides,
        o = s.pad,
        l = s.dilations,
        u = ms(r.shape, a.shape, i, o, "NHWC", l);
    var c;
    var h = new f$(u);
    c = n.runWebGLProgram(h, [r, a], "float32");
    var d = cv({
      inputs: {
        x: c
      },
      backend: n,
      attrs: {
        shape: u.outShape
      }
    });
    return n.disposeIntermediateTensorInfo(c), d;
  }
},
    m$ = {
  kernelName: "Einsum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.equation,
        a = t,
        _Ho2 = Ho(r, a.length),
        i = _Ho2.allDims,
        o = _Ho2.summedDims,
        l = _Ho2.idDims;

    qo(i.length, l, a);

    var _Ko2 = Ko(o, l),
        u = _Ko2.path,
        c = _Ko2.steps,
        h = c.length;

    var d = null,
        f = i.length;
    var g = [];

    for (var _e487 = 0; _e487 < h; ++_e487) {
      var _iterator116 = _createForOfIteratorHelper(c[_e487]),
          _step116;

      try {
        for (_iterator116.s(); !(_step116 = _iterator116.n()).done;) {
          var _t452 = _step116.value;

          var _jo2 = jo(f, l[_t452]),
              _e488 = _jo2.permutationIndices,
              _s232 = _jo2.expandDims;

          var _r171 = void 0;

          Xo(_e488) ? _r171 = a[_t452] : (_r171 = kv({
            inputs: {
              x: a[_t452]
            },
            backend: n,
            attrs: {
              perm: _e488
            }
          }), g.push(_r171));

          var _i111 = _r171.shape.slice();

          for (var _e489 = 0; _e489 < _s232.length; ++_e489) {
            _i111.splice(_s232[_e489], 0, 1);
          }

          p(_r171.shape, _i111) || (_r171 = cv({
            inputs: {
              x: _r171
            },
            backend: n,
            attrs: {
              shape: _i111
            }
          }), g.push(_r171)), null === d ? d = _r171 : (d = lv({
            inputs: {
              a: _r171,
              b: d
            },
            backend: n
          }), g.push(d));
        }
      } catch (err) {
        _iterator116.e(err);
      } finally {
        _iterator116.f();
      }

      _e487 < h - 1 && (u[_e487] >= 0 && (d = xv({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          axis: u[_e487] - (i.length - f),
          keepDims: !1
        }
      }), g.push(d)), f--);
    }

    for (var _i112 = 0, _g24 = g; _i112 < _g24.length; _i112++) {
      var _e490 = _g24[_i112];
      _e490 !== d && n.disposeIntermediateTensorInfo(_e490);
    }

    return d;
  }
},
    b$ = {
  kernelName: "Elu",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
  })
},
    x$ = {
  kernelName: "EluGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.dy,
        r = t.y,
        a = V().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Hw("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", s.shape, r.shape) : new Gw("return (b >= 1.0) ? a : a * (b + 1.0);", s.shape, r.shape);
    return n.runWebGLProgram(a, [s, r], s.dtype);
  }
},
    y$ = {
  kernelName: "Equal",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a == b);",
    packedOpSnippet: "\n  return vec4(equal(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: qk
  })
},
    k$ = {
  kernelName: "Erf",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n'
  })
},
    w$ = "return exp(x);",
    v$ = nv({
  opSnippet: w$,
  packedOpSnippet: w$,
  cpuKernelImpl: Kk
}),
    I$ = {
  kernelName: "Exp",
  backendName: "webgl",
  kernelFunc: v$
};

function $$(e) {
  var t = e.inputs,
      n = e.attrs,
      s = e.backend,
      r = n.dim,
      a = t.input,
      i = a.shape.length,
      o = a.shape.slice();
  var u = r;
  return r < 0 && (l(-(i + 1) <= r, function () {
    return "Axis must be in the interval [".concat(-(i + 1), ", ").concat(i, "]");
  }), u = i + r + 1), o.splice(u, 0, 1), cv({
    inputs: {
      x: a
    },
    backend: s,
    attrs: {
      shape: o
    }
  });
}

var N$ = {
  kernelName: "ExpandDims",
  backendName: "webgl",
  kernelFunc: $$
},
    C$ = "return exp(x) - 1.0;",
    S$ = {
  kernelName: "Expm1",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: C$,
    packedOpSnippet: C$,
    cpuKernelImpl: Xk
  })
};

var T$ = function T$(e, t, n) {
  "use strict";

  _classCallCheck(this, T$);

  this.variableNames = ["real", "imag"];
  var s = t[1];
  this.outputShape = t;
  var r = n ? "2.0 * ".concat(Math.PI) : "-2.0 * ".concat(Math.PI),
      a = n ? "".concat(s, ".0") : "1.0";
  var i;
  if ("real" === e) i = "return real * expR - imag * expI;";else {
    if ("imag" !== e) throw new Error("FFT component must be either \"real\" or \"imag\", got ".concat(e, "."));
    i = "return real * expI + imag * expR;";
  }
  this.userCode = "\n      const float exponentMultiplier = ".concat(r, ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i, "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(s, ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(s, "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(a, ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ");
};

function E$(e, t, n) {
  var s = n.texData.get(e.dataId),
      r = d(e.shape),
      a = e.shape[e.shape.length - 1],
      i = cv({
    inputs: {
      x: e
    },
    backend: n,
    attrs: {
      shape: [r / a, a]
    }
  }),
      o = i.shape,
      l = new T$("real", o, t),
      u = new T$("imag", o, t),
      c = [{
    dataId: s.complexTensorInfos.real.dataId,
    dtype: s.complexTensorInfos.real.dtype,
    shape: o
  }, {
    dataId: s.complexTensorInfos.imag.dataId,
    dtype: s.complexTensorInfos.imag.dtype,
    shape: o
  }],
      h = n.runWebGLProgram(l, c, "float32"),
      p = n.runWebGLProgram(u, c, "float32"),
      f = Kw({
    inputs: {
      real: h,
      imag: p
    },
    backend: n
  });
  n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p);
  var g = cv({
    inputs: {
      x: f
    },
    backend: n,
    attrs: {
      shape: e.shape
    }
  });
  return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(f), g;
}

var R$ = {
  kernelName: "FFT",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.input;
    return E$(s, !1, n);
  }
};

var A$ = function A$(e, t) {
  "use strict";

  _classCallCheck(this, A$);

  this.outputShape = [], this.customUniforms = [{
    name: "value",
    type: "float"
  }], this.variableNames = ["x"], this.outputShape = e, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
};

function F$(e) {
  var t = e.backend,
      n = e.attrs,
      s = n.shape,
      r = n.value;
  var a = n.dtype;

  if (a = a || T(r), "string" === a) {
    var _e491 = v(a, d(s));

    return _e491.fill(r), t.makeTensorInfo(s, a, _e491);
  }

  {
    var _e492 = new A$(s, r);

    return t.runWebGLProgram(_e492, [], a, [[r]]);
  }
}

var D$ = {
  kernelName: "Fill",
  backendName: "webgl",
  kernelFunc: F$
};

var _$ = function _$(e) {
  "use strict";

  _classCallCheck(this, _$);

  this.variableNames = ["Image"], this.outputShape = [];
  var t = e[2];
  this.outputShape = e, this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t, " - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t, ") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
};

var O$ = {
  kernelName: "FlipLeftRight",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref53) {
    var e = _ref53.inputs,
        t = _ref53.backend;
    var n = e.image,
        s = t,
        r = new _$(n.shape);
    return s.runWebGLProgram(r, [n], n.dtype);
  }
},
    M$ = "return floor(x);",
    L$ = {
  kernelName: "Floor",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: M$,
    packedOpSnippet: M$,
    cpuKernelImpl: Yk
  })
},
    z$ = {
  kernelName: "FloorDiv",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
    packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
    dtype: "int32"
  })
};

var B$ = function B$(e) {
  "use strict";

  _classCallCheck(this, B$);

  this.variableNames = ["A"];

  var t = lk(),
      _e493 = _slicedToArray(e, 2),
      n = _e493[0],
      s = _e493[1];

  this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(s, ".0, ").concat(n, ".0);\n\n        vec4 values = ").concat(t.texture2D, "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ");
};

var P$ = function P$(e) {
  "use strict";

  _classCallCheck(this, P$);

  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;

  var t = lk(),
      _e494 = _slicedToArray(e, 2),
      n = _e494[0],
      s = _e494[1];

  this.outputShape = e, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(s, ".0, ").concat(n, ".0);\n            vec4 values = ").concat(t.texture2D, "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output, " = result;\n      }\n    ");
};

var W$ = {
  kernelName: "FromPixels",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs;
    var r = t.pixels;

    var a = s.numChannels,
        i = "undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement,
        o = "undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement,
        _ref54 = i ? [r.videoWidth, r.videoHeight] : [r.width, r.height],
        _ref55 = _slicedToArray(_ref54, 2),
        l = _ref55[0],
        u = _ref55[1],
        c = [u, l],
        h = [u, l, a];

    (o || i) && (null == U$ && (U$ = document.createElement("canvas").getContext("2d")), U$.canvas.width = l, U$.canvas.height = u, U$.drawImage(r, 0, 0, l, u), r = U$.canvas);
    var d = n.makeTensorInfo(c, "int32");
    n.texData.get(d.dataId).usage = _y.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), r);
    var p = V().getBool("WEBGL_PACK") ? new P$(h) : new B$(h),
        f = n.runWebGLProgram(p, [d], "int32");
    return n.disposeData(d.dataId), f;
  }
};
var U$;
var V$ = {
  kernelName: "FusedConv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = t.bias,
        o = t.preluActivationWeights,
        l = s.strides,
        u = s.pad,
        c = s.dataFormat,
        h = s.dilations,
        d = s.dimRoundingMode,
        p = s.activation,
        f = s.leakyreluAlpha,
        g = Ts(c),
        m = ys(r.shape, a.shape, l, h, u, d, !1, g);
    var b;
    var x = [];
    if (1 !== m.filterHeight || 1 !== m.filterWidth || 1 !== m.dilationHeight || 1 !== m.dilationWidth || 1 !== m.strideHeight || 1 !== m.strideWidth || "SAME" !== m.padInfo.type && "VALID" !== m.padInfo.type) {
      if (V().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) b = LI({
        x: r,
        filter: a,
        convInfo: m,
        backend: n,
        bias: i,
        activation: p,
        preluActivationWeights: o,
        leakyreluAlpha: f
      });else {
        var _e495 = null != i,
            _t453 = null != o,
            _s233 = "leakyrelu" === p,
            _l54 = p ? rv(p, !1) : null,
            _u37 = new DI(m, _e495, _l54, _t453, _s233),
            _c29 = [r, a];

        if (i && _c29.push(i), o && _c29.push(o), _s233) {
          var _e496 = n.makeTensorInfo([], "float32", We(f, "float32"));

          _c29.push(_e496), x.push(_e496);
        }

        b = n.runWebGLProgram(_u37, _c29, "float32");
      }
    } else b = MI({
      x: r,
      filter: a,
      convInfo: m,
      backend: n,
      bias: i,
      activation: p,
      preluActivationWeights: o,
      leakyreluAlpha: f
    });
    var y = cv({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        shape: m.outShape
      }
    });
    return x.push(b), x.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), y;
  }
},
    G$ = {
  kernelName: "FusedDepthwiseConv2D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.filter,
        i = t.bias,
        o = t.preluActivationWeights,
        u = s.strides,
        c = s.pad,
        h = s.dilations,
        d = s.dimRoundingMode,
        p = s.activation,
        f = s.leakyreluAlpha,
        g = [];
    var m = h;
    null == m && (m = [1, 1]), l(Ss(u, m), function () {
      return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ".concat(u, " and dilations '").concat(m, "'");
    });
    var b = ys(r.shape, a.shape, u, m, c, d, !0),
        x = V().getBool("WEBGL_PACK_DEPTHWISECONV") && b.strideWidth <= 2 && b.outChannels / b.inChannels == 1,
        y = p ? rv(p, x) : null,
        k = [r, a],
        w = null != i,
        v = null != o,
        I = "leakyrelu" === p;

    if (w && k.push(i), v && k.push(o), I) {
      var _e497 = n.makeTensorInfo([], "float32", We(f, "float32"));

      k.push(_e497), g.push(_e497);
    }

    var $;
    $ = x ? new i$(b, w, y, v, I) : new a$(b, w, y, v, I);
    var N = n.runWebGLProgram($, k, "float32");
    return g.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), N;
  }
};

var H$ = function H$(e, t, n) {
  "use strict";

  _classCallCheck(this, H$);

  this.sliceDim = e, this.strides = t, this.variableNames = ["x", "indices"], this.outputShape = n;
  var s = Mk(t.length),
      r = Mk(n.length);
  this.userCode = "\n        ".concat(s, " strides = ").concat(s, "(").concat(this.strides, ");\n         void main() {\n          ").concat(r, " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ").concat(this.sliceDim, "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ").concat(this.sliceDim > 1 ? "strides[j]" : "strides", ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ");
};

var j$ = {
  kernelName: "GatherNd",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.params,
        r = t.indices,
        a = r.shape,
        i = a[a.length - 1],
        o = d(s.shape),
        _Nn3 = Nn(s, r),
        _Nn4 = _slicedToArray(_Nn3, 4),
        l = _Nn4[0],
        u = _Nn4[1],
        c = _Nn4[2],
        h = _Nn4[3],
        p = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [u, i]
      }
    }),
        f = cv({
      inputs: {
        x: s
      },
      backend: n,
      attrs: {
        shape: [d(s.shape) / c, c]
      }
    });

    if (n.shouldExecuteOnCPU([s, r]) || "string" === s.dtype) {
      var _e498 = n.readSync(r.dataId),
          _t454 = n.bufferSync(s),
          _a122 = Jk(_e498, _t454, s.dtype, u, i, c, h, s.shape, o);

      return n.makeTensorInfo(l, s.dtype, _a122.values);
    }

    var g = new H$(i, h, [u, c]),
        m = n.runWebGLProgram(g, [f, p], f.dtype),
        b = cv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: l
      }
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), b;
  }
};

var q$ = function q$(e, t) {
  "use strict";

  _classCallCheck(this, q$);

  this.variableNames = ["A", "indices"], this.outputShape = t, this.rank = t.length;

  var n = Mk(this.rank),
      s = function (e, t) {
    var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
        s = [];

    for (var _t455 = 0; _t455 < e.length; _t455++) {
      s.push(2 === _t455 ? "int(getIndices(resRC.x, resRC.z))" : "".concat(n[_t455]));
    }

    return s.join();
  }(e);

  this.userCode = "\n      void main() {\n        ".concat(n, " resRC = getOutputCoords();\n        setOutput(getA(").concat(s, "));\n      }\n    ");
};

function K$(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = t.indices,
      i = s.axis,
      o = s.batchDims,
      l = el(r, a, y(i, r.shape)[0], o),
      u = d(a.shape),
      c = [],
      h = cv({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize]
    }
  }),
      p = cv({
    inputs: {
      x: a
    },
    backend: n,
    attrs: {
      shape: [l.batchSize, u / l.batchSize]
    }
  });
  c.push(h), c.push(p);
  var f = [l.batchSize, l.outerSize, u / l.batchSize, l.sliceSize];

  if (n.shouldExecuteOnCPU([r, a]) || "string" === r.dtype) {
    var _e499 = n.bufferSync(p),
        _t456 = n.bufferSync(h),
        _s234 = Zk(_t456, _e499, f);

    return c.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), n.makeTensorInfo(l.outputShape, _s234.dtype, _s234.values);
  }

  var g = new q$(h.shape, f),
      m = n.runWebGLProgram(g, [h, p], h.dtype);
  c.push(m);
  var b = cv({
    inputs: {
      x: m
    },
    backend: n,
    attrs: {
      shape: l.outputShape
    }
  });
  return c.forEach(function (e) {
    return n.disposeIntermediateTensorInfo(e);
  }), b;
}

var X$ = {
  kernelName: "GatherV2",
  backendName: "webgl",
  kernelFunc: K$
},
    Y$ = {
  kernelName: "Greater",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a > b);",
    packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
    cpuKernelImpl: Qk,
    dtype: "bool"
  })
},
    J$ = {
  kernelName: "GreaterEqual",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a >= b);",
    packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: ew
  })
},
    Z$ = {
  kernelName: "IFFT",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.input;
    return E$(s, !0, n);
  }
},
    Q$ = {
  kernelName: "IsFinite",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(!isnan(x) && !isinf(x));",
    dtype: "bool"
  })
},
    eN = {
  kernelName: "IsInf",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(isinf(x));",
    dtype: "bool"
  })
},
    tN = {
  kernelName: "IsNan",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(isnan(x));",
    dtype: "bool"
  })
},
    nN = {
  kernelName: "Less",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a < b);",
    packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
    cpuKernelImpl: tw,
    dtype: "bool"
  })
},
    sN = {
  kernelName: "LessEqual",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a <= b);",
    packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
    cpuKernelImpl: nw,
    dtype: "bool"
  })
},
    rN = {
  kernelName: "LinSpace",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.backend,
        n = e.attrs,
        s = n.start,
        r = n.stop,
        a = n.num,
        i = sw(s, r, a);
    return t.makeTensorInfo([i.length], "float32", i);
  }
},
    aN = {
  kernelName: "Log",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (x < 0.0) return NAN;\n  return log(x);",
    packedOpSnippet: "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: rw
  })
},
    iN = {
  kernelName: "Log1p",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return log(1.0 + x);"
  })
},
    oN = {
  kernelName: "LogicalAnd",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a >= 1.0 && b >= 1.0);",
    packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
    dtype: "bool"
  })
},
    lN = {
  kernelName: "LogicalNot",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return float(!(x >= 1.0));"
  })
},
    uN = {
  kernelName: "LogicalOr",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return float(a >= 1.0 || b >= 1.0);",
    packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
    dtype: "bool"
  })
};

var cN = function cN(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, cN);

  this.variableNames = ["x"], this.outputShape = [];
  var a = t,
      i = e[3] - 1;
  var o;
  this.outputShape = e;
  var l = "float(".concat(n, ") + float(").concat(s, ") * sum");
  o = .5 === r ? "inversesqrt(".concat(l, ")") : 1 === r ? "1.0/(".concat(l, ")") : "exp(log(".concat(l, ") * float(-").concat(r, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(a, "; j <= ").concat(a, "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i, ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o, ";\n        setOutput(val);\n      }\n    ");
};

var hN = function hN(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, hN);

  this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
  var a = t,
      i = e[3] - 1;
  var o;
  this.outputShape = e;
  var l = "float(".concat(n, ") + float(").concat(s, ") * sum");
  o = .5 === r ? "inversesqrt(".concat(l, ")") : 1 === r ? "1.0/(".concat(l, ")") : "exp(log(".concat(l, ") * float(-").concat(r, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3], ";\n        bool hasNextRow = c < ").concat(this.outputShape[2], ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(a, ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(a, "; j <= ").concat(a, "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i, "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o, ";\n        setOutput(result);\n      }\n    ");
};

var dN = {
  kernelName: "LRN",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.depthRadius,
        i = s.bias,
        o = s.alpha,
        l = s.beta,
        u = V().getBool("WEBGL_PACK_NORMALIZATION") ? new hN(r.shape, a, i, o, l) : new cN(r.shape, a, i, o, l);
    return n.runWebGLProgram(u, [r], r.dtype);
  }
};

var pN = function pN(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, pN);

  this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, this.alpha = s, this.beta = r, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth, "; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t, ")));\n          int depthEnd = int(min(float(").concat(this.depth, "),\n              float(d + ").concat(t, " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth, ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(s, ") * norm + float(").concat(n, ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(s, ")\n                * float(").concat(r, ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r, ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ");
};

var fN = {
  kernelName: "LRNGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.y,
        i = t.dy,
        o = s.depthRadius,
        l = s.bias,
        u = s.alpha,
        c = s.beta,
        h = new pN(r.shape, o, l, u, c);
    return n.runWebGLProgram(h, [r, a, i], r.dtype);
  }
};

function gN(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.reductionIndices,
      i = s.keepDims,
      o = r.shape.length,
      l = y(a, r.shape);
  var u = l;
  var c = Jr(u, o),
      h = null != c,
      p = n.shouldExecuteOnCPU([r]);
  var f = r;

  if (h) {
    if (p) {
      var _e500 = n.texData.get(f.dataId).values,
          _t457 = new Array(o);

      for (var _e501 = 0; _e501 < _t457.length; _e501++) {
        _t457[_e501] = r.shape[c[_e501]];
      }

      var _s235 = Cw(_e500, r.shape, r.dtype, c, _t457);

      f = n.makeTensorInfo(_t457, r.dtype), n.texData.get(f.dataId).values = _s235;
    } else f = bv(r, c, n);

    u = Qr(u.length, o);
  }

  Yr("max", u, o);

  var _Kr25 = Kr(f.shape, u),
      _Kr26 = _slicedToArray(_Kr25, 2),
      g = _Kr26[0],
      m = _Kr26[1];

  var b,
      x = g;

  if (i && (x = Xr(g, l)), p) {
    var _e502 = n.texData.get(f.dataId),
        _t458 = aw(_e502.values, d(m), x, r.dtype);

    b = n.makeTensorInfo(x, r.dtype), n.texData.get(b.dataId).values = _t458;
  } else b = function (e, t, n, s) {
    var r = d(t),
        a = cv({
      inputs: {
        x: e
      },
      attrs: {
        shape: [d(e.shape) / r, r]
      },
      backend: s
    }),
        i = fv(a, e.dtype, "max", s),
        o = cv({
      inputs: {
        x: i
      },
      attrs: {
        shape: n
      },
      backend: s
    });
    return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o;
  }(f, m, x, n);

  return h && n.disposeIntermediateTensorInfo(f), b;
}

var mN = {
  kernelName: "Max",
  backendName: "webgl",
  kernelFunc: gN
},
    bN = {
  kernelName: "Maximum",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: iw
  })
},
    xN = {
  kernelName: "MaxPool",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x;
    ik(r, "maxPool");
    var a = s.filterSize,
        i = s.strides,
        o = s.pad,
        u = s.dimRoundingMode;
    l(Ss(i, 1), function () {
      return "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(i, " and dilations '1'");
    });
    var c = bs(r.shape, a, i, 1, o, u);
    if (1 === c.filterWidth && 1 === c.filterHeight && p(c.inShape, c.outShape)) return jw({
      inputs: {
        x: r
      },
      backend: n
    });
    var h = new qv(c, "max", !1);
    return n.runWebGLProgram(h, [r], r.dtype);
  }
},
    yN = {
  kernelName: "MaxPool3D",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.filterSize,
        i = s.strides,
        o = s.pad,
        l = s.dataFormat,
        u = s.dimRoundingMode,
        c = xs(r.shape, a, i, [1, 1, 1], o, u, l),
        h = new Kv(c, "max", !1);
    return n.runWebGLProgram(h, [r], r.dtype);
  }
};

var kN = function kN(e) {
  "use strict";

  _classCallCheck(this, kN);

  this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
  var t = e.effectiveFilterHeight,
      n = e.effectiveFilterWidth;
  this.userCode = "\n      const ivec2 pads = ivec2(".concat(t - 1 - e.padInfo.top, ", ").concat(n - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t, ";\n          wR += ").concat(e.dilationHeight, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(n, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(t * n - 1, " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(n, " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var wN = function wN(e) {
  "use strict";

  _classCallCheck(this, wN);

  this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
  var t = e.effectiveFilterDepth,
      n = e.effectiveFilterHeight,
      s = e.effectiveFilterWidth;
  this.userCode = "\n      const ivec3 pads = ivec3(".concat(t - 1 - e.padInfo.front, ", ").concat(n - 1 - e.padInfo.top, ", ").concat(s - 1 - e.padInfo.left, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(t, ";\n           wD += ").concat(e.dilationDepth, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(e.strideDepth, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(n, ";\n              wR += ").concat(e.dilationHeight, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(e.strideHeight, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(s, ";\n                wC += ").concat(e.dilationWidth, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(e.strideWidth, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(t * n * s - 1, " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(n, " * ").concat(s, " +\n                  wR * ").concat(s, " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ");
};

var vN = {
  kernelName: "MaxPool3DGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = a,
        o = s.filterSize,
        l = s.strides,
        u = s.pad,
        c = s.dimRoundingMode,
        h = xs(i.shape, o, l, [1, 1, 1], u, c),
        d = new Kv(h, "max", !0),
        p = n.runWebGLProgram(d, [i], i.dtype),
        f = new wN(h),
        g = n.runWebGLProgram(f, [r, p], i.dtype);
    return n.disposeIntermediateTensorInfo(p), g;
  }
},
    IN = {
  kernelName: "MaxPoolGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.dy,
        a = t.input,
        i = t.output,
        o = a;
    ik([a, i], "maxPoolGrad");
    var l = s.filterSize,
        u = s.strides,
        c = s.pad,
        h = s.dimRoundingMode,
        d = bs(o.shape, l, u, 1, c, h),
        p = new qv(d, "max", !0),
        f = n.runWebGLProgram(p, [o], o.dtype),
        g = new kN(d),
        m = n.runWebGLProgram(g, [r, f], o.dtype);
    return n.disposeIntermediateTensorInfo(f), m;
  }
},
    $N = {
  kernelName: "MaxPoolWithArgmax",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref56) {
    var e = _ref56.inputs,
        t = _ref56.attrs,
        n = _ref56.backend;
    var s = e.x,
        r = t.filterSize,
        a = t.strides,
        i = t.pad,
        o = t.includeBatchInIndex,
        u = n;
    l(4 === s.shape.length, function () {
      return "Error in maxPool: input must be rank 4 but got rank ".concat(s.shape.length, ".");
    });
    var c = [1, 1];
    l(Ss(a, c), function () {
      return "Error in maxPool: Either strides or dilations must be 1. Got strides ".concat(a, " and dilations '").concat(c, "'");
    });

    var h = bs(s.shape, r, a, c, i),
        _ref57 = function (e, t, n, s) {
      var r = new qv(n, "max", !1);
      var a = s.runWebGLProgram(r, [e], "float32");
      return r = new qv(n, "max", !0, !0, t), [a, s.runWebGLProgram(r, [e], "float32")];
    }(s, o, h, u),
        _ref58 = _slicedToArray(_ref57, 2),
        d = _ref58[0],
        p = _ref58[1];

    return [d, p];
  }
},
    NN = {
  kernelName: "Mean",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref59) {
    var e = _ref59.inputs,
        t = _ref59.attrs,
        n = _ref59.backend;
    var s = e.x,
        r = t.keepDims,
        a = t.axis,
        i = n,
        o = s.shape.length,
        l = y(a, s.shape);
    var u = l;
    var c = Jr(u, o),
        h = null != c,
        p = i.shouldExecuteOnCPU([s]),
        f = [];
    var g = s;

    if (h) {
      if (p) {
        var _e503 = i.texData.get(g.dataId).values,
            _t459 = new Array(o);

        for (var _e504 = 0; _e504 < _t459.length; _e504++) {
          _t459[_e504] = s.shape[c[_e504]];
        }

        var _n302 = Cw(_e503, s.shape, s.dtype, c, _t459);

        g = i.makeTensorInfo(_t459, s.dtype), i.texData.get(g.dataId).values = _n302;
      } else g = bv(s, c, i);

      f.push(g), u = Qr(u.length, o);
    }

    Yr("sum", u, o);

    var _Kr27 = Kr(g.shape, u),
        _Kr28 = _slicedToArray(_Kr27, 2),
        m = _Kr28[0],
        b = _Kr28[1];

    var x = m;
    r && (x = Xr(m, l));

    var k = function (e, t, n, s) {
      var r = d(t),
          a = cv({
        inputs: {
          x: e
        },
        attrs: {
          shape: [d(e.shape) / r, r]
        },
        backend: s
      }),
          i = fv(a, "float32", "mean", s),
          o = cv({
        inputs: {
          x: i
        },
        attrs: {
          shape: n
        },
        backend: s
      });
      return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o;
    }(g, b, x, i);

    for (var _i113 = 0, _f15 = f; _i113 < _f15.length; _i113++) {
      var _e505 = _f15[_i113];
      i.disposeIntermediateTensorInfo(_e505);
    }

    return k;
  }
},
    CN = {
  kernelName: "Min",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims,
        o = r.shape.length,
        l = y(a, r.shape);
    var u = l;
    var c = Jr(u, o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), u = Qr(u.length, r.shape.length)), Yr("min", u, o);

    var _Kr29 = Kr(h.shape, u),
        _Kr30 = _slicedToArray(_Kr29, 2),
        p = _Kr30[0],
        f = _Kr30[1],
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, d(f)]
      }
    }),
        m = fv(g, g.dtype, "min", n);

    var b;
    return b = cv(i ? {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: Xr(p, l)
      }
    } : {
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: p
      }
    }), n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), b;
  }
},
    SN = {
  kernelName: "Minimum",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: ow
  })
};

var TN = function TN(e, t, n) {
  "use strict";

  _classCallCheck(this, TN);

  this.variableNames = ["x"], this.outputShape = t.map(function (t, n) {
    return t[0] + e[n] + t[1];
  });
  var s = e.length,
      r = Mk(s),
      a = t.map(function (e) {
    return e[0];
  }).join(","),
      i = t.map(function (t, n) {
    return t[0] + e[n];
  }).join(","),
      o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s),
      l = "reflect" === n ? 0 : 1;
  this.userCode = 1 !== s ? "\n      ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outC = getOutputCoords();\n        for (int i = 0; i < ").concat(s, "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(l, ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(l, ";\n          }\n        }\n        ").concat(r, " coords = outC - start;\n        setOutput(getX(").concat(o, "));\n      }\n    ") : "\n        int start = ".concat(a, ";\n        int end = ").concat(i, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(l, ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(l, ";\n          }\n          setOutput(getX(outC - start));\n        }\n      ");
};

var EN = function EN(e, t, n) {
  "use strict";

  _classCallCheck(this, EN);

  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.map(function (t, n) {
    return t[0] + e[n] + t[1];
  });
  var s = e.length,
      r = Mk(s),
      a = t.map(function (e) {
    return e[0];
  }).join(","),
      i = t.map(function (t, n) {
    return t[0] + e[n];
  }).join(","),
      o = Ew("rc", s),
      l = Ew("source", s),
      u = "".concat(o[s - 1], " < ").concat(this.outputShape[s - 1]),
      c = 1 === s ? "source" : "vec2(".concat(l.slice(-2).join(), ")"),
      h = "reflect" === n ? 0 : 1;
  var d = "";

  if (1 === s) {
    var _e506 = "\n        ".concat(r, " source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h, ";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h, ";\n        }\n        source -= start;\n      ");

    d = "\n        ".concat(r, " rc = outputLoc;\n        ").concat(_e506, "\n        result[0] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        ").concat(o[s - 1], " += 1;\n        if(").concat(u, ") {\n          ").concat(_e506, "\n          result[1] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n      ");
  } else {
    var _e507 = "\n        ".concat(r, " source = rc;\n        ").concat(r, " lt = ").concat(r, "(lessThan(source, start));\n        ").concat(r, " gte = ").concat(r, "(greaterThanEqual(source, end));\n        ").concat(r, " orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h, ") +\n                gte * ((end - 1) * 2 - source + ").concat(h, ");\n        source -= start;\n      ");

    d = "\n        ".concat(r, " rc = outputLoc;\n        ").concat(_e507, "\n        result[0] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        ").concat(o[s - 1], " += 1;\n        if(").concat(u, ") {\n          ").concat(_e507, "\n          result[1] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n        rc = outputLoc;\n        ").concat(o[s - 2], " += 1;\n        if(").concat(o[s - 2], " < ").concat(this.outputShape[s - 2], ") {\n          ").concat(_e507, "\n          result[2] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n          ").concat(o[s - 1], " += 1;\n          if(").concat(u, ") {\n            ").concat(_e507, "\n            result[3] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n          }\n        }\n      ");
  }

  this.userCode = "\n      const ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      const ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d, "\n        setOutput(result);\n      }\n    ");
};

var RN = {
  kernelName: "MirrorPad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref60) {
    var e = _ref60.inputs,
        t = _ref60.backend,
        n = _ref60.attrs;
    var s = e.x,
        r = n.paddings,
        a = n.mode,
        i = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new EN(s.shape, r, a) : new TN(s.shape, r, a);
    return t.runWebGLProgram(i, [s], s.dtype);
  }
},
    AN = {
  kernelName: "Mod",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
    packedOpSnippet: "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
};

var FN = function FN(e, t, n) {
  "use strict";

  _classCallCheck(this, FN);

  this.variableNames = ["probs"], this.customUniforms = [{
    name: "seed",
    type: "float"
  }], this.outputShape = [e, n], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t - 1, "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t - 1, "));\n      }\n    ");
};

var DN = sv({
  opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
  packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
  checkOutOfBounds: !0
}),
    _N = {
  kernelName: "RealDiv",
  backendName: "webgl",
  kernelFunc: DN
},
    ON = "return a - b;",
    MN = sv({
  opSnippet: ON,
  packedOpSnippet: ON,
  supportsComplex: !0,
  cpuKernelImpl: Iw
}),
    LN = {
  kernelName: "Sub",
  backendName: "webgl",
  kernelFunc: MN
};

function zN(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.logits,
      a = s.dim,
      i = y([a], r.shape),
      o = gN({
    inputs: {
      x: r
    },
    backend: n,
    attrs: {
      reductionIndices: i,
      keepDims: !1
    }
  }),
      l = Xr(o.shape, i),
      u = cv({
    inputs: {
      x: o
    },
    backend: n,
    attrs: {
      shape: l
    }
  }),
      c = MN({
    inputs: {
      a: r,
      b: u
    },
    backend: n
  }),
      h = v$({
    inputs: {
      x: c
    },
    backend: n
  }),
      d = xv({
    inputs: {
      x: h
    },
    backend: n,
    attrs: {
      axis: i,
      keepDims: !1
    }
  }),
      p = cv({
    inputs: {
      x: d
    },
    backend: n,
    attrs: {
      shape: l
    }
  }),
      f = DN({
    inputs: {
      a: h,
      b: p
    },
    backend: n
  });
  return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(p), f;
}

var BN = {
  kernelName: "Softmax",
  backendName: "webgl",
  kernelFunc: zN
},
    PN = {
  kernelName: "Multinomial",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.logits,
        a = s.numSamples,
        i = s.seed,
        o = s.normalized,
        l = o ? r : zN({
      inputs: {
        logits: r
      },
      backend: n,
      attrs: {
        dim: r.shape.length - 1
      }
    }),
        u = new FN(l.shape[0], l.shape[1], a),
        c = n.runWebGLProgram(u, [l], "int32", [[i]]);
    return o || n.disposeIntermediateTensorInfo(l), c;
  }
},
    WN = "return -x;",
    UN = {
  kernelName: "Neg",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.x;

    if (n.shouldExecuteOnCPU([s])) {
      var _e508 = n.texData.get(s.dataId),
          _uw = uw(_e508.values, s.shape, s.dtype),
          _uw2 = _slicedToArray(_uw, 2),
          _t460 = _uw2[0],
          _r172 = _uw2[1];

      return n.makeTensorInfo(_r172, s.dtype, _t460);
    }

    var r;
    return r = V().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new zw(s.shape, WN) : new Mw(s.shape, WN), n.runWebGLProgram(r, [s], s.dtype);
  }
},
    VN = ji,
    GN = {
  kernelName: "NonMaxSuppressionV3",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");

    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.boxes,
        a = t.scores,
        i = s.maxOutputSize,
        o = s.iouThreshold,
        l = s.scoreThreshold,
        u = n.readSync(r.dataId),
        c = n.readSync(a.dataId),
        _VN = VN(u, c, i, o, l),
        h = _VN.selectedIndices;

    return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
  }
},
    HN = qi,
    jN = {
  kernelName: "NonMaxSuppressionV4",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");

    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.boxes,
        a = t.scores,
        i = s.maxOutputSize,
        o = s.iouThreshold,
        l = s.scoreThreshold,
        u = s.padToMaxOutputSize,
        c = n.readSync(r.dataId),
        h = n.readSync(a.dataId),
        _HN = HN(c, h, i, o, l, u),
        d = _HN.selectedIndices,
        p = _HN.validOutputs;

    return [n.makeTensorInfo([d.length], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([p]))];
  }
},
    qN = Ki,
    KN = {
  kernelName: "NonMaxSuppressionV5",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    Oo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");

    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.boxes,
        a = t.scores,
        i = s.maxOutputSize,
        o = s.iouThreshold,
        l = s.scoreThreshold,
        u = s.softNmsSigma,
        c = n.readSync(r.dataId),
        h = n.readSync(a.dataId),
        d = i,
        p = o,
        f = l,
        g = u,
        _qN = qN(c, h, d, p, f, g),
        m = _qN.selectedIndices,
        b = _qN.selectedScores;

    return [n.makeTensorInfo([m.length], "int32", new Int32Array(m)), n.makeTensorInfo([b.length], "float32", new Float32Array(b))];
  }
};

var XN = function XN(e, t, n, s) {
  "use strict";

  _classCallCheck(this, XN);

  this.variableNames = ["indices"], this.outputShape = [e, t], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(s, "), float(").concat(n, "),\n                      float(index == coords.y)));\n      }\n    ");
};

var YN = {
  kernelName: "OneHot",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.indices,
        a = s.depth,
        i = s.onValue,
        o = s.offValue,
        l = d(r.shape),
        u = new XN(l, a, i, o),
        c = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [l]
      }
    }),
        h = n.runWebGLProgram(u, [c], r.dtype);
    n.disposeIntermediateTensorInfo(c);
    var p = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [].concat(_toConsumableArray(r.shape), [a])
      }
    });
    return n.disposeIntermediateTensorInfo(h), p;
  }
};

function JN(e) {
  var t = e.inputs,
      n = e.backend,
      s = t.x;

  if ("complex64" === s.dtype) {
    var _e509 = fI({
      inputs: {
        input: s
      },
      backend: n
    }),
        _t461 = JN({
      inputs: {
        x: _e509
      },
      backend: n
    }),
        _r173 = TI({
      inputs: {
        input: s
      },
      backend: n
    }),
        a = JN({
      inputs: {
        x: _r173
      },
      backend: n
    }),
        _i114 = Kw({
      inputs: {
        real: _t461,
        imag: a
      },
      backend: n
    });

    return n.disposeIntermediateTensorInfo(_e509), n.disposeIntermediateTensorInfo(_t461), n.disposeIntermediateTensorInfo(_r173), n.disposeIntermediateTensorInfo(a), _i114;
  }

  return F$({
    attrs: {
      shape: s.shape,
      dtype: s.dtype,
      value: "string" === s.dtype ? "" : 0
    },
    backend: n
  });
}

var ZN = {
  kernelName: "ZerosLike",
  backendName: "webgl",
  kernelFunc: JN
},
    QN = {
  kernelName: "OnesLike",
  backendName: "webgl",
  kernelFunc: function e(t) {
    var n = t.inputs,
        s = t.backend,
        r = n.x;
    if ("string" === r.dtype) throw new Error("onesLike is not supported under string dtype");

    if ("complex64" === r.dtype) {
      var _t462 = fI({
        inputs: {
          input: r
        },
        backend: s
      }),
          _n303 = e({
        inputs: {
          x: _t462
        },
        backend: s
      }),
          a = TI({
        inputs: {
          input: r
        },
        backend: s
      }),
          _i115 = JN({
        inputs: {
          x: a
        },
        backend: s
      }),
          _o73 = Kw({
        inputs: {
          real: _n303,
          imag: _i115
        },
        backend: s
      });

      return s.disposeIntermediateTensorInfo(_t462), s.disposeIntermediateTensorInfo(_n303), s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(_i115), _o73;
    }

    return F$({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: 1
      },
      backend: s
    });
  }
},
    eC = {
  kernelName: "Pack",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.axis;
    if (1 === t.length) return $$({
      inputs: {
        input: t[0]
      },
      backend: n,
      attrs: {
        dim: r
      }
    });
    var a = t[0].shape,
        i = t[0].dtype;
    t.forEach(function (e) {
      u(a, e.shape, "All tensors passed to stack must have matching shapes"), l(i === e.dtype, function () {
        return "All tensors passed to stack must have matching dtypes";
      });
    });
    var o = [],
        c = AI({
      inputs: t.map(function (e) {
        var t = $$({
          inputs: {
            input: e
          },
          backend: n,
          attrs: {
            dim: r
          }
        });
        return o.push(t), t;
      }),
      backend: n,
      attrs: {
        axis: r
      }
    });
    return o.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), c;
  }
};

var tC = function tC(e, t, n) {
  "use strict";

  _classCallCheck(this, tC);

  this.variableNames = ["x"], this.customUniforms = [{
    name: "value",
    type: "float"
  }], this.outputShape = t.map(function (t, n) {
    return t[0] + e[n] + t[1];
  });
  var s = e.length,
      r = Mk(s),
      a = t.map(function (e) {
    return e[0];
  }).join(","),
      i = t.map(function (t, n) {
    return t[0] + e[n];
  }).join(","),
      o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s);
  this.userCode = 1 !== s ? "\n      ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r, " coords = outC - start;\n          setOutput(getX(").concat(o, "));\n        }\n      }\n    ") : "\n        int start = ".concat(a, ";\n        int end = ").concat(i, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ");
};

var nC = function nC(e, t, n) {
  "use strict";

  _classCallCheck(this, nC);

  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
    name: "value",
    type: "float"
  }], this.outputShape = t.map(function (t, n) {
    return t[0] + e[n] + t[1];
  });
  var s = e.length,
      r = Mk(s),
      a = t.map(function (e) {
    return e[0];
  }).join(","),
      i = t.map(function (t, n) {
    return t[0] + e[n];
  }).join(","),
      o = Ew("rc", s),
      l = Ew("source", s),
      u = "".concat(o[s - 1], " < ").concat(this.outputShape[s - 1]),
      c = 1 === s ? "source" : "vec2(".concat(l.slice(-2).join(), ")"),
      h = ["".concat(r, " rc = outputLoc;"), "".concat(o[s - 1], " += 1;\n       if(").concat(u, ") {\n      "), 1 === s ? "" : "}\n       rc = outputLoc;\n       ".concat(o[s - 2], " += 1;\n       if(").concat(o[s - 2], " < ").concat(this.outputShape[s - 2], ") {"), 1 === s ? "" : "  ".concat(o[s - 1], " += 1;\n         if(").concat(u, ") {")],
      d = 1 === s ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
  var p = "";

  for (var _e510 = 0, _t463 = 1 === s ? 2 : 4; _e510 < _t463; _e510++) {
    p += "\n        ".concat(h[_e510], "\n        if (").concat(d, ") {\n          result[").concat(_e510, "] = float(value);\n        } else {\n          ").concat(r, " source = rc - start;\n          result[").concat(_e510, "] = getChannel(getX(").concat(l.join(), "), ").concat(c, ");\n        }\n      ");
  }

  p += 1 === s ? "} " : "}}", this.userCode = "\n      const ".concat(r, " start = ").concat(r, "(").concat(a, ");\n      const ").concat(r, " end = ").concat(r, "(").concat(i, ");\n\n      void main() {\n        ").concat(r, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p, "\n        setOutput(result);\n      }\n    ");
};

var sC = function sC(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.paddings,
      i = s.constantValue,
      o = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new nC(r.shape, a, i) : new tC(r.shape, a, i);
  return n.runWebGLProgram(o, [r], r.dtype, [[i]]);
},
    rC = {
  kernelName: "PadV2",
  backendName: "webgl",
  kernelFunc: sC
},
    aC = {
  kernelName: "Pow",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
    packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
  })
},
    iC = {
  kernelName: "Prod",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.axis,
        i = s.keepDims,
        o = r.shape.length,
        l = [],
        u = y(a, r.shape);
    var c = u;
    var h = Jr(c, o);
    var p,
        f = r;

    if (null != h && (f = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: h
      }
    }), c = Qr(c.length, o), l.push(f)), Yr("prod", c, o), n.shouldExecuteOnCPU([f])) {
      var _e511 = n.texData.get(f.dataId).values,
          _hw = hw(f.shape, f.dtype, _e511, c),
          _t464 = _hw.outVals,
          _s236 = _hw.outShape,
          _r174 = _hw.outDtype;

      p = n.makeTensorInfo(_s236, _r174, _t464);
    } else {
      var _Kr31 = Kr(f.shape, c),
          _Kr32 = _slicedToArray(_Kr31, 2),
          _e512 = _Kr32[0],
          _t465 = _Kr32[1],
          _s237 = d(_t465),
          _a123 = cv({
        inputs: {
          x: f
        },
        backend: n,
        attrs: {
          shape: [-1, _s237]
        }
      }),
          _i116 = fv(_a123, pt(r.dtype), "prod", n);

      p = cv({
        inputs: {
          x: _i116
        },
        backend: n,
        attrs: {
          shape: _e512
        }
      }), l.push(_a123), l.push(_i116);
    }

    if (i) {
      l.push(p);

      var _e513 = Xr(p.shape, u);

      p = cv({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          shape: _e513
        }
      });
    }

    return l.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), p;
  }
},
    oC = function oC(e) {
  var t = e.backend,
      n = e.attrs,
      s = n.start,
      r = n.stop,
      a = n.step,
      i = n.dtype,
      o = dw(s, r, a, i);
  return t.makeTensorInfo([o.length], i, o);
},
    lC = {
  kernelName: "Range",
  backendName: "webgl",
  kernelFunc: oC
},
    uC = {
  kernelName: "Reciprocal",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return 1.0 / x;"
  })
},
    cC = {
  kernelName: "Relu",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
    packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  })
},
    hC = {
  kernelName: "Relu6",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  })
};

var dC = function dC(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, dC);

  this.variableNames = ["A"], this.outputShape = [];

  var _e514 = _slicedToArray(e, 4),
      a = _e514[0],
      i = _e514[1],
      o = _e514[2],
      l = _e514[3];

  this.outputShape = [a, t, n, l];
  var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
      c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
  var h;
  h = r ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ");\n      const vec2 inputShapeRC = vec2(").concat(i, ".0, ").concat(o, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ");
};

var pC = function pC(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, pC);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];

  var _e515 = _slicedToArray(e, 4),
      a = _e515[0],
      i = _e515[1],
      o = _e515[2],
      l = _e515[3];

  this.outputShape = [a, t, n, l];
  var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
      c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
  var h;
  h = r ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ",\n          ").concat(u[1] / c[1], ");\n      const vec3 inputShapeRC = vec3(").concat(i, ".0, ").concat(o, ".0,\n                                     ").concat(o, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l - 1, ";\n        bool hasNextRow = coords.z < ").concat(n - 1, ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ");
};

var fC = {
  kernelName: "ResizeBilinear",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = s.alignCorners,
        i = s.halfPixelCenters,
        o = s.size,
        _o74 = _slicedToArray(o, 2),
        l = _o74[0],
        u = _o74[1],
        c = V().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new pC(r.shape, l, u, a, i) : new dC(r.shape, l, u, a, i);

    return n.runWebGLProgram(c, [r], "float32");
  }
};

var gC = function gC(e, t, n) {
  "use strict";

  _classCallCheck(this, gC);

  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;

  var _t466 = _slicedToArray(t, 3),
      s = _t466[1],
      r = _t466[2],
      _e516 = _slicedToArray(e, 3),
      a = _e516[1],
      i = _e516[2],
      o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r],
      l = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i],
      u = o[0] / l[0],
      c = o[1] / l[1],
      h = 1 / u,
      d = 1 / c,
      p = 2 * Math.ceil(h) + 2,
      f = 2 * Math.ceil(d) + 2;

  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(u, ");\n        const float widthScale = float(").concat(c, ");\n\n        const float invHeightScale = float(").concat(h, ");\n        const float invWidthScale = float(").concat(d, ");\n\n        const int winHeight = int(").concat(p, ");\n        const int winWidth = int(").concat(f, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i, ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(s - 1, ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r - 1, ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
};

var mC = {
  kernelName: "ResizeBilinearGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = t.dy,
        i = s.alignCorners,
        o = new gC(a.shape, r.shape, i);
    return n.runWebGLProgram(o, [a], a.dtype);
  }
};

var bC = function bC(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, bC);

  this.variableNames = ["A"], this.outputShape = [];

  var _e517 = _slicedToArray(e, 4),
      a = _e517[0],
      i = _e517[1],
      o = _e517[2],
      l = _e517[3];

  this.outputShape = [a, t, n, l];
  var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
      c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
  var h;
  h = r ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ");\n      const vec2 inputShapeRC = vec2(").concat(i, ".0, ").concat(o, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(s ? "0.5" : "0.0", ")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ");
};

var xC = function xC(e, t, n, s, r) {
  "use strict";

  _classCallCheck(this, xC);

  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];

  var _e518 = _slicedToArray(e, 4),
      a = _e518[0],
      i = _e518[1],
      o = _e518[2],
      l = _e518[3];

  this.outputShape = [a, t, n, l];
  var u = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
      c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
  var h;
  h = r ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(u[0] / c[0], ",\n          ").concat(u[1] / c[1], ",\n          ").concat(u[1] / c[1], ");\n      const vec3 inputShapeRC = vec3(").concat(i, ".0, ").concat(o, ".0,\n                                     ").concat(o, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(s ? "0.5" : "0.0", ")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(l - 1, ";\n        bool hasNextRow = coords.z < ").concat(n - 1, ";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ");
};

var yC = {
  kernelName: "ResizeNearestNeighbor",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = s.alignCorners,
        i = s.halfPixelCenters,
        o = s.size,
        _o75 = _slicedToArray(o, 2),
        l = _o75[0],
        u = _o75[1],
        c = V().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new xC(r.shape, l, u, a, i) : new bC(r.shape, l, u, a, i);

    return n.runWebGLProgram(c, [r], r.dtype);
  }
};

var kC = function kC(e, t, n) {
  "use strict";

  _classCallCheck(this, kC);

  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;

  var _t467 = _slicedToArray(t, 3),
      s = _t467[1],
      r = _t467[2],
      _e519 = _slicedToArray(e, 3),
      a = _e519[1],
      i = _e519[2],
      o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r],
      l = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i],
      u = o[0] / l[0],
      c = o[1] / l[1],
      h = 1 / u,
      d = 1 / c,
      p = 2 * Math.ceil(h) + 2,
      f = 2 * Math.ceil(d) + 2;

  this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(u, ");\n        const float widthScale = float(").concat(c, ");\n\n        const float invHeightScale = float(").concat(h, ");\n        const float invWidthScale = float(").concat(d, ");\n\n        const int winHeight = int(").concat(p, ");\n        const int winWidth = int(").concat(f, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(a, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i, ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(o[0], ") *\n                (float(dyR) / float(").concat(l[0], "));\n\n            float sourceFracCol =\n                float(").concat(o[1], ") *\n                  (float(dyC) / float(").concat(l[1], "));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(s, ") - 1),\n                ").concat(n, " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r, ") - 1),\n                ").concat(n, " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ");
};

var wC = {
  kernelName: "ResizeNearestNeighborGrad",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.images,
        a = t.dy,
        i = s.alignCorners,
        o = new kC(a.shape, r.shape, i);
    return n.runWebGLProgram(o, [a], a.dtype);
  }
};

var vC = function vC(e, t) {
  "use strict";

  _classCallCheck(this, vC);

  this.variableNames = ["x"];
  var n = e.length;
  if (n > 4) throw new Error("WebGL backend: Reverse of rank-".concat(n, " tensor is not yet supported"));
  if (this.outputShape = e, 1 === n) return void (this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0], " - coord - 1));\n        }\n      "));
  var s = e.map(function (n, s) {
    return function (n) {
      return -1 !== t.indexOf(n) && 1 !== e[n] ? "".concat(e[n], " - coords[").concat(n, "] - 1") : "coords[".concat(n, "]");
    }(s);
  }).join(","),
      r = Mk(n);
  this.userCode = "\n      void main() {\n        ".concat(r, " coords = getOutputCoords();\n        setOutput(getX(").concat(s, "));\n      }\n    ");
};

var IC = function IC(e, t) {
  "use strict";

  _classCallCheck(this, IC);

  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
  var n = e.length;
  if (n > 4) throw new Error("WebGL backend: Reverse of rank-".concat(n, " tensor is not yet supported"));
  this.outputShape = e;
  var s = Ew("rc", n),
      r = "".concat(s[n - 1], " + 1 < ").concat(this.outputShape[n - 1]),
      a = "".concat(s[n - 2], " + 1 < ").concat(this.outputShape[n - 2]),
      i = Mk(n);

  function o(n) {
    var s = e.map(function (s, r) {
      return function (n, s) {
        return -1 !== t.indexOf(n) && 1 !== e[n] ? "".concat(e[n], " - ").concat(s[n], " - 1") : "".concat(s[n]);
      }(r, n);
    });
    return "getChannel(getX(".concat(s.join(","), "), vec2(").concat(s.slice(-2).join(","), "))");
  }

  this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0], " - rc - 1),\n            ").concat(e[0], " - rc - 1);\n          if(").concat(r, "){\n              result.g = getChannel(getX(").concat(e[0], " - (rc  + 1) - 1),\n                ").concat(e[0], " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ") : "\n        void main() {\n          ".concat(i, " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function (e) {
    return o(e);
  }(s.slice()), ";\n          if(").concat(r, "){\n            result.g = ").concat(function (e) {
    return e[n - 1] = "(" + e[n - 1] + " + 1)", o(e);
  }(s.slice()), ";\n          }\n          if(").concat(a, ") {\n            result.b = ").concat(function (e) {
    return e[n - 2] = "(" + e[n - 2] + " + 1)", o(e);
  }(s.slice()), ";\n            if(").concat(r, ") {\n              result.a = ").concat(function (e) {
    return e[n - 1] = "(" + e[n - 1] + " + 1)", e[n - 2] = "(" + e[n - 2] + " + 1)", o(e);
  }(s.slice()), ";\n            }\n          }\n          setOutput(result);\n        }\n    ");
};

var $C = {
  kernelName: "Reverse",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.dims,
        i = r.shape.length,
        o = y(a, r.shape);
    if (0 === i) return jw({
      inputs: {
        x: r
      },
      backend: n
    });
    var l = V().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new IC(r.shape, o) : new vC(r.shape, o);
    return n.runWebGLProgram(l, [r], r.dtype);
  }
};

var NC = function NC(e, t) {
  "use strict";

  _classCallCheck(this, NC);

  this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{
    name: "params",
    type: "vec4"
  }];
  var n = e[1],
      s = e[2];
  this.outputShape = e;
  var r = "";
  r = "number" == typeof t ? "float outputValue = ".concat(t.toFixed(2), ";") : "\n        vec3 fill = vec3(".concat(t.join(","), ");\n        float outputValue = fill[coords[3]];"), this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r, "\n          if(coordX >= 0 && coordX < ").concat(s, " && coordY >= 0 && coordY < ").concat(n, ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ");
};

var CC = {
  kernelName: "RotateWithOffset",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref61) {
    var e = _ref61.inputs,
        t = _ref61.attrs,
        n = _ref61.backend;

    var s = e.image,
        r = t.radians,
        a = t.fillValue,
        i = t.center,
        o = n,
        l = new NC(s.shape, a),
        _Eo3 = Eo(i, s.shape[1], s.shape[2]),
        _Eo4 = _slicedToArray(_Eo3, 2),
        u = _Eo4[0],
        c = _Eo4[1],
        h = [[u, c, Math.sin(r), Math.cos(r)]];

    return o.runWebGLProgram(l, [s], s.dtype, h);
  }
},
    SC = {
  kernelName: "Round",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
  })
},
    TC = {
  kernelName: "Rsqrt",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return inversesqrt(x);",
    cpuKernelImpl: pw
  })
};

var EC = /*#__PURE__*/function () {
  "use strict";

  function EC(e, t, n, s, r, a) {
    var i = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;

    _classCallCheck(this, EC);

    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
    var o = Mk(r.length),
        l = Mk(a.length);
    var u = "";
    1 === n ? u = "i" : 2 === n && (u = "i, j");
    var c = "";
    1 === s ? c = "i" : 2 === s && (c = "i, coords[1]"), this.userCode = "\n        ".concat(o, " strides = ").concat(o, "(").concat(r, ");\n\n        void main() {\n          ").concat(l, " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e, "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t, "; j++) {\n              int index = round(getIndices(").concat(u, "));\n              flattenedIndex += index * ").concat(t > 1 ? "strides[j]" : "strides", ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(").concat(c, ");\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ");
  }

  return EC;
}();

var RC = {
  kernelName: "ScatterNd",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.indices,
        a = t.updates,
        i = s.shape,
        _Sn3 = Sn(0, r, i),
        o = _Sn3.sliceRank,
        l = _Sn3.numUpdates,
        u = _Sn3.sliceSize,
        c = _Sn3.strides,
        h = _Sn3.outputSize,
        d = [h / u, u];

    if (0 === h) return n.makeTensorInfo(i, r.dtype);
    var p = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: [l, o]
      }
    }),
        f = cv({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [l, u]
      }
    }),
        g = n.makeTensorInfo([], "float32", new Float32Array([0])),
        m = new EC(l, o, p.shape.length, f.shape.length, c, d),
        b = n.runWebGLProgram(m, [f, p, g], f.dtype),
        x = cv({
      inputs: {
        x: b
      },
      backend: n,
      attrs: {
        shape: i
      }
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(g), x;
  }
};

var AC = function AC(e, t, n) {
  "use strict";

  _classCallCheck(this, AC);

  var s, r;
  if (this.variableNames = ["c", "a", "b"], this.outputShape = t, n > 4) throw Error("Where for rank ".concat(n, " is not yet supported"));
  if (1 === n) r = "resRC", s = "resRC";else {
    var _n304 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
        _a124 = [],
        _i117 = [];

    for (var _s238 = 0; _s238 < t.length; _s238++) {
      _i117.push("".concat(_n304[_s238])), _s238 < e && _a124.push("".concat(_n304[_s238]));
    }

    s = _a124.join(), r = _i117.join();
  }
  var a = Mk(n);
  this.userCode = "\n      void main() {\n        ".concat(a, " resRC = getOutputCoords();\n        float cVal = getC(").concat(s, ");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r, "));\n        } else {\n          setOutput(getB(").concat(r, "));\n        }\n      }\n    ");
};

var FC = {
  kernelName: "Select",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.condition,
        r = t.t,
        a = t.e,
        i = new AC(s.shape.length, r.shape, r.shape.length);
    return n.runWebGLProgram(i, [s, r, a], dt(r.dtype, a.dtype));
  }
},
    DC = {
  kernelName: "Selu",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n"
  })
},
    _C = {
  kernelName: "Sigmoid",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return 1.0 / (1.0 + exp(-1.0 * x));"
  })
},
    OC = {
  kernelName: "Sign",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
  })
},
    MC = {
  kernelName: "Sin",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n"
  })
},
    LC = {
  kernelName: "Sinh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
  })
},
    zC = {
  kernelName: "Softplus",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
  })
},
    BC = {
  kernelName: "SpaceToBatchND",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.blockShape,
        i = s.paddings;
    l(r.shape.length <= 4, function () {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var o = a.reduce(function (e, t) {
      return e * t;
    }),
        u = [[0, 0]];
    u.push.apply(u, _toConsumableArray(i));

    for (var _e520 = 1 + a.length; _e520 < r.shape.length; ++_e520) {
      u.push([0, 0]);
    }

    var c = [],
        h = sC({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        paddings: u,
        constantValue: 0
      }
    }),
        d = Ro(h.shape, a, o, !1),
        p = Ao(d.length, a.length, !1),
        f = Fo(h.shape, a, o, !1),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: d
      }
    }),
        m = kv({
      inputs: {
        x: g
      },
      backend: n,
      attrs: {
        perm: p
      }
    }),
        b = cv({
      inputs: {
        x: m
      },
      backend: n,
      attrs: {
        shape: f
      }
    });
    return c.push(h), c.push(g), c.push(m), c.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), b;
  }
},
    PC = {
  kernelName: "SparseFillEmptyRows",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.indices,
        r = t.values,
        a = t.denseShape,
        i = t.defaultValue;
    if (1 !== a.shape.length) throw new Error("Dense shape must be a vector, saw:\n         ".concat(a.shape));
    if (2 !== s.shape.length) throw new Error("Indices must be a matrix, saw:\n         ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));
    if (0 !== i.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));

    var o = n.readSync(s.dataId),
        l = n.readSync(r.dataId),
        u = n.readSync(a.dataId),
        c = n.readSync(i.dataId)[0],
        _mw = mw(o, s.shape, s.dtype, l, r.dtype, u, c),
        _mw2 = _slicedToArray(_mw, 5),
        h = _mw2[0],
        d = _mw2[1],
        p = _mw2[2],
        f = _mw2[3],
        g = _mw2[4];

    return [n.makeTensorInfo(d, s.dtype, h), n.makeTensorInfo([d[0]], r.dtype, p), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map(function (e) {
      return Number(e);
    }))), n.makeTensorInfo([g.length], s.dtype, new Int32Array(g))];
  }
},
    WC = {
  kernelName: "SparseReshape",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.inputIndices,
        r = t.inputShape,
        a = t.newShape;
    if (2 !== s.shape.length) throw new Error("Input indices should be a matrix but received shape ".concat(s.shape));
    if (1 !== r.shape.length) throw new Error("Input shape should be a vector but received shape ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(a.shape));

    var i = Array.from(n.readSync(r.dataId)),
        o = n.readSync(s.dataId),
        l = Array.from(n.readSync(a.dataId)),
        _bw = bw(o, s.shape, s.dtype, i, l),
        _bw2 = _slicedToArray(_bw, 3),
        u = _bw2[0],
        c = _bw2[1],
        h = _bw2[2];

    return [n.makeTensorInfo(c, s.dtype, u), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))];
  }
},
    UC = {
  kernelName: "SparseSegmentMean",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.data,
        r = t.indices,
        a = t.segmentIds;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n              ".concat(a.shape));

    var i = n.readSync(s.dataId),
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        _xw = xw(i, s.shape, s.dtype, o, l, !0),
        _xw2 = _slicedToArray(_xw, 2),
        u = _xw2[0],
        c = _xw2[1];

    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    VC = {
  kernelName: "SparseSegmentSum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = t.data,
        r = t.indices,
        a = t.segmentIds;
    if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (1 !== r.shape.length) throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));
    if (1 !== a.shape.length) throw new Error("Segment ids should be a vector but received shape\n             ".concat(a.shape));

    var i = n.readSync(s.dataId),
        o = n.readSync(r.dataId),
        l = n.readSync(a.dataId),
        _xw3 = xw(i, s.shape, s.dtype, o, l),
        _xw4 = _slicedToArray(_xw3, 2),
        u = _xw4[0],
        c = _xw4[1];

    return n.makeTensorInfo(c, s.dtype, u);
  }
},
    GC = {
  kernelName: "SparseToDense",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.sparseIndices,
        a = t.sparseValues,
        i = t.defaultValue,
        o = s.outputShape,
        _Sn4 = Sn(0, r, o),
        l = _Sn4.sliceRank,
        u = _Sn4.numUpdates,
        c = _Sn4.strides,
        h = _Sn4.outputSize,
        d = new EC(u, l, r.shape.length, a.shape.length, c, [h, 1], !1),
        p = n.runWebGLProgram(d, [a, r, i], a.dtype),
        f = cv({
      inputs: {
        x: p
      },
      backend: n,
      attrs: {
        shape: o
      }
    });

    return n.disposeIntermediateTensorInfo(p), f;
  }
},
    HC = {
  kernelName: "SplitV",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.numOrSizeSplits,
        i = s.axis,
        o = y(i, r.shape)[0],
        l = Jo(r, a, o),
        u = new Array(r.shape.length).fill(0),
        c = r.shape.slice();
    return l.map(function (e) {
      var t = _toConsumableArray(c);

      t[o] = e;
      var s = lI({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          begin: u,
          size: t
        }
      });
      return u[o] += e, s;
    });
  }
},
    jC = {
  kernelName: "Sqrt",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return sqrt(x);"
  })
},
    qC = {
  kernelName: "Square",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return x * x;"
  })
},
    KC = {
  kernelName: "SquaredDifference",
  backendName: "webgl",
  kernelFunc: sv({
    opSnippet: "return (a - b) * (a - b);",
    packedOpSnippet: "return (a - b) * (a - b);"
  })
},
    XC = {
  kernelName: "Step",
  backendName: "webgl",
  kernelFunc: function kernelFunc(_ref62) {
    var e = _ref62.inputs,
        t = _ref62.attrs,
        n = _ref62.backend;
    var s = e.x,
        r = new Mw(s.shape, "if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(".concat(t.alpha, ");\n  "));
    return n.runWebGLProgram(r, [s], s.dtype);
  }
};

var YC = function YC(e, t, n) {
  "use strict";

  _classCallCheck(this, YC);

  this.variableNames = ["x"], this.outputShape = n;
  var s = n.length,
      r = Mk(n.length),
      a = Mk(n.length);
  var i = "";
  if (1 === s) i = "coords * strides + begin";else {
    var _e521 = 0;
    i = n.map(function (t, s) {
      return _e521++, 1 === n.length ? "coords * strides[".concat(s, "] + begin[").concat(s, "]") : "coords[".concat(_e521 - 1, "] * strides[").concat(s, "] + begin[").concat(s, "]");
    }).join(",");
  }
  this.userCode = "\n      ".concat(r, " begin = ").concat(r, "(").concat(e, ");\n      ").concat(r, " strides = ").concat(r, "(").concat(t, ");\n\n      void main() {\n        ").concat(a, " coords = getOutputCoords();\n        setOutput(getX(").concat(i, "));\n      }\n    ");
};

var JC = {
  kernelName: "StridedSlice",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.begin,
        i = s.end,
        o = s.strides,
        l = s.beginMask,
        u = s.endMask,
        c = s.ellipsisMask,
        h = s.newAxisMask,
        d = s.shrinkAxisMask,
        _Vn2 = Vn(r.shape, a, i, o, l, u, c, h, d),
        p = _Vn2.nonStrided,
        f = _Vn2.$begin,
        g = _Vn2.$strides,
        m = _Vn2.size,
        b = _Vn2.newShape,
        x = _Vn2.outShape,
        y = cv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        shape: b
      }
    });

    var k;

    if (p) {
      var _e522 = lI({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          begin: f,
          size: m
        }
      });

      k = cv({
        inputs: {
          x: _e522
        },
        backend: n,
        attrs: {
          shape: x
        }
      }), n.disposeIntermediateTensorInfo(_e522);
    } else if (x.some(function (e) {
      return 0 === e;
    })) k = n.makeTensorInfo(x, r.dtype, []);else if (n.shouldExecuteOnCPU([y])) {
      var _e523 = n.texData.get(y.dataId),
          _t468 = dn(y.shape, y.dtype, _e523.values),
          _s239 = yw(x, _t468, g, f);

      k = n.makeTensorInfo(x, y.dtype, _s239.values);
    } else {
      var _e524 = new YC(f, g, x);

      k = n.runWebGLProgram(_e524, [y], y.dtype);
    }

    var w = cv({
      inputs: {
        x: k
      },
      backend: n,
      attrs: {
        shape: x
      }
    });
    return n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(k), w;
  }
},
    ZC = {
  kernelName: "StringNGrams",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.separator,
        a = s.nGramWidths,
        i = s.leftPad,
        o = s.rightPad,
        l = s.padWidth,
        u = s.preserveShortSequences,
        c = t.data,
        h = t.dataSplits,
        d = n.readSync(c.dataId),
        p = n.readSync(h.dataId),
        _kw = kw(d, p, r, a, i, o, l, u),
        _kw2 = _slicedToArray(_kw, 2),
        f = _kw2[0],
        g = _kw2[1];

    return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", g)];
  }
},
    QC = {
  kernelName: "StringSplit",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.skipEmpty,
        a = t.input,
        i = t.delimiter;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
    if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));

    var o = n.readSync(a.dataId),
        l = n.readSync(i.dataId)[0],
        _ww = ww(o, l, r),
        _ww2 = _slicedToArray(_ww, 3),
        u = _ww2[0],
        c = _ww2[1],
        h = _ww2[2],
        d = c.length;

    return [n.makeTensorInfo([d, 2], "int32", u), n.makeTensorInfo([d], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))];
  }
},
    eS = {
  kernelName: "StringToHashBucketFast",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = s.numBuckets,
        a = t.input;
    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
    if (r <= 0) throw new Error("Number of buckets must be at least 1");
    var i = n.readSync(a.dataId),
        o = vw(i, r);
    return n.makeTensorInfo(a.shape, "int32", o);
  }
},
    tS = {
  kernelName: "Tan",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "return tan(x);"
  })
},
    nS = {
  kernelName: "Tanh",
  backendName: "webgl",
  kernelFunc: nv({
    opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
  })
};

var sS = function sS(e, t) {
  "use strict";

  _classCallCheck(this, sS);

  this.variableNames = ["A"];
  var n = new Array(e.length);

  for (var _s240 = 0; _s240 < n.length; _s240++) {
    n[_s240] = e[_s240] * t[_s240];
  }

  this.outputShape = n, this.rank = n.length;

  var s = Mk(this.rank),
      r = function (e) {
    var t = e.length;
    if (t > 5) throw Error("Tile for rank ".concat(t, " is not yet supported"));
    if (1 === t) return "imod(resRC, ".concat(e[0], ")");
    var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"],
        s = [];

    for (var _t469 = 0; _t469 < e.length; _t469++) {
      s.push("imod(".concat(n[_t469], ", ").concat(e[_t469], ")"));
    }

    return s.join();
  }(e);

  this.userCode = "\n      void main() {\n        ".concat(s, " resRC = getOutputCoords();\n        setOutput(getA(").concat(r, "));\n      }\n    ");
};

function rS(e) {
  var t = e.inputs,
      n = e.backend,
      s = e.attrs,
      r = t.x,
      a = s.reps;

  if ("string" === r.dtype || r.shape.length > 5) {
    var _e525 = n.readSync(r.dataId),
        _t470 = "string" === r.dtype ? _e525.map(function (e) {
      return He(e);
    }) : _e525,
        _s241 = dn(r.shape, r.dtype, _t470),
        _i118 = $w(_s241, a);

    return n.makeTensorInfo(_i118.shape, _i118.dtype, _i118.values);
  }

  var i = new sS(r.shape, a);
  return n.runWebGLProgram(i, [r], r.dtype);
}

var aS = {
  kernelName: "Tile",
  backendName: "webgl",
  kernelFunc: rS
};

var iS = function iS(e) {
  "use strict";

  _classCallCheck(this, iS);

  this.variableNames = ["x", "indices"], this.customUniforms = [{
    name: "n",
    type: "int"
  }, {
    name: "firstPass",
    type: "int"
  }, {
    name: "negativeInf",
    type: "float"
  }, {
    name: "dir",
    type: "int"
  }, {
    name: "inc",
    type: "int"
  }], this.outputShape = e, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ";
};

var oS = function oS(e) {
  "use strict";

  _classCallCheck(this, oS);

  this.variableNames = ["x", "indices"], this.customUniforms = [{
    name: "n",
    type: "int"
  }, {
    name: "firstPass",
    type: "int"
  }, {
    name: "k",
    type: "int"
  }], this.outputShape = e, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ";
};

function lS(e, t) {
  null !== t && e.disposeIntermediateTensorInfo(t);
}

function uS(e) {
  var t = 1;

  for (; t < e;) {
    t *= 2;
  }

  return t;
}

var cS = {
  kernelName: "TopK",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = s.k,
        i = s.sorted,
        o = V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),
        l = V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),
        u = r.shape,
        c = u[u.length - 1];

    if (n.shouldExecuteOnCPU([r]) || c < o || a > l) {
      var _e526 = n.readSync(r.dataId),
          _Nw = Nw(_e526, u, r.dtype, a, i),
          _Nw2 = _slicedToArray(_Nw, 2),
          _t471 = _Nw2[0],
          _s242 = _Nw2[1];

      return [n.makeTensorInfo(_t471.shape, _t471.dtype, _t471.values), n.makeTensorInfo(_s242.shape, _s242.dtype, _s242.values)];
    }

    if (0 === a) return u[u.length - 1] = 0, [n.makeTensorInfo(u, r.dtype, []), n.makeTensorInfo(u, "int32", [])];
    if (1 === c) return [r, F$({
      attrs: {
        shape: u,
        dtype: "int32",
        value: 0
      },
      backend: n
    })];
    var h = n.texData.get(r.dataId),
        p = null !== h && h.isPacked,
        f = p ? n.unpackTensor(r) : r,
        g = d(u) / c,
        m = cv({
      inputs: {
        x: f
      },
      attrs: {
        shape: [g, c]
      },
      backend: n
    });
    p && lS(n, f);
    var b = uS(a),
        x = uS(c);
    var y = null;

    var k = function k() {
      return null === y ? [m, m] : [m, y];
    },
        w = function w(e, t, s) {
      var r = k(),
          a = new iS(s),
          i = y;
      y = n.runWebGLProgram(a, r, "int32", [[c], [null === y ? 1 : 0], [Number.NEGATIVE_INFINITY], [e], [t]]), lS(n, i);
    };

    for (var _e527 = 1; _e527 < b; _e527 *= 2) {
      var _t472 = 2 * _e527;

      for (var _n305 = _e527; _n305 >= 1; _n305 /= 2) {
        w(_t472, _n305, [g, x]);
      }
    }

    for (var _e528 = x; _e528 > b; _e528 /= 2) {
      var _t473 = k(),
          _s243 = new oS([g, _e528 / 2]),
          _r175 = y;

      y = n.runWebGLProgram(_s243, _t473, "int32", [[c], [null === y ? 1 : 0], [b]]), lS(n, _r175);

      var _a125 = b / 2,
          _i119 = 2 * _a125;

      for (var _e529 = _a125; _e529 >= 1; _e529 /= 2) {
        w(_i119, _e529, y.shape);
      }
    }

    var v = y;
    y = lI({
      inputs: {
        x: y
      },
      backend: n,
      attrs: {
        begin: 0,
        size: [g, a]
      }
    }), lS(n, v);
    var I = K$({
      inputs: {
        x: m,
        indices: y
      },
      backend: n,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    lS(n, m);
    var $ = u.slice(0, -1);
    $.push(a), v = y, y = cv({
      inputs: {
        x: y
      },
      attrs: {
        shape: $
      },
      backend: n
    }), lS(n, v);
    var N = I;
    return I = cv({
      inputs: {
        x: I
      },
      attrs: {
        shape: $
      },
      backend: n
    }), lS(n, N), [I, y];
  }
};

var hS = function hS(e, t, n, s, r, a) {
  "use strict";

  _classCallCheck(this, hS);

  this.variableNames = ["Image", "Transforms"], this.outputShape = a;
  var i = "nearest" === n ? 1 : 2;
  var o;

  switch (s) {
    case "constant":
      o = 1;
      break;

    case "reflect":
      o = 2;
      break;

    case "wrap":
      o = 3;
      break;

    case "nearest":
      o = 4;
      break;

    default:
      o = 1;
  }

  this.userCode = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(o, " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o, " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(o, " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e, " && 0 <= coordX && coordX < ").concat(t, ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r, ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r, ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t, "));\n                float mapY = mapCoord(inY, float(").concat(e, "));\n\n                if (").concat(i, " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ");
};

var dS = {
  kernelName: "Transform",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.image,
        a = t.transforms,
        i = s.interpolation,
        o = s.fillMode,
        l = s.fillValue,
        u = s.outputShape,
        _r$shape7 = _slicedToArray(r.shape, 4),
        c = _r$shape7[0],
        h = _r$shape7[1],
        d = _r$shape7[2],
        p = _r$shape7[3],
        _ref63 = null != u ? u : [h, d],
        _ref64 = _slicedToArray(_ref63, 2),
        f = _ref64[0],
        g = _ref64[1],
        m = new hS(h, d, i, o, l, [c, f, g, p]);

    return n.runWebGLProgram(m, [r, a], "float32");
  }
},
    pS = {
  kernelName: "Unique",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.attrs,
        s = e.backend,
        r = n.axis,
        a = t.x;
    ik(a, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");

    var i = s.readSync(a.dataId),
        _Sw = Sw(i, r, a.shape, a.dtype),
        o = _Sw.outputValues,
        l = _Sw.outputShape,
        u = _Sw.indices;

    return [s.makeTensorInfo(l, a.dtype, o), s.makeTensorInfo([u.length], "int32", u)];
  }
},
    fS = {
  kernelName: "Unpack",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.value;
    var a = s.axis;
    a < 0 && (a += r.shape.length);
    var i = r,
        o = i.shape.length,
        l = r.shape[a],
        u = new Array(o - 1);
    var c = 0;

    for (var _e530 = 0; _e530 < o; _e530++) {
      _e530 !== a && (u[c++] = i.shape[_e530]);
    }

    var h = [],
        d = new Array(o).fill(0),
        p = i.shape.slice();
    p[a] = 1;
    var f = new Array(l);

    for (var _e531 = 0; _e531 < f.length; _e531++) {
      d[a] = _e531;

      var _t474 = lI({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          begin: d,
          size: p
        }
      }),
          _s244 = cv({
        inputs: {
          x: _t474
        },
        backend: n,
        attrs: {
          shape: u
        }
      });

      f[_e531] = _s244, h.push(_t474);
    }

    return h.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), f;
  }
};

var gS = function gS(e, t) {
  "use strict";

  _classCallCheck(this, gS);

  this.variableNames = ["x", "segmentIds"];
  var n = e.windowSize,
      s = e.batchSize,
      r = e.inSize,
      a = e.numSegments,
      i = a * Math.ceil(r / n);
  this.outputShape = [s, i];
  var o = 4 * Math.floor(n / 4),
      l = n % 4,
      u = "\n        sumValue += dot(values, segFilter);\n    ";
  var c = "";
  r % n > 0 && (c = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return initializationValue;\n        }\n      "));
  var h = "";
  r % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= ".concat(r, ") {\n          return -1.0;\n        }\n      ")), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c, "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h, "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(a, ")) * float(").concat(n, "));\n        int currentSeg = int(mod(float(outIdx), float(").concat(a, ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(u, "\n        }\n\n        int inIdx = inOffset + ").concat(o, ";\n        if (").concat(1 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(u, "\n        } else if (").concat(2 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(u, "\n        } else if (").concat(3 === l, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(u, "\n        }\n        setOutput(sumValue);\n      }\n    ");
};

var mS = [dN, fN, Iv, Nv, Cv, Sv, Ev, Fv, Dv, _v, Pv, Wv, Uv, Vv, Hv, Gv, jv, Yv, Xv, Qv, eI, tI, rI, cI, hI, mI, xI, wI, $I, Xw, FI, VI, GI, zI, jI, qI, HI, KI, XI, JI, t$, n$, r$, c$, h$, o$, p$, g$, m$, b$, x$, y$, k$, I$, N$, S$, R$, D$, O$, L$, z$, W$, V$, G$, j$, X$, Y$, J$, qw, Z$, EI, Q$, eN, tN, Zw, nN, sN, rN, iN, aN, oN, lN, uN, mN, yN, xN, vN, IN, $N, bN, NN, CN, SN, RN, AN, PN, uv, UN, GN, jN, KN, pI, YN, QN, eC, rC, aC, tv, iC, lC, gI, _N, uC, hC, cC, hv, fC, mC, yC, wC, $C, CC, SC, TC, RC, FC, DC, _C, OC, MC, LC, uI, BN, zC, BC, PC, WC, UC, VC, GC, HC, jC, qC, KC, XC, JC, ZC, QC, eS, LN, yv, tS, nS, aS, cS, dS, wv, pS, fS, {
  kernelName: "UnsortedSegmentSum",
  backendName: "webgl",
  kernelFunc: function kernelFunc(e) {
    var t = e.inputs,
        n = e.backend,
        s = e.attrs,
        r = t.x,
        a = t.segmentIds,
        i = s.numSegments,
        o = r.shape.length,
        l = [];
    var u = 0;
    var c = Jr([u], o);
    var h = r;
    null != c && (h = kv({
      inputs: {
        x: r
      },
      backend: n,
      attrs: {
        perm: c
      }
    }), l.push(h), u = Qr(1, o)[0]);
    var p = Qo(h.shape, u, i),
        f = d([h.shape[u]]),
        g = cv({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: [-1, f]
      }
    });
    l.push(g);

    var m = pt(r.dtype),
        b = function b(e, t, s, r, a) {
      var i = e.shape[0],
          o = e.shape[1],
          u = Zo(o, a),
          c = new gS({
        windowSize: u,
        inSize: o,
        batchSize: i,
        numSegments: a
      }, t),
          h = n.compileAndRun(c, [e, s], r);
      if (l.push(h), h.shape[1] === a) return h;
      var d = oC({
        backend: n,
        attrs: {
          start: 0,
          stop: a,
          step: 1,
          dtype: "float32"
        }
      }),
          p = rS({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          reps: [o / u]
        }
      });
      return l.push(d), l.push(p), b(h, t, p, r, a);
    },
        x = cv({
      inputs: {
        x: b(g, "unsortedSegmentSum", a, m, i)
      },
      backend: n,
      attrs: {
        shape: p
      }
    });

    var y = x;

    if (null != c) {
      l.push(x);

      var _e532 = Zr(c);

      y = kv({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          perm: _e532
        }
      });
    }

    return l.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    }), y;
  }
}, ZN];

for (var _i120 = 0, _mS = mS; _i120 < _mS.length; _i120++) {
  var _e533 = _mS[_i120];
  Q(_e533);
}

var bS = ["worker"],
    xS = {
  train: function () {
    var _train = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee91(e) {
      var t, n, s, r, _ref65, a, i, o, l;

      return _regeneratorRuntime.wrap(function _callee91$(_context94) {
        while (1) {
          switch (_context94.prev = _context94.next) {
            case 0:
              t = e.data;
              n = [];
              s = function (e, t, n) {
                if (c(e), null != t && 3 !== t.length) throw new Error("tensor3d() requires shape to have three numbers");
                var s = Ct(e, n);
                if (3 !== s.length && 1 !== s.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
                if (1 === s.length && null == t) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
                return Dt(e, t, s, n);
              }(t.xData, [t.xData.length, t.model.inputShape[0], t.model.inputShape[1]]), r = In(mi(t.yData, "int32"), t.model.labels.length), _ref65 = function (e, t) {
                var n = new Ed(void 0);
                return "" == t && (n.add(Of({
                  inputShape: e.inputShape,
                  kernelSize: [4],
                  strides: 1,
                  filters: 16,
                  activation: "relu"
                })), n.add(Lf({
                  poolSize: [2]
                })), n.add(Mf({
                  rate: .1
                })), n.add(Of({
                  kernelSize: [2],
                  strides: 1,
                  filters: 16,
                  activation: "relu"
                })), n.add(Lf({
                  poolSize: [2]
                })), n.add(Mf({
                  rate: .1
                })), n.add(Of({
                  kernelSize: [2],
                  strides: 1,
                  filters: 16,
                  activation: "relu"
                })), n.add(Mf({
                  rate: .1
                })), n.add(new Hp(void 0)), n.add(new Gp({
                  units: e.outputShape,
                  activation: "softmax"
                })), n.compile({
                  loss: "categoricalCrossentropy",
                  optimizer: "adam",
                  metrics: ["accuracy"]
                })), {
                  model: n,
                  epochs: 250
                };
              }(t.model, t.modelBlockJSON), a = _ref65.epochs, i = _ref65.model;
              _context94.next = 5;
              return i.fit(s, r, {
                epochs: a,
                callbacks: {
                  onEpochEnd: yS
                }
              }).then(function (e) {
                n = e.history.acc;
              });

            case 5:
              _context94.next = 7;
              return i.save({
                save: function save(e) {
                  o = e;
                  var t = {
                    modelArtifactsInfo: {
                      dateSaved: new Date(),
                      modelTopologyType: "JSON"
                    }
                  };
                  return Promise.resolve(t);
                }
              });

            case 7:
              l = o.weightData;
              return _context94.abrupt("return", (o.weightData = null, {
                modelJSON: JSON.stringify(o),
                modelWeights: l,
                trainingInfo: n
              }));

            case 9:
            case "end":
              return _context94.stop();
          }
        }
      }, _callee91);
    }));

    function train(_x144) {
      return _train.apply(this, arguments);
    }

    return train;
  }(),
  predict: function () {
    var _predict = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee94(e) {
      var t, n, s, r, a, i, o;
      return _regeneratorRuntime.wrap(function _callee94$(_context97) {
        while (1) {
          switch (_context97.prev = _context97.next) {
            case 0:
              t = e.data, n = _t(t.zData), s = JSON.parse(t.model.modelJSON);
              s.weightData = new Uint32Array(t.model.weights).buffer;
              _context97.next = 4;
              return a = {
                load: function load() {
                  return Promise.resolve(s);
                }
              }, null == i && (i = {}), function () {
                var _ref66 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee93(e, t) {
                  var _n306;

                  return _regeneratorRuntime.wrap(function _callee93$(_context96) {
                    while (1) {
                      switch (_context96.prev = _context96.next) {
                        case 0:
                          if (!(null == t && (t = {}), "string" == typeof e)) {
                            _context96.next = 9;
                            break;
                          }

                          _n306 = Gt.getLoadHandlers(e, t);

                          if (!(0 === _n306.length)) {
                            _context96.next = 6;
                            break;
                          }

                          _n306.push(wn(e, t));

                          _context96.next = 8;
                          break;

                        case 6:
                          if (!(_n306.length > 1)) {
                            _context96.next = 8;
                            break;
                          }

                          throw new bu("Found more than one (".concat(_n306.length, ") load handlers for URL '").concat(e, "'"));

                        case 8:
                          e = _n306[0];

                        case 9:
                          return _context96.abrupt("return", function () {
                            var _ref67 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee92(e, t, n) {
                              var s, r, a, i, o, l, _ref68, _e534, _t475;

                              return _regeneratorRuntime.wrap(function _callee92$(_context95) {
                                while (1) {
                                  switch (_context95.prev = _context95.next) {
                                    case 0:
                                      if (!(null == n && (n = {}), null == e.load)) {
                                        _context95.next = 2;
                                        break;
                                      }

                                      throw new bu("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");

                                    case 2:
                                      _context95.next = 4;
                                      return e.load();

                                    case 4:
                                      s = _context95.sent;
                                      r = s.modelTopology;
                                      null != r.model_config && (r = r.model_config);
                                      a = null == n.strict || n.strict, i = null != s.weightData && null != s.weightSpecs && a, o = Eh(td(r), void 0, i), l = s.trainingConfig;

                                      if (!(null != l && o.loadTrainingConfig(l), null != s.userDefinedMetadata && o.setUserDefinedMetadata(s.userDefinedMetadata), null != s.weightData)) {
                                        _context95.next = 19;
                                        break;
                                      }

                                      if (!(null == s.weightSpecs)) {
                                        _context95.next = 11;
                                        break;
                                      }

                                      throw new bu("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");

                                    case 11:
                                      _ref68 = function (e, t) {
                                        var n = function (e, t) {
                                          var n = {};
                                          var s,
                                              r = 0;

                                          var _iterator117 = _createForOfIteratorHelper(t),
                                              _step117;

                                          try {
                                            for (_iterator117.s(); !(_step117 = _iterator117.n()).done;) {
                                              var _a126 = _step117.value;

                                              var _t476 = _a126.name,
                                                  _i121 = _a126.dtype,
                                                  _o76 = _a126.shape,
                                                  _l55 = d(_o76);

                                              var u = void 0;

                                              if ("quantization" in _a126) {
                                                var _n307 = _a126.quantization;

                                                if ("uint8" === _n307.dtype || "uint16" === _n307.dtype) {
                                                  if (!("min" in _n307) || !("scale" in _n307)) throw new Error("Weight ".concat(_a126.name, " with quantization ").concat(_n307.dtype, " doesn't have corresponding metadata min and scale."));
                                                } else {
                                                  if ("float16" !== _n307.dtype) throw new Error("Weight ".concat(_a126.name, " has unknown quantization dtype ").concat(_n307.dtype, ". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'."));
                                                  if ("float32" !== _i121) throw new Error("Weight ".concat(_a126.name, " is quantized with ").concat(_n307.dtype, " which only supports weights of type float32 not ").concat(_i121, "."));
                                                }

                                                var _o77 = Ot[_n307.dtype],
                                                    _c30 = e.slice(r, r + _l55 * _o77),
                                                    _h17 = "uint8" === _n307.dtype ? new Uint8Array(_c30) : new Uint16Array(_c30);

                                                if ("float32" === _i121) {
                                                  if ("uint8" === _n307.dtype || "uint16" === _n307.dtype) {
                                                    u = new Float32Array(_h17.length);

                                                    for (var _e535 = 0; _e535 < _h17.length; _e535++) {
                                                      u[_e535] = _h17[_e535] * _n307.scale + _n307.min;
                                                    }
                                                  } else {
                                                    if ("float16" !== _n307.dtype) throw new Error("Unsupported quantization type ".concat(_n307.dtype, " for weight type float32."));
                                                    void 0 === s && (s = Vt()), u = s(_h17);
                                                  }
                                                } else {
                                                  if ("int32" !== _i121) throw new Error("Unsupported dtype in weight '".concat(_t476, "': ").concat(_i121));
                                                  if ("uint8" !== _n307.dtype && "uint16" !== _n307.dtype) throw new Error("Unsupported quantization type ".concat(_n307.dtype, " for weight type int32."));
                                                  u = new Int32Array(_h17.length);

                                                  for (var _e536 = 0; _e536 < _h17.length; _e536++) {
                                                    u[_e536] = Math.round(_h17[_e536] * _n307.scale + _n307.min);
                                                  }
                                                }
                                                r += _l55 * _o77;
                                              } else if ("string" === _i121) {
                                                var _t477 = d(_a126.shape);

                                                u = [];

                                                for (var _n308 = 0; _n308 < _t477; _n308++) {
                                                  var _t478 = new Uint32Array(e.slice(r, r + 4))[0];
                                                  r += 4;

                                                  var _n309 = new Uint8Array(e.slice(r, r + _t478));

                                                  u.push(_n309), r += _t478;
                                                }
                                              } else {
                                                var _s245 = Ot[_i121],
                                                    _a127 = e.slice(r, r + _l55 * _s245);

                                                if ("float32" === _i121) u = new Float32Array(_a127);else if ("int32" === _i121) u = new Int32Array(_a127);else if ("bool" === _i121) u = new Uint8Array(_a127);else {
                                                  if ("complex64" !== _i121) throw new Error("Unsupported dtype in weight '".concat(_t476, "': ").concat(_i121));
                                                  {
                                                    u = new Float32Array(_a127);

                                                    var _e537 = new Float32Array(u.length / 2),
                                                        _s246 = new Float32Array(u.length / 2);

                                                    for (var _t479 = 0; _t479 < _e537.length; _t479++) {
                                                      _e537[_t479] = u[2 * _t479], _s246[_t479] = u[2 * _t479 + 1];
                                                    }

                                                    var _r176 = _t(_e537, _o76, "float32"),
                                                        _i122 = _t(_s246, _o76, "float32");

                                                    n[_t476] = Ft(_r176, _i122), _r176.dispose(), _i122.dispose();
                                                  }
                                                }
                                                r += _l55 * _s245;
                                              }

                                              "complex64" !== _i121 && (n[_t476] = _t(u, _o76, _i121));
                                            }
                                          } catch (err) {
                                            _iterator117.e(err);
                                          } finally {
                                            _iterator117.f();
                                          }

                                          return n;
                                        }(e, t),
                                            s = {},
                                            r = [];

                                        return t.forEach(function (e) {
                                          "optimizer" === e.group ? r.push({
                                            name: e.name,
                                            tensor: n[e.name]
                                          }) : s[e.name] = n[e.name];
                                        }), {
                                          modelWeights: s,
                                          optimizerWeights: r
                                        };
                                      }(s.weightData, s.weightSpecs), _e534 = _ref68.modelWeights, _t475 = _ref68.optimizerWeights;
                                      o.loadWeights(_e534, a);
                                      _context95.t0 = null != o.optimizer && _t475.length > 0;

                                      if (!_context95.t0) {
                                        _context95.next = 17;
                                        break;
                                      }

                                      _context95.next = 17;
                                      return o.optimizer.setWeights(_t475);

                                    case 17:
                                      Jn(_e534);
                                      Jn(_t475.map(function (e) {
                                        return e.tensor;
                                      }));

                                    case 19:
                                      return _context95.abrupt("return", o);

                                    case 20:
                                    case "end":
                                      return _context95.stop();
                                  }
                                }
                              }, _callee92);
                            }));

                            return function (_x148, _x149, _x150) {
                              return _ref67.apply(this, arguments);
                            };
                          }()(e, 0, t));

                        case 10:
                        case "end":
                          return _context96.stop();
                      }
                    }
                  }, _callee93);
                }));

                return function (_x146, _x147) {
                  return _ref66.apply(this, arguments);
                };
              }()(a, i);

            case 4:
              r = _context97.sent;
              _context97.next = 7;
              return r.predict(n);

            case 7:
              o = _context97.sent;
              _context97.next = 10;
              return o.dataSync();

            case 10:
              _context97.t0 = _context97.sent;
              return _context97.abrupt("return", {
                prediction: _context97.t0
              });

            case 12:
            case "end":
              return _context97.stop();
          }
        }
      }, _callee94);
    }));

    function predict(_x145) {
      return _predict.apply(this, arguments);
    }

    return predict;
  }()
};

function yS(e, t) {
  self.postMessage({
    type: "progress",
    data: t
  });
}

self.addEventListener("message", /*#__PURE__*/function () {
  var _ref69 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee96(t) {
    var n, s, r, a;
    return _regeneratorRuntime.wrap(function _callee96$(_context99) {
      while (1) {
        switch (_context99.prev = _context99.next) {
          case 0:
            n = t.data, s = n.worker, r = function (e, t) {
              if (null == e) return {};
              var n,
                  s,
                  r = {},
                  a = Object.keys(e);

              for (s = 0; s < a.length; s++) {
                t.indexOf(n = a[s]) >= 0 || (r[n] = e[n]);
              }

              return r;
            }(n, bS);

            if (!("tf" !== s)) {
              _context99.next = 3;
              break;
            }

            return _context99.abrupt("return");

          case 3:
            _context99.t0 = e;
            _context99.t1 = {
              worker: s
            };
            _context99.t2 = r;
            _context99.next = 8;
            return function () {
              var _ref70 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee95(e) {
                var _t480;

                return _regeneratorRuntime.wrap(function _callee95$(_context98) {
                  while (1) {
                    switch (_context98.prev = _context98.next) {
                      case 0:
                        _context98.prev = 0;
                        _t480 = xS[e.type];
                        _context98.next = 4;
                        return null == _t480 ? void 0 : _t480(e);

                      case 4:
                        return _context98.abrupt("return", _context98.sent);

                      case 7:
                        _context98.prev = 7;
                        _context98.t0 = _context98["catch"](0);
                        return _context98.abrupt("return", void console.error(_context98.t0));

                      case 10:
                      case "end":
                        return _context98.stop();
                    }
                  }
                }, _callee95, null, [[0, 7]]);
              }));

              return function (_x152) {
                return _ref70.apply(this, arguments);
              };
            }()(n);

          case 8:
            _context99.t3 = _context99.sent;
            _context99.t4 = {
              data: _context99.t3
            };
            a = (0, _context99.t0)(_context99.t1, _context99.t2, _context99.t4);
            self.postMessage(a);

          case 12:
          case "end":
            return _context99.stop();
        }
      }
    }, _callee96);
  }));

  return function (_x151) {
    return _ref69.apply(this, arguments);
  };
}()), console.debug("jacdac tf: worker registered");

/***/ })

}]);