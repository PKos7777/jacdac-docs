(self["webpackChunkjacdac_docs"] = self["webpackChunkjacdac_docs"] || []).push([[4841],{

/***/ 66213:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ _get; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(77608);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/superPropBase.js

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = (0,getPrototypeOf/* default */.Z)(object);
    if (object === null) break;
  }

  return object;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/get.js

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

/***/ }),

/***/ 32253:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export styles */
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22122);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);
/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34621);
/* harmony import */ var _Typography__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80453);




var styles = {
  /* Styles applied to the root element. */
  root: {
    marginBottom: 12
  }
};
var DialogContentText = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function DialogContentText(props, ref) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Typography__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)({
    component: "p",
    variant: "body1",
    color: "textSecondary",
    ref: ref
  }, props));
});
 false ? 0 : void 0;
/* harmony default export */ __webpack_exports__["Z"] = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(styles, {
  name: 'MuiDialogContentText'
})(DialogContentText));

/***/ }),

/***/ 61452:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15911)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * @fileoverview Blockly module.
   */

  /* eslint-disable */
  'use strict';

  return Blockly;
});

/***/ }),

/***/ 71269:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(43049)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * @fileoverview Blockly Blocks module.
   */

  /* eslint-disable */
  'use strict';

  Blockly.Blocks = {};
  return Blockly.Blocks;
});

/***/ }),

/***/ 43049:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Do not edit this file; automatically generated by gulp.

/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15911)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  'use strict';

  Blockly.Blocks.colour = {};
  Blockly.Constants = {};
  Blockly.Constants.Colour = {};
  Blockly.Constants.Colour.HUE = 20;
  Blockly.defineBlocksWithJsonArray([{
    type: "colour_picker",
    message0: "%1",
    args0: [{
      type: "field_colour",
      name: "COLOUR",
      colour: "#ff0000"
    }],
    output: "Colour",
    helpUrl: "%{BKY_COLOUR_PICKER_HELPURL}",
    style: "colour_blocks",
    tooltip: "%{BKY_COLOUR_PICKER_TOOLTIP}",
    extensions: ["parent_tooltip_when_inline"]
  }, {
    type: "colour_random",
    message0: "%{BKY_COLOUR_RANDOM_TITLE}",
    output: "Colour",
    helpUrl: "%{BKY_COLOUR_RANDOM_HELPURL}",
    style: "colour_blocks",
    tooltip: "%{BKY_COLOUR_RANDOM_TOOLTIP}"
  }, {
    type: "colour_rgb",
    message0: "%{BKY_COLOUR_RGB_TITLE} %{BKY_COLOUR_RGB_RED} %1 %{BKY_COLOUR_RGB_GREEN} %2 %{BKY_COLOUR_RGB_BLUE} %3",
    args0: [{
      type: "input_value",
      name: "RED",
      check: "Number",
      align: "RIGHT"
    }, {
      type: "input_value",
      name: "GREEN",
      check: "Number",
      align: "RIGHT"
    }, {
      type: "input_value",
      name: "BLUE",
      check: "Number",
      align: "RIGHT"
    }],
    output: "Colour",
    helpUrl: "%{BKY_COLOUR_RGB_HELPURL}",
    style: "colour_blocks",
    tooltip: "%{BKY_COLOUR_RGB_TOOLTIP}"
  }, {
    type: "colour_blend",
    message0: "%{BKY_COLOUR_BLEND_TITLE} %{BKY_COLOUR_BLEND_COLOUR1} %1 %{BKY_COLOUR_BLEND_COLOUR2} %2 %{BKY_COLOUR_BLEND_RATIO} %3",
    args0: [{
      type: "input_value",
      name: "COLOUR1",
      check: "Colour",
      align: "RIGHT"
    }, {
      type: "input_value",
      name: "COLOUR2",
      check: "Colour",
      align: "RIGHT"
    }, {
      type: "input_value",
      name: "RATIO",
      check: "Number",
      align: "RIGHT"
    }],
    output: "Colour",
    helpUrl: "%{BKY_COLOUR_BLEND_HELPURL}",
    style: "colour_blocks",
    tooltip: "%{BKY_COLOUR_BLEND_TOOLTIP}"
  }]);
  Blockly.Blocks.lists = {};
  Blockly.Constants.Lists = {};
  Blockly.Constants.Lists.HUE = 260;
  Blockly.defineBlocksWithJsonArray([{
    type: "lists_create_empty",
    message0: "%{BKY_LISTS_CREATE_EMPTY_TITLE}",
    output: "Array",
    style: "list_blocks",
    tooltip: "%{BKY_LISTS_CREATE_EMPTY_TOOLTIP}",
    helpUrl: "%{BKY_LISTS_CREATE_EMPTY_HELPURL}"
  }, {
    type: "lists_repeat",
    message0: "%{BKY_LISTS_REPEAT_TITLE}",
    args0: [{
      type: "input_value",
      name: "ITEM"
    }, {
      type: "input_value",
      name: "NUM",
      check: "Number"
    }],
    output: "Array",
    style: "list_blocks",
    tooltip: "%{BKY_LISTS_REPEAT_TOOLTIP}",
    helpUrl: "%{BKY_LISTS_REPEAT_HELPURL}"
  }, {
    type: "lists_reverse",
    message0: "%{BKY_LISTS_REVERSE_MESSAGE0}",
    args0: [{
      type: "input_value",
      name: "LIST",
      check: "Array"
    }],
    output: "Array",
    inputsInline: !0,
    style: "list_blocks",
    tooltip: "%{BKY_LISTS_REVERSE_TOOLTIP}",
    helpUrl: "%{BKY_LISTS_REVERSE_HELPURL}"
  }, {
    type: "lists_isEmpty",
    message0: "%{BKY_LISTS_ISEMPTY_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: ["String", "Array"]
    }],
    output: "Boolean",
    style: "list_blocks",
    tooltip: "%{BKY_LISTS_ISEMPTY_TOOLTIP}",
    helpUrl: "%{BKY_LISTS_ISEMPTY_HELPURL}"
  }, {
    type: "lists_length",
    message0: "%{BKY_LISTS_LENGTH_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: ["String", "Array"]
    }],
    output: "Number",
    style: "list_blocks",
    tooltip: "%{BKY_LISTS_LENGTH_TOOLTIP}",
    helpUrl: "%{BKY_LISTS_LENGTH_HELPURL}"
  }]);
  Blockly.Blocks.lists_create_with = {
    init: function init() {
      this.setHelpUrl(Blockly.Msg.LISTS_CREATE_WITH_HELPURL);
      this.setStyle("list_blocks");
      this.itemCount_ = 3;
      this.updateShape_();
      this.setOutput(!0, "Array");
      this.setMutator(new Blockly.Mutator(["lists_create_with_item"]));
      this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_TOOLTIP);
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("items", this.itemCount_);
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.itemCount_ = parseInt(a.getAttribute("items"), 10);
      this.updateShape_();
    },
    decompose: function decompose(a) {
      var b = a.newBlock("lists_create_with_container");
      b.initSvg();

      for (var c = b.getInput("STACK").connection, d = 0; d < this.itemCount_; d++) {
        var e = a.newBlock("lists_create_with_item");
        e.initSvg();
        c.connect(e.previousConnection);
        c = e.nextConnection;
      }

      return b;
    },
    compose: function compose(a) {
      var b = a.getInputTargetBlock("STACK");

      for (a = []; b && !b.isInsertionMarker();) {
        a.push(b.valueConnection_), b = b.nextConnection && b.nextConnection.targetBlock();
      }

      for (b = 0; b < this.itemCount_; b++) {
        var c = this.getInput("ADD" + b).connection.targetConnection;
        c && -1 == a.indexOf(c) && c.disconnect();
      }

      this.itemCount_ = a.length;
      this.updateShape_();

      for (b = 0; b < this.itemCount_; b++) {
        Blockly.Mutator.reconnect(a[b], this, "ADD" + b);
      }
    },
    saveConnections: function saveConnections(a) {
      a = a.getInputTargetBlock("STACK");

      for (var b = 0; a;) {
        var c = this.getInput("ADD" + b);
        a.valueConnection_ = c && c.connection.targetConnection;
        b++;
        a = a.nextConnection && a.nextConnection.targetBlock();
      }
    },
    updateShape_: function updateShape_() {
      this.itemCount_ && this.getInput("EMPTY") ? this.removeInput("EMPTY") : this.itemCount_ || this.getInput("EMPTY") || this.appendDummyInput("EMPTY").appendField(Blockly.Msg.LISTS_CREATE_EMPTY_TITLE);

      for (var a = 0; a < this.itemCount_; a++) {
        if (!this.getInput("ADD" + a)) {
          var b = this.appendValueInput("ADD" + a).setAlign(Blockly.ALIGN_RIGHT);
          0 == a && b.appendField(Blockly.Msg.LISTS_CREATE_WITH_INPUT_WITH);
        }
      }

      for (; this.getInput("ADD" + a);) {
        this.removeInput("ADD" + a), a++;
      }
    }
  };
  Blockly.Blocks.lists_create_with_container = {
    init: function init() {
      this.setStyle("list_blocks");
      this.appendDummyInput().appendField(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD);
      this.appendStatementInput("STACK");
      this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP);
      this.contextMenu = !1;
    }
  };
  Blockly.Blocks.lists_create_with_item = {
    init: function init() {
      this.setStyle("list_blocks");
      this.appendDummyInput().appendField(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TITLE);
      this.setPreviousStatement(!0);
      this.setNextStatement(!0);
      this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP);
      this.contextMenu = !1;
    }
  };
  Blockly.Blocks.lists_indexOf = {
    init: function init() {
      var a = [[Blockly.Msg.LISTS_INDEX_OF_FIRST, "FIRST"], [Blockly.Msg.LISTS_INDEX_OF_LAST, "LAST"]];
      this.setHelpUrl(Blockly.Msg.LISTS_INDEX_OF_HELPURL);
      this.setStyle("list_blocks");
      this.setOutput(!0, "Number");
      this.appendValueInput("VALUE").setCheck("Array").appendField(Blockly.Msg.LISTS_INDEX_OF_INPUT_IN_LIST);
      this.appendValueInput("FIND").appendField(new Blockly.FieldDropdown(a), "END");
      this.setInputsInline(!0);
      var b = this;
      this.setTooltip(function () {
        return Blockly.Msg.LISTS_INDEX_OF_TOOLTIP.replace("%1", b.workspace.options.oneBasedIndex ? "0" : "-1");
      });
    }
  };
  Blockly.Blocks.lists_getIndex = {
    init: function init() {
      var a = [[Blockly.Msg.LISTS_GET_INDEX_GET, "GET"], [Blockly.Msg.LISTS_GET_INDEX_GET_REMOVE, "GET_REMOVE"], [Blockly.Msg.LISTS_GET_INDEX_REMOVE, "REMOVE"]];
      this.WHERE_OPTIONS = [[Blockly.Msg.LISTS_GET_INDEX_FROM_START, "FROM_START"], [Blockly.Msg.LISTS_GET_INDEX_FROM_END, "FROM_END"], [Blockly.Msg.LISTS_GET_INDEX_FIRST, "FIRST"], [Blockly.Msg.LISTS_GET_INDEX_LAST, "LAST"], [Blockly.Msg.LISTS_GET_INDEX_RANDOM, "RANDOM"]];
      this.setHelpUrl(Blockly.Msg.LISTS_GET_INDEX_HELPURL);
      this.setStyle("list_blocks");
      a = new Blockly.FieldDropdown(a, function (c) {
        c = "REMOVE" == c;
        this.getSourceBlock().updateStatement_(c);
      });
      this.appendValueInput("VALUE").setCheck("Array").appendField(Blockly.Msg.LISTS_GET_INDEX_INPUT_IN_LIST);
      this.appendDummyInput().appendField(a, "MODE").appendField("", "SPACE");
      this.appendDummyInput("AT");
      Blockly.Msg.LISTS_GET_INDEX_TAIL && this.appendDummyInput("TAIL").appendField(Blockly.Msg.LISTS_GET_INDEX_TAIL);
      this.setInputsInline(!0);
      this.setOutput(!0);
      this.updateAt_(!0);
      var b = this;
      this.setTooltip(function () {
        var c = b.getFieldValue("MODE"),
            d = b.getFieldValue("WHERE"),
            e = "";

        switch (c + " " + d) {
          case "GET FROM_START":
          case "GET FROM_END":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM;
            break;

          case "GET FIRST":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FIRST;
            break;

          case "GET LAST":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_LAST;
            break;

          case "GET RANDOM":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM;
            break;

          case "GET_REMOVE FROM_START":
          case "GET_REMOVE FROM_END":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM;
            break;

          case "GET_REMOVE FIRST":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST;
            break;

          case "GET_REMOVE LAST":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST;
            break;

          case "GET_REMOVE RANDOM":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM;
            break;

          case "REMOVE FROM_START":
          case "REMOVE FROM_END":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM;
            break;

          case "REMOVE FIRST":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST;
            break;

          case "REMOVE LAST":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST;
            break;

          case "REMOVE RANDOM":
            e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM;
        }

        if ("FROM_START" == d || "FROM_END" == d) e += "  " + ("FROM_START" == d ? Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP : Blockly.Msg.LISTS_INDEX_FROM_END_TOOLTIP).replace("%1", b.workspace.options.oneBasedIndex ? "#1" : "#0");
        return e;
      });
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("statement", !this.outputConnection);
      var b = this.getInput("AT").type == Blockly.INPUT_VALUE;
      a.setAttribute("at", b);
      return a;
    },
    domToMutation: function domToMutation(a) {
      var b = "true" == a.getAttribute("statement");
      this.updateStatement_(b);
      a = "false" != a.getAttribute("at");
      this.updateAt_(a);
    },
    updateStatement_: function updateStatement_(a) {
      a != !this.outputConnection && (this.unplug(!0, !0), a ? (this.setOutput(!1), this.setPreviousStatement(!0), this.setNextStatement(!0)) : (this.setPreviousStatement(!1), this.setNextStatement(!1), this.setOutput(!0)));
    },
    updateAt_: function updateAt_(a) {
      this.removeInput("AT");
      this.removeInput("ORDINAL", !0);
      a ? (this.appendValueInput("AT").setCheck("Number"), Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT");
      var b = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function (c) {
        var d = "FROM_START" == c || "FROM_END" == c;

        if (d != a) {
          var e = this.getSourceBlock();
          e.updateAt_(d);
          e.setFieldValue(c, "WHERE");
          return null;
        }
      });
      this.getInput("AT").appendField(b, "WHERE");
      Blockly.Msg.LISTS_GET_INDEX_TAIL && this.moveInputBefore("TAIL", null);
    }
  };
  Blockly.Blocks.lists_setIndex = {
    init: function init() {
      var a = [[Blockly.Msg.LISTS_SET_INDEX_SET, "SET"], [Blockly.Msg.LISTS_SET_INDEX_INSERT, "INSERT"]];
      this.WHERE_OPTIONS = [[Blockly.Msg.LISTS_GET_INDEX_FROM_START, "FROM_START"], [Blockly.Msg.LISTS_GET_INDEX_FROM_END, "FROM_END"], [Blockly.Msg.LISTS_GET_INDEX_FIRST, "FIRST"], [Blockly.Msg.LISTS_GET_INDEX_LAST, "LAST"], [Blockly.Msg.LISTS_GET_INDEX_RANDOM, "RANDOM"]];
      this.setHelpUrl(Blockly.Msg.LISTS_SET_INDEX_HELPURL);
      this.setStyle("list_blocks");
      this.appendValueInput("LIST").setCheck("Array").appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_IN_LIST);
      this.appendDummyInput().appendField(new Blockly.FieldDropdown(a), "MODE").appendField("", "SPACE");
      this.appendDummyInput("AT");
      this.appendValueInput("TO").appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_TO);
      this.setInputsInline(!0);
      this.setPreviousStatement(!0);
      this.setNextStatement(!0);
      this.setTooltip(Blockly.Msg.LISTS_SET_INDEX_TOOLTIP);
      this.updateAt_(!0);
      var b = this;
      this.setTooltip(function () {
        var c = b.getFieldValue("MODE"),
            d = b.getFieldValue("WHERE"),
            e = "";

        switch (c + " " + d) {
          case "SET FROM_START":
          case "SET FROM_END":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FROM;
            break;

          case "SET FIRST":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FIRST;
            break;

          case "SET LAST":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_LAST;
            break;

          case "SET RANDOM":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_RANDOM;
            break;

          case "INSERT FROM_START":
          case "INSERT FROM_END":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FROM;
            break;

          case "INSERT FIRST":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST;
            break;

          case "INSERT LAST":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_LAST;
            break;

          case "INSERT RANDOM":
            e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM;
        }

        if ("FROM_START" == d || "FROM_END" == d) e += "  " + Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP.replace("%1", b.workspace.options.oneBasedIndex ? "#1" : "#0");
        return e;
      });
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation"),
          b = this.getInput("AT").type == Blockly.INPUT_VALUE;
      a.setAttribute("at", b);
      return a;
    },
    domToMutation: function domToMutation(a) {
      a = "false" != a.getAttribute("at");
      this.updateAt_(a);
    },
    updateAt_: function updateAt_(a) {
      this.removeInput("AT");
      this.removeInput("ORDINAL", !0);
      a ? (this.appendValueInput("AT").setCheck("Number"), Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT");
      var b = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function (c) {
        var d = "FROM_START" == c || "FROM_END" == c;

        if (d != a) {
          var e = this.getSourceBlock();
          e.updateAt_(d);
          e.setFieldValue(c, "WHERE");
          return null;
        }
      });
      this.moveInputBefore("AT", "TO");
      this.getInput("ORDINAL") && this.moveInputBefore("ORDINAL", "TO");
      this.getInput("AT").appendField(b, "WHERE");
    }
  };
  Blockly.Blocks.lists_getSublist = {
    init: function init() {
      this.WHERE_OPTIONS_1 = [[Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_START, "FROM_START"], [Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_END, "FROM_END"], [Blockly.Msg.LISTS_GET_SUBLIST_START_FIRST, "FIRST"]];
      this.WHERE_OPTIONS_2 = [[Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_START, "FROM_START"], [Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_END, "FROM_END"], [Blockly.Msg.LISTS_GET_SUBLIST_END_LAST, "LAST"]];
      this.setHelpUrl(Blockly.Msg.LISTS_GET_SUBLIST_HELPURL);
      this.setStyle("list_blocks");
      this.appendValueInput("LIST").setCheck("Array").appendField(Blockly.Msg.LISTS_GET_SUBLIST_INPUT_IN_LIST);
      this.appendDummyInput("AT1");
      this.appendDummyInput("AT2");
      Blockly.Msg.LISTS_GET_SUBLIST_TAIL && this.appendDummyInput("TAIL").appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL);
      this.setInputsInline(!0);
      this.setOutput(!0, "Array");
      this.updateAt_(1, !0);
      this.updateAt_(2, !0);
      this.setTooltip(Blockly.Msg.LISTS_GET_SUBLIST_TOOLTIP);
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation"),
          b = this.getInput("AT1").type == Blockly.INPUT_VALUE;
      a.setAttribute("at1", b);
      b = this.getInput("AT2").type == Blockly.INPUT_VALUE;
      a.setAttribute("at2", b);
      return a;
    },
    domToMutation: function domToMutation(a) {
      var b = "true" == a.getAttribute("at1");
      a = "true" == a.getAttribute("at2");
      this.updateAt_(1, b);
      this.updateAt_(2, a);
    },
    updateAt_: function updateAt_(a, b) {
      this.removeInput("AT" + a);
      this.removeInput("ORDINAL" + a, !0);
      b ? (this.appendValueInput("AT" + a).setCheck("Number"), Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL" + a).appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT" + a);
      var c = new Blockly.FieldDropdown(this["WHERE_OPTIONS_" + a], function (d) {
        var e = "FROM_START" == d || "FROM_END" == d;

        if (e != b) {
          var f = this.getSourceBlock();
          f.updateAt_(a, e);
          f.setFieldValue(d, "WHERE" + a);
          return null;
        }
      });
      this.getInput("AT" + a).appendField(c, "WHERE" + a);
      1 == a && (this.moveInputBefore("AT1", "AT2"), this.getInput("ORDINAL1") && this.moveInputBefore("ORDINAL1", "AT2"));
      Blockly.Msg.LISTS_GET_SUBLIST_TAIL && this.moveInputBefore("TAIL", null);
    }
  };
  Blockly.Blocks.lists_sort = {
    init: function init() {
      this.jsonInit({
        message0: Blockly.Msg.LISTS_SORT_TITLE,
        args0: [{
          type: "field_dropdown",
          name: "TYPE",
          options: [[Blockly.Msg.LISTS_SORT_TYPE_NUMERIC, "NUMERIC"], [Blockly.Msg.LISTS_SORT_TYPE_TEXT, "TEXT"], [Blockly.Msg.LISTS_SORT_TYPE_IGNORECASE, "IGNORE_CASE"]]
        }, {
          type: "field_dropdown",
          name: "DIRECTION",
          options: [[Blockly.Msg.LISTS_SORT_ORDER_ASCENDING, "1"], [Blockly.Msg.LISTS_SORT_ORDER_DESCENDING, "-1"]]
        }, {
          type: "input_value",
          name: "LIST",
          check: "Array"
        }],
        output: "Array",
        style: "list_blocks",
        tooltip: Blockly.Msg.LISTS_SORT_TOOLTIP,
        helpUrl: Blockly.Msg.LISTS_SORT_HELPURL
      });
    }
  };
  Blockly.Blocks.lists_split = {
    init: function init() {
      var a = this,
          b = new Blockly.FieldDropdown([[Blockly.Msg.LISTS_SPLIT_LIST_FROM_TEXT, "SPLIT"], [Blockly.Msg.LISTS_SPLIT_TEXT_FROM_LIST, "JOIN"]], function (c) {
        a.updateType_(c);
      });
      this.setHelpUrl(Blockly.Msg.LISTS_SPLIT_HELPURL);
      this.setStyle("list_blocks");
      this.appendValueInput("INPUT").setCheck("String").appendField(b, "MODE");
      this.appendValueInput("DELIM").setCheck("String").appendField(Blockly.Msg.LISTS_SPLIT_WITH_DELIMITER);
      this.setInputsInline(!0);
      this.setOutput(!0, "Array");
      this.setTooltip(function () {
        var c = a.getFieldValue("MODE");
        if ("SPLIT" == c) return Blockly.Msg.LISTS_SPLIT_TOOLTIP_SPLIT;
        if ("JOIN" == c) return Blockly.Msg.LISTS_SPLIT_TOOLTIP_JOIN;
        throw Error("Unknown mode: " + c);
      });
    },
    updateType_: function updateType_(a) {
      if (this.getFieldValue("MODE") != a) {
        var b = this.getInput("INPUT").connection;
        b.setShadowDom(null);
        var c = b.targetBlock();
        c && (b.disconnect(), c.isShadow() ? c.dispose() : this.bumpNeighbours());
      }

      "SPLIT" == a ? (this.outputConnection.setCheck("Array"), this.getInput("INPUT").setCheck("String")) : (this.outputConnection.setCheck("String"), this.getInput("INPUT").setCheck("Array"));
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("mode", this.getFieldValue("MODE"));
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.updateType_(a.getAttribute("mode"));
    }
  };
  Blockly.Blocks.logic = {};
  Blockly.Constants.Logic = {};
  Blockly.Constants.Logic.HUE = 210;
  Blockly.defineBlocksWithJsonArray([{
    type: "logic_boolean",
    message0: "%1",
    args0: [{
      type: "field_dropdown",
      name: "BOOL",
      options: [["%{BKY_LOGIC_BOOLEAN_TRUE}", "TRUE"], ["%{BKY_LOGIC_BOOLEAN_FALSE}", "FALSE"]]
    }],
    output: "Boolean",
    style: "logic_blocks",
    tooltip: "%{BKY_LOGIC_BOOLEAN_TOOLTIP}",
    helpUrl: "%{BKY_LOGIC_BOOLEAN_HELPURL}"
  }, {
    type: "controls_if",
    message0: "%{BKY_CONTROLS_IF_MSG_IF} %1",
    args0: [{
      type: "input_value",
      name: "IF0",
      check: "Boolean"
    }],
    message1: "%{BKY_CONTROLS_IF_MSG_THEN} %1",
    args1: [{
      type: "input_statement",
      name: "DO0"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "logic_blocks",
    helpUrl: "%{BKY_CONTROLS_IF_HELPURL}",
    mutator: "controls_if_mutator",
    extensions: ["controls_if_tooltip"]
  }, {
    type: "controls_ifelse",
    message0: "%{BKY_CONTROLS_IF_MSG_IF} %1",
    args0: [{
      type: "input_value",
      name: "IF0",
      check: "Boolean"
    }],
    message1: "%{BKY_CONTROLS_IF_MSG_THEN} %1",
    args1: [{
      type: "input_statement",
      name: "DO0"
    }],
    message2: "%{BKY_CONTROLS_IF_MSG_ELSE} %1",
    args2: [{
      type: "input_statement",
      name: "ELSE"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "logic_blocks",
    tooltip: "%{BKYCONTROLS_IF_TOOLTIP_2}",
    helpUrl: "%{BKY_CONTROLS_IF_HELPURL}",
    extensions: ["controls_if_tooltip"]
  }, {
    type: "logic_compare",
    message0: "%1 %2 %3",
    args0: [{
      type: "input_value",
      name: "A"
    }, {
      type: "field_dropdown",
      name: "OP",
      options: [["=", "EQ"], ["\u2260", "NEQ"], ["\u200F<", "LT"], ["\u200F\u2264", "LTE"], ["\u200F>", "GT"], ["\u200F\u2265", "GTE"]]
    }, {
      type: "input_value",
      name: "B"
    }],
    inputsInline: !0,
    output: "Boolean",
    style: "logic_blocks",
    helpUrl: "%{BKY_LOGIC_COMPARE_HELPURL}",
    extensions: ["logic_compare", "logic_op_tooltip"]
  }, {
    type: "logic_operation",
    message0: "%1 %2 %3",
    args0: [{
      type: "input_value",
      name: "A",
      check: "Boolean"
    }, {
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_LOGIC_OPERATION_AND}", "AND"], ["%{BKY_LOGIC_OPERATION_OR}", "OR"]]
    }, {
      type: "input_value",
      name: "B",
      check: "Boolean"
    }],
    inputsInline: !0,
    output: "Boolean",
    style: "logic_blocks",
    helpUrl: "%{BKY_LOGIC_OPERATION_HELPURL}",
    extensions: ["logic_op_tooltip"]
  }, {
    type: "logic_negate",
    message0: "%{BKY_LOGIC_NEGATE_TITLE}",
    args0: [{
      type: "input_value",
      name: "BOOL",
      check: "Boolean"
    }],
    output: "Boolean",
    style: "logic_blocks",
    tooltip: "%{BKY_LOGIC_NEGATE_TOOLTIP}",
    helpUrl: "%{BKY_LOGIC_NEGATE_HELPURL}"
  }, {
    type: "logic_null",
    message0: "%{BKY_LOGIC_NULL}",
    output: null,
    style: "logic_blocks",
    tooltip: "%{BKY_LOGIC_NULL_TOOLTIP}",
    helpUrl: "%{BKY_LOGIC_NULL_HELPURL}"
  }, {
    type: "logic_ternary",
    message0: "%{BKY_LOGIC_TERNARY_CONDITION} %1",
    args0: [{
      type: "input_value",
      name: "IF",
      check: "Boolean"
    }],
    message1: "%{BKY_LOGIC_TERNARY_IF_TRUE} %1",
    args1: [{
      type: "input_value",
      name: "THEN"
    }],
    message2: "%{BKY_LOGIC_TERNARY_IF_FALSE} %1",
    args2: [{
      type: "input_value",
      name: "ELSE"
    }],
    output: null,
    style: "logic_blocks",
    tooltip: "%{BKY_LOGIC_TERNARY_TOOLTIP}",
    helpUrl: "%{BKY_LOGIC_TERNARY_HELPURL}",
    extensions: ["logic_ternary"]
  }]);
  Blockly.defineBlocksWithJsonArray([{
    type: "controls_if_if",
    message0: "%{BKY_CONTROLS_IF_IF_TITLE_IF}",
    nextStatement: null,
    enableContextMenu: !1,
    style: "logic_blocks",
    tooltip: "%{BKY_CONTROLS_IF_IF_TOOLTIP}"
  }, {
    type: "controls_if_elseif",
    message0: "%{BKY_CONTROLS_IF_ELSEIF_TITLE_ELSEIF}",
    previousStatement: null,
    nextStatement: null,
    enableContextMenu: !1,
    style: "logic_blocks",
    tooltip: "%{BKY_CONTROLS_IF_ELSEIF_TOOLTIP}"
  }, {
    type: "controls_if_else",
    message0: "%{BKY_CONTROLS_IF_ELSE_TITLE_ELSE}",
    previousStatement: null,
    enableContextMenu: !1,
    style: "logic_blocks",
    tooltip: "%{BKY_CONTROLS_IF_ELSE_TOOLTIP}"
  }]);
  Blockly.Constants.Logic.TOOLTIPS_BY_OP = {
    EQ: "%{BKY_LOGIC_COMPARE_TOOLTIP_EQ}",
    NEQ: "%{BKY_LOGIC_COMPARE_TOOLTIP_NEQ}",
    LT: "%{BKY_LOGIC_COMPARE_TOOLTIP_LT}",
    LTE: "%{BKY_LOGIC_COMPARE_TOOLTIP_LTE}",
    GT: "%{BKY_LOGIC_COMPARE_TOOLTIP_GT}",
    GTE: "%{BKY_LOGIC_COMPARE_TOOLTIP_GTE}",
    AND: "%{BKY_LOGIC_OPERATION_TOOLTIP_AND}",
    OR: "%{BKY_LOGIC_OPERATION_TOOLTIP_OR}"
  };
  Blockly.Extensions.register("logic_op_tooltip", Blockly.Extensions.buildTooltipForDropdown("OP", Blockly.Constants.Logic.TOOLTIPS_BY_OP));
  Blockly.Constants.Logic.CONTROLS_IF_MUTATOR_MIXIN = {
    elseifCount_: 0,
    elseCount_: 0,
    suppressPrefixSuffix: !0,
    mutationToDom: function mutationToDom() {
      if (!this.elseifCount_ && !this.elseCount_) return null;
      var a = Blockly.utils.xml.createElement("mutation");
      this.elseifCount_ && a.setAttribute("elseif", this.elseifCount_);
      this.elseCount_ && a.setAttribute("else", 1);
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.elseifCount_ = parseInt(a.getAttribute("elseif"), 10) || 0;
      this.elseCount_ = parseInt(a.getAttribute("else"), 10) || 0;
      this.rebuildShape_();
    },
    decompose: function decompose(a) {
      var b = a.newBlock("controls_if_if");
      b.initSvg();

      for (var c = b.nextConnection, d = 1; d <= this.elseifCount_; d++) {
        var e = a.newBlock("controls_if_elseif");
        e.initSvg();
        c.connect(e.previousConnection);
        c = e.nextConnection;
      }

      this.elseCount_ && (a = a.newBlock("controls_if_else"), a.initSvg(), c.connect(a.previousConnection));
      return b;
    },
    compose: function compose(a) {
      a = a.nextConnection.targetBlock();
      this.elseCount_ = this.elseifCount_ = 0;

      for (var b = [null], c = [null], d = null; a && !a.isInsertionMarker();) {
        switch (a.type) {
          case "controls_if_elseif":
            this.elseifCount_++;
            b.push(a.valueConnection_);
            c.push(a.statementConnection_);
            break;

          case "controls_if_else":
            this.elseCount_++;
            d = a.statementConnection_;
            break;

          default:
            throw TypeError("Unknown block type: " + a.type);
        }

        a = a.nextConnection && a.nextConnection.targetBlock();
      }

      this.updateShape_();
      this.reconnectChildBlocks_(b, c, d);
    },
    saveConnections: function saveConnections(a) {
      a = a.nextConnection.targetBlock();

      for (var b = 1; a;) {
        switch (a.type) {
          case "controls_if_elseif":
            var c = this.getInput("IF" + b),
                d = this.getInput("DO" + b);
            a.valueConnection_ = c && c.connection.targetConnection;
            a.statementConnection_ = d && d.connection.targetConnection;
            b++;
            break;

          case "controls_if_else":
            d = this.getInput("ELSE");
            a.statementConnection_ = d && d.connection.targetConnection;
            break;

          default:
            throw TypeError("Unknown block type: " + a.type);
        }

        a = a.nextConnection && a.nextConnection.targetBlock();
      }
    },
    rebuildShape_: function rebuildShape_() {
      var a = [null],
          b = [null],
          c = null;
      this.getInput("ELSE") && (c = this.getInput("ELSE").connection.targetConnection);

      for (var d = 1; this.getInput("IF" + d);) {
        var e = this.getInput("IF" + d),
            f = this.getInput("DO" + d);
        a.push(e.connection.targetConnection);
        b.push(f.connection.targetConnection);
        d++;
      }

      this.updateShape_();
      this.reconnectChildBlocks_(a, b, c);
    },
    updateShape_: function updateShape_() {
      this.getInput("ELSE") && this.removeInput("ELSE");

      for (var a = 1; this.getInput("IF" + a);) {
        this.removeInput("IF" + a), this.removeInput("DO" + a), a++;
      }

      for (a = 1; a <= this.elseifCount_; a++) {
        this.appendValueInput("IF" + a).setCheck("Boolean").appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSEIF), this.appendStatementInput("DO" + a).appendField(Blockly.Msg.CONTROLS_IF_MSG_THEN);
      }

      this.elseCount_ && this.appendStatementInput("ELSE").appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSE);
    },
    reconnectChildBlocks_: function reconnectChildBlocks_(a, b, c) {
      for (var d = 1; d <= this.elseifCount_; d++) {
        Blockly.Mutator.reconnect(a[d], this, "IF" + d), Blockly.Mutator.reconnect(b[d], this, "DO" + d);
      }

      Blockly.Mutator.reconnect(c, this, "ELSE");
    }
  };
  Blockly.Extensions.registerMutator("controls_if_mutator", Blockly.Constants.Logic.CONTROLS_IF_MUTATOR_MIXIN, null, ["controls_if_elseif", "controls_if_else"]);

  Blockly.Constants.Logic.CONTROLS_IF_TOOLTIP_EXTENSION = function () {
    this.setTooltip(function () {
      if (this.elseifCount_ || this.elseCount_) {
        if (!this.elseifCount_ && this.elseCount_) return Blockly.Msg.CONTROLS_IF_TOOLTIP_2;
        if (this.elseifCount_ && !this.elseCount_) return Blockly.Msg.CONTROLS_IF_TOOLTIP_3;
        if (this.elseifCount_ && this.elseCount_) return Blockly.Msg.CONTROLS_IF_TOOLTIP_4;
      } else return Blockly.Msg.CONTROLS_IF_TOOLTIP_1;

      return "";
    }.bind(this));
  };

  Blockly.Extensions.register("controls_if_tooltip", Blockly.Constants.Logic.CONTROLS_IF_TOOLTIP_EXTENSION);
  Blockly.Constants.Logic.LOGIC_COMPARE_ONCHANGE_MIXIN = {
    onchange: function onchange(a) {
      this.prevBlocks_ || (this.prevBlocks_ = [null, null]);
      var b = this.getInputTargetBlock("A"),
          c = this.getInputTargetBlock("B");
      b && c && !this.workspace.connectionChecker.doTypeChecks(b.outputConnection, c.outputConnection) && (Blockly.Events.setGroup(a.group), a = this.prevBlocks_[0], a !== b && (b.unplug(), !a || a.isDisposed() || a.isShadow() || this.getInput("A").connection.connect(a.outputConnection)), b = this.prevBlocks_[1], b !== c && (c.unplug(), !b || b.isDisposed() || b.isShadow() || this.getInput("B").connection.connect(b.outputConnection)), this.bumpNeighbours(), Blockly.Events.setGroup(!1));
      this.prevBlocks_[0] = this.getInputTargetBlock("A");
      this.prevBlocks_[1] = this.getInputTargetBlock("B");
    }
  };

  Blockly.Constants.Logic.LOGIC_COMPARE_EXTENSION = function () {
    this.mixin(Blockly.Constants.Logic.LOGIC_COMPARE_ONCHANGE_MIXIN);
  };

  Blockly.Extensions.register("logic_compare", Blockly.Constants.Logic.LOGIC_COMPARE_EXTENSION);
  Blockly.Constants.Logic.LOGIC_TERNARY_ONCHANGE_MIXIN = {
    prevParentConnection_: null,
    onchange: function onchange(a) {
      var b = this.getInputTargetBlock("THEN"),
          c = this.getInputTargetBlock("ELSE"),
          d = this.outputConnection.targetConnection;
      if ((b || c) && d) for (var e = 0; 2 > e; e++) {
        var f = 1 == e ? b : c;
        f && !f.workspace.connectionChecker.doTypeChecks(f.outputConnection, d) && (Blockly.Events.setGroup(a.group), d === this.prevParentConnection_ ? (this.unplug(), d.getSourceBlock().bumpNeighbours()) : (f.unplug(), f.bumpNeighbours()), Blockly.Events.setGroup(!1));
      }
      this.prevParentConnection_ = d;
    }
  };
  Blockly.Extensions.registerMixin("logic_ternary", Blockly.Constants.Logic.LOGIC_TERNARY_ONCHANGE_MIXIN);
  Blockly.Blocks.loops = {};
  Blockly.Constants.Loops = {};
  Blockly.Constants.Loops.HUE = 120;
  Blockly.defineBlocksWithJsonArray([{
    type: "controls_repeat_ext",
    message0: "%{BKY_CONTROLS_REPEAT_TITLE}",
    args0: [{
      type: "input_value",
      name: "TIMES",
      check: "Number"
    }],
    message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
    args1: [{
      type: "input_statement",
      name: "DO"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "loop_blocks",
    tooltip: "%{BKY_CONTROLS_REPEAT_TOOLTIP}",
    helpUrl: "%{BKY_CONTROLS_REPEAT_HELPURL}"
  }, {
    type: "controls_repeat",
    message0: "%{BKY_CONTROLS_REPEAT_TITLE}",
    args0: [{
      type: "field_number",
      name: "TIMES",
      value: 10,
      min: 0,
      precision: 1
    }],
    message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
    args1: [{
      type: "input_statement",
      name: "DO"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "loop_blocks",
    tooltip: "%{BKY_CONTROLS_REPEAT_TOOLTIP}",
    helpUrl: "%{BKY_CONTROLS_REPEAT_HELPURL}"
  }, {
    type: "controls_whileUntil",
    message0: "%1 %2",
    args0: [{
      type: "field_dropdown",
      name: "MODE",
      options: [["%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_WHILE}", "WHILE"], ["%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL}", "UNTIL"]]
    }, {
      type: "input_value",
      name: "BOOL",
      check: "Boolean"
    }],
    message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
    args1: [{
      type: "input_statement",
      name: "DO"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "loop_blocks",
    helpUrl: "%{BKY_CONTROLS_WHILEUNTIL_HELPURL}",
    extensions: ["controls_whileUntil_tooltip"]
  }, {
    type: "controls_for",
    message0: "%{BKY_CONTROLS_FOR_TITLE}",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: null
    }, {
      type: "input_value",
      name: "FROM",
      check: "Number",
      align: "RIGHT"
    }, {
      type: "input_value",
      name: "TO",
      check: "Number",
      align: "RIGHT"
    }, {
      type: "input_value",
      name: "BY",
      check: "Number",
      align: "RIGHT"
    }],
    message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
    args1: [{
      type: "input_statement",
      name: "DO"
    }],
    inputsInline: !0,
    previousStatement: null,
    nextStatement: null,
    style: "loop_blocks",
    helpUrl: "%{BKY_CONTROLS_FOR_HELPURL}",
    extensions: ["contextMenu_newGetVariableBlock", "controls_for_tooltip"]
  }, {
    type: "controls_forEach",
    message0: "%{BKY_CONTROLS_FOREACH_TITLE}",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: null
    }, {
      type: "input_value",
      name: "LIST",
      check: "Array"
    }],
    message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
    args1: [{
      type: "input_statement",
      name: "DO"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "loop_blocks",
    helpUrl: "%{BKY_CONTROLS_FOREACH_HELPURL}",
    extensions: ["contextMenu_newGetVariableBlock", "controls_forEach_tooltip"]
  }, {
    type: "controls_flow_statements",
    message0: "%1",
    args0: [{
      type: "field_dropdown",
      name: "FLOW",
      options: [["%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK}", "BREAK"], ["%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE}", "CONTINUE"]]
    }],
    previousStatement: null,
    style: "loop_blocks",
    helpUrl: "%{BKY_CONTROLS_FLOW_STATEMENTS_HELPURL}",
    extensions: ["controls_flow_tooltip", "controls_flow_in_loop_check"]
  }]);
  Blockly.Constants.Loops.WHILE_UNTIL_TOOLTIPS = {
    WHILE: "%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_WHILE}",
    UNTIL: "%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL}"
  };
  Blockly.Extensions.register("controls_whileUntil_tooltip", Blockly.Extensions.buildTooltipForDropdown("MODE", Blockly.Constants.Loops.WHILE_UNTIL_TOOLTIPS));
  Blockly.Constants.Loops.BREAK_CONTINUE_TOOLTIPS = {
    BREAK: "%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK}",
    CONTINUE: "%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE}"
  };
  Blockly.Extensions.register("controls_flow_tooltip", Blockly.Extensions.buildTooltipForDropdown("FLOW", Blockly.Constants.Loops.BREAK_CONTINUE_TOOLTIPS));
  Blockly.Constants.Loops.CUSTOM_CONTEXT_MENU_CREATE_VARIABLES_GET_MIXIN = {
    customContextMenu: function customContextMenu(a) {
      if (!this.isInFlyout) {
        var b = this.getField("VAR").getVariable(),
            c = b.name;

        if (!this.isCollapsed() && null != c) {
          var d = {
            enabled: !0
          };
          d.text = Blockly.Msg.VARIABLES_SET_CREATE_GET.replace("%1", c);
          b = Blockly.Variables.generateVariableFieldDom(b);
          c = Blockly.utils.xml.createElement("block");
          c.setAttribute("type", "variables_get");
          c.appendChild(b);
          d.callback = Blockly.ContextMenu.callbackFactory(this, c);
          a.push(d);
        }
      }
    }
  };
  Blockly.Extensions.registerMixin("contextMenu_newGetVariableBlock", Blockly.Constants.Loops.CUSTOM_CONTEXT_MENU_CREATE_VARIABLES_GET_MIXIN);
  Blockly.Extensions.register("controls_for_tooltip", Blockly.Extensions.buildTooltipWithFieldText("%{BKY_CONTROLS_FOR_TOOLTIP}", "VAR"));
  Blockly.Extensions.register("controls_forEach_tooltip", Blockly.Extensions.buildTooltipWithFieldText("%{BKY_CONTROLS_FOREACH_TOOLTIP}", "VAR"));
  Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN = {
    LOOP_TYPES: ["controls_repeat", "controls_repeat_ext", "controls_forEach", "controls_for", "controls_whileUntil"],
    suppressPrefixSuffix: !0,
    getSurroundLoop: function getSurroundLoop(a) {
      do {
        if (-1 != Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.LOOP_TYPES.indexOf(a.type)) return a;
        a = a.getSurroundParent();
      } while (a);

      return null;
    },
    onchange: function onchange(a) {
      if (this.workspace.isDragging && !this.workspace.isDragging() && a.type == Blockly.Events.BLOCK_MOVE) {
        var b = Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(this);
        this.setWarningText(b ? null : Blockly.Msg.CONTROLS_FLOW_STATEMENTS_WARNING);

        if (!this.isInFlyout) {
          var c = Blockly.Events.getGroup();
          Blockly.Events.setGroup(a.group);
          this.setEnabled(b);
          Blockly.Events.setGroup(c);
        }
      }
    }
  };
  Blockly.Extensions.registerMixin("controls_flow_in_loop_check", Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN);
  Blockly.Blocks.math = {};
  Blockly.Constants.Math = {};
  Blockly.Constants.Math.HUE = 230;
  Blockly.defineBlocksWithJsonArray([{
    type: "math_number",
    message0: "%1",
    args0: [{
      type: "field_number",
      name: "NUM",
      value: 0
    }],
    output: "Number",
    helpUrl: "%{BKY_MATH_NUMBER_HELPURL}",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_NUMBER_TOOLTIP}",
    extensions: ["parent_tooltip_when_inline"]
  }, {
    type: "math_arithmetic",
    message0: "%1 %2 %3",
    args0: [{
      type: "input_value",
      name: "A",
      check: "Number"
    }, {
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_MATH_ADDITION_SYMBOL}", "ADD"], ["%{BKY_MATH_SUBTRACTION_SYMBOL}", "MINUS"], ["%{BKY_MATH_MULTIPLICATION_SYMBOL}", "MULTIPLY"], ["%{BKY_MATH_DIVISION_SYMBOL}", "DIVIDE"], ["%{BKY_MATH_POWER_SYMBOL}", "POWER"]]
    }, {
      type: "input_value",
      name: "B",
      check: "Number"
    }],
    inputsInline: !0,
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_ARITHMETIC_HELPURL}",
    extensions: ["math_op_tooltip"]
  }, {
    type: "math_single",
    message0: "%1 %2",
    args0: [{
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_MATH_SINGLE_OP_ROOT}", "ROOT"], ["%{BKY_MATH_SINGLE_OP_ABSOLUTE}", "ABS"], ["-", "NEG"], ["ln", "LN"], ["log10", "LOG10"], ["e^", "EXP"], ["10^", "POW10"]]
    }, {
      type: "input_value",
      name: "NUM",
      check: "Number"
    }],
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_SINGLE_HELPURL}",
    extensions: ["math_op_tooltip"]
  }, {
    type: "math_trig",
    message0: "%1 %2",
    args0: [{
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_MATH_TRIG_SIN}", "SIN"], ["%{BKY_MATH_TRIG_COS}", "COS"], ["%{BKY_MATH_TRIG_TAN}", "TAN"], ["%{BKY_MATH_TRIG_ASIN}", "ASIN"], ["%{BKY_MATH_TRIG_ACOS}", "ACOS"], ["%{BKY_MATH_TRIG_ATAN}", "ATAN"]]
    }, {
      type: "input_value",
      name: "NUM",
      check: "Number"
    }],
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_TRIG_HELPURL}",
    extensions: ["math_op_tooltip"]
  }, {
    type: "math_constant",
    message0: "%1",
    args0: [{
      type: "field_dropdown",
      name: "CONSTANT",
      options: [["\u03C0", "PI"], ["e", "E"], ["\u03C6", "GOLDEN_RATIO"], ["sqrt(2)", "SQRT2"], ["sqrt(\xBD)", "SQRT1_2"], ["\u221E", "INFINITY"]]
    }],
    output: "Number",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_CONSTANT_TOOLTIP}",
    helpUrl: "%{BKY_MATH_CONSTANT_HELPURL}"
  }, {
    type: "math_number_property",
    message0: "%1 %2",
    args0: [{
      type: "input_value",
      name: "NUMBER_TO_CHECK",
      check: "Number"
    }, {
      type: "field_dropdown",
      name: "PROPERTY",
      options: [["%{BKY_MATH_IS_EVEN}", "EVEN"], ["%{BKY_MATH_IS_ODD}", "ODD"], ["%{BKY_MATH_IS_PRIME}", "PRIME"], ["%{BKY_MATH_IS_WHOLE}", "WHOLE"], ["%{BKY_MATH_IS_POSITIVE}", "POSITIVE"], ["%{BKY_MATH_IS_NEGATIVE}", "NEGATIVE"], ["%{BKY_MATH_IS_DIVISIBLE_BY}", "DIVISIBLE_BY"]]
    }],
    inputsInline: !0,
    output: "Boolean",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_IS_TOOLTIP}",
    mutator: "math_is_divisibleby_mutator"
  }, {
    type: "math_change",
    message0: "%{BKY_MATH_CHANGE_TITLE}",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: "%{BKY_MATH_CHANGE_TITLE_ITEM}"
    }, {
      type: "input_value",
      name: "DELTA",
      check: "Number"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "variable_blocks",
    helpUrl: "%{BKY_MATH_CHANGE_HELPURL}",
    extensions: ["math_change_tooltip"]
  }, {
    type: "math_round",
    message0: "%1 %2",
    args0: [{
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_MATH_ROUND_OPERATOR_ROUND}", "ROUND"], ["%{BKY_MATH_ROUND_OPERATOR_ROUNDUP}", "ROUNDUP"], ["%{BKY_MATH_ROUND_OPERATOR_ROUNDDOWN}", "ROUNDDOWN"]]
    }, {
      type: "input_value",
      name: "NUM",
      check: "Number"
    }],
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_ROUND_HELPURL}",
    tooltip: "%{BKY_MATH_ROUND_TOOLTIP}"
  }, {
    type: "math_on_list",
    message0: "%1 %2",
    args0: [{
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_MATH_ONLIST_OPERATOR_SUM}", "SUM"], ["%{BKY_MATH_ONLIST_OPERATOR_MIN}", "MIN"], ["%{BKY_MATH_ONLIST_OPERATOR_MAX}", "MAX"], ["%{BKY_MATH_ONLIST_OPERATOR_AVERAGE}", "AVERAGE"], ["%{BKY_MATH_ONLIST_OPERATOR_MEDIAN}", "MEDIAN"], ["%{BKY_MATH_ONLIST_OPERATOR_MODE}", "MODE"], ["%{BKY_MATH_ONLIST_OPERATOR_STD_DEV}", "STD_DEV"], ["%{BKY_MATH_ONLIST_OPERATOR_RANDOM}", "RANDOM"]]
    }, {
      type: "input_value",
      name: "LIST",
      check: "Array"
    }],
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_ONLIST_HELPURL}",
    mutator: "math_modes_of_list_mutator",
    extensions: ["math_op_tooltip"]
  }, {
    type: "math_modulo",
    message0: "%{BKY_MATH_MODULO_TITLE}",
    args0: [{
      type: "input_value",
      name: "DIVIDEND",
      check: "Number"
    }, {
      type: "input_value",
      name: "DIVISOR",
      check: "Number"
    }],
    inputsInline: !0,
    output: "Number",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_MODULO_TOOLTIP}",
    helpUrl: "%{BKY_MATH_MODULO_HELPURL}"
  }, {
    type: "math_constrain",
    message0: "%{BKY_MATH_CONSTRAIN_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: "Number"
    }, {
      type: "input_value",
      name: "LOW",
      check: "Number"
    }, {
      type: "input_value",
      name: "HIGH",
      check: "Number"
    }],
    inputsInline: !0,
    output: "Number",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_CONSTRAIN_TOOLTIP}",
    helpUrl: "%{BKY_MATH_CONSTRAIN_HELPURL}"
  }, {
    type: "math_random_int",
    message0: "%{BKY_MATH_RANDOM_INT_TITLE}",
    args0: [{
      type: "input_value",
      name: "FROM",
      check: "Number"
    }, {
      type: "input_value",
      name: "TO",
      check: "Number"
    }],
    inputsInline: !0,
    output: "Number",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_RANDOM_INT_TOOLTIP}",
    helpUrl: "%{BKY_MATH_RANDOM_INT_HELPURL}"
  }, {
    type: "math_random_float",
    message0: "%{BKY_MATH_RANDOM_FLOAT_TITLE_RANDOM}",
    output: "Number",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_RANDOM_FLOAT_TOOLTIP}",
    helpUrl: "%{BKY_MATH_RANDOM_FLOAT_HELPURL}"
  }, {
    type: "math_atan2",
    message0: "%{BKY_MATH_ATAN2_TITLE}",
    args0: [{
      type: "input_value",
      name: "X",
      check: "Number"
    }, {
      type: "input_value",
      name: "Y",
      check: "Number"
    }],
    inputsInline: !0,
    output: "Number",
    style: "math_blocks",
    tooltip: "%{BKY_MATH_ATAN2_TOOLTIP}",
    helpUrl: "%{BKY_MATH_ATAN2_HELPURL}"
  }]);
  Blockly.Constants.Math.TOOLTIPS_BY_OP = {
    ADD: "%{BKY_MATH_ARITHMETIC_TOOLTIP_ADD}",
    MINUS: "%{BKY_MATH_ARITHMETIC_TOOLTIP_MINUS}",
    MULTIPLY: "%{BKY_MATH_ARITHMETIC_TOOLTIP_MULTIPLY}",
    DIVIDE: "%{BKY_MATH_ARITHMETIC_TOOLTIP_DIVIDE}",
    POWER: "%{BKY_MATH_ARITHMETIC_TOOLTIP_POWER}",
    ROOT: "%{BKY_MATH_SINGLE_TOOLTIP_ROOT}",
    ABS: "%{BKY_MATH_SINGLE_TOOLTIP_ABS}",
    NEG: "%{BKY_MATH_SINGLE_TOOLTIP_NEG}",
    LN: "%{BKY_MATH_SINGLE_TOOLTIP_LN}",
    LOG10: "%{BKY_MATH_SINGLE_TOOLTIP_LOG10}",
    EXP: "%{BKY_MATH_SINGLE_TOOLTIP_EXP}",
    POW10: "%{BKY_MATH_SINGLE_TOOLTIP_POW10}",
    SIN: "%{BKY_MATH_TRIG_TOOLTIP_SIN}",
    COS: "%{BKY_MATH_TRIG_TOOLTIP_COS}",
    TAN: "%{BKY_MATH_TRIG_TOOLTIP_TAN}",
    ASIN: "%{BKY_MATH_TRIG_TOOLTIP_ASIN}",
    ACOS: "%{BKY_MATH_TRIG_TOOLTIP_ACOS}",
    ATAN: "%{BKY_MATH_TRIG_TOOLTIP_ATAN}",
    SUM: "%{BKY_MATH_ONLIST_TOOLTIP_SUM}",
    MIN: "%{BKY_MATH_ONLIST_TOOLTIP_MIN}",
    MAX: "%{BKY_MATH_ONLIST_TOOLTIP_MAX}",
    AVERAGE: "%{BKY_MATH_ONLIST_TOOLTIP_AVERAGE}",
    MEDIAN: "%{BKY_MATH_ONLIST_TOOLTIP_MEDIAN}",
    MODE: "%{BKY_MATH_ONLIST_TOOLTIP_MODE}",
    STD_DEV: "%{BKY_MATH_ONLIST_TOOLTIP_STD_DEV}",
    RANDOM: "%{BKY_MATH_ONLIST_TOOLTIP_RANDOM}"
  };
  Blockly.Extensions.register("math_op_tooltip", Blockly.Extensions.buildTooltipForDropdown("OP", Blockly.Constants.Math.TOOLTIPS_BY_OP));
  Blockly.Constants.Math.IS_DIVISIBLEBY_MUTATOR_MIXIN = {
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation"),
          b = "DIVISIBLE_BY" == this.getFieldValue("PROPERTY");
      a.setAttribute("divisor_input", b);
      return a;
    },
    domToMutation: function domToMutation(a) {
      a = "true" == a.getAttribute("divisor_input");
      this.updateShape_(a);
    },
    updateShape_: function updateShape_(a) {
      var b = this.getInput("DIVISOR");
      a ? b || this.appendValueInput("DIVISOR").setCheck("Number") : b && this.removeInput("DIVISOR");
    }
  };

  Blockly.Constants.Math.IS_DIVISIBLE_MUTATOR_EXTENSION = function () {
    this.getField("PROPERTY").setValidator(function (a) {
      a = "DIVISIBLE_BY" == a;
      this.getSourceBlock().updateShape_(a);
    });
  };

  Blockly.Extensions.registerMutator("math_is_divisibleby_mutator", Blockly.Constants.Math.IS_DIVISIBLEBY_MUTATOR_MIXIN, Blockly.Constants.Math.IS_DIVISIBLE_MUTATOR_EXTENSION);
  Blockly.Extensions.register("math_change_tooltip", Blockly.Extensions.buildTooltipWithFieldText("%{BKY_MATH_CHANGE_TOOLTIP}", "VAR"));
  Blockly.Constants.Math.LIST_MODES_MUTATOR_MIXIN = {
    updateType_: function updateType_(a) {
      "MODE" == a ? this.outputConnection.setCheck("Array") : this.outputConnection.setCheck("Number");
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("op", this.getFieldValue("OP"));
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.updateType_(a.getAttribute("op"));
    }
  };

  Blockly.Constants.Math.LIST_MODES_MUTATOR_EXTENSION = function () {
    this.getField("OP").setValidator(function (a) {
      this.updateType_(a);
    }.bind(this));
  };

  Blockly.Extensions.registerMutator("math_modes_of_list_mutator", Blockly.Constants.Math.LIST_MODES_MUTATOR_MIXIN, Blockly.Constants.Math.LIST_MODES_MUTATOR_EXTENSION);
  Blockly.Blocks.procedures = {};
  Blockly.Blocks.procedures_defnoreturn = {
    init: function init() {
      var a = Blockly.Procedures.findLegalName("", this);
      a = new Blockly.FieldTextInput(a, Blockly.Procedures.rename);
      a.setSpellcheck(!1);
      this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_TITLE).appendField(a, "NAME").appendField("", "PARAMS");
      this.setMutator(new Blockly.Mutator(["procedures_mutatorarg"]));
      (this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments) && Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT && this.setCommentText(Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT);
      this.setStyle("procedure_blocks");
      this.setTooltip(Blockly.Msg.PROCEDURES_DEFNORETURN_TOOLTIP);
      this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFNORETURN_HELPURL);
      this.arguments_ = [];
      this.argumentVarModels_ = [];
      this.setStatements_(!0);
      this.statementConnection_ = null;
    },
    setStatements_: function setStatements_(a) {
      this.hasStatements_ !== a && (a ? (this.appendStatementInput("STACK").appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_DO), this.getInput("RETURN") && this.moveInputBefore("STACK", "RETURN")) : this.removeInput("STACK", !0), this.hasStatements_ = a);
    },
    updateParams_: function updateParams_() {
      var a = "";
      this.arguments_.length && (a = Blockly.Msg.PROCEDURES_BEFORE_PARAMS + " " + this.arguments_.join(", "));
      Blockly.Events.disable();

      try {
        this.setFieldValue(a, "PARAMS");
      } finally {
        Blockly.Events.enable();
      }
    },
    mutationToDom: function mutationToDom(a) {
      var b = Blockly.utils.xml.createElement("mutation");
      a && b.setAttribute("name", this.getFieldValue("NAME"));

      for (var c = 0; c < this.argumentVarModels_.length; c++) {
        var d = Blockly.utils.xml.createElement("arg"),
            e = this.argumentVarModels_[c];
        d.setAttribute("name", e.name);
        d.setAttribute("varid", e.getId());
        a && this.paramIds_ && d.setAttribute("paramId", this.paramIds_[c]);
        b.appendChild(d);
      }

      this.hasStatements_ || b.setAttribute("statements", "false");
      return b;
    },
    domToMutation: function domToMutation(a) {
      this.arguments_ = [];
      this.argumentVarModels_ = [];

      for (var b = 0, c; c = a.childNodes[b]; b++) {
        if ("arg" == c.nodeName.toLowerCase()) {
          var d = c.getAttribute("name");
          c = c.getAttribute("varid") || c.getAttribute("varId");
          this.arguments_.push(d);
          c = Blockly.Variables.getOrCreateVariablePackage(this.workspace, c, d, "");
          null != c ? this.argumentVarModels_.push(c) : console.log("Failed to create a variable with name " + d + ", ignoring.");
        }
      }

      this.updateParams_();
      Blockly.Procedures.mutateCallers(this);
      this.setStatements_("false" !== a.getAttribute("statements"));
    },
    decompose: function decompose(a) {
      var b = Blockly.utils.xml.createElement("block");
      b.setAttribute("type", "procedures_mutatorcontainer");
      var c = Blockly.utils.xml.createElement("statement");
      c.setAttribute("name", "STACK");
      b.appendChild(c);

      for (var d = 0; d < this.arguments_.length; d++) {
        var e = Blockly.utils.xml.createElement("block");
        e.setAttribute("type", "procedures_mutatorarg");
        var f = Blockly.utils.xml.createElement("field");
        f.setAttribute("name", "NAME");
        var g = Blockly.utils.xml.createTextNode(this.arguments_[d]);
        f.appendChild(g);
        e.appendChild(f);
        f = Blockly.utils.xml.createElement("next");
        e.appendChild(f);
        c.appendChild(e);
        c = f;
      }

      a = Blockly.Xml.domToBlock(b, a);
      "procedures_defreturn" == this.type ? a.setFieldValue(this.hasStatements_, "STATEMENTS") : a.removeInput("STATEMENT_INPUT");
      Blockly.Procedures.mutateCallers(this);
      return a;
    },
    compose: function compose(a) {
      this.arguments_ = [];
      this.paramIds_ = [];
      this.argumentVarModels_ = [];

      for (var b = a.getInputTargetBlock("STACK"); b && !b.isInsertionMarker();) {
        var c = b.getFieldValue("NAME");
        this.arguments_.push(c);
        c = this.workspace.getVariable(c, "");
        this.argumentVarModels_.push(c);
        this.paramIds_.push(b.id);
        b = b.nextConnection && b.nextConnection.targetBlock();
      }

      this.updateParams_();
      Blockly.Procedures.mutateCallers(this);
      a = a.getFieldValue("STATEMENTS");
      if (null !== a && (a = "TRUE" == a, this.hasStatements_ != a)) if (a) this.setStatements_(!0), Blockly.Mutator.reconnect(this.statementConnection_, this, "STACK"), this.statementConnection_ = null;else {
        a = this.getInput("STACK").connection;
        if (this.statementConnection_ = a.targetConnection) a = a.targetBlock(), a.unplug(), a.bumpNeighbours();
        this.setStatements_(!1);
      }
    },
    getProcedureDef: function getProcedureDef() {
      return [this.getFieldValue("NAME"), this.arguments_, !1];
    },
    getVars: function getVars() {
      return this.arguments_;
    },
    getVarModels: function getVarModels() {
      return this.argumentVarModels_;
    },
    renameVarById: function renameVarById(a, b) {
      var c = this.workspace.getVariableById(a);

      if ("" == c.type) {
        c = c.name;
        b = this.workspace.getVariableById(b);

        for (var d = !1, e = 0; e < this.argumentVarModels_.length; e++) {
          this.argumentVarModels_[e].getId() == a && (this.arguments_[e] = b.name, this.argumentVarModels_[e] = b, d = !0);
        }

        d && (this.displayRenamedVar_(c, b.name), Blockly.Procedures.mutateCallers(this));
      }
    },
    updateVarName: function updateVarName(a) {
      for (var b = a.name, c = !1, d = 0; d < this.argumentVarModels_.length; d++) {
        if (this.argumentVarModels_[d].getId() == a.getId()) {
          var e = this.arguments_[d];
          this.arguments_[d] = b;
          c = !0;
        }
      }

      c && (this.displayRenamedVar_(e, b), Blockly.Procedures.mutateCallers(this));
    },
    displayRenamedVar_: function displayRenamedVar_(a, b) {
      this.updateParams_();
      if (this.mutator && this.mutator.isVisible()) for (var c = this.mutator.workspace_.getAllBlocks(!1), d = 0, e; e = c[d]; d++) {
        "procedures_mutatorarg" == e.type && Blockly.Names.equals(a, e.getFieldValue("NAME")) && e.setFieldValue(b, "NAME");
      }
    },
    customContextMenu: function customContextMenu(a) {
      if (!this.isInFlyout) {
        var b = {
          enabled: !0
        },
            c = this.getFieldValue("NAME");
        b.text = Blockly.Msg.PROCEDURES_CREATE_DO.replace("%1", c);
        var d = Blockly.utils.xml.createElement("mutation");
        d.setAttribute("name", c);

        for (c = 0; c < this.arguments_.length; c++) {
          var e = Blockly.utils.xml.createElement("arg");
          e.setAttribute("name", this.arguments_[c]);
          d.appendChild(e);
        }

        c = Blockly.utils.xml.createElement("block");
        c.setAttribute("type", this.callType_);
        c.appendChild(d);
        b.callback = Blockly.ContextMenu.callbackFactory(this, c);
        a.push(b);
        if (!this.isCollapsed()) for (c = 0; c < this.argumentVarModels_.length; c++) {
          b = {
            enabled: !0
          }, d = this.argumentVarModels_[c], b.text = Blockly.Msg.VARIABLES_SET_CREATE_GET.replace("%1", d.name), d = Blockly.Variables.generateVariableFieldDom(d), e = Blockly.utils.xml.createElement("block"), e.setAttribute("type", "variables_get"), e.appendChild(d), b.callback = Blockly.ContextMenu.callbackFactory(this, e), a.push(b);
        }
      }
    },
    callType_: "procedures_callnoreturn"
  };
  Blockly.Blocks.procedures_defreturn = {
    init: function init() {
      var a = Blockly.Procedures.findLegalName("", this);
      a = new Blockly.FieldTextInput(a, Blockly.Procedures.rename);
      a.setSpellcheck(!1);
      this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_DEFRETURN_TITLE).appendField(a, "NAME").appendField("", "PARAMS");
      this.appendValueInput("RETURN").setAlign(Blockly.ALIGN_RIGHT).appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);
      this.setMutator(new Blockly.Mutator(["procedures_mutatorarg"]));
      (this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments) && Blockly.Msg.PROCEDURES_DEFRETURN_COMMENT && this.setCommentText(Blockly.Msg.PROCEDURES_DEFRETURN_COMMENT);
      this.setStyle("procedure_blocks");
      this.setTooltip(Blockly.Msg.PROCEDURES_DEFRETURN_TOOLTIP);
      this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFRETURN_HELPURL);
      this.arguments_ = [];
      this.argumentVarModels_ = [];
      this.setStatements_(!0);
      this.statementConnection_ = null;
    },
    setStatements_: Blockly.Blocks.procedures_defnoreturn.setStatements_,
    updateParams_: Blockly.Blocks.procedures_defnoreturn.updateParams_,
    mutationToDom: Blockly.Blocks.procedures_defnoreturn.mutationToDom,
    domToMutation: Blockly.Blocks.procedures_defnoreturn.domToMutation,
    decompose: Blockly.Blocks.procedures_defnoreturn.decompose,
    compose: Blockly.Blocks.procedures_defnoreturn.compose,
    getProcedureDef: function getProcedureDef() {
      return [this.getFieldValue("NAME"), this.arguments_, !0];
    },
    getVars: Blockly.Blocks.procedures_defnoreturn.getVars,
    getVarModels: Blockly.Blocks.procedures_defnoreturn.getVarModels,
    renameVarById: Blockly.Blocks.procedures_defnoreturn.renameVarById,
    updateVarName: Blockly.Blocks.procedures_defnoreturn.updateVarName,
    displayRenamedVar_: Blockly.Blocks.procedures_defnoreturn.displayRenamedVar_,
    customContextMenu: Blockly.Blocks.procedures_defnoreturn.customContextMenu,
    callType_: "procedures_callreturn"
  };
  Blockly.Blocks.procedures_mutatorcontainer = {
    init: function init() {
      this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TITLE);
      this.appendStatementInput("STACK");
      this.appendDummyInput("STATEMENT_INPUT").appendField(Blockly.Msg.PROCEDURES_ALLOW_STATEMENTS).appendField(new Blockly.FieldCheckbox("TRUE"), "STATEMENTS");
      this.setStyle("procedure_blocks");
      this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP);
      this.contextMenu = !1;
    }
  };
  Blockly.Blocks.procedures_mutatorarg = {
    init: function init() {
      var a = new Blockly.FieldTextInput(Blockly.Procedures.DEFAULT_ARG, this.validator_);
      a.oldShowEditorFn_ = a.showEditor_;

      a.showEditor_ = function () {
        this.createdVariables_ = [];
        this.oldShowEditorFn_();
      };

      this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_MUTATORARG_TITLE).appendField(a, "NAME");
      this.setPreviousStatement(!0);
      this.setNextStatement(!0);
      this.setStyle("procedure_blocks");
      this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORARG_TOOLTIP);
      this.contextMenu = !1;
      a.onFinishEditing_ = this.deleteIntermediateVars_;
      a.createdVariables_ = [];
      a.onFinishEditing_("x");
    },
    validator_: function validator_(a) {
      var b = this.getSourceBlock(),
          c = Blockly.Mutator.findParentWs(b.workspace);
      a = a.replace(/[\s\xa0]+/g, " ").replace(/^ | $/g, "");
      if (!a) return null;

      for (var d = (b.workspace.targetWorkspace || b.workspace).getAllBlocks(!1), e = a.toLowerCase(), f = 0; f < d.length; f++) {
        if (d[f].id != this.getSourceBlock().id) {
          var g = d[f].getFieldValue("NAME");
          if (g && g.toLowerCase() == e) return null;
        }
      }

      if (b.isInFlyout) return a;
      (b = c.getVariable(a, "")) && b.name != a && c.renameVariableById(b.getId(), a);
      b || (b = c.createVariable(a, "")) && this.createdVariables_ && this.createdVariables_.push(b);
      return a;
    },
    deleteIntermediateVars_: function deleteIntermediateVars_(a) {
      var b = Blockly.Mutator.findParentWs(this.getSourceBlock().workspace);
      if (b) for (var c = 0; c < this.createdVariables_.length; c++) {
        var d = this.createdVariables_[c];
        d.name != a && b.deleteVariableById(d.getId());
      }
    }
  };
  Blockly.Blocks.procedures_callnoreturn = {
    init: function init() {
      this.appendDummyInput("TOPROW").appendField("", "NAME");
      this.setPreviousStatement(!0);
      this.setNextStatement(!0);
      this.setStyle("procedure_blocks");
      this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLNORETURN_HELPURL);
      this.arguments_ = [];
      this.argumentVarModels_ = [];
      this.quarkConnections_ = {};
      this.quarkIds_ = null;
      this.previousEnabledState_ = !0;
    },
    getProcedureCall: function getProcedureCall() {
      return this.getFieldValue("NAME");
    },
    renameProcedure: function renameProcedure(a, b) {
      Blockly.Names.equals(a, this.getProcedureCall()) && (this.setFieldValue(b, "NAME"), this.setTooltip((this.outputConnection ? Blockly.Msg.PROCEDURES_CALLRETURN_TOOLTIP : Blockly.Msg.PROCEDURES_CALLNORETURN_TOOLTIP).replace("%1", b)));
    },
    setProcedureParameters_: function setProcedureParameters_(a, b) {
      var c = Blockly.Procedures.getDefinition(this.getProcedureCall(), this.workspace),
          d = c && c.mutator && c.mutator.isVisible();
      d || (this.quarkConnections_ = {}, this.quarkIds_ = null);
      if (b) if (a.join("\n") == this.arguments_.join("\n")) this.quarkIds_ = b;else {
        if (b.length != a.length) throw RangeError("paramNames and paramIds must be the same length.");
        this.setCollapsed(!1);
        this.quarkIds_ || (this.quarkConnections_ = {}, this.quarkIds_ = []);
        c = this.rendered;
        this.rendered = !1;

        for (var e = 0; e < this.arguments_.length; e++) {
          var f = this.getInput("ARG" + e);
          f && (f = f.connection.targetConnection, this.quarkConnections_[this.quarkIds_[e]] = f, d && f && -1 == b.indexOf(this.quarkIds_[e]) && (f.disconnect(), f.getSourceBlock().bumpNeighbours()));
        }

        this.arguments_ = [].concat(a);
        this.argumentVarModels_ = [];

        for (e = 0; e < this.arguments_.length; e++) {
          a = Blockly.Variables.getOrCreateVariablePackage(this.workspace, null, this.arguments_[e], ""), this.argumentVarModels_.push(a);
        }

        this.updateShape_();
        if (this.quarkIds_ = b) for (e = 0; e < this.arguments_.length; e++) {
          b = this.quarkIds_[e], b in this.quarkConnections_ && (f = this.quarkConnections_[b], Blockly.Mutator.reconnect(f, this, "ARG" + e) || delete this.quarkConnections_[b]);
        }
        (this.rendered = c) && this.render();
      }
    },
    updateShape_: function updateShape_() {
      for (var a = 0; a < this.arguments_.length; a++) {
        var b = this.getField("ARGNAME" + a);

        if (b) {
          Blockly.Events.disable();

          try {
            b.setValue(this.arguments_[a]);
          } finally {
            Blockly.Events.enable();
          }
        } else b = new Blockly.FieldLabel(this.arguments_[a]), this.appendValueInput("ARG" + a).setAlign(Blockly.ALIGN_RIGHT).appendField(b, "ARGNAME" + a).init();
      }

      for (; this.getInput("ARG" + a);) {
        this.removeInput("ARG" + a), a++;
      }

      if (a = this.getInput("TOPROW")) this.arguments_.length ? this.getField("WITH") || (a.appendField(Blockly.Msg.PROCEDURES_CALL_BEFORE_PARAMS, "WITH"), a.init()) : this.getField("WITH") && a.removeField("WITH");
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("name", this.getProcedureCall());

      for (var b = 0; b < this.arguments_.length; b++) {
        var c = Blockly.utils.xml.createElement("arg");
        c.setAttribute("name", this.arguments_[b]);
        a.appendChild(c);
      }

      return a;
    },
    domToMutation: function domToMutation(a) {
      var b = a.getAttribute("name");
      this.renameProcedure(this.getProcedureCall(), b);
      b = [];

      for (var c = [], d = 0, e; e = a.childNodes[d]; d++) {
        "arg" == e.nodeName.toLowerCase() && (b.push(e.getAttribute("name")), c.push(e.getAttribute("paramId")));
      }

      this.setProcedureParameters_(b, c);
    },
    getVars: function getVars() {
      return this.arguments_;
    },
    getVarModels: function getVarModels() {
      return this.argumentVarModels_;
    },
    onchange: function onchange(a) {
      if (this.workspace && !this.workspace.isFlyout && a.recordUndo) if (a.type == Blockly.Events.BLOCK_CREATE && -1 != a.ids.indexOf(this.id)) {
        var b = this.getProcedureCall();
        b = Blockly.Procedures.getDefinition(b, this.workspace);
        !b || b.type == this.defType_ && JSON.stringify(b.getVars()) == JSON.stringify(this.arguments_) || (b = null);

        if (!b) {
          Blockly.Events.setGroup(a.group);
          a = Blockly.utils.xml.createElement("xml");
          b = Blockly.utils.xml.createElement("block");
          b.setAttribute("type", this.defType_);
          var c = this.getRelativeToSurfaceXY(),
              d = c.y + 2 * Blockly.SNAP_RADIUS;
          b.setAttribute("x", c.x + Blockly.SNAP_RADIUS * (this.RTL ? -1 : 1));
          b.setAttribute("y", d);
          c = this.mutationToDom();
          b.appendChild(c);
          c = Blockly.utils.xml.createElement("field");
          c.setAttribute("name", "NAME");
          d = this.getProcedureCall();
          d || (d = Blockly.Procedures.findLegalName("", this), this.renameProcedure("", d));
          c.appendChild(Blockly.utils.xml.createTextNode(d));
          b.appendChild(c);
          a.appendChild(b);
          Blockly.Xml.domToWorkspace(a, this.workspace);
          Blockly.Events.setGroup(!1);
        }
      } else a.type == Blockly.Events.BLOCK_DELETE ? (b = this.getProcedureCall(), b = Blockly.Procedures.getDefinition(b, this.workspace), b || (Blockly.Events.setGroup(a.group), this.dispose(!0), Blockly.Events.setGroup(!1))) : a.type == Blockly.Events.CHANGE && "disabled" == a.element && (b = this.getProcedureCall(), (b = Blockly.Procedures.getDefinition(b, this.workspace)) && b.id == a.blockId && ((b = Blockly.Events.getGroup()) && console.log("Saw an existing group while responding to a definition change"), Blockly.Events.setGroup(a.group), a.newValue ? (this.previousEnabledState_ = this.isEnabled(), this.setEnabled(!1)) : this.setEnabled(this.previousEnabledState_), Blockly.Events.setGroup(b)));
    },
    customContextMenu: function customContextMenu(a) {
      if (this.workspace.isMovable()) {
        var b = {
          enabled: !0
        };
        b.text = Blockly.Msg.PROCEDURES_HIGHLIGHT_DEF;
        var c = this.getProcedureCall(),
            d = this.workspace;

        b.callback = function () {
          var e = Blockly.Procedures.getDefinition(c, d);
          e && (d.centerOnBlock(e.id), e.select());
        };

        a.push(b);
      }
    },
    defType_: "procedures_defnoreturn"
  };
  Blockly.Blocks.procedures_callreturn = {
    init: function init() {
      this.appendDummyInput("TOPROW").appendField("", "NAME");
      this.setOutput(!0);
      this.setStyle("procedure_blocks");
      this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLRETURN_HELPURL);
      this.arguments_ = [];
      this.argumentVarModels_ = [];
      this.quarkConnections_ = {};
      this.quarkIds_ = null;
      this.previousEnabledState_ = !0;
    },
    getProcedureCall: Blockly.Blocks.procedures_callnoreturn.getProcedureCall,
    renameProcedure: Blockly.Blocks.procedures_callnoreturn.renameProcedure,
    setProcedureParameters_: Blockly.Blocks.procedures_callnoreturn.setProcedureParameters_,
    updateShape_: Blockly.Blocks.procedures_callnoreturn.updateShape_,
    mutationToDom: Blockly.Blocks.procedures_callnoreturn.mutationToDom,
    domToMutation: Blockly.Blocks.procedures_callnoreturn.domToMutation,
    getVars: Blockly.Blocks.procedures_callnoreturn.getVars,
    getVarModels: Blockly.Blocks.procedures_callnoreturn.getVarModels,
    onchange: Blockly.Blocks.procedures_callnoreturn.onchange,
    customContextMenu: Blockly.Blocks.procedures_callnoreturn.customContextMenu,
    defType_: "procedures_defreturn"
  };
  Blockly.Blocks.procedures_ifreturn = {
    init: function init() {
      this.appendValueInput("CONDITION").setCheck("Boolean").appendField(Blockly.Msg.CONTROLS_IF_MSG_IF);
      this.appendValueInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);
      this.setInputsInline(!0);
      this.setPreviousStatement(!0);
      this.setNextStatement(!0);
      this.setStyle("procedure_blocks");
      this.setTooltip(Blockly.Msg.PROCEDURES_IFRETURN_TOOLTIP);
      this.setHelpUrl(Blockly.Msg.PROCEDURES_IFRETURN_HELPURL);
      this.hasReturnValue_ = !0;
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("value", Number(this.hasReturnValue_));
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.hasReturnValue_ = 1 == a.getAttribute("value");
      this.hasReturnValue_ || (this.removeInput("VALUE"), this.appendDummyInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN));
    },
    onchange: function onchange(a) {
      if (this.workspace.isDragging && !this.workspace.isDragging()) {
        a = !1;
        var b = this;

        do {
          if (-1 != this.FUNCTION_TYPES.indexOf(b.type)) {
            a = !0;
            break;
          }

          b = b.getSurroundParent();
        } while (b);

        a ? ("procedures_defnoreturn" == b.type && this.hasReturnValue_ ? (this.removeInput("VALUE"), this.appendDummyInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN), this.hasReturnValue_ = !1) : "procedures_defreturn" != b.type || this.hasReturnValue_ || (this.removeInput("VALUE"), this.appendValueInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN), this.hasReturnValue_ = !0), this.setWarningText(null), this.isInFlyout || this.setEnabled(!0)) : (this.setWarningText(Blockly.Msg.PROCEDURES_IFRETURN_WARNING), this.isInFlyout || this.getInheritedDisabled() || this.setEnabled(!1));
      }
    },
    FUNCTION_TYPES: ["procedures_defnoreturn", "procedures_defreturn"]
  };
  Blockly.Blocks.texts = {};
  Blockly.Constants.Text = {};
  Blockly.Constants.Text.HUE = 160;
  Blockly.defineBlocksWithJsonArray([{
    type: "text",
    message0: "%1",
    args0: [{
      type: "field_input",
      name: "TEXT",
      text: ""
    }],
    output: "String",
    style: "text_blocks",
    helpUrl: "%{BKY_TEXT_TEXT_HELPURL}",
    tooltip: "%{BKY_TEXT_TEXT_TOOLTIP}",
    extensions: ["text_quotes", "parent_tooltip_when_inline"]
  }, {
    type: "text_multiline",
    message0: "%1 %2",
    args0: [{
      type: "field_image",
      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAARCAYAAADpPU2iAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAdhgAAHYYBXaITgQAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS42/U4J6AAAAP1JREFUOE+Vks0KQUEYhjmRIja4ABtZ2dm5A3t3Ia6AUm7CylYuQRaUhZSlLZJiQbFAyRnPN33y01HOW08z8873zpwzM4F3GWOCruvGIE4/rLaV+Nq1hVGMBqzhqlxgCys4wJA65xnogMHsQ5lujnYHTejBBCK2mE4abjCgMGhNxHgDFWjDSG07kdfVa2pZMf4ZyMAdWmpZMfYOsLiDMYMjlMB+K613QISRhTnITnsYg5yUd0DETmEoMlkFOeIT/A58iyK5E18BuTBfgYXfwNJv4P9/oEBerLylOnRhygmGdPpTTBZAPkde61lbQe4moWUvYUZYLfUNftIY4zwA5X2Z9AYnQrEAAAAASUVORK5CYII=",
      width: 12,
      height: 17,
      alt: "\xB6"
    }, {
      type: "field_multilinetext",
      name: "TEXT",
      text: ""
    }],
    output: "String",
    style: "text_blocks",
    helpUrl: "%{BKY_TEXT_TEXT_HELPURL}",
    tooltip: "%{BKY_TEXT_TEXT_TOOLTIP}",
    extensions: ["parent_tooltip_when_inline"]
  }, {
    type: "text_join",
    message0: "",
    output: "String",
    style: "text_blocks",
    helpUrl: "%{BKY_TEXT_JOIN_HELPURL}",
    tooltip: "%{BKY_TEXT_JOIN_TOOLTIP}",
    mutator: "text_join_mutator"
  }, {
    type: "text_create_join_container",
    message0: "%{BKY_TEXT_CREATE_JOIN_TITLE_JOIN} %1 %2",
    args0: [{
      type: "input_dummy"
    }, {
      type: "input_statement",
      name: "STACK"
    }],
    style: "text_blocks",
    tooltip: "%{BKY_TEXT_CREATE_JOIN_TOOLTIP}",
    enableContextMenu: !1
  }, {
    type: "text_create_join_item",
    message0: "%{BKY_TEXT_CREATE_JOIN_ITEM_TITLE_ITEM}",
    previousStatement: null,
    nextStatement: null,
    style: "text_blocks",
    tooltip: "%{BKY_TEXT_CREATE_JOIN_ITEM_TOOLTIP}",
    enableContextMenu: !1
  }, {
    type: "text_append",
    message0: "%{BKY_TEXT_APPEND_TITLE}",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: "%{BKY_TEXT_APPEND_VARIABLE}"
    }, {
      type: "input_value",
      name: "TEXT"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "text_blocks",
    extensions: ["text_append_tooltip"]
  }, {
    type: "text_length",
    message0: "%{BKY_TEXT_LENGTH_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: ["String", "Array"]
    }],
    output: "Number",
    style: "text_blocks",
    tooltip: "%{BKY_TEXT_LENGTH_TOOLTIP}",
    helpUrl: "%{BKY_TEXT_LENGTH_HELPURL}"
  }, {
    type: "text_isEmpty",
    message0: "%{BKY_TEXT_ISEMPTY_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: ["String", "Array"]
    }],
    output: "Boolean",
    style: "text_blocks",
    tooltip: "%{BKY_TEXT_ISEMPTY_TOOLTIP}",
    helpUrl: "%{BKY_TEXT_ISEMPTY_HELPURL}"
  }, {
    type: "text_indexOf",
    message0: "%{BKY_TEXT_INDEXOF_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: "String"
    }, {
      type: "field_dropdown",
      name: "END",
      options: [["%{BKY_TEXT_INDEXOF_OPERATOR_FIRST}", "FIRST"], ["%{BKY_TEXT_INDEXOF_OPERATOR_LAST}", "LAST"]]
    }, {
      type: "input_value",
      name: "FIND",
      check: "String"
    }],
    output: "Number",
    style: "text_blocks",
    helpUrl: "%{BKY_TEXT_INDEXOF_HELPURL}",
    inputsInline: !0,
    extensions: ["text_indexOf_tooltip"]
  }, {
    type: "text_charAt",
    message0: "%{BKY_TEXT_CHARAT_TITLE}",
    args0: [{
      type: "input_value",
      name: "VALUE",
      check: "String"
    }, {
      type: "field_dropdown",
      name: "WHERE",
      options: [["%{BKY_TEXT_CHARAT_FROM_START}", "FROM_START"], ["%{BKY_TEXT_CHARAT_FROM_END}", "FROM_END"], ["%{BKY_TEXT_CHARAT_FIRST}", "FIRST"], ["%{BKY_TEXT_CHARAT_LAST}", "LAST"], ["%{BKY_TEXT_CHARAT_RANDOM}", "RANDOM"]]
    }],
    output: "String",
    style: "text_blocks",
    helpUrl: "%{BKY_TEXT_CHARAT_HELPURL}",
    inputsInline: !0,
    mutator: "text_charAt_mutator"
  }]);
  Blockly.Blocks.text_getSubstring = {
    init: function init() {
      this.WHERE_OPTIONS_1 = [[Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_START, "FROM_START"], [Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_END, "FROM_END"], [Blockly.Msg.TEXT_GET_SUBSTRING_START_FIRST, "FIRST"]];
      this.WHERE_OPTIONS_2 = [[Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_START, "FROM_START"], [Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_END, "FROM_END"], [Blockly.Msg.TEXT_GET_SUBSTRING_END_LAST, "LAST"]];
      this.setHelpUrl(Blockly.Msg.TEXT_GET_SUBSTRING_HELPURL);
      this.setStyle("text_blocks");
      this.appendValueInput("STRING").setCheck("String").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT);
      this.appendDummyInput("AT1");
      this.appendDummyInput("AT2");
      Blockly.Msg.TEXT_GET_SUBSTRING_TAIL && this.appendDummyInput("TAIL").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL);
      this.setInputsInline(!0);
      this.setOutput(!0, "String");
      this.updateAt_(1, !0);
      this.updateAt_(2, !0);
      this.setTooltip(Blockly.Msg.TEXT_GET_SUBSTRING_TOOLTIP);
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation"),
          b = this.getInput("AT1").type == Blockly.INPUT_VALUE;
      a.setAttribute("at1", b);
      b = this.getInput("AT2").type == Blockly.INPUT_VALUE;
      a.setAttribute("at2", b);
      return a;
    },
    domToMutation: function domToMutation(a) {
      var b = "true" == a.getAttribute("at1");
      a = "true" == a.getAttribute("at2");
      this.updateAt_(1, b);
      this.updateAt_(2, a);
    },
    updateAt_: function updateAt_(a, b) {
      this.removeInput("AT" + a);
      this.removeInput("ORDINAL" + a, !0);
      b ? (this.appendValueInput("AT" + a).setCheck("Number"), Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL" + a).appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT" + a);
      2 == a && Blockly.Msg.TEXT_GET_SUBSTRING_TAIL && (this.removeInput("TAIL", !0), this.appendDummyInput("TAIL").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL));
      var c = new Blockly.FieldDropdown(this["WHERE_OPTIONS_" + a], function (d) {
        var e = "FROM_START" == d || "FROM_END" == d;

        if (e != b) {
          var f = this.getSourceBlock();
          f.updateAt_(a, e);
          f.setFieldValue(d, "WHERE" + a);
          return null;
        }
      });
      this.getInput("AT" + a).appendField(c, "WHERE" + a);
      1 == a && (this.moveInputBefore("AT1", "AT2"), this.getInput("ORDINAL1") && this.moveInputBefore("ORDINAL1", "AT2"));
    }
  };
  Blockly.Blocks.text_changeCase = {
    init: function init() {
      var a = [[Blockly.Msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE, "UPPERCASE"], [Blockly.Msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE, "LOWERCASE"], [Blockly.Msg.TEXT_CHANGECASE_OPERATOR_TITLECASE, "TITLECASE"]];
      this.setHelpUrl(Blockly.Msg.TEXT_CHANGECASE_HELPURL);
      this.setStyle("text_blocks");
      this.appendValueInput("TEXT").setCheck("String").appendField(new Blockly.FieldDropdown(a), "CASE");
      this.setOutput(!0, "String");
      this.setTooltip(Blockly.Msg.TEXT_CHANGECASE_TOOLTIP);
    }
  };
  Blockly.Blocks.text_trim = {
    init: function init() {
      var a = [[Blockly.Msg.TEXT_TRIM_OPERATOR_BOTH, "BOTH"], [Blockly.Msg.TEXT_TRIM_OPERATOR_LEFT, "LEFT"], [Blockly.Msg.TEXT_TRIM_OPERATOR_RIGHT, "RIGHT"]];
      this.setHelpUrl(Blockly.Msg.TEXT_TRIM_HELPURL);
      this.setStyle("text_blocks");
      this.appendValueInput("TEXT").setCheck("String").appendField(new Blockly.FieldDropdown(a), "MODE");
      this.setOutput(!0, "String");
      this.setTooltip(Blockly.Msg.TEXT_TRIM_TOOLTIP);
    }
  };
  Blockly.Blocks.text_print = {
    init: function init() {
      this.jsonInit({
        message0: Blockly.Msg.TEXT_PRINT_TITLE,
        args0: [{
          type: "input_value",
          name: "TEXT"
        }],
        previousStatement: null,
        nextStatement: null,
        style: "text_blocks",
        tooltip: Blockly.Msg.TEXT_PRINT_TOOLTIP,
        helpUrl: Blockly.Msg.TEXT_PRINT_HELPURL
      });
    }
  };
  Blockly.Blocks.text_prompt_ext = {
    init: function init() {
      var a = [[Blockly.Msg.TEXT_PROMPT_TYPE_TEXT, "TEXT"], [Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER, "NUMBER"]];
      this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);
      this.setStyle("text_blocks");
      var b = this;
      a = new Blockly.FieldDropdown(a, function (c) {
        b.updateType_(c);
      });
      this.appendValueInput("TEXT").appendField(a, "TYPE");
      this.setOutput(!0, "String");
      this.setTooltip(function () {
        return "TEXT" == b.getFieldValue("TYPE") ? Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT : Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER;
      });
    },
    updateType_: function updateType_(a) {
      this.outputConnection.setCheck("NUMBER" == a ? "Number" : "String");
    },
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("type", this.getFieldValue("TYPE"));
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.updateType_(a.getAttribute("type"));
    }
  };
  Blockly.Blocks.text_prompt = {
    init: function init() {
      this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);
      var a = [[Blockly.Msg.TEXT_PROMPT_TYPE_TEXT, "TEXT"], [Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER, "NUMBER"]],
          b = this;
      this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);
      this.setStyle("text_blocks");
      a = new Blockly.FieldDropdown(a, function (c) {
        b.updateType_(c);
      });
      this.appendDummyInput().appendField(a, "TYPE").appendField(this.newQuote_(!0)).appendField(new Blockly.FieldTextInput(""), "TEXT").appendField(this.newQuote_(!1));
      this.setOutput(!0, "String");
      this.setTooltip(function () {
        return "TEXT" == b.getFieldValue("TYPE") ? Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT : Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER;
      });
    },
    updateType_: Blockly.Blocks.text_prompt_ext.updateType_,
    mutationToDom: Blockly.Blocks.text_prompt_ext.mutationToDom,
    domToMutation: Blockly.Blocks.text_prompt_ext.domToMutation
  };
  Blockly.Blocks.text_count = {
    init: function init() {
      this.jsonInit({
        message0: Blockly.Msg.TEXT_COUNT_MESSAGE0,
        args0: [{
          type: "input_value",
          name: "SUB",
          check: "String"
        }, {
          type: "input_value",
          name: "TEXT",
          check: "String"
        }],
        output: "Number",
        inputsInline: !0,
        style: "text_blocks",
        tooltip: Blockly.Msg.TEXT_COUNT_TOOLTIP,
        helpUrl: Blockly.Msg.TEXT_COUNT_HELPURL
      });
    }
  };
  Blockly.Blocks.text_replace = {
    init: function init() {
      this.jsonInit({
        message0: Blockly.Msg.TEXT_REPLACE_MESSAGE0,
        args0: [{
          type: "input_value",
          name: "FROM",
          check: "String"
        }, {
          type: "input_value",
          name: "TO",
          check: "String"
        }, {
          type: "input_value",
          name: "TEXT",
          check: "String"
        }],
        output: "String",
        inputsInline: !0,
        style: "text_blocks",
        tooltip: Blockly.Msg.TEXT_REPLACE_TOOLTIP,
        helpUrl: Blockly.Msg.TEXT_REPLACE_HELPURL
      });
    }
  };
  Blockly.Blocks.text_reverse = {
    init: function init() {
      this.jsonInit({
        message0: Blockly.Msg.TEXT_REVERSE_MESSAGE0,
        args0: [{
          type: "input_value",
          name: "TEXT",
          check: "String"
        }],
        output: "String",
        inputsInline: !0,
        style: "text_blocks",
        tooltip: Blockly.Msg.TEXT_REVERSE_TOOLTIP,
        helpUrl: Blockly.Msg.TEXT_REVERSE_HELPURL
      });
    }
  };
  Blockly.Constants.Text.QUOTE_IMAGE_MIXIN = {
    QUOTE_IMAGE_LEFT_DATAURI: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC",
    QUOTE_IMAGE_RIGHT_DATAURI: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==",
    QUOTE_IMAGE_WIDTH: 12,
    QUOTE_IMAGE_HEIGHT: 12,
    quoteField_: function quoteField_(a) {
      for (var b = 0, c; c = this.inputList[b]; b++) {
        for (var d = 0, e; e = c.fieldRow[d]; d++) {
          if (a == e.name) {
            c.insertFieldAt(d, this.newQuote_(!0));
            c.insertFieldAt(d + 2, this.newQuote_(!1));
            return;
          }
        }
      }

      console.warn('field named "' + a + '" not found in ' + this.toDevString());
    },
    newQuote_: function newQuote_(a) {
      a = this.RTL ? !a : a;
      return new Blockly.FieldImage(a ? this.QUOTE_IMAGE_LEFT_DATAURI : this.QUOTE_IMAGE_RIGHT_DATAURI, this.QUOTE_IMAGE_WIDTH, this.QUOTE_IMAGE_HEIGHT, a ? "\u201C" : "\u201D");
    }
  };

  Blockly.Constants.Text.TEXT_QUOTES_EXTENSION = function () {
    this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);
    this.quoteField_("TEXT");
  };

  Blockly.Constants.Text.TEXT_JOIN_MUTATOR_MIXIN = {
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("items", this.itemCount_);
      return a;
    },
    domToMutation: function domToMutation(a) {
      this.itemCount_ = parseInt(a.getAttribute("items"), 10);
      this.updateShape_();
    },
    decompose: function decompose(a) {
      var b = a.newBlock("text_create_join_container");
      b.initSvg();

      for (var c = b.getInput("STACK").connection, d = 0; d < this.itemCount_; d++) {
        var e = a.newBlock("text_create_join_item");
        e.initSvg();
        c.connect(e.previousConnection);
        c = e.nextConnection;
      }

      return b;
    },
    compose: function compose(a) {
      var b = a.getInputTargetBlock("STACK");

      for (a = []; b && !b.isInsertionMarker();) {
        a.push(b.valueConnection_), b = b.nextConnection && b.nextConnection.targetBlock();
      }

      for (b = 0; b < this.itemCount_; b++) {
        var c = this.getInput("ADD" + b).connection.targetConnection;
        c && -1 == a.indexOf(c) && c.disconnect();
      }

      this.itemCount_ = a.length;
      this.updateShape_();

      for (b = 0; b < this.itemCount_; b++) {
        Blockly.Mutator.reconnect(a[b], this, "ADD" + b);
      }
    },
    saveConnections: function saveConnections(a) {
      a = a.getInputTargetBlock("STACK");

      for (var b = 0; a;) {
        var c = this.getInput("ADD" + b);
        a.valueConnection_ = c && c.connection.targetConnection;
        b++;
        a = a.nextConnection && a.nextConnection.targetBlock();
      }
    },
    updateShape_: function updateShape_() {
      this.itemCount_ && this.getInput("EMPTY") ? this.removeInput("EMPTY") : this.itemCount_ || this.getInput("EMPTY") || this.appendDummyInput("EMPTY").appendField(this.newQuote_(!0)).appendField(this.newQuote_(!1));

      for (var a = 0; a < this.itemCount_; a++) {
        if (!this.getInput("ADD" + a)) {
          var b = this.appendValueInput("ADD" + a).setAlign(Blockly.ALIGN_RIGHT);
          0 == a && b.appendField(Blockly.Msg.TEXT_JOIN_TITLE_CREATEWITH);
        }
      }

      for (; this.getInput("ADD" + a);) {
        this.removeInput("ADD" + a), a++;
      }
    }
  };

  Blockly.Constants.Text.TEXT_JOIN_EXTENSION = function () {
    this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);
    this.itemCount_ = 2;
    this.updateShape_();
    this.setMutator(new Blockly.Mutator(["text_create_join_item"]));
  };

  Blockly.Extensions.register("text_append_tooltip", Blockly.Extensions.buildTooltipWithFieldText("%{BKY_TEXT_APPEND_TOOLTIP}", "VAR"));

  Blockly.Constants.Text.TEXT_INDEXOF_TOOLTIP_EXTENSION = function () {
    var a = this;
    this.setTooltip(function () {
      return Blockly.Msg.TEXT_INDEXOF_TOOLTIP.replace("%1", a.workspace.options.oneBasedIndex ? "0" : "-1");
    });
  };

  Blockly.Constants.Text.TEXT_CHARAT_MUTATOR_MIXIN = {
    mutationToDom: function mutationToDom() {
      var a = Blockly.utils.xml.createElement("mutation");
      a.setAttribute("at", !!this.isAt_);
      return a;
    },
    domToMutation: function domToMutation(a) {
      a = "false" != a.getAttribute("at");
      this.updateAt_(a);
    },
    updateAt_: function updateAt_(a) {
      this.removeInput("AT", !0);
      this.removeInput("ORDINAL", !0);
      a && (this.appendValueInput("AT").setCheck("Number"), Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX));
      Blockly.Msg.TEXT_CHARAT_TAIL && (this.removeInput("TAIL", !0), this.appendDummyInput("TAIL").appendField(Blockly.Msg.TEXT_CHARAT_TAIL));
      this.isAt_ = a;
    }
  };

  Blockly.Constants.Text.TEXT_CHARAT_EXTENSION = function () {
    this.getField("WHERE").setValidator(function (b) {
      b = "FROM_START" == b || "FROM_END" == b;
      b != this.isAt_ && this.getSourceBlock().updateAt_(b);
    });
    this.updateAt_(!0);
    var a = this;
    this.setTooltip(function () {
      var b = a.getFieldValue("WHERE"),
          c = Blockly.Msg.TEXT_CHARAT_TOOLTIP;
      ("FROM_START" == b || "FROM_END" == b) && (b = "FROM_START" == b ? Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP : Blockly.Msg.LISTS_INDEX_FROM_END_TOOLTIP) && (c += "  " + b.replace("%1", a.workspace.options.oneBasedIndex ? "#1" : "#0"));
      return c;
    });
  };

  Blockly.Extensions.register("text_indexOf_tooltip", Blockly.Constants.Text.TEXT_INDEXOF_TOOLTIP_EXTENSION);
  Blockly.Extensions.register("text_quotes", Blockly.Constants.Text.TEXT_QUOTES_EXTENSION);
  Blockly.Extensions.registerMutator("text_join_mutator", Blockly.Constants.Text.TEXT_JOIN_MUTATOR_MIXIN, Blockly.Constants.Text.TEXT_JOIN_EXTENSION);
  Blockly.Extensions.registerMutator("text_charAt_mutator", Blockly.Constants.Text.TEXT_CHARAT_MUTATOR_MIXIN, Blockly.Constants.Text.TEXT_CHARAT_EXTENSION);
  Blockly.Blocks.variables = {};
  Blockly.Constants.Variables = {};
  Blockly.Constants.Variables.HUE = 330;
  Blockly.defineBlocksWithJsonArray([{
    type: "variables_get",
    message0: "%1",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
    }],
    output: null,
    style: "variable_blocks",
    helpUrl: "%{BKY_VARIABLES_GET_HELPURL}",
    tooltip: "%{BKY_VARIABLES_GET_TOOLTIP}",
    extensions: ["contextMenu_variableSetterGetter"]
  }, {
    type: "variables_set",
    message0: "%{BKY_VARIABLES_SET}",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
    }, {
      type: "input_value",
      name: "VALUE"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "variable_blocks",
    tooltip: "%{BKY_VARIABLES_SET_TOOLTIP}",
    helpUrl: "%{BKY_VARIABLES_SET_HELPURL}",
    extensions: ["contextMenu_variableSetterGetter"]
  }]);
  Blockly.Constants.Variables.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN = {
    customContextMenu: function customContextMenu(a) {
      if (!this.isInFlyout) {
        if ("variables_get" == this.type) var b = "variables_set",
            c = Blockly.Msg.VARIABLES_GET_CREATE_SET;else b = "variables_get", c = Blockly.Msg.VARIABLES_SET_CREATE_GET;
        var d = {
          enabled: 0 < this.workspace.remainingCapacity()
        },
            e = this.getField("VAR").getText();
        d.text = c.replace("%1", e);
        c = Blockly.utils.xml.createElement("field");
        c.setAttribute("name", "VAR");
        c.appendChild(Blockly.utils.xml.createTextNode(e));
        e = Blockly.utils.xml.createElement("block");
        e.setAttribute("type", b);
        e.appendChild(c);
        d.callback = Blockly.ContextMenu.callbackFactory(this, e);
        a.push(d);
      } else if ("variables_get" == this.type || "variables_get_reporter" == this.type) b = {
        text: Blockly.Msg.RENAME_VARIABLE,
        enabled: !0,
        callback: Blockly.Constants.Variables.RENAME_OPTION_CALLBACK_FACTORY(this)
      }, e = this.getField("VAR").getText(), d = {
        text: Blockly.Msg.DELETE_VARIABLE.replace("%1", e),
        enabled: !0,
        callback: Blockly.Constants.Variables.DELETE_OPTION_CALLBACK_FACTORY(this)
      }, a.unshift(b), a.unshift(d);
    }
  };

  Blockly.Constants.Variables.RENAME_OPTION_CALLBACK_FACTORY = function (a) {
    return function () {
      var b = a.workspace,
          c = a.getField("VAR").getVariable();
      Blockly.Variables.renameVariable(b, c);
    };
  };

  Blockly.Constants.Variables.DELETE_OPTION_CALLBACK_FACTORY = function (a) {
    return function () {
      var b = a.workspace,
          c = a.getField("VAR").getVariable();
      b.deleteVariableById(c.getId());
      b.refreshToolboxSelection();
    };
  };

  Blockly.Extensions.registerMixin("contextMenu_variableSetterGetter", Blockly.Constants.Variables.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN);
  Blockly.Constants.VariablesDynamic = {};
  Blockly.Constants.VariablesDynamic.HUE = 310;
  Blockly.defineBlocksWithJsonArray([{
    type: "variables_get_dynamic",
    message0: "%1",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
    }],
    output: null,
    style: "variable_dynamic_blocks",
    helpUrl: "%{BKY_VARIABLES_GET_HELPURL}",
    tooltip: "%{BKY_VARIABLES_GET_TOOLTIP}",
    extensions: ["contextMenu_variableDynamicSetterGetter"]
  }, {
    type: "variables_set_dynamic",
    message0: "%{BKY_VARIABLES_SET}",
    args0: [{
      type: "field_variable",
      name: "VAR",
      variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
    }, {
      type: "input_value",
      name: "VALUE"
    }],
    previousStatement: null,
    nextStatement: null,
    style: "variable_dynamic_blocks",
    tooltip: "%{BKY_VARIABLES_SET_TOOLTIP}",
    helpUrl: "%{BKY_VARIABLES_SET_HELPURL}",
    extensions: ["contextMenu_variableDynamicSetterGetter"]
  }]);
  Blockly.Constants.VariablesDynamic.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN = {
    customContextMenu: function customContextMenu(a) {
      if (!this.isInFlyout) {
        var b = this.getFieldValue("VAR");
        var c = this.workspace.getVariableById(b).type;

        if ("variables_get_dynamic" == this.type) {
          b = "variables_set_dynamic";
          var d = Blockly.Msg.VARIABLES_GET_CREATE_SET;
        } else b = "variables_get_dynamic", d = Blockly.Msg.VARIABLES_SET_CREATE_GET;

        var e = {
          enabled: 0 < this.workspace.remainingCapacity()
        },
            f = this.getField("VAR").getText();
        e.text = d.replace("%1", f);
        d = Blockly.utils.xml.createElement("field");
        d.setAttribute("name", "VAR");
        d.setAttribute("variabletype", c);
        d.appendChild(Blockly.utils.xml.createTextNode(f));
        f = Blockly.utils.xml.createElement("block");
        f.setAttribute("type", b);
        f.appendChild(d);
        e.callback = Blockly.ContextMenu.callbackFactory(this, f);
        a.push(e);
      } else if ("variables_get_dynamic" == this.type || "variables_get_reporter_dynamic" == this.type) b = {
        text: Blockly.Msg.RENAME_VARIABLE,
        enabled: !0,
        callback: Blockly.Constants.Variables.RENAME_OPTION_CALLBACK_FACTORY(this)
      }, f = this.getField("VAR").getText(), e = {
        text: Blockly.Msg.DELETE_VARIABLE.replace("%1", f),
        enabled: !0,
        callback: Blockly.Constants.Variables.DELETE_OPTION_CALLBACK_FACTORY(this)
      }, a.unshift(b), a.unshift(e);
    },
    onchange: function onchange(a) {
      a = this.getFieldValue("VAR");
      a = Blockly.Variables.getVariable(this.workspace, a);
      "variables_get_dynamic" == this.type ? this.outputConnection.setCheck(a.type) : this.getInput("VALUE").connection.setCheck(a.type);
    }
  };

  Blockly.Constants.VariablesDynamic.RENAME_OPTION_CALLBACK_FACTORY = function (a) {
    return function () {
      var b = a.workspace,
          c = a.getField("VAR").getVariable();
      Blockly.Variables.renameVariable(b, c);
    };
  };

  Blockly.Constants.VariablesDynamic.DELETE_OPTION_CALLBACK_FACTORY = function (a) {
    return function () {
      var b = a.workspace,
          c = a.getField("VAR").getVariable();
      b.deleteVariableById(c.getId());
      b.refreshToolboxSelection();
    };
  };

  Blockly.Extensions.registerMixin("contextMenu_variableDynamicSetterGetter", Blockly.Constants.VariablesDynamic.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN);
  return Blockly.Blocks;
});

/***/ }),

/***/ 11221:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(90888), __webpack_require__(85115), __webpack_require__(71269), __webpack_require__(76881)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly, En, BlocklyBlocks, BlocklyJS) {
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * @fileoverview Blockly module for the browser. This includes Blockly core
   * and built in blocks, the JavaScript code generator and the English block
   * localization files.
   */

  /* eslint-disable */
  'use strict'; // Include the EN Locale by default.

  Blockly.setLocale(En);
  Blockly.Blocks = Blockly.Blocks || {};
  Object.keys(BlocklyBlocks).forEach(function (k) {
    Blockly.Blocks[k] = BlocklyBlocks[k];
  });
  Blockly.JavaScript = BlocklyJS;
  return Blockly;
});

/***/ }),

/***/ 90888:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(61452)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * @fileoverview Blockly core module for the browser. It includes blockly.js
   *               and adds a helper method for setting the locale.
   */

  /* eslint-disable */
  'use strict'; // Add a helper method to set the Blockly locale.

  Blockly.setLocale = function (locale) {
    Blockly.Msg = Blockly.Msg || {};
    Object.keys(locale).forEach(function (k) {
      Blockly.Msg[k] = locale[k];
    });
  };

  return Blockly;
});

/***/ }),

/***/ 74640:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11221)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  /**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * @fileoverview Blockly module.
   */

  /* eslint-disable */
  'use strict';

  return Blockly;
});

/***/ }),

/***/ 76881:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(90888), __webpack_require__(75107)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly, BlocklyJavaScript) {
  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * @fileoverview JavaScript Generator module.
   */

  /* eslint-disable */
  'use strict';

  Blockly.JavaScript = BlocklyJavaScript;
  return BlocklyJavaScript;
});

/***/ }),

/***/ 75107:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Do not edit this file; automatically generated by gulp.

/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15911)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  'use strict';

  Blockly.JavaScript = new Blockly.Generator("JavaScript");
  Blockly.JavaScript.addReservedWords("break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,new,return,super,switch,this,throw,try,typeof,var,void,while,with,yield,enum,implements,interface,let,package,private,protected,public,static,await,null,true,false,arguments," + Object.getOwnPropertyNames(Blockly.utils.global).join(","));
  Blockly.JavaScript.ORDER_ATOMIC = 0;
  Blockly.JavaScript.ORDER_NEW = 1.1;
  Blockly.JavaScript.ORDER_MEMBER = 1.2;
  Blockly.JavaScript.ORDER_FUNCTION_CALL = 2;
  Blockly.JavaScript.ORDER_INCREMENT = 3;
  Blockly.JavaScript.ORDER_DECREMENT = 3;
  Blockly.JavaScript.ORDER_BITWISE_NOT = 4.1;
  Blockly.JavaScript.ORDER_UNARY_PLUS = 4.2;
  Blockly.JavaScript.ORDER_UNARY_NEGATION = 4.3;
  Blockly.JavaScript.ORDER_LOGICAL_NOT = 4.4;
  Blockly.JavaScript.ORDER_TYPEOF = 4.5;
  Blockly.JavaScript.ORDER_VOID = 4.6;
  Blockly.JavaScript.ORDER_DELETE = 4.7;
  Blockly.JavaScript.ORDER_AWAIT = 4.8;
  Blockly.JavaScript.ORDER_EXPONENTIATION = 5;
  Blockly.JavaScript.ORDER_MULTIPLICATION = 5.1;
  Blockly.JavaScript.ORDER_DIVISION = 5.2;
  Blockly.JavaScript.ORDER_MODULUS = 5.3;
  Blockly.JavaScript.ORDER_SUBTRACTION = 6.1;
  Blockly.JavaScript.ORDER_ADDITION = 6.2;
  Blockly.JavaScript.ORDER_BITWISE_SHIFT = 7;
  Blockly.JavaScript.ORDER_RELATIONAL = 8;
  Blockly.JavaScript.ORDER_IN = 8;
  Blockly.JavaScript.ORDER_INSTANCEOF = 8;
  Blockly.JavaScript.ORDER_EQUALITY = 9;
  Blockly.JavaScript.ORDER_BITWISE_AND = 10;
  Blockly.JavaScript.ORDER_BITWISE_XOR = 11;
  Blockly.JavaScript.ORDER_BITWISE_OR = 12;
  Blockly.JavaScript.ORDER_LOGICAL_AND = 13;
  Blockly.JavaScript.ORDER_LOGICAL_OR = 14;
  Blockly.JavaScript.ORDER_CONDITIONAL = 15;
  Blockly.JavaScript.ORDER_ASSIGNMENT = 16;
  Blockly.JavaScript.ORDER_YIELD = 17;
  Blockly.JavaScript.ORDER_COMMA = 18;
  Blockly.JavaScript.ORDER_NONE = 99;
  Blockly.JavaScript.ORDER_OVERRIDES = [[Blockly.JavaScript.ORDER_FUNCTION_CALL, Blockly.JavaScript.ORDER_MEMBER], [Blockly.JavaScript.ORDER_FUNCTION_CALL, Blockly.JavaScript.ORDER_FUNCTION_CALL], [Blockly.JavaScript.ORDER_MEMBER, Blockly.JavaScript.ORDER_MEMBER], [Blockly.JavaScript.ORDER_MEMBER, Blockly.JavaScript.ORDER_FUNCTION_CALL], [Blockly.JavaScript.ORDER_LOGICAL_NOT, Blockly.JavaScript.ORDER_LOGICAL_NOT], [Blockly.JavaScript.ORDER_MULTIPLICATION, Blockly.JavaScript.ORDER_MULTIPLICATION], [Blockly.JavaScript.ORDER_ADDITION, Blockly.JavaScript.ORDER_ADDITION], [Blockly.JavaScript.ORDER_LOGICAL_AND, Blockly.JavaScript.ORDER_LOGICAL_AND], [Blockly.JavaScript.ORDER_LOGICAL_OR, Blockly.JavaScript.ORDER_LOGICAL_OR]];
  Blockly.JavaScript.isInitialized = !1;

  Blockly.JavaScript.init = function (a) {
    Blockly.JavaScript.definitions_ = Object.create(null);
    Blockly.JavaScript.functionNames_ = Object.create(null);
    Blockly.JavaScript.variableDB_ ? Blockly.JavaScript.variableDB_.reset() : Blockly.JavaScript.variableDB_ = new Blockly.Names(Blockly.JavaScript.RESERVED_WORDS_);
    Blockly.JavaScript.variableDB_.setVariableMap(a.getVariableMap());

    for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++) {
      b.push(Blockly.JavaScript.variableDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE));
    }

    a = Blockly.Variables.allUsedVarModels(a);

    for (d = 0; d < a.length; d++) {
      b.push(Blockly.JavaScript.variableDB_.getName(a[d].getId(), Blockly.VARIABLE_CATEGORY_NAME));
    }

    b.length && (Blockly.JavaScript.definitions_.variables = "var " + b.join(", ") + ";");
    this.isInitialized = !0;
  };

  Blockly.JavaScript.finish = function (a) {
    var b = [],
        c;

    for (c in Blockly.JavaScript.definitions_) {
      b.push(Blockly.JavaScript.definitions_[c]);
    }

    delete Blockly.JavaScript.definitions_;
    delete Blockly.JavaScript.functionNames_;
    Blockly.JavaScript.variableDB_.reset();
    return b.join("\n\n") + "\n\n\n" + a;
  };

  Blockly.JavaScript.scrubNakedValue = function (a) {
    return a + ";\n";
  };

  Blockly.JavaScript.quote_ = function (a) {
    a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/'/g, "\\'");
    return "'" + a + "'";
  };

  Blockly.JavaScript.multiline_quote_ = function (a) {
    return a.split(/\n/g).map(Blockly.JavaScript.quote_).join(" + '\\n' +\n");
  };

  Blockly.JavaScript.scrub_ = function (a, b, c) {
    var d = "";

    if (!a.outputConnection || !a.outputConnection.targetConnection) {
      var e = a.getCommentText();
      e && (e = Blockly.utils.string.wrap(e, Blockly.JavaScript.COMMENT_WRAP - 3), d += Blockly.JavaScript.prefixLines(e + "\n", "// "));

      for (var f = 0; f < a.inputList.length; f++) {
        a.inputList[f].type == Blockly.inputTypes.VALUE && (e = a.inputList[f].connection.targetBlock()) && (e = Blockly.JavaScript.allNestedComments(e)) && (d += Blockly.JavaScript.prefixLines(e, "// "));
      }
    }

    a = a.nextConnection && a.nextConnection.targetBlock();
    c = c ? "" : Blockly.JavaScript.blockToCode(a);
    return d + b + c;
  };

  Blockly.JavaScript.getAdjusted = function (a, b, c, d, e) {
    c = c || 0;
    e = e || Blockly.JavaScript.ORDER_NONE;
    a.workspace.options.oneBasedIndex && c--;
    var f = a.workspace.options.oneBasedIndex ? "1" : "0";
    a = 0 < c ? Blockly.JavaScript.valueToCode(a, b, Blockly.JavaScript.ORDER_ADDITION) || f : 0 > c ? Blockly.JavaScript.valueToCode(a, b, Blockly.JavaScript.ORDER_SUBTRACTION) || f : d ? Blockly.JavaScript.valueToCode(a, b, Blockly.JavaScript.ORDER_UNARY_NEGATION) || f : Blockly.JavaScript.valueToCode(a, b, e) || f;
    if (Blockly.isNumber(a)) a = Number(a) + c, d && (a = -a);else {
      if (0 < c) {
        a = a + " + " + c;
        var g = Blockly.JavaScript.ORDER_ADDITION;
      } else 0 > c && (a = a + " - " + -c, g = Blockly.JavaScript.ORDER_SUBTRACTION);

      d && (a = c ? "-(" + a + ")" : "-" + a, g = Blockly.JavaScript.ORDER_UNARY_NEGATION);
      g = Math.floor(g);
      e = Math.floor(e);
      g && e >= g && (a = "(" + a + ")");
    }
    return a;
  };

  Blockly.JavaScript.colour = {};

  Blockly.JavaScript.colour_picker = function (a) {
    return [Blockly.JavaScript.quote_(a.getFieldValue("COLOUR")), Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.colour_random = function (a) {
    return [Blockly.JavaScript.provideFunction_("colourRandom", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "() {", "  var num = Math.floor(Math.random() * Math.pow(2, 24));", "  return '#' + ('00000' + num.toString(16)).substr(-6);", "}"]) + "()", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.colour_rgb = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "RED", Blockly.JavaScript.ORDER_NONE) || 0,
        c = Blockly.JavaScript.valueToCode(a, "GREEN", Blockly.JavaScript.ORDER_NONE) || 0;
    a = Blockly.JavaScript.valueToCode(a, "BLUE", Blockly.JavaScript.ORDER_NONE) || 0;
    return [Blockly.JavaScript.provideFunction_("colourRgb", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b) {", "  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;", "  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;", "  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;", "  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);", "  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);", "  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);", "  return '#' + r + g + b;", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.colour_blend = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "COLOUR1", Blockly.JavaScript.ORDER_NONE) || "'#000000'",
        c = Blockly.JavaScript.valueToCode(a, "COLOUR2", Blockly.JavaScript.ORDER_NONE) || "'#000000'";
    a = Blockly.JavaScript.valueToCode(a, "RATIO", Blockly.JavaScript.ORDER_NONE) || .5;
    return [Blockly.JavaScript.provideFunction_("colourBlend", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(c1, c2, ratio) {", "  ratio = Math.max(Math.min(Number(ratio), 1), 0);", "  var r1 = parseInt(c1.substring(1, 3), 16);", "  var g1 = parseInt(c1.substring(3, 5), 16);", "  var b1 = parseInt(c1.substring(5, 7), 16);", "  var r2 = parseInt(c2.substring(1, 3), 16);", "  var g2 = parseInt(c2.substring(3, 5), 16);", "  var b2 = parseInt(c2.substring(5, 7), 16);", "  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);", "  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);", "  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);", "  r = ('0' + (r || 0).toString(16)).slice(-2);", "  g = ('0' + (g || 0).toString(16)).slice(-2);", "  b = ('0' + (b || 0).toString(16)).slice(-2);", "  return '#' + r + g + b;", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.lists = {};

  Blockly.JavaScript.lists_create_empty = function (a) {
    return ["[]", Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.lists_create_with = function (a) {
    for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) {
      b[c] = Blockly.JavaScript.valueToCode(a, "ADD" + c, Blockly.JavaScript.ORDER_NONE) || "null";
    }

    return ["[" + b.join(", ") + "]", Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.lists_repeat = function (a) {
    var b = Blockly.JavaScript.provideFunction_("listsRepeat", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(value, n) {", "  var array = [];", "  for (var i = 0; i < n; i++) {", "    array[i] = value;", "  }", "  return array;", "}"]),
        c = Blockly.JavaScript.valueToCode(a, "ITEM", Blockly.JavaScript.ORDER_NONE) || "null";
    a = Blockly.JavaScript.valueToCode(a, "NUM", Blockly.JavaScript.ORDER_NONE) || "0";
    return [b + "(" + c + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.lists_length = function (a) {
    return [(Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_MEMBER) || "[]") + ".length", Blockly.JavaScript.ORDER_MEMBER];
  };

  Blockly.JavaScript.lists_isEmpty = function (a) {
    return ["!" + (Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_MEMBER) || "[]") + ".length", Blockly.JavaScript.ORDER_LOGICAL_NOT];
  };

  Blockly.JavaScript.lists_indexOf = function (a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.JavaScript.valueToCode(a, "FIND", Blockly.JavaScript.ORDER_NONE) || "''";
    b = (Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_MEMBER) || "[]") + "." + b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.JavaScript.ORDER_ADDITION] : [b, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.lists_getIndex = function (a) {
    var b = a.getFieldValue("MODE") || "GET",
        c = a.getFieldValue("WHERE") || "FROM_START",
        d = Blockly.JavaScript.valueToCode(a, "VALUE", "RANDOM" == c ? Blockly.JavaScript.ORDER_NONE : Blockly.JavaScript.ORDER_MEMBER) || "[]";

    switch (c) {
      case "FIRST":
        if ("GET" == b) return [d + "[0]", Blockly.JavaScript.ORDER_MEMBER];
        if ("GET_REMOVE" == b) return [d + ".shift()", Blockly.JavaScript.ORDER_MEMBER];
        if ("REMOVE" == b) return d + ".shift();\n";
        break;

      case "LAST":
        if ("GET" == b) return [d + ".slice(-1)[0]", Blockly.JavaScript.ORDER_MEMBER];
        if ("GET_REMOVE" == b) return [d + ".pop()", Blockly.JavaScript.ORDER_MEMBER];
        if ("REMOVE" == b) return d + ".pop();\n";
        break;

      case "FROM_START":
        a = Blockly.JavaScript.getAdjusted(a, "AT");
        if ("GET" == b) return [d + "[" + a + "]", Blockly.JavaScript.ORDER_MEMBER];
        if ("GET_REMOVE" == b) return [d + ".splice(" + a + ", 1)[0]", Blockly.JavaScript.ORDER_FUNCTION_CALL];
        if ("REMOVE" == b) return d + ".splice(" + a + ", 1);\n";
        break;

      case "FROM_END":
        a = Blockly.JavaScript.getAdjusted(a, "AT", 1, !0);
        if ("GET" == b) return [d + ".slice(" + a + ")[0]", Blockly.JavaScript.ORDER_FUNCTION_CALL];
        if ("GET_REMOVE" == b) return [d + ".splice(" + a + ", 1)[0]", Blockly.JavaScript.ORDER_FUNCTION_CALL];
        if ("REMOVE" == b) return d + ".splice(" + a + ", 1);";
        break;

      case "RANDOM":
        d = Blockly.JavaScript.provideFunction_("listsGetRandomItem", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(list, remove) {", "  var x = Math.floor(Math.random() * list.length);", "  if (remove) {", "    return list.splice(x, 1)[0];", "  } else {", "    return list[x];", "  }", "}"]) + "(" + d + ", " + ("GET" != b) + ")";
        if ("GET" == b || "GET_REMOVE" == b) return [d, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        if ("REMOVE" == b) return d + ";\n";
    }

    throw Error("Unhandled combination (lists_getIndex).");
  };

  Blockly.JavaScript.lists_setIndex = function (a) {
    function b() {
      if (c.match(/^\w+$/)) return "";
      var g = Blockly.JavaScript.variableDB_.getDistinctName("tmpList", Blockly.VARIABLE_CATEGORY_NAME),
          h = "var " + g + " = " + c + ";\n";
      c = g;
      return h;
    }

    var c = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_MEMBER) || "[]",
        d = a.getFieldValue("MODE") || "GET",
        e = a.getFieldValue("WHERE") || "FROM_START",
        f = Blockly.JavaScript.valueToCode(a, "TO", Blockly.JavaScript.ORDER_ASSIGNMENT) || "null";

    switch (e) {
      case "FIRST":
        if ("SET" == d) return c + "[0] = " + f + ";\n";
        if ("INSERT" == d) return c + ".unshift(" + f + ");\n";
        break;

      case "LAST":
        if ("SET" == d) return a = b(), a + (c + "[" + c + ".length - 1] = " + f + ";\n");
        if ("INSERT" == d) return c + ".push(" + f + ");\n";
        break;

      case "FROM_START":
        e = Blockly.JavaScript.getAdjusted(a, "AT");
        if ("SET" == d) return c + "[" + e + "] = " + f + ";\n";
        if ("INSERT" == d) return c + ".splice(" + e + ", 0, " + f + ");\n";
        break;

      case "FROM_END":
        e = Blockly.JavaScript.getAdjusted(a, "AT", 1, !1, Blockly.JavaScript.ORDER_SUBTRACTION);
        a = b();
        if ("SET" == d) return a + (c + "[" + c + ".length - " + e + "] = " + f + ";\n");
        if ("INSERT" == d) return a + (c + ".splice(" + c + ".length - " + e + ", 0, " + f + ");\n");
        break;

      case "RANDOM":
        a = b();
        e = Blockly.JavaScript.variableDB_.getDistinctName("tmpX", Blockly.VARIABLE_CATEGORY_NAME);
        a += "var " + e + " = Math.floor(Math.random() * " + c + ".length);\n";
        if ("SET" == d) return a + (c + "[" + e + "] = " + f + ";\n");
        if ("INSERT" == d) return a + (c + ".splice(" + e + ", 0, " + f + ");\n");
    }

    throw Error("Unhandled combination (lists_setIndex).");
  };

  Blockly.JavaScript.lists.getIndex_ = function (a, b, c) {
    return "FIRST" == b ? "0" : "FROM_END" == b ? a + ".length - 1 - " + c : "LAST" == b ? a + ".length - 1" : c;
  };

  Blockly.JavaScript.lists_getSublist = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_MEMBER) || "[]",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2");
    if ("FIRST" == c && "LAST" == d) b += ".slice(0)";else if (b.match(/^\w+$/) || "FROM_END" != c && "FROM_START" == d) {
      switch (c) {
        case "FROM_START":
          var e = Blockly.JavaScript.getAdjusted(a, "AT1");
          break;

        case "FROM_END":
          e = Blockly.JavaScript.getAdjusted(a, "AT1", 1, !1, Blockly.JavaScript.ORDER_SUBTRACTION);
          e = b + ".length - " + e;
          break;

        case "FIRST":
          e = "0";
          break;

        default:
          throw Error("Unhandled option (lists_getSublist).");
      }

      switch (d) {
        case "FROM_START":
          a = Blockly.JavaScript.getAdjusted(a, "AT2", 1);
          break;

        case "FROM_END":
          a = Blockly.JavaScript.getAdjusted(a, "AT2", 0, !1, Blockly.JavaScript.ORDER_SUBTRACTION);
          a = b + ".length - " + a;
          break;

        case "LAST":
          a = b + ".length";
          break;

        default:
          throw Error("Unhandled option (lists_getSublist).");
      }

      b = b + ".slice(" + e + ", " + a + ")";
    } else {
      e = Blockly.JavaScript.getAdjusted(a, "AT1");
      a = Blockly.JavaScript.getAdjusted(a, "AT2");
      var f = Blockly.JavaScript.lists.getIndex_,
          g = {
        FIRST: "First",
        LAST: "Last",
        FROM_START: "FromStart",
        FROM_END: "FromEnd"
      };
      b = Blockly.JavaScript.provideFunction_("subsequence" + g[c] + g[d], ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + ("FROM_END" == c || "FROM_START" == c ? ", at1" : "") + ("FROM_END" == d || "FROM_START" == d ? ", at2" : "") + ") {", "  var start = " + f("sequence", c, "at1") + ";", "  var end = " + f("sequence", d, "at2") + " + 1;", "  return sequence.slice(start, end);", "}"]) + "(" + b + ("FROM_END" == c || "FROM_START" == c ? ", " + e : "") + ("FROM_END" == d || "FROM_START" == d ? ", " + a : "") + ")";
    }
    return [b, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.lists_sort = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_FUNCTION_CALL) || "[]",
        c = "1" === a.getFieldValue("DIRECTION") ? 1 : -1;
    a = a.getFieldValue("TYPE");
    var d = Blockly.JavaScript.provideFunction_("listsGetSortCompare", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(type, direction) {", "  var compareFuncs = {", '    "NUMERIC": function(a, b) {', "        return Number(a) - Number(b); },", '    "TEXT": function(a, b) {', "        return a.toString() > b.toString() ? 1 : -1; },", '    "IGNORE_CASE": function(a, b) {', "        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },", "  };", "  var compare = compareFuncs[type];", "  return function(a, b) { return compare(a, b) * direction; }", "}"]);
    return [b + ".slice().sort(" + d + '("' + a + '", ' + c + "))", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.lists_split = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "INPUT", Blockly.JavaScript.ORDER_MEMBER),
        c = Blockly.JavaScript.valueToCode(a, "DELIM", Blockly.JavaScript.ORDER_NONE) || "''";
    a = a.getFieldValue("MODE");
    if ("SPLIT" == a) b || (b = "''"), a = "split";else if ("JOIN" == a) b || (b = "[]"), a = "join";else throw Error("Unknown mode: " + a);
    return [b + "." + a + "(" + c + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.lists_reverse = function (a) {
    return [(Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_FUNCTION_CALL) || "[]") + ".slice().reverse()", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.logic = {};

  Blockly.JavaScript.controls_if = function (a) {
    var b = 0,
        c = "";
    Blockly.JavaScript.STATEMENT_PREFIX && (c += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX, a));

    do {
      var d = Blockly.JavaScript.valueToCode(a, "IF" + b, Blockly.JavaScript.ORDER_NONE) || "false";
      var e = Blockly.JavaScript.statementToCode(a, "DO" + b);
      Blockly.JavaScript.STATEMENT_SUFFIX && (e = Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX, a), Blockly.JavaScript.INDENT) + e);
      c += (0 < b ? " else " : "") + "if (" + d + ") {\n" + e + "}";
      ++b;
    } while (a.getInput("IF" + b));

    if (a.getInput("ELSE") || Blockly.JavaScript.STATEMENT_SUFFIX) e = Blockly.JavaScript.statementToCode(a, "ELSE"), Blockly.JavaScript.STATEMENT_SUFFIX && (e = Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX, a), Blockly.JavaScript.INDENT) + e), c += " else {\n" + e + "}";
    return c + "\n";
  };

  Blockly.JavaScript.controls_ifelse = Blockly.JavaScript.controls_if;

  Blockly.JavaScript.logic_compare = function (a) {
    var b = {
      EQ: "==",
      NEQ: "!=",
      LT: "<",
      LTE: "<=",
      GT: ">",
      GTE: ">="
    }[a.getFieldValue("OP")],
        c = "==" == b || "!=" == b ? Blockly.JavaScript.ORDER_EQUALITY : Blockly.JavaScript.ORDER_RELATIONAL,
        d = Blockly.JavaScript.valueToCode(a, "A", c) || "0";
    a = Blockly.JavaScript.valueToCode(a, "B", c) || "0";
    return [d + " " + b + " " + a, c];
  };

  Blockly.JavaScript.logic_operation = function (a) {
    var b = "AND" == a.getFieldValue("OP") ? "&&" : "||",
        c = "&&" == b ? Blockly.JavaScript.ORDER_LOGICAL_AND : Blockly.JavaScript.ORDER_LOGICAL_OR,
        d = Blockly.JavaScript.valueToCode(a, "A", c);
    a = Blockly.JavaScript.valueToCode(a, "B", c);

    if (d || a) {
      var e = "&&" == b ? "true" : "false";
      d || (d = e);
      a || (a = e);
    } else a = d = "false";

    return [d + " " + b + " " + a, c];
  };

  Blockly.JavaScript.logic_negate = function (a) {
    var b = Blockly.JavaScript.ORDER_LOGICAL_NOT;
    return ["!" + (Blockly.JavaScript.valueToCode(a, "BOOL", b) || "true"), b];
  };

  Blockly.JavaScript.logic_boolean = function (a) {
    return ["TRUE" == a.getFieldValue("BOOL") ? "true" : "false", Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.logic_null = function (a) {
    return ["null", Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.logic_ternary = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "IF", Blockly.JavaScript.ORDER_CONDITIONAL) || "false",
        c = Blockly.JavaScript.valueToCode(a, "THEN", Blockly.JavaScript.ORDER_CONDITIONAL) || "null";
    a = Blockly.JavaScript.valueToCode(a, "ELSE", Blockly.JavaScript.ORDER_CONDITIONAL) || "null";
    return [b + " ? " + c + " : " + a, Blockly.JavaScript.ORDER_CONDITIONAL];
  };

  Blockly.JavaScript.loops = {};

  Blockly.JavaScript.controls_repeat_ext = function (a) {
    var b = a.getField("TIMES") ? String(Number(a.getFieldValue("TIMES"))) : Blockly.JavaScript.valueToCode(a, "TIMES", Blockly.JavaScript.ORDER_ASSIGNMENT) || "0",
        c = Blockly.JavaScript.statementToCode(a, "DO");
    c = Blockly.JavaScript.addLoopTrap(c, a);
    a = "";
    var d = Blockly.JavaScript.variableDB_.getDistinctName("count", Blockly.VARIABLE_CATEGORY_NAME),
        e = b;
    b.match(/^\w+$/) || Blockly.isNumber(b) || (e = Blockly.JavaScript.variableDB_.getDistinctName("repeat_end", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + e + " = " + b + ";\n");
    return a + ("for (var " + d + " = 0; " + d + " < " + e + "; " + d + "++) {\n" + c + "}\n");
  };

  Blockly.JavaScript.controls_repeat = Blockly.JavaScript.controls_repeat_ext;

  Blockly.JavaScript.controls_whileUntil = function (a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly.JavaScript.valueToCode(a, "BOOL", b ? Blockly.JavaScript.ORDER_LOGICAL_NOT : Blockly.JavaScript.ORDER_NONE) || "false",
        d = Blockly.JavaScript.statementToCode(a, "DO");
    d = Blockly.JavaScript.addLoopTrap(d, a);
    b && (c = "!" + c);
    return "while (" + c + ") {\n" + d + "}\n";
  };

  Blockly.JavaScript.controls_for = function (a) {
    var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
        c = Blockly.JavaScript.valueToCode(a, "FROM", Blockly.JavaScript.ORDER_ASSIGNMENT) || "0",
        d = Blockly.JavaScript.valueToCode(a, "TO", Blockly.JavaScript.ORDER_ASSIGNMENT) || "0",
        e = Blockly.JavaScript.valueToCode(a, "BY", Blockly.JavaScript.ORDER_ASSIGNMENT) || "1",
        f = Blockly.JavaScript.statementToCode(a, "DO");
    f = Blockly.JavaScript.addLoopTrap(f, a);

    if (Blockly.isNumber(c) && Blockly.isNumber(d) && Blockly.isNumber(e)) {
      var g = Number(c) <= Number(d);
      a = "for (" + b + " = " + c + "; " + b + (g ? " <= " : " >= ") + d + "; " + b;
      b = Math.abs(Number(e));
      a = (1 == b ? a + (g ? "++" : "--") : a + ((g ? " += " : " -= ") + b)) + (") {\n" + f + "}\n");
    } else a = "", g = c, c.match(/^\w+$/) || Blockly.isNumber(c) || (g = Blockly.JavaScript.variableDB_.getDistinctName(b + "_start", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + g + " = " + c + ";\n"), c = d, d.match(/^\w+$/) || Blockly.isNumber(d) || (c = Blockly.JavaScript.variableDB_.getDistinctName(b + "_end", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + c + " = " + d + ";\n"), d = Blockly.JavaScript.variableDB_.getDistinctName(b + "_inc", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + d + " = ", a = Blockly.isNumber(e) ? a + (Math.abs(e) + ";\n") : a + ("Math.abs(" + e + ");\n"), a = a + ("if (" + g + " > " + c + ") {\n") + (Blockly.JavaScript.INDENT + d + " = -" + d + ";\n"), a += "}\n", a += "for (" + b + " = " + g + "; " + d + " >= 0 ? " + b + " <= " + c + " : " + b + " >= " + c + "; " + b + " += " + d + ") {\n" + f + "}\n";

    return a;
  };

  Blockly.JavaScript.controls_forEach = function (a) {
    var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
        c = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_ASSIGNMENT) || "[]",
        d = Blockly.JavaScript.statementToCode(a, "DO");
    d = Blockly.JavaScript.addLoopTrap(d, a);
    a = "";
    var e = c;
    c.match(/^\w+$/) || (e = Blockly.JavaScript.variableDB_.getDistinctName(b + "_list", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + e + " = " + c + ";\n");
    c = Blockly.JavaScript.variableDB_.getDistinctName(b + "_index", Blockly.VARIABLE_CATEGORY_NAME);
    d = Blockly.JavaScript.INDENT + b + " = " + e + "[" + c + "];\n" + d;
    return a + ("for (var " + c + " in " + e + ") {\n" + d + "}\n");
  };

  Blockly.JavaScript.controls_flow_statements = function (a) {
    var b = "";
    Blockly.JavaScript.STATEMENT_PREFIX && (b += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX, a));
    Blockly.JavaScript.STATEMENT_SUFFIX && (b += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX, a));

    if (Blockly.JavaScript.STATEMENT_PREFIX) {
      var c = Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(a);
      c && !c.suppressPrefixSuffix && (b += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX, c));
    }

    switch (a.getFieldValue("FLOW")) {
      case "BREAK":
        return b + "break;\n";

      case "CONTINUE":
        return b + "continue;\n";
    }

    throw Error("Unknown flow statement.");
  };

  Blockly.JavaScript.math = {};

  Blockly.JavaScript.math_number = function (a) {
    a = Number(a.getFieldValue("NUM"));
    return [a, 0 <= a ? Blockly.JavaScript.ORDER_ATOMIC : Blockly.JavaScript.ORDER_UNARY_NEGATION];
  };

  Blockly.JavaScript.math_arithmetic = function (a) {
    var b = {
      ADD: [" + ", Blockly.JavaScript.ORDER_ADDITION],
      MINUS: [" - ", Blockly.JavaScript.ORDER_SUBTRACTION],
      MULTIPLY: [" * ", Blockly.JavaScript.ORDER_MULTIPLICATION],
      DIVIDE: [" / ", Blockly.JavaScript.ORDER_DIVISION],
      POWER: [null, Blockly.JavaScript.ORDER_NONE]
    }[a.getFieldValue("OP")],
        c = b[0];
    b = b[1];
    var d = Blockly.JavaScript.valueToCode(a, "A", b) || "0";
    a = Blockly.JavaScript.valueToCode(a, "B", b) || "0";
    return c ? [d + c + a, b] : ["Math.pow(" + d + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.math_single = function (a) {
    var b = a.getFieldValue("OP");
    if ("NEG" == b) return a = Blockly.JavaScript.valueToCode(a, "NUM", Blockly.JavaScript.ORDER_UNARY_NEGATION) || "0", "-" == a[0] && (a = " " + a), ["-" + a, Blockly.JavaScript.ORDER_UNARY_NEGATION];
    a = "SIN" == b || "COS" == b || "TAN" == b ? Blockly.JavaScript.valueToCode(a, "NUM", Blockly.JavaScript.ORDER_DIVISION) || "0" : Blockly.JavaScript.valueToCode(a, "NUM", Blockly.JavaScript.ORDER_NONE) || "0";

    switch (b) {
      case "ABS":
        var c = "Math.abs(" + a + ")";
        break;

      case "ROOT":
        c = "Math.sqrt(" + a + ")";
        break;

      case "LN":
        c = "Math.log(" + a + ")";
        break;

      case "EXP":
        c = "Math.exp(" + a + ")";
        break;

      case "POW10":
        c = "Math.pow(10," + a + ")";
        break;

      case "ROUND":
        c = "Math.round(" + a + ")";
        break;

      case "ROUNDUP":
        c = "Math.ceil(" + a + ")";
        break;

      case "ROUNDDOWN":
        c = "Math.floor(" + a + ")";
        break;

      case "SIN":
        c = "Math.sin(" + a + " / 180 * Math.PI)";
        break;

      case "COS":
        c = "Math.cos(" + a + " / 180 * Math.PI)";
        break;

      case "TAN":
        c = "Math.tan(" + a + " / 180 * Math.PI)";
    }

    if (c) return [c, Blockly.JavaScript.ORDER_FUNCTION_CALL];

    switch (b) {
      case "LOG10":
        c = "Math.log(" + a + ") / Math.log(10)";
        break;

      case "ASIN":
        c = "Math.asin(" + a + ") / Math.PI * 180";
        break;

      case "ACOS":
        c = "Math.acos(" + a + ") / Math.PI * 180";
        break;

      case "ATAN":
        c = "Math.atan(" + a + ") / Math.PI * 180";
        break;

      default:
        throw Error("Unknown math operator: " + b);
    }

    return [c, Blockly.JavaScript.ORDER_DIVISION];
  };

  Blockly.JavaScript.math_constant = function (a) {
    return {
      PI: ["Math.PI", Blockly.JavaScript.ORDER_MEMBER],
      E: ["Math.E", Blockly.JavaScript.ORDER_MEMBER],
      GOLDEN_RATIO: ["(1 + Math.sqrt(5)) / 2", Blockly.JavaScript.ORDER_DIVISION],
      SQRT2: ["Math.SQRT2", Blockly.JavaScript.ORDER_MEMBER],
      SQRT1_2: ["Math.SQRT1_2", Blockly.JavaScript.ORDER_MEMBER],
      INFINITY: ["Infinity", Blockly.JavaScript.ORDER_ATOMIC]
    }[a.getFieldValue("CONSTANT")];
  };

  Blockly.JavaScript.math_number_property = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "NUMBER_TO_CHECK", Blockly.JavaScript.ORDER_MODULUS) || "0",
        c = a.getFieldValue("PROPERTY");
    if ("PRIME" == c) return [Blockly.JavaScript.provideFunction_("mathIsPrime", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(n) {", "  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods", "  if (n == 2 || n == 3) {", "    return true;", "  }", "  // False if n is NaN, negative, is 1, or not whole.", "  // And false if n is divisible by 2 or 3.", "  if (isNaN(n) || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {", "    return false;", "  }", "  // Check all the numbers of form 6k +/- 1, up to sqrt(n).", "  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {", "    if (n % (x - 1) == 0 || n % (x + 1) == 0) {", "      return false;", "    }", "  }", "  return true;", "}"]) + "(" + b + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];

    switch (c) {
      case "EVEN":
        var d = b + " % 2 == 0";
        break;

      case "ODD":
        d = b + " % 2 == 1";
        break;

      case "WHOLE":
        d = b + " % 1 == 0";
        break;

      case "POSITIVE":
        d = b + " > 0";
        break;

      case "NEGATIVE":
        d = b + " < 0";
        break;

      case "DIVISIBLE_BY":
        a = Blockly.JavaScript.valueToCode(a, "DIVISOR", Blockly.JavaScript.ORDER_MODULUS) || "0", d = b + " % " + a + " == 0";
    }

    return [d, Blockly.JavaScript.ORDER_EQUALITY];
  };

  Blockly.JavaScript.math_change = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "DELTA", Blockly.JavaScript.ORDER_ADDITION) || "0";
    a = Blockly.JavaScript.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
    return a + " = (typeof " + a + " == 'number' ? " + a + " : 0) + " + b + ";\n";
  };

  Blockly.JavaScript.math_round = Blockly.JavaScript.math_single;
  Blockly.JavaScript.math_trig = Blockly.JavaScript.math_single;

  Blockly.JavaScript.math_on_list = function (a) {
    var b = a.getFieldValue("OP");

    switch (b) {
      case "SUM":
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_MEMBER) || "[]";
        a += ".reduce(function(x, y) {return x + y;})";
        break;

      case "MIN":
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = "Math.min.apply(null, " + a + ")";
        break;

      case "MAX":
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = "Math.max.apply(null, " + a + ")";
        break;

      case "AVERAGE":
        b = Blockly.JavaScript.provideFunction_("mathMean", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {", "  return myList.reduce(function(x, y) {return x + y;}) / myList.length;", "}"]);
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = b + "(" + a + ")";
        break;

      case "MEDIAN":
        b = Blockly.JavaScript.provideFunction_("mathMedian", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {", "  var localList = myList.filter(function (x) {return typeof x == 'number';});", "  if (!localList.length) return null;", "  localList.sort(function(a, b) {return b - a;});", "  if (localList.length % 2 == 0) {", "    return (localList[localList.length / 2 - 1] + localList[localList.length / 2]) / 2;", "  } else {", "    return localList[(localList.length - 1) / 2];", "  }", "}"]);
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = b + "(" + a + ")";
        break;

      case "MODE":
        b = Blockly.JavaScript.provideFunction_("mathModes", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(values) {", "  var modes = [];", "  var counts = [];", "  var maxCount = 0;", "  for (var i = 0; i < values.length; i++) {", "    var value = values[i];", "    var found = false;", "    var thisCount;", "    for (var j = 0; j < counts.length; j++) {", "      if (counts[j][0] === value) {", "        thisCount = ++counts[j][1];", "        found = true;", "        break;", "      }", "    }", "    if (!found) {", "      counts.push([value, 1]);", "      thisCount = 1;", "    }", "    maxCount = Math.max(thisCount, maxCount);", "  }", "  for (var j = 0; j < counts.length; j++) {", "    if (counts[j][1] == maxCount) {", "        modes.push(counts[j][0]);", "    }", "  }", "  return modes;", "}"]);
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = b + "(" + a + ")";
        break;

      case "STD_DEV":
        b = Blockly.JavaScript.provideFunction_("mathStandardDeviation", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(numbers) {", "  var n = numbers.length;", "  if (!n) return null;", "  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;", "  var variance = 0;", "  for (var j = 0; j < n; j++) {", "    variance += Math.pow(numbers[j] - mean, 2);", "  }", "  variance = variance / n;", "  return Math.sqrt(variance);", "}"]);
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = b + "(" + a + ")";
        break;

      case "RANDOM":
        b = Blockly.JavaScript.provideFunction_("mathRandomList", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(list) {", "  var x = Math.floor(Math.random() * list.length);", "  return list[x];", "}"]);
        a = Blockly.JavaScript.valueToCode(a, "LIST", Blockly.JavaScript.ORDER_NONE) || "[]";
        a = b + "(" + a + ")";
        break;

      default:
        throw Error("Unknown operator: " + b);
    }

    return [a, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.math_modulo = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "DIVIDEND", Blockly.JavaScript.ORDER_MODULUS) || "0";
    a = Blockly.JavaScript.valueToCode(a, "DIVISOR", Blockly.JavaScript.ORDER_MODULUS) || "0";
    return [b + " % " + a, Blockly.JavaScript.ORDER_MODULUS];
  };

  Blockly.JavaScript.math_constrain = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_NONE) || "0",
        c = Blockly.JavaScript.valueToCode(a, "LOW", Blockly.JavaScript.ORDER_NONE) || "0";
    a = Blockly.JavaScript.valueToCode(a, "HIGH", Blockly.JavaScript.ORDER_NONE) || "Infinity";
    return ["Math.min(Math.max(" + b + ", " + c + "), " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.math_random_int = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "FROM", Blockly.JavaScript.ORDER_NONE) || "0";
    a = Blockly.JavaScript.valueToCode(a, "TO", Blockly.JavaScript.ORDER_NONE) || "0";
    return [Blockly.JavaScript.provideFunction_("mathRandomInt", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(a, b) {", "  if (a > b) {", "    // Swap a and b to ensure a is smaller.", "    var c = a;", "    a = b;", "    b = c;", "  }", "  return Math.floor(Math.random() * (b - a + 1) + a);", "}"]) + "(" + b + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.math_random_float = function (a) {
    return ["Math.random()", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.math_atan2 = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "X", Blockly.JavaScript.ORDER_NONE) || "0";
    return ["Math.atan2(" + (Blockly.JavaScript.valueToCode(a, "Y", Blockly.JavaScript.ORDER_NONE) || "0") + ", " + b + ") / Math.PI * 180", Blockly.JavaScript.ORDER_DIVISION];
  };

  Blockly.JavaScript.procedures = {};

  Blockly.JavaScript.procedures_defreturn = function (a) {
    var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME),
        c = "";
    Blockly.JavaScript.STATEMENT_PREFIX && (c += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX, a));
    Blockly.JavaScript.STATEMENT_SUFFIX && (c += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX, a));
    c && (c = Blockly.JavaScript.prefixLines(c, Blockly.JavaScript.INDENT));
    var d = "";
    Blockly.JavaScript.INFINITE_LOOP_TRAP && (d = Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.INFINITE_LOOP_TRAP, a), Blockly.JavaScript.INDENT));
    var e = Blockly.JavaScript.statementToCode(a, "STACK"),
        f = Blockly.JavaScript.valueToCode(a, "RETURN", Blockly.JavaScript.ORDER_NONE) || "",
        g = "";
    e && f && (g = c);
    f && (f = Blockly.JavaScript.INDENT + "return " + f + ";\n");

    for (var h = [], l = a.getVars(), k = 0; k < l.length; k++) {
      h[k] = Blockly.JavaScript.variableDB_.getName(l[k], Blockly.VARIABLE_CATEGORY_NAME);
    }

    c = "function " + b + "(" + h.join(", ") + ") {\n" + c + d + e + g + f + "}";
    c = Blockly.JavaScript.scrub_(a, c);
    Blockly.JavaScript.definitions_["%" + b] = c;
    return null;
  };

  Blockly.JavaScript.procedures_defnoreturn = Blockly.JavaScript.procedures_defreturn;

  Blockly.JavaScript.procedures_callreturn = function (a) {
    for (var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = [], d = a.getVars(), e = 0; e < d.length; e++) {
      c[e] = Blockly.JavaScript.valueToCode(a, "ARG" + e, Blockly.JavaScript.ORDER_NONE) || "null";
    }

    return [b + "(" + c.join(", ") + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.procedures_callnoreturn = function (a) {
    return Blockly.JavaScript.procedures_callreturn(a)[0] + ";\n";
  };

  Blockly.JavaScript.procedures_ifreturn = function (a) {
    var b = "if (" + (Blockly.JavaScript.valueToCode(a, "CONDITION", Blockly.JavaScript.ORDER_NONE) || "false") + ") {\n";
    Blockly.JavaScript.STATEMENT_SUFFIX && (b += Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX, a), Blockly.JavaScript.INDENT));
    a.hasReturnValue_ ? (a = Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_NONE) || "null", b += Blockly.JavaScript.INDENT + "return " + a + ";\n") : b += Blockly.JavaScript.INDENT + "return;\n";
    return b + "}\n";
  };

  Blockly.JavaScript.texts = {};

  Blockly.JavaScript.text = function (a) {
    return [Blockly.JavaScript.quote_(a.getFieldValue("TEXT")), Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.text_multiline = function (a) {
    a = Blockly.JavaScript.multiline_quote_(a.getFieldValue("TEXT"));
    var b = -1 != a.indexOf("+") ? Blockly.JavaScript.ORDER_ADDITION : Blockly.JavaScript.ORDER_ATOMIC;
    return [a, b];
  };

  Blockly.JavaScript.text.forceString_ = function (a) {
    return Blockly.JavaScript.text.forceString_.strRegExp.test(a) ? [a, Blockly.JavaScript.ORDER_ATOMIC] : ["String(" + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text.forceString_.strRegExp = /^\s*'([^']|\\')*'\s*$/;

  Blockly.JavaScript.text_join = function (a) {
    switch (a.itemCount_) {
      case 0:
        return ["''", Blockly.JavaScript.ORDER_ATOMIC];

      case 1:
        return a = Blockly.JavaScript.valueToCode(a, "ADD0", Blockly.JavaScript.ORDER_NONE) || "''", Blockly.JavaScript.text.forceString_(a);

      case 2:
        var b = Blockly.JavaScript.valueToCode(a, "ADD0", Blockly.JavaScript.ORDER_NONE) || "''";
        a = Blockly.JavaScript.valueToCode(a, "ADD1", Blockly.JavaScript.ORDER_NONE) || "''";
        a = Blockly.JavaScript.text.forceString_(b)[0] + " + " + Blockly.JavaScript.text.forceString_(a)[0];
        return [a, Blockly.JavaScript.ORDER_ADDITION];

      default:
        b = Array(a.itemCount_);

        for (var c = 0; c < a.itemCount_; c++) {
          b[c] = Blockly.JavaScript.valueToCode(a, "ADD" + c, Blockly.JavaScript.ORDER_NONE) || "''";
        }

        a = "[" + b.join(",") + "].join('')";
        return [a, Blockly.JavaScript.ORDER_FUNCTION_CALL];
    }
  };

  Blockly.JavaScript.text_append = function (a) {
    var b = Blockly.JavaScript.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
    a = Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_NONE) || "''";
    return b + " += " + Blockly.JavaScript.text.forceString_(a)[0] + ";\n";
  };

  Blockly.JavaScript.text_length = function (a) {
    return [(Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_MEMBER) || "''") + ".length", Blockly.JavaScript.ORDER_MEMBER];
  };

  Blockly.JavaScript.text_isEmpty = function (a) {
    return ["!" + (Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_MEMBER) || "''") + ".length", Blockly.JavaScript.ORDER_LOGICAL_NOT];
  };

  Blockly.JavaScript.text_indexOf = function (a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.JavaScript.valueToCode(a, "FIND", Blockly.JavaScript.ORDER_NONE) || "''";
    b = (Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_MEMBER) || "''") + "." + b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.JavaScript.ORDER_ADDITION] : [b, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_charAt = function (a) {
    var b = a.getFieldValue("WHERE") || "FROM_START",
        c = Blockly.JavaScript.valueToCode(a, "VALUE", "RANDOM" == b ? Blockly.JavaScript.ORDER_NONE : Blockly.JavaScript.ORDER_MEMBER) || "''";

    switch (b) {
      case "FIRST":
        return [c + ".charAt(0)", Blockly.JavaScript.ORDER_FUNCTION_CALL];

      case "LAST":
        return [c + ".slice(-1)", Blockly.JavaScript.ORDER_FUNCTION_CALL];

      case "FROM_START":
        return a = Blockly.JavaScript.getAdjusted(a, "AT"), [c + ".charAt(" + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];

      case "FROM_END":
        return a = Blockly.JavaScript.getAdjusted(a, "AT", 1, !0), [c + ".slice(" + a + ").charAt(0)", Blockly.JavaScript.ORDER_FUNCTION_CALL];

      case "RANDOM":
        return [Blockly.JavaScript.provideFunction_("textRandomLetter", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(text) {", "  var x = Math.floor(Math.random() * text.length);", "  return text[x];", "}"]) + "(" + c + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
    }

    throw Error("Unhandled option (text_charAt).");
  };

  Blockly.JavaScript.text.getIndex_ = function (a, b, c) {
    return "FIRST" == b ? "0" : "FROM_END" == b ? a + ".length - 1 - " + c : "LAST" == b ? a + ".length - 1" : c;
  };

  Blockly.JavaScript.text_getSubstring = function (a) {
    var b = a.getFieldValue("WHERE1"),
        c = a.getFieldValue("WHERE2"),
        d = "FROM_END" != b && "LAST" != b && "FROM_END" != c && "LAST" != c,
        e = Blockly.JavaScript.valueToCode(a, "STRING", d ? Blockly.JavaScript.ORDER_MEMBER : Blockly.JavaScript.ORDER_NONE) || "''";
    if ("FIRST" == b && "LAST" == c) return [e, Blockly.JavaScript.ORDER_NONE];

    if (e.match(/^'?\w+'?$/) || d) {
      switch (b) {
        case "FROM_START":
          d = Blockly.JavaScript.getAdjusted(a, "AT1");
          break;

        case "FROM_END":
          d = Blockly.JavaScript.getAdjusted(a, "AT1", 1, !1, Blockly.JavaScript.ORDER_SUBTRACTION);
          d = e + ".length - " + d;
          break;

        case "FIRST":
          d = "0";
          break;

        default:
          throw Error("Unhandled option (text_getSubstring).");
      }

      switch (c) {
        case "FROM_START":
          a = Blockly.JavaScript.getAdjusted(a, "AT2", 1);
          break;

        case "FROM_END":
          a = Blockly.JavaScript.getAdjusted(a, "AT2", 0, !1, Blockly.JavaScript.ORDER_SUBTRACTION);
          a = e + ".length - " + a;
          break;

        case "LAST":
          a = e + ".length";
          break;

        default:
          throw Error("Unhandled option (text_getSubstring).");
      }

      b = e + ".slice(" + d + ", " + a + ")";
    } else {
      d = Blockly.JavaScript.getAdjusted(a, "AT1");
      a = Blockly.JavaScript.getAdjusted(a, "AT2");
      var f = Blockly.JavaScript.text.getIndex_,
          g = {
        FIRST: "First",
        LAST: "Last",
        FROM_START: "FromStart",
        FROM_END: "FromEnd"
      };
      b = Blockly.JavaScript.provideFunction_("subsequence" + g[b] + g[c], ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + ("FROM_END" == b || "FROM_START" == b ? ", at1" : "") + ("FROM_END" == c || "FROM_START" == c ? ", at2" : "") + ") {", "  var start = " + f("sequence", b, "at1") + ";", "  var end = " + f("sequence", c, "at2") + " + 1;", "  return sequence.slice(start, end);", "}"]) + "(" + e + ("FROM_END" == b || "FROM_START" == b ? ", " + d : "") + ("FROM_END" == c || "FROM_START" == c ? ", " + a : "") + ")";
    }

    return [b, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_changeCase = function (a) {
    var b = {
      UPPERCASE: ".toUpperCase()",
      LOWERCASE: ".toLowerCase()",
      TITLECASE: null
    }[a.getFieldValue("CASE")];
    a = Blockly.JavaScript.valueToCode(a, "TEXT", b ? Blockly.JavaScript.ORDER_MEMBER : Blockly.JavaScript.ORDER_NONE) || "''";
    return [b ? a + b : Blockly.JavaScript.provideFunction_("textToTitleCase", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(str) {", "  return str.replace(/\\S+/g,", "      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});", "}"]) + "(" + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_trim = function (a) {
    var b = {
      LEFT: ".replace(/^[\\s\\xa0]+/, '')",
      RIGHT: ".replace(/[\\s\\xa0]+$/, '')",
      BOTH: ".trim()"
    }[a.getFieldValue("MODE")];
    return [(Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_MEMBER) || "''") + b, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_print = function (a) {
    return "window.alert(" + (Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_NONE) || "''") + ");\n";
  };

  Blockly.JavaScript.text_prompt_ext = function (a) {
    var b = "window.prompt(" + (a.getField("TEXT") ? Blockly.JavaScript.quote_(a.getFieldValue("TEXT")) : Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_NONE) || "''") + ")";
    "NUMBER" == a.getFieldValue("TYPE") && (b = "Number(" + b + ")");
    return [b, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_prompt = Blockly.JavaScript.text_prompt_ext;

  Blockly.JavaScript.text_count = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_NONE) || "''";
    a = Blockly.JavaScript.valueToCode(a, "SUB", Blockly.JavaScript.ORDER_NONE) || "''";
    return [Blockly.JavaScript.provideFunction_("textCount", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle) {", "  if (needle.length === 0) {", "    return haystack.length + 1;", "  } else {", "    return haystack.split(needle).length - 1;", "  }", "}"]) + "(" + b + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_replace = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_NONE) || "''",
        c = Blockly.JavaScript.valueToCode(a, "FROM", Blockly.JavaScript.ORDER_NONE) || "''";
    a = Blockly.JavaScript.valueToCode(a, "TO", Blockly.JavaScript.ORDER_NONE) || "''";
    return [Blockly.JavaScript.provideFunction_("textReplace", ["function " + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle, replacement) {", '  needle = needle.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,"\\\\$1")', '                 .replace(/\\x08/g,"\\\\x08");', "  return haystack.replace(new RegExp(needle, 'g'), replacement);", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.text_reverse = function (a) {
    return [(Blockly.JavaScript.valueToCode(a, "TEXT", Blockly.JavaScript.ORDER_MEMBER) || "''") + ".split('').reverse().join('')", Blockly.JavaScript.ORDER_FUNCTION_CALL];
  };

  Blockly.JavaScript.variables = {};

  Blockly.JavaScript.variables_get = function (a) {
    return [Blockly.JavaScript.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.JavaScript.ORDER_ATOMIC];
  };

  Blockly.JavaScript.variables_set = function (a) {
    var b = Blockly.JavaScript.valueToCode(a, "VALUE", Blockly.JavaScript.ORDER_ASSIGNMENT) || "0";
    return Blockly.JavaScript.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME) + " = " + b + ";\n";
  };

  Blockly.JavaScript.variablesDynamic = {};
  Blockly.JavaScript.variables_get_dynamic = Blockly.JavaScript.variables_get;
  Blockly.JavaScript.variables_set_dynamic = Blockly.JavaScript.variables_set;
  return Blockly.JavaScript;
});

/***/ }),

/***/ 85115:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
;

(function (root, factory) {
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(90888)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (Blockly) {
  var Blockly = {};
  Blockly.Msg = {}; // This file was automatically generated.  Do not modify.

  'use strict';

  Blockly.Msg["ADD_COMMENT"] = "Add Comment";
  Blockly.Msg["CANNOT_DELETE_VARIABLE_PROCEDURE"] = "Can't delete the variable '%1' because it's part of the definition of the function '%2'";
  Blockly.Msg["CHANGE_VALUE_TITLE"] = "Change value:";
  Blockly.Msg["CLEAN_UP"] = "Clean up Blocks";
  Blockly.Msg["COLLAPSED_WARNINGS_WARNING"] = "Collapsed blocks contain warnings.";
  Blockly.Msg["COLLAPSE_ALL"] = "Collapse Blocks";
  Blockly.Msg["COLLAPSE_BLOCK"] = "Collapse Block";
  Blockly.Msg["COLOUR_BLEND_COLOUR1"] = "colour 1";
  Blockly.Msg["COLOUR_BLEND_COLOUR2"] = "colour 2";
  Blockly.Msg["COLOUR_BLEND_HELPURL"] = "https://meyerweb.com/eric/tools/color-blend/#:::rgbp";
  Blockly.Msg["COLOUR_BLEND_RATIO"] = "ratio";
  Blockly.Msg["COLOUR_BLEND_TITLE"] = "blend";
  Blockly.Msg["COLOUR_BLEND_TOOLTIP"] = "Blends two colours together with a given ratio (0.0 - 1.0).";
  Blockly.Msg["COLOUR_PICKER_HELPURL"] = "https://en.wikipedia.org/wiki/Color";
  Blockly.Msg["COLOUR_PICKER_TOOLTIP"] = "Choose a colour from the palette.";
  Blockly.Msg["COLOUR_RANDOM_HELPURL"] = "http://randomcolour.com";
  Blockly.Msg["COLOUR_RANDOM_TITLE"] = "random colour";
  Blockly.Msg["COLOUR_RANDOM_TOOLTIP"] = "Choose a colour at random.";
  Blockly.Msg["COLOUR_RGB_BLUE"] = "blue";
  Blockly.Msg["COLOUR_RGB_GREEN"] = "green";
  Blockly.Msg["COLOUR_RGB_HELPURL"] = "https://www.december.com/html/spec/colorpercompact.html";
  Blockly.Msg["COLOUR_RGB_RED"] = "red";
  Blockly.Msg["COLOUR_RGB_TITLE"] = "colour with";
  Blockly.Msg["COLOUR_RGB_TOOLTIP"] = "Create a colour with the specified amount of red, green, and blue. All values must be between 0 and 100.";
  Blockly.Msg["CONTROLS_FLOW_STATEMENTS_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#loop-termination-blocks";
  Blockly.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK"] = "break out of loop";
  Blockly.Msg["CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE"] = "continue with next iteration of loop";
  Blockly.Msg["CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK"] = "Break out of the containing loop.";
  Blockly.Msg["CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE"] = "Skip the rest of this loop, and continue with the next iteration.";
  Blockly.Msg["CONTROLS_FLOW_STATEMENTS_WARNING"] = "Warning: This block may only be used within a loop.";
  Blockly.Msg["CONTROLS_FOREACH_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#for-each";
  Blockly.Msg["CONTROLS_FOREACH_TITLE"] = "for each item %1 in list %2";
  Blockly.Msg["CONTROLS_FOREACH_TOOLTIP"] = "For each item in a list, set the variable '%1' to the item, and then do some statements.";
  Blockly.Msg["CONTROLS_FOR_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#count-with";
  Blockly.Msg["CONTROLS_FOR_TITLE"] = "count with %1 from %2 to %3 by %4";
  Blockly.Msg["CONTROLS_FOR_TOOLTIP"] = "Have the variable '%1' take on the values from the start number to the end number, counting by the specified interval, and do the specified blocks.";
  Blockly.Msg["CONTROLS_IF_ELSEIF_TOOLTIP"] = "Add a condition to the if block.";
  Blockly.Msg["CONTROLS_IF_ELSE_TOOLTIP"] = "Add a final, catch-all condition to the if block.";
  Blockly.Msg["CONTROLS_IF_HELPURL"] = "https://github.com/google/blockly/wiki/IfElse";
  Blockly.Msg["CONTROLS_IF_IF_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this if block.";
  Blockly.Msg["CONTROLS_IF_MSG_ELSE"] = "else";
  Blockly.Msg["CONTROLS_IF_MSG_ELSEIF"] = "else if";
  Blockly.Msg["CONTROLS_IF_MSG_IF"] = "if";
  Blockly.Msg["CONTROLS_IF_TOOLTIP_1"] = "If a value is true, then do some statements.";
  Blockly.Msg["CONTROLS_IF_TOOLTIP_2"] = "If a value is true, then do the first block of statements. Otherwise, do the second block of statements.";
  Blockly.Msg["CONTROLS_IF_TOOLTIP_3"] = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements.";
  Blockly.Msg["CONTROLS_IF_TOOLTIP_4"] = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements. If none of the values are true, do the last block of statements.";
  Blockly.Msg["CONTROLS_REPEAT_HELPURL"] = "https://en.wikipedia.org/wiki/For_loop";
  Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"] = "do";
  Blockly.Msg["CONTROLS_REPEAT_TITLE"] = "repeat %1 times";
  Blockly.Msg["CONTROLS_REPEAT_TOOLTIP"] = "Do some statements several times.";
  Blockly.Msg["CONTROLS_WHILEUNTIL_HELPURL"] = "https://github.com/google/blockly/wiki/Loops#repeat";
  Blockly.Msg["CONTROLS_WHILEUNTIL_OPERATOR_UNTIL"] = "repeat until";
  Blockly.Msg["CONTROLS_WHILEUNTIL_OPERATOR_WHILE"] = "repeat while";
  Blockly.Msg["CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL"] = "While a value is false, then do some statements.";
  Blockly.Msg["CONTROLS_WHILEUNTIL_TOOLTIP_WHILE"] = "While a value is true, then do some statements.";
  Blockly.Msg["DELETE_ALL_BLOCKS"] = "Delete all %1 blocks?";
  Blockly.Msg["DELETE_BLOCK"] = "Delete Block";
  Blockly.Msg["DELETE_VARIABLE"] = "Delete the '%1' variable";
  Blockly.Msg["DELETE_VARIABLE_CONFIRMATION"] = "Delete %1 uses of the '%2' variable?";
  Blockly.Msg["DELETE_X_BLOCKS"] = "Delete %1 Blocks";
  Blockly.Msg["DISABLE_BLOCK"] = "Disable Block";
  Blockly.Msg["DUPLICATE_BLOCK"] = "Duplicate";
  Blockly.Msg["DUPLICATE_COMMENT"] = "Duplicate Comment";
  Blockly.Msg["ENABLE_BLOCK"] = "Enable Block";
  Blockly.Msg["EXPAND_ALL"] = "Expand Blocks";
  Blockly.Msg["EXPAND_BLOCK"] = "Expand Block";
  Blockly.Msg["EXTERNAL_INPUTS"] = "External Inputs";
  Blockly.Msg["HELP"] = "Help";
  Blockly.Msg["INLINE_INPUTS"] = "Inline Inputs";
  Blockly.Msg["IOS_CANCEL"] = "Cancel";
  Blockly.Msg["IOS_ERROR"] = "Error";
  Blockly.Msg["IOS_OK"] = "OK";
  Blockly.Msg["IOS_PROCEDURES_ADD_INPUT"] = "+ Add Input";
  Blockly.Msg["IOS_PROCEDURES_ALLOW_STATEMENTS"] = "Allow statements";
  Blockly.Msg["IOS_PROCEDURES_DUPLICATE_INPUTS_ERROR"] = "This function has duplicate inputs.";
  Blockly.Msg["IOS_PROCEDURES_INPUTS"] = "INPUTS";
  Blockly.Msg["IOS_VARIABLES_ADD_BUTTON"] = "Add";
  Blockly.Msg["IOS_VARIABLES_ADD_VARIABLE"] = "+ Add Variable";
  Blockly.Msg["IOS_VARIABLES_DELETE_BUTTON"] = "Delete";
  Blockly.Msg["IOS_VARIABLES_EMPTY_NAME_ERROR"] = "You can't use an empty variable name.";
  Blockly.Msg["IOS_VARIABLES_RENAME_BUTTON"] = "Rename";
  Blockly.Msg["IOS_VARIABLES_VARIABLE_NAME"] = "Variable name";
  Blockly.Msg["LISTS_CREATE_EMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-empty-list";
  Blockly.Msg["LISTS_CREATE_EMPTY_TITLE"] = "create empty list";
  Blockly.Msg["LISTS_CREATE_EMPTY_TOOLTIP"] = "Returns a list, of length 0, containing no data records";
  Blockly.Msg["LISTS_CREATE_WITH_CONTAINER_TITLE_ADD"] = "list";
  Blockly.Msg["LISTS_CREATE_WITH_CONTAINER_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this list block.";
  Blockly.Msg["LISTS_CREATE_WITH_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-list-with";
  Blockly.Msg["LISTS_CREATE_WITH_INPUT_WITH"] = "create list with";
  Blockly.Msg["LISTS_CREATE_WITH_ITEM_TOOLTIP"] = "Add an item to the list.";
  Blockly.Msg["LISTS_CREATE_WITH_TOOLTIP"] = "Create a list with any number of items.";
  Blockly.Msg["LISTS_GET_INDEX_FIRST"] = "first";
  Blockly.Msg["LISTS_GET_INDEX_FROM_END"] = "# from end";
  Blockly.Msg["LISTS_GET_INDEX_FROM_START"] = "#";
  Blockly.Msg["LISTS_GET_INDEX_GET"] = "get";
  Blockly.Msg["LISTS_GET_INDEX_GET_REMOVE"] = "get and remove";
  Blockly.Msg["LISTS_GET_INDEX_LAST"] = "last";
  Blockly.Msg["LISTS_GET_INDEX_RANDOM"] = "random";
  Blockly.Msg["LISTS_GET_INDEX_REMOVE"] = "remove";
  Blockly.Msg["LISTS_GET_INDEX_TAIL"] = "";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_FIRST"] = "Returns the first item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_FROM"] = "Returns the item at the specified position in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_LAST"] = "Returns the last item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_RANDOM"] = "Returns a random item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST"] = "Removes and returns the first item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM"] = "Removes and returns the item at the specified position in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST"] = "Removes and returns the last item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM"] = "Removes and returns a random item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST"] = "Removes the first item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM"] = "Removes the item at the specified position in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST"] = "Removes the last item in a list.";
  Blockly.Msg["LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM"] = "Removes a random item in a list.";
  Blockly.Msg["LISTS_GET_SUBLIST_END_FROM_END"] = "to # from end";
  Blockly.Msg["LISTS_GET_SUBLIST_END_FROM_START"] = "to #";
  Blockly.Msg["LISTS_GET_SUBLIST_END_LAST"] = "to last";
  Blockly.Msg["LISTS_GET_SUBLIST_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#getting-a-sublist";
  Blockly.Msg["LISTS_GET_SUBLIST_START_FIRST"] = "get sub-list from first";
  Blockly.Msg["LISTS_GET_SUBLIST_START_FROM_END"] = "get sub-list from # from end";
  Blockly.Msg["LISTS_GET_SUBLIST_START_FROM_START"] = "get sub-list from #";
  Blockly.Msg["LISTS_GET_SUBLIST_TAIL"] = "";
  Blockly.Msg["LISTS_GET_SUBLIST_TOOLTIP"] = "Creates a copy of the specified portion of a list.";
  Blockly.Msg["LISTS_INDEX_FROM_END_TOOLTIP"] = "%1 is the last item.";
  Blockly.Msg["LISTS_INDEX_FROM_START_TOOLTIP"] = "%1 is the first item.";
  Blockly.Msg["LISTS_INDEX_OF_FIRST"] = "find first occurrence of item";
  Blockly.Msg["LISTS_INDEX_OF_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#getting-items-from-a-list";
  Blockly.Msg["LISTS_INDEX_OF_LAST"] = "find last occurrence of item";
  Blockly.Msg["LISTS_INDEX_OF_TOOLTIP"] = "Returns the index of the first/last occurrence of the item in the list. Returns %1 if item is not found.";
  Blockly.Msg["LISTS_INLIST"] = "in list";
  Blockly.Msg["LISTS_ISEMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#is-empty";
  Blockly.Msg["LISTS_ISEMPTY_TITLE"] = "%1 is empty";
  Blockly.Msg["LISTS_ISEMPTY_TOOLTIP"] = "Returns true if the list is empty.";
  Blockly.Msg["LISTS_LENGTH_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#length-of";
  Blockly.Msg["LISTS_LENGTH_TITLE"] = "length of %1";
  Blockly.Msg["LISTS_LENGTH_TOOLTIP"] = "Returns the length of a list.";
  Blockly.Msg["LISTS_REPEAT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#create-list-with";
  Blockly.Msg["LISTS_REPEAT_TITLE"] = "create list with item %1 repeated %2 times";
  Blockly.Msg["LISTS_REPEAT_TOOLTIP"] = "Creates a list consisting of the given value repeated the specified number of times.";
  Blockly.Msg["LISTS_REVERSE_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#reversing-a-list";
  Blockly.Msg["LISTS_REVERSE_MESSAGE0"] = "reverse %1";
  Blockly.Msg["LISTS_REVERSE_TOOLTIP"] = "Reverse a copy of a list.";
  Blockly.Msg["LISTS_SET_INDEX_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#in-list--set";
  Blockly.Msg["LISTS_SET_INDEX_INPUT_TO"] = "as";
  Blockly.Msg["LISTS_SET_INDEX_INSERT"] = "insert at";
  Blockly.Msg["LISTS_SET_INDEX_SET"] = "set";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST"] = "Inserts the item at the start of a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_FROM"] = "Inserts the item at the specified position in a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_LAST"] = "Append the item to the end of a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM"] = "Inserts the item randomly in a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_SET_FIRST"] = "Sets the first item in a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_SET_FROM"] = "Sets the item at the specified position in a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_SET_LAST"] = "Sets the last item in a list.";
  Blockly.Msg["LISTS_SET_INDEX_TOOLTIP_SET_RANDOM"] = "Sets a random item in a list.";
  Blockly.Msg["LISTS_SORT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#sorting-a-list";
  Blockly.Msg["LISTS_SORT_ORDER_ASCENDING"] = "ascending";
  Blockly.Msg["LISTS_SORT_ORDER_DESCENDING"] = "descending";
  Blockly.Msg["LISTS_SORT_TITLE"] = "sort %1 %2 %3";
  Blockly.Msg["LISTS_SORT_TOOLTIP"] = "Sort a copy of a list.";
  Blockly.Msg["LISTS_SORT_TYPE_IGNORECASE"] = "alphabetic, ignore case";
  Blockly.Msg["LISTS_SORT_TYPE_NUMERIC"] = "numeric";
  Blockly.Msg["LISTS_SORT_TYPE_TEXT"] = "alphabetic";
  Blockly.Msg["LISTS_SPLIT_HELPURL"] = "https://github.com/google/blockly/wiki/Lists#splitting-strings-and-joining-lists";
  Blockly.Msg["LISTS_SPLIT_LIST_FROM_TEXT"] = "make list from text";
  Blockly.Msg["LISTS_SPLIT_TEXT_FROM_LIST"] = "make text from list";
  Blockly.Msg["LISTS_SPLIT_TOOLTIP_JOIN"] = "Join a list of texts into one text, separated by a delimiter.";
  Blockly.Msg["LISTS_SPLIT_TOOLTIP_SPLIT"] = "Split text into a list of texts, breaking at each delimiter.";
  Blockly.Msg["LISTS_SPLIT_WITH_DELIMITER"] = "with delimiter";
  Blockly.Msg["LOGIC_BOOLEAN_FALSE"] = "false";
  Blockly.Msg["LOGIC_BOOLEAN_HELPURL"] = "https://github.com/google/blockly/wiki/Logic#values";
  Blockly.Msg["LOGIC_BOOLEAN_TOOLTIP"] = "Returns either true or false.";
  Blockly.Msg["LOGIC_BOOLEAN_TRUE"] = "true";
  Blockly.Msg["LOGIC_COMPARE_HELPURL"] = "https://en.wikipedia.org/wiki/Inequality_(mathematics)";
  Blockly.Msg["LOGIC_COMPARE_TOOLTIP_EQ"] = "Return true if both inputs equal each other.";
  Blockly.Msg["LOGIC_COMPARE_TOOLTIP_GT"] = "Return true if the first input is greater than the second input.";
  Blockly.Msg["LOGIC_COMPARE_TOOLTIP_GTE"] = "Return true if the first input is greater than or equal to the second input.";
  Blockly.Msg["LOGIC_COMPARE_TOOLTIP_LT"] = "Return true if the first input is smaller than the second input.";
  Blockly.Msg["LOGIC_COMPARE_TOOLTIP_LTE"] = "Return true if the first input is smaller than or equal to the second input.";
  Blockly.Msg["LOGIC_COMPARE_TOOLTIP_NEQ"] = "Return true if both inputs are not equal to each other.";
  Blockly.Msg["LOGIC_NEGATE_HELPURL"] = "https://github.com/google/blockly/wiki/Logic#not";
  Blockly.Msg["LOGIC_NEGATE_TITLE"] = "not %1";
  Blockly.Msg["LOGIC_NEGATE_TOOLTIP"] = "Returns true if the input is false. Returns false if the input is true.";
  Blockly.Msg["LOGIC_NULL"] = "null";
  Blockly.Msg["LOGIC_NULL_HELPURL"] = "https://en.wikipedia.org/wiki/Nullable_type";
  Blockly.Msg["LOGIC_NULL_TOOLTIP"] = "Returns null.";
  Blockly.Msg["LOGIC_OPERATION_AND"] = "and";
  Blockly.Msg["LOGIC_OPERATION_HELPURL"] = "https://github.com/google/blockly/wiki/Logic#logical-operations";
  Blockly.Msg["LOGIC_OPERATION_OR"] = "or";
  Blockly.Msg["LOGIC_OPERATION_TOOLTIP_AND"] = "Return true if both inputs are true.";
  Blockly.Msg["LOGIC_OPERATION_TOOLTIP_OR"] = "Return true if at least one of the inputs is true.";
  Blockly.Msg["LOGIC_TERNARY_CONDITION"] = "test";
  Blockly.Msg["LOGIC_TERNARY_HELPURL"] = "https://en.wikipedia.org/wiki/%3F:";
  Blockly.Msg["LOGIC_TERNARY_IF_FALSE"] = "if false";
  Blockly.Msg["LOGIC_TERNARY_IF_TRUE"] = "if true";
  Blockly.Msg["LOGIC_TERNARY_TOOLTIP"] = "Check the condition in 'test'. If the condition is true, returns the 'if true' value; otherwise returns the 'if false' value.";
  Blockly.Msg["MATH_ADDITION_SYMBOL"] = "+";
  Blockly.Msg["MATH_ARITHMETIC_HELPURL"] = "https://en.wikipedia.org/wiki/Arithmetic";
  Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_ADD"] = "Return the sum of the two numbers.";
  Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_DIVIDE"] = "Return the quotient of the two numbers.";
  Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_MINUS"] = "Return the difference of the two numbers.";
  Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_MULTIPLY"] = "Return the product of the two numbers.";
  Blockly.Msg["MATH_ARITHMETIC_TOOLTIP_POWER"] = "Return the first number raised to the power of the second number.";
  Blockly.Msg["MATH_ATAN2_HELPURL"] = "https://en.wikipedia.org/wiki/Atan2";
  Blockly.Msg["MATH_ATAN2_TITLE"] = "atan2 of X:%1 Y:%2";
  Blockly.Msg["MATH_ATAN2_TOOLTIP"] = "Return the arctangent of point (X, Y) in degrees from -180 to 180.";
  Blockly.Msg["MATH_CHANGE_HELPURL"] = "https://en.wikipedia.org/wiki/Programming_idiom#Incrementing_a_counter";
  Blockly.Msg["MATH_CHANGE_TITLE"] = "change %1 by %2";
  Blockly.Msg["MATH_CHANGE_TOOLTIP"] = "Add a number to variable '%1'.";
  Blockly.Msg["MATH_CONSTANT_HELPURL"] = "https://en.wikipedia.org/wiki/Mathematical_constant";
  Blockly.Msg["MATH_CONSTANT_TOOLTIP"] = "Return one of the common constants: π (3.141…), e (2.718…), φ (1.618…), sqrt(2) (1.414…), sqrt(½) (0.707…), or ∞ (infinity).";
  Blockly.Msg["MATH_CONSTRAIN_HELPURL"] = "https://en.wikipedia.org/wiki/Clamping_(graphics)";
  Blockly.Msg["MATH_CONSTRAIN_TITLE"] = "constrain %1 low %2 high %3";
  Blockly.Msg["MATH_CONSTRAIN_TOOLTIP"] = "Constrain a number to be between the specified limits (inclusive).";
  Blockly.Msg["MATH_DIVISION_SYMBOL"] = "÷";
  Blockly.Msg["MATH_IS_DIVISIBLE_BY"] = "is divisible by";
  Blockly.Msg["MATH_IS_EVEN"] = "is even";
  Blockly.Msg["MATH_IS_NEGATIVE"] = "is negative";
  Blockly.Msg["MATH_IS_ODD"] = "is odd";
  Blockly.Msg["MATH_IS_POSITIVE"] = "is positive";
  Blockly.Msg["MATH_IS_PRIME"] = "is prime";
  Blockly.Msg["MATH_IS_TOOLTIP"] = "Check if a number is an even, odd, prime, whole, positive, negative, or if it is divisible by certain number. Returns true or false.";
  Blockly.Msg["MATH_IS_WHOLE"] = "is whole";
  Blockly.Msg["MATH_MODULO_HELPURL"] = "https://en.wikipedia.org/wiki/Modulo_operation";
  Blockly.Msg["MATH_MODULO_TITLE"] = "remainder of %1 ÷ %2";
  Blockly.Msg["MATH_MODULO_TOOLTIP"] = "Return the remainder from dividing the two numbers.";
  Blockly.Msg["MATH_MULTIPLICATION_SYMBOL"] = "×";
  Blockly.Msg["MATH_NUMBER_HELPURL"] = "https://en.wikipedia.org/wiki/Number";
  Blockly.Msg["MATH_NUMBER_TOOLTIP"] = "A number.";
  Blockly.Msg["MATH_ONLIST_HELPURL"] = "";
  Blockly.Msg["MATH_ONLIST_OPERATOR_AVERAGE"] = "average of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_MAX"] = "max of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_MEDIAN"] = "median of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_MIN"] = "min of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_MODE"] = "modes of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_RANDOM"] = "random item of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_STD_DEV"] = "standard deviation of list";
  Blockly.Msg["MATH_ONLIST_OPERATOR_SUM"] = "sum of list";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_AVERAGE"] = "Return the average (arithmetic mean) of the numeric values in the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_MAX"] = "Return the largest number in the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_MEDIAN"] = "Return the median number in the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_MIN"] = "Return the smallest number in the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_MODE"] = "Return a list of the most common item(s) in the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_RANDOM"] = "Return a random element from the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_STD_DEV"] = "Return the standard deviation of the list.";
  Blockly.Msg["MATH_ONLIST_TOOLTIP_SUM"] = "Return the sum of all the numbers in the list.";
  Blockly.Msg["MATH_POWER_SYMBOL"] = "^";
  Blockly.Msg["MATH_RANDOM_FLOAT_HELPURL"] = "https://en.wikipedia.org/wiki/Random_number_generation";
  Blockly.Msg["MATH_RANDOM_FLOAT_TITLE_RANDOM"] = "random fraction";
  Blockly.Msg["MATH_RANDOM_FLOAT_TOOLTIP"] = "Return a random fraction between 0.0 (inclusive) and 1.0 (exclusive).";
  Blockly.Msg["MATH_RANDOM_INT_HELPURL"] = "https://en.wikipedia.org/wiki/Random_number_generation";
  Blockly.Msg["MATH_RANDOM_INT_TITLE"] = "random integer from %1 to %2";
  Blockly.Msg["MATH_RANDOM_INT_TOOLTIP"] = "Return a random integer between the two specified limits, inclusive.";
  Blockly.Msg["MATH_ROUND_HELPURL"] = "https://en.wikipedia.org/wiki/Rounding";
  Blockly.Msg["MATH_ROUND_OPERATOR_ROUND"] = "round";
  Blockly.Msg["MATH_ROUND_OPERATOR_ROUNDDOWN"] = "round down";
  Blockly.Msg["MATH_ROUND_OPERATOR_ROUNDUP"] = "round up";
  Blockly.Msg["MATH_ROUND_TOOLTIP"] = "Round a number up or down.";
  Blockly.Msg["MATH_SINGLE_HELPURL"] = "https://en.wikipedia.org/wiki/Square_root";
  Blockly.Msg["MATH_SINGLE_OP_ABSOLUTE"] = "absolute";
  Blockly.Msg["MATH_SINGLE_OP_ROOT"] = "square root";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_ABS"] = "Return the absolute value of a number.";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_EXP"] = "Return e to the power of a number.";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_LN"] = "Return the natural logarithm of a number.";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_LOG10"] = "Return the base 10 logarithm of a number.";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_NEG"] = "Return the negation of a number.";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_POW10"] = "Return 10 to the power of a number.";
  Blockly.Msg["MATH_SINGLE_TOOLTIP_ROOT"] = "Return the square root of a number.";
  Blockly.Msg["MATH_SUBTRACTION_SYMBOL"] = "-";
  Blockly.Msg["MATH_TRIG_ACOS"] = "acos";
  Blockly.Msg["MATH_TRIG_ASIN"] = "asin";
  Blockly.Msg["MATH_TRIG_ATAN"] = "atan";
  Blockly.Msg["MATH_TRIG_COS"] = "cos";
  Blockly.Msg["MATH_TRIG_HELPURL"] = "https://en.wikipedia.org/wiki/Trigonometric_functions";
  Blockly.Msg["MATH_TRIG_SIN"] = "sin";
  Blockly.Msg["MATH_TRIG_TAN"] = "tan";
  Blockly.Msg["MATH_TRIG_TOOLTIP_ACOS"] = "Return the arccosine of a number.";
  Blockly.Msg["MATH_TRIG_TOOLTIP_ASIN"] = "Return the arcsine of a number.";
  Blockly.Msg["MATH_TRIG_TOOLTIP_ATAN"] = "Return the arctangent of a number.";
  Blockly.Msg["MATH_TRIG_TOOLTIP_COS"] = "Return the cosine of a degree (not radian).";
  Blockly.Msg["MATH_TRIG_TOOLTIP_SIN"] = "Return the sine of a degree (not radian).";
  Blockly.Msg["MATH_TRIG_TOOLTIP_TAN"] = "Return the tangent of a degree (not radian).";
  Blockly.Msg["NEW_COLOUR_VARIABLE"] = "Create colour variable...";
  Blockly.Msg["NEW_NUMBER_VARIABLE"] = "Create number variable...";
  Blockly.Msg["NEW_STRING_VARIABLE"] = "Create string variable...";
  Blockly.Msg["NEW_VARIABLE"] = "Create variable...";
  Blockly.Msg["NEW_VARIABLE_TITLE"] = "New variable name:";
  Blockly.Msg["NEW_VARIABLE_TYPE_TITLE"] = "New variable type:";
  Blockly.Msg["ORDINAL_NUMBER_SUFFIX"] = "";
  Blockly.Msg["PROCEDURES_ALLOW_STATEMENTS"] = "allow statements";
  Blockly.Msg["PROCEDURES_BEFORE_PARAMS"] = "with:";
  Blockly.Msg["PROCEDURES_CALLNORETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
  Blockly.Msg["PROCEDURES_CALLNORETURN_TOOLTIP"] = "Run the user-defined function '%1'.";
  Blockly.Msg["PROCEDURES_CALLRETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
  Blockly.Msg["PROCEDURES_CALLRETURN_TOOLTIP"] = "Run the user-defined function '%1' and use its output.";
  Blockly.Msg["PROCEDURES_CALL_BEFORE_PARAMS"] = "with:";
  Blockly.Msg["PROCEDURES_CREATE_DO"] = "Create '%1'";
  Blockly.Msg["PROCEDURES_DEFNORETURN_COMMENT"] = "Describe this function...";
  Blockly.Msg["PROCEDURES_DEFNORETURN_DO"] = "";
  Blockly.Msg["PROCEDURES_DEFNORETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
  Blockly.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"] = "do something";
  Blockly.Msg["PROCEDURES_DEFNORETURN_TITLE"] = "to";
  Blockly.Msg["PROCEDURES_DEFNORETURN_TOOLTIP"] = "Creates a function with no output.";
  Blockly.Msg["PROCEDURES_DEFRETURN_HELPURL"] = "https://en.wikipedia.org/wiki/Subroutine";
  Blockly.Msg["PROCEDURES_DEFRETURN_RETURN"] = "return";
  Blockly.Msg["PROCEDURES_DEFRETURN_TOOLTIP"] = "Creates a function with an output.";
  Blockly.Msg["PROCEDURES_DEF_DUPLICATE_WARNING"] = "Warning: This function has duplicate parameters.";
  Blockly.Msg["PROCEDURES_HIGHLIGHT_DEF"] = "Highlight function definition";
  Blockly.Msg["PROCEDURES_IFRETURN_HELPURL"] = "http://c2.com/cgi/wiki?GuardClause";
  Blockly.Msg["PROCEDURES_IFRETURN_TOOLTIP"] = "If a value is true, then return a second value.";
  Blockly.Msg["PROCEDURES_IFRETURN_WARNING"] = "Warning: This block may be used only within a function definition.";
  Blockly.Msg["PROCEDURES_MUTATORARG_TITLE"] = "input name:";
  Blockly.Msg["PROCEDURES_MUTATORARG_TOOLTIP"] = "Add an input to the function.";
  Blockly.Msg["PROCEDURES_MUTATORCONTAINER_TITLE"] = "inputs";
  Blockly.Msg["PROCEDURES_MUTATORCONTAINER_TOOLTIP"] = "Add, remove, or reorder inputs to this function.";
  Blockly.Msg["REDO"] = "Redo";
  Blockly.Msg["REMOVE_COMMENT"] = "Remove Comment";
  Blockly.Msg["RENAME_VARIABLE"] = "Rename variable...";
  Blockly.Msg["RENAME_VARIABLE_TITLE"] = "Rename all '%1' variables to:";
  Blockly.Msg["TEXT_APPEND_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-modification";
  Blockly.Msg["TEXT_APPEND_TITLE"] = "to %1 append text %2";
  Blockly.Msg["TEXT_APPEND_TOOLTIP"] = "Append some text to variable '%1'.";
  Blockly.Msg["TEXT_CHANGECASE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#adjusting-text-case";
  Blockly.Msg["TEXT_CHANGECASE_OPERATOR_LOWERCASE"] = "to lower case";
  Blockly.Msg["TEXT_CHANGECASE_OPERATOR_TITLECASE"] = "to Title Case";
  Blockly.Msg["TEXT_CHANGECASE_OPERATOR_UPPERCASE"] = "to UPPER CASE";
  Blockly.Msg["TEXT_CHANGECASE_TOOLTIP"] = "Return a copy of the text in a different case.";
  Blockly.Msg["TEXT_CHARAT_FIRST"] = "get first letter";
  Blockly.Msg["TEXT_CHARAT_FROM_END"] = "get letter # from end";
  Blockly.Msg["TEXT_CHARAT_FROM_START"] = "get letter #";
  Blockly.Msg["TEXT_CHARAT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#extracting-text";
  Blockly.Msg["TEXT_CHARAT_LAST"] = "get last letter";
  Blockly.Msg["TEXT_CHARAT_RANDOM"] = "get random letter";
  Blockly.Msg["TEXT_CHARAT_TAIL"] = "";
  Blockly.Msg["TEXT_CHARAT_TITLE"] = "in text %1 %2";
  Blockly.Msg["TEXT_CHARAT_TOOLTIP"] = "Returns the letter at the specified position.";
  Blockly.Msg["TEXT_COUNT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#counting-substrings";
  Blockly.Msg["TEXT_COUNT_MESSAGE0"] = "count %1 in %2";
  Blockly.Msg["TEXT_COUNT_TOOLTIP"] = "Count how many times some text occurs within some other text.";
  Blockly.Msg["TEXT_CREATE_JOIN_ITEM_TOOLTIP"] = "Add an item to the text.";
  Blockly.Msg["TEXT_CREATE_JOIN_TITLE_JOIN"] = "join";
  Blockly.Msg["TEXT_CREATE_JOIN_TOOLTIP"] = "Add, remove, or reorder sections to reconfigure this text block.";
  Blockly.Msg["TEXT_GET_SUBSTRING_END_FROM_END"] = "to letter # from end";
  Blockly.Msg["TEXT_GET_SUBSTRING_END_FROM_START"] = "to letter #";
  Blockly.Msg["TEXT_GET_SUBSTRING_END_LAST"] = "to last letter";
  Blockly.Msg["TEXT_GET_SUBSTRING_HELPURL"] = "https://github.com/google/blockly/wiki/Text#extracting-a-region-of-text";
  Blockly.Msg["TEXT_GET_SUBSTRING_INPUT_IN_TEXT"] = "in text";
  Blockly.Msg["TEXT_GET_SUBSTRING_START_FIRST"] = "get substring from first letter";
  Blockly.Msg["TEXT_GET_SUBSTRING_START_FROM_END"] = "get substring from letter # from end";
  Blockly.Msg["TEXT_GET_SUBSTRING_START_FROM_START"] = "get substring from letter #";
  Blockly.Msg["TEXT_GET_SUBSTRING_TAIL"] = "";
  Blockly.Msg["TEXT_GET_SUBSTRING_TOOLTIP"] = "Returns a specified portion of the text.";
  Blockly.Msg["TEXT_INDEXOF_HELPURL"] = "https://github.com/google/blockly/wiki/Text#finding-text";
  Blockly.Msg["TEXT_INDEXOF_OPERATOR_FIRST"] = "find first occurrence of text";
  Blockly.Msg["TEXT_INDEXOF_OPERATOR_LAST"] = "find last occurrence of text";
  Blockly.Msg["TEXT_INDEXOF_TITLE"] = "in text %1 %2 %3";
  Blockly.Msg["TEXT_INDEXOF_TOOLTIP"] = "Returns the index of the first/last occurrence of the first text in the second text. Returns %1 if text is not found.";
  Blockly.Msg["TEXT_ISEMPTY_HELPURL"] = "https://github.com/google/blockly/wiki/Text#checking-for-empty-text";
  Blockly.Msg["TEXT_ISEMPTY_TITLE"] = "%1 is empty";
  Blockly.Msg["TEXT_ISEMPTY_TOOLTIP"] = "Returns true if the provided text is empty.";
  Blockly.Msg["TEXT_JOIN_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-creation";
  Blockly.Msg["TEXT_JOIN_TITLE_CREATEWITH"] = "create text with";
  Blockly.Msg["TEXT_JOIN_TOOLTIP"] = "Create a piece of text by joining together any number of items.";
  Blockly.Msg["TEXT_LENGTH_HELPURL"] = "https://github.com/google/blockly/wiki/Text#text-modification";
  Blockly.Msg["TEXT_LENGTH_TITLE"] = "length of %1";
  Blockly.Msg["TEXT_LENGTH_TOOLTIP"] = "Returns the number of letters (including spaces) in the provided text.";
  Blockly.Msg["TEXT_PRINT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#printing-text";
  Blockly.Msg["TEXT_PRINT_TITLE"] = "print %1";
  Blockly.Msg["TEXT_PRINT_TOOLTIP"] = "Print the specified text, number or other value.";
  Blockly.Msg["TEXT_PROMPT_HELPURL"] = "https://github.com/google/blockly/wiki/Text#getting-input-from-the-user";
  Blockly.Msg["TEXT_PROMPT_TOOLTIP_NUMBER"] = "Prompt for user for a number.";
  Blockly.Msg["TEXT_PROMPT_TOOLTIP_TEXT"] = "Prompt for user for some text.";
  Blockly.Msg["TEXT_PROMPT_TYPE_NUMBER"] = "prompt for number with message";
  Blockly.Msg["TEXT_PROMPT_TYPE_TEXT"] = "prompt for text with message";
  Blockly.Msg["TEXT_REPLACE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#replacing-substrings";
  Blockly.Msg["TEXT_REPLACE_MESSAGE0"] = "replace %1 with %2 in %3";
  Blockly.Msg["TEXT_REPLACE_TOOLTIP"] = "Replace all occurances of some text within some other text.";
  Blockly.Msg["TEXT_REVERSE_HELPURL"] = "https://github.com/google/blockly/wiki/Text#reversing-text";
  Blockly.Msg["TEXT_REVERSE_MESSAGE0"] = "reverse %1";
  Blockly.Msg["TEXT_REVERSE_TOOLTIP"] = "Reverses the order of the characters in the text.";
  Blockly.Msg["TEXT_TEXT_HELPURL"] = "https://en.wikipedia.org/wiki/String_(computer_science)";
  Blockly.Msg["TEXT_TEXT_TOOLTIP"] = "A letter, word, or line of text.";
  Blockly.Msg["TEXT_TRIM_HELPURL"] = "https://github.com/google/blockly/wiki/Text#trimming-removing-spaces";
  Blockly.Msg["TEXT_TRIM_OPERATOR_BOTH"] = "trim spaces from both sides of";
  Blockly.Msg["TEXT_TRIM_OPERATOR_LEFT"] = "trim spaces from left side of";
  Blockly.Msg["TEXT_TRIM_OPERATOR_RIGHT"] = "trim spaces from right side of";
  Blockly.Msg["TEXT_TRIM_TOOLTIP"] = "Return a copy of the text with spaces removed from one or both ends.";
  Blockly.Msg["TODAY"] = "Today";
  Blockly.Msg["UNDO"] = "Undo";
  Blockly.Msg["UNNAMED_KEY"] = "unnamed";
  Blockly.Msg["VARIABLES_DEFAULT_NAME"] = "item";
  Blockly.Msg["VARIABLES_GET_CREATE_SET"] = "Create 'set %1'";
  Blockly.Msg["VARIABLES_GET_HELPURL"] = "https://github.com/google/blockly/wiki/Variables#get";
  Blockly.Msg["VARIABLES_GET_TOOLTIP"] = "Returns the value of this variable.";
  Blockly.Msg["VARIABLES_SET"] = "set %1 to %2";
  Blockly.Msg["VARIABLES_SET_CREATE_GET"] = "Create 'get %1'";
  Blockly.Msg["VARIABLES_SET_HELPURL"] = "https://github.com/google/blockly/wiki/Variables#set";
  Blockly.Msg["VARIABLES_SET_TOOLTIP"] = "Sets this variable to be equal to the input.";
  Blockly.Msg["VARIABLE_ALREADY_EXISTS"] = "A variable named '%1' already exists.";
  Blockly.Msg["VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE"] = "A variable named '%1' already exists for another type: '%2'.";
  Blockly.Msg["WORKSPACE_ARIA_LABEL"] = "Blockly Workspace";
  Blockly.Msg["WORKSPACE_COMMENT_DEFAULT_TEXT"] = "Say something...";
  Blockly.Msg["CONTROLS_FOREACH_INPUT_DO"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
  Blockly.Msg["CONTROLS_FOR_INPUT_DO"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
  Blockly.Msg["CONTROLS_IF_ELSEIF_TITLE_ELSEIF"] = Blockly.Msg["CONTROLS_IF_MSG_ELSEIF"];
  Blockly.Msg["CONTROLS_IF_ELSE_TITLE_ELSE"] = Blockly.Msg["CONTROLS_IF_MSG_ELSE"];
  Blockly.Msg["CONTROLS_IF_IF_TITLE_IF"] = Blockly.Msg["CONTROLS_IF_MSG_IF"];
  Blockly.Msg["CONTROLS_IF_MSG_THEN"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
  Blockly.Msg["CONTROLS_WHILEUNTIL_INPUT_DO"] = Blockly.Msg["CONTROLS_REPEAT_INPUT_DO"];
  Blockly.Msg["LISTS_CREATE_WITH_ITEM_TITLE"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
  Blockly.Msg["LISTS_GET_INDEX_HELPURL"] = Blockly.Msg["LISTS_INDEX_OF_HELPURL"];
  Blockly.Msg["LISTS_GET_INDEX_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
  Blockly.Msg["LISTS_GET_SUBLIST_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
  Blockly.Msg["LISTS_INDEX_OF_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
  Blockly.Msg["LISTS_SET_INDEX_INPUT_IN_LIST"] = Blockly.Msg["LISTS_INLIST"];
  Blockly.Msg["MATH_CHANGE_TITLE_ITEM"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
  Blockly.Msg["PROCEDURES_DEFRETURN_COMMENT"] = Blockly.Msg["PROCEDURES_DEFNORETURN_COMMENT"];
  Blockly.Msg["PROCEDURES_DEFRETURN_DO"] = Blockly.Msg["PROCEDURES_DEFNORETURN_DO"];
  Blockly.Msg["PROCEDURES_DEFRETURN_PROCEDURE"] = Blockly.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"];
  Blockly.Msg["PROCEDURES_DEFRETURN_TITLE"] = Blockly.Msg["PROCEDURES_DEFNORETURN_TITLE"];
  Blockly.Msg["TEXT_APPEND_VARIABLE"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
  Blockly.Msg["TEXT_CREATE_JOIN_ITEM_TITLE_ITEM"] = Blockly.Msg["VARIABLES_DEFAULT_NAME"];
  Blockly.Msg["MATH_HUE"] = "230";
  Blockly.Msg["LOOPS_HUE"] = "120";
  Blockly.Msg["LISTS_HUE"] = "260";
  Blockly.Msg["LOGIC_HUE"] = "210";
  Blockly.Msg["VARIABLES_HUE"] = "330";
  Blockly.Msg["TEXTS_HUE"] = "160";
  Blockly.Msg["PROCEDURES_HUE"] = "290";
  Blockly.Msg["COLOUR_HUE"] = "20";
  Blockly.Msg["VARIABLES_DYNAMIC_HUE"] = "310";
  return Blockly.Msg;
});

/***/ }),

/***/ 5495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(67294));

var _propTypes = _interopRequireDefault(__webpack_require__(45697));

var _useBlocklyWorkspace2 = _interopRequireDefault(__webpack_require__(48877));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var propTypes = {
  initialXml: _propTypes.default.string,
  toolboxConfiguration: _propTypes.default.object,
  // eslint-disable-line react/forbid-prop-types
  workspaceConfiguration: _propTypes.default.object,
  // eslint-disable-line react/forbid-prop-types
  className: _propTypes.default.string,
  onWorkspaceChange: _propTypes.default.func,
  onImportXmlError: _propTypes.default.func,
  onXmlChange: _propTypes.default.func,
  onInject: _propTypes.default.func,
  onDispose: _propTypes.default.func
};
var defaultProps = {
  initialXml: null,
  toolboxConfiguration: null,
  workspaceConfiguration: null,
  className: null,
  onWorkspaceChange: null,
  onImportXmlError: null,
  onXmlChange: null,
  onInject: null,
  onDispose: null
};

function BlocklyWorkspace(_ref) {
  var initialXml = _ref.initialXml,
      toolboxConfiguration = _ref.toolboxConfiguration,
      workspaceConfiguration = _ref.workspaceConfiguration,
      className = _ref.className,
      onWorkspaceChange = _ref.onWorkspaceChange,
      onXmlChange = _ref.onXmlChange,
      onImportXmlError = _ref.onImportXmlError,
      onInject = _ref.onInject,
      onDispose = _ref.onDispose;

  var editorDiv = _react.default.useRef(null);

  var _useBlocklyWorkspace = (0, _useBlocklyWorkspace2.default)({
    ref: editorDiv,
    initialXml: initialXml,
    toolboxConfiguration: toolboxConfiguration,
    workspaceConfiguration: workspaceConfiguration,
    onWorkspaceChange: onWorkspaceChange,
    onImportXmlError: onImportXmlError,
    onInject: onInject,
    onDispose: onDispose
  }),
      xml = _useBlocklyWorkspace.xml;

  var onXmlChangeRef = _react.default.useRef(onXmlChange);

  _react.default.useEffect(function () {
    onXmlChangeRef.current = onXmlChange;
  }, [onXmlChange]);

  _react.default.useEffect(function () {
    if (onXmlChangeRef.current && xml) {
      onXmlChangeRef.current(xml);
    }
  }, [xml]);

  return /*#__PURE__*/_react.default.createElement("div", {
    className: className,
    ref: editorDiv
  });
}

BlocklyWorkspace.propTypes = propTypes;
BlocklyWorkspace.defaultProps = defaultProps;
var _default = BlocklyWorkspace;
exports.default = _default;

/***/ }),

/***/ 16995:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = debounce;

function debounce(func, wait) {
  var timeout = null;
  var later = null;

  var debouncedFunction = function debouncedFunction() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    later = function later() {
      timeout = null;
      func.apply(void 0, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };

  var cancel = function cancel() {
    if (timeout !== null) {
      clearTimeout(timeout);
      later();
    }
  };

  return [debouncedFunction, cancel];
}

/***/ }),

/***/ 691:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
Object.defineProperty(exports, "JP", ({
  enumerable: true,
  get: function get() {
    return _useBlocklyWorkspace.default;
  }
}));
__webpack_unused_export__ = ({
  enumerable: true,
  get: function get() {
    return _BlocklyWorkspace.default;
  }
});

var _useBlocklyWorkspace = _interopRequireDefault(__webpack_require__(48877));

var _BlocklyWorkspace = _interopRequireDefault(__webpack_require__(5495));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ 48877:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(67294));

var _blockly = _interopRequireDefault(__webpack_require__(74640));

var _debounce3 = _interopRequireDefault(__webpack_require__(16995));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function importFromXml(xml, workspace, onImportXmlError) {
  try {
    _blockly.default.Xml.domToWorkspace(_blockly.default.Xml.textToDom(xml), workspace);

    return true;
  } catch (e) {
    if (onImportXmlError) {
      onImportXmlError(e);
    }

    return false;
  }
}

var useBlocklyWorkspace = function useBlocklyWorkspace(_ref) {
  var ref = _ref.ref,
      initialXml = _ref.initialXml,
      toolboxConfiguration = _ref.toolboxConfiguration,
      workspaceConfiguration = _ref.workspaceConfiguration,
      onWorkspaceChange = _ref.onWorkspaceChange,
      onImportXmlError = _ref.onImportXmlError,
      onInject = _ref.onInject,
      onDispose = _ref.onDispose;

  var _React$useState = _react.default.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      workspace = _React$useState2[0],
      setWorkspace = _React$useState2[1];

  var _React$useState3 = _react.default.useState(initialXml),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      xml = _React$useState4[0],
      setXml = _React$useState4[1];

  var _React$useState5 = _react.default.useState(false),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      didInitialImport = _React$useState6[0],
      setDidInitialImport = _React$useState6[1];

  var _React$useState7 = _react.default.useState(false),
      _React$useState8 = _slicedToArray(_React$useState7, 2),
      didHandleNewWorkspace = _React$useState8[0],
      setDidHandleNewWorkspace = _React$useState8[1]; // we explicitly don't want to recreate the workspace when the configuration changes
  // so, we'll keep it in a ref and update as necessary in an effect hook


  var workspaceConfigurationRef = _react.default.useRef(workspaceConfiguration);

  _react.default.useEffect(function () {
    workspaceConfigurationRef.current = workspaceConfiguration;
  }, [workspaceConfiguration]);

  var toolboxConfigurationRef = _react.default.useRef(toolboxConfiguration);

  _react.default.useEffect(function () {
    toolboxConfigurationRef.current = toolboxConfiguration;

    if (toolboxConfiguration && workspace) {
      workspace.updateToolbox(toolboxConfiguration);
    }
  }, [toolboxConfiguration, workspace]);

  var onInjectRef = _react.default.useRef(onInject);

  var onDisposeRef = _react.default.useRef(onDispose);

  _react.default.useEffect(function () {
    onInjectRef.current = onInject;
  }, [onInject]);

  _react.default.useEffect(function () {
    onDisposeRef.current = onDispose;
  }, [onDispose]);

  var handleWorkspaceChanged = _react.default.useCallback(function (newWorkspace) {
    if (onWorkspaceChange) {
      onWorkspaceChange(newWorkspace);
    }
  }, [onWorkspaceChange]); // Workspace creation


  _react.default.useEffect(function () {
    var newWorkspace = _blockly.default.inject(ref.current, _objectSpread(_objectSpread({}, workspaceConfigurationRef.current), {}, {
      toolbox: toolboxConfigurationRef.current
    }));

    setWorkspace(newWorkspace);
    setDidInitialImport(false); // force a re-import if we recreate the workspace

    setDidHandleNewWorkspace(false); // Singal that a workspace change event needs to be sent.

    if (onInjectRef.current) {
      onInjectRef.current(newWorkspace);
    }

    var onDisposeFunction = onDisposeRef.current; // Dispose of the workspace when our div ref goes away (Equivalent to didComponentUnmount)

    return function () {
      newWorkspace.dispose();

      if (onDisposeFunction) {
        onDisposeFunction(newWorkspace);
      }
    };
  }, [ref]); // Send a workspace change event when the workspace is created


  _react.default.useEffect(function () {
    if (workspace && !didHandleNewWorkspace) {
      handleWorkspaceChanged(workspace);
    }
  }, [handleWorkspaceChanged, didHandleNewWorkspace, workspace]); // Workspace change listener


  _react.default.useEffect(function () {
    if (workspace == null) {
      return undefined;
    }

    var listener = function listener() {
      handleWorkspaceChanged(workspace);
    };

    workspace.addChangeListener(listener);
    return function () {
      workspace.removeChangeListener(listener);
    };
  }, [workspace, handleWorkspaceChanged]); // xmlDidChange callback


  _react.default.useEffect(function () {
    if (workspace == null) {
      return undefined;
    }

    var _debounce = (0, _debounce3.default)(function () {
      var newXml = _blockly.default.Xml.domToText(_blockly.default.Xml.workspaceToDom(workspace));

      if (newXml === xml) {
        return;
      }

      setXml(newXml);
    }, 200),
        _debounce2 = _slicedToArray(_debounce, 2),
        callback = _debounce2[0],
        cancel = _debounce2[1];

    workspace.addChangeListener(callback);
    return function () {
      workspace.removeChangeListener(callback);
      cancel();
    };
  }, [workspace, xml]); // Initial Xml Changes


  _react.default.useEffect(function () {
    if (xml && workspace && !didInitialImport) {
      var success = importFromXml(xml, workspace, onImportXmlError);

      if (!success) {
        setXml(null);
      }

      setDidInitialImport(true);
    }
  }, [xml, workspace, didInitialImport, onImportXmlError]);

  return {
    workspace: workspace,
    xml: xml
  };
};

var _default = useBlocklyWorkspace;
exports.default = _default;

/***/ }),

/***/ 66775:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": function() { return /* binding */ createToneContext; }
/* harmony export */ });
var VOLUME_GAIN = 0.4;
function createToneContext(defaultVolume) {
  try {
    console.log("create tone context");
    var ctx = new (window.AudioContext || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    window.webkitAudioContext)(); // play silence sound within onlick to unlock it

    var buffer = ctx.createBuffer(1, 1, 22050);
    var source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(ctx.destination);
    source.start(); // output node with volume

    var volume = ctx.createGain();
    volume.connect(ctx.destination);
    volume.gain.value = (defaultVolume !== undefined ? defaultVolume : 0.2) * VOLUME_GAIN;

    var setVolume = function setVolume(v) {
      if (volume && !isNaN(v)) {
        volume.gain.value = v * VOLUME_GAIN;
      }
    };

    var playTone = function playTone(frequency, duration) {
      try {
        var tone = ctx.createOscillator();
        tone.type = "sawtooth";
        tone.connect(volume);
        tone.frequency.value = frequency; // update frequency

        tone.start(); // start and stop

        tone.stop(ctx.currentTime + duration / 1000);
      } catch (e) {
        console.debug(e);
      }
    };

    var close = function close() {
      try {
        if (ctx.state === "running") ctx.close();
      } catch (e) {
        console.warn(e);
      }
    };

    console.log("tone context created");
    return {
      setVolume: setVolume,
      playTone: playTone,
      close: close
    };
  } catch (e) {
    return undefined;
  }
}

/***/ }),

/***/ 2928:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ useServices; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);
/* harmony import */ var _jacdac_Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20392);
/* harmony import */ var _jacdac_useChange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54774);



function useServices(options) {
  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_jacdac_Context__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z),
      bus = _useContext.bus;

  var services = (0,_jacdac_useChange__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(bus, function (b) {
    return b.services(options);
  }, [JSON.stringify(options)]);
  return services;
}

/***/ }),

/***/ 79739:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ PaperBox; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19756);
/* harmony import */ var _material_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59355);
/* harmony import */ var _material_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8266);
/* harmony import */ var _material_ui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58063);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);



function PaperBox(props) {
  var children = props.children,
      padding = props.padding,
      elevation = props.elevation,
      bgcolor = props.bgcolor,
      others = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(props, ["children", "padding", "elevation", "bgcolor"]);

  var theme = (0,_material_ui_core__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)();
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_material_ui_core__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z, Object.assign({}, others, {
    bgcolor: bgcolor,
    mb: theme.spacing(0.25)
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_material_ui_core__WEBPACK_IMPORTED_MODULE_4__/* .default */ .Z, {
    square: true,
    elevation: elevation
  }, padding !== 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_material_ui_core__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z, {
    p: theme.spacing(padding || 0.25)
  }, children), padding === 0 && children));
}

/***/ }),

/***/ 9426:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ VMBlockEditor; }
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
// EXTERNAL MODULE: ./node_modules/react-blockly/dist/index.js
var dist = __webpack_require__(691);
// EXTERNAL MODULE: ./node_modules/blockly/index.js
var blockly = __webpack_require__(74640);
var blockly_default = /*#__PURE__*/__webpack_require__.n(blockly);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(6610);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(5991);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/get.js + 1 modules
var get = __webpack_require__(66213);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__(10379);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(46070);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(77608);
// EXTERNAL MODULE: ./node_modules/blockly/core-browser.js
var core_browser = __webpack_require__(90888);
var core_browser_default = /*#__PURE__*/__webpack_require__.n(core_browser);
;// CONCATENATED MODULE: ./node_modules/@blockly/field-slider/src/field_slider.js







function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,getPrototypeOf/* default */.Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,getPrototypeOf/* default */.Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,possibleConstructorReturn/* default */.Z)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Number slider input field.
 * @author kozbial@google.com (Monica Kozbial)
 */

/**
 * Slider field.
 */

var FieldSlider = /*#__PURE__*/function (_Blockly$FieldNumber) {
  (0,inherits/* default */.Z)(FieldSlider, _Blockly$FieldNumber);

  var _super = _createSuper(FieldSlider);

  /**
   * Class for an number slider field.
   * @param {string|number=} opt_value The initial value of the field. Should
   *    cast to a number. Defaults to 0.
   * @param {?(string|number)=} opt_min Minimum value.
   * @param {?(string|number)=} opt_max Maximum value.
   * @param {?(string|number)=} opt_precision Precision for value.
   * @param {?Function=} opt_validator A function that is called to validate
   *    changes to the field's value. Takes in a number & returns a validated
   *    number, or null to abort the change.
   * @param {Object=} opt_config A map of options used to configure the field.
   *    See the [field creation documentation]{@link https://developers.google.com/blockly/guides/create-custom-blocks/fields/built-in-fields/number#creation}
   *    for a list of properties this parameter supports.
   * @extends {Blockly.FieldNumber}
   * @constructor
   */
  function FieldSlider(opt_value, opt_min, opt_max, opt_precision, opt_validator, opt_config) {
    var _this;

    (0,classCallCheck/* default */.Z)(this, FieldSlider);

    _this = _super.call(this, opt_value, opt_min, opt_max, opt_precision, opt_validator, opt_config);
    /**
     * Array holding info needed to unbind events.
     * Used for disposing.
     * Ex: [[node, name, func], [node, name, func]].
     * @type {!Array.<Array<?>>}
     * @private
     */

    _this.boundEvents_ = [];
    /**
     * The HTML range input element.
     * @type {?HTMLInputElement}
     * @private
     */

    _this.sliderInput_ = null;
    return _this;
  }
  /**
   * Constructs a FieldSlider from a JSON arg object.
   * @param {!Object} options A JSON object with options (value, min, max, and
   *                          precision).
   * @return {!FieldSlider} The new field instance.
   * @package
   * @nocollapse
   */


  (0,createClass/* default */.Z)(FieldSlider, [{
    key: "showEditor_",
    value:
    /**
     * Show the inline free-text editor on top of the text along with the slider
     *    editor.
     * @param {Event=} opt_e Optional mouse event that triggered the field to
     *     open, or undefined if triggered programmatically.
     * @param {boolean=} _opt_quietInput Quiet input.
     * @protected
     * @override
     */
    function showEditor_(opt_e, _opt_quietInput) {
      // Mobile browsers have issues with in-line textareas (focus & keyboards).
      var noFocus = core_browser.utils.userAgent.MOBILE || core_browser.utils.userAgent.ANDROID || core_browser.utils.userAgent.IPAD;

      (0,get/* default */.Z)((0,getPrototypeOf/* default */.Z)(FieldSlider.prototype), "showEditor_", this).call(this, opt_e, noFocus); // Build the DOM.


      var editor = this.dropdownCreate_();
      core_browser.DropDownDiv.getContentDiv().appendChild(editor);
      core_browser.DropDownDiv.setColour(this.sourceBlock_.style.colourPrimary, this.sourceBlock_.style.colourTertiary);
      core_browser.DropDownDiv.showPositionedByField(this, this.dropdownDispose_.bind(this));
    }
    /**
     * Updates the slider when the field rerenders.
     * @protected
     * @override
     */

  }, {
    key: "render_",
    value: function render_() {
      (0,get/* default */.Z)((0,getPrototypeOf/* default */.Z)(FieldSlider.prototype), "render_", this).call(this);

      this.updateSlider_();
    }
    /**
     * Creates the slider editor and add event listeners.
     * @return {!Element} The newly created slider.
     * @private
     */

  }, {
    key: "dropdownCreate_",
    value: function dropdownCreate_() {
      var wrapper = document.createElement('div');
      wrapper.className = 'fieldSliderContainer';
      var sliderInput = document.createElement('input');
      sliderInput.setAttribute('type', 'range');
      sliderInput.setAttribute('min', this.min_);
      sliderInput.setAttribute('max', this.max_);
      sliderInput.setAttribute('step', this.precision_);
      sliderInput.setAttribute('value', this.getValue());
      sliderInput.className = 'fieldSlider';
      wrapper.appendChild(sliderInput);
      this.sliderInput_ = sliderInput;
      this.boundEvents_.push(core_browser.bindEventWithChecks_(sliderInput, 'input', this, this.onSliderChange_));
      return wrapper;
    }
    /**
     * Disposes of events belonging to the slider editor.
     * @private
     */

  }, {
    key: "dropdownDispose_",
    value: function dropdownDispose_() {
      var _iterator = _createForOfIteratorHelper(this.boundEvents_),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var event = _step.value;
          core_browser.unbindEvent_(event);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.sliderInput_ = null;
    }
    /**
     * Sets the text to match the slider's position.
     * @private
     */

  }, {
    key: "onSliderChange_",
    value: function onSliderChange_() {
      this.setEditorValue_(this.sliderInput_.value);
    }
    /**
     * Updates the slider when the field rerenders.
     * @private
     */

  }, {
    key: "updateSlider_",
    value: function updateSlider_() {
      if (!this.sliderInput_) {
        return;
      }

      this.sliderInput_.setAttribute('value', this.getValue());
    }
  }], [{
    key: "fromJson",
    value: function fromJson(options) {
      return new FieldSlider(options['value'], undefined, undefined, undefined, undefined, options);
    }
  }]);

  return FieldSlider;
}(core_browser.FieldNumber);
core_browser.fieldRegistry.register('field_slider', FieldSlider);
/**
 * CSS for slider field.
 */

core_browser.Css.register([
/* eslint-disable indent */
".fieldSliderContainer {\n      align-items: center;\n      display: flex;\n      height: 32px;\n      justify-content: center;\n      width: 150px;\n    }\n    .fieldSlider {\n      -webkit-appearance: none;\n      background: transparent; /* override white in chrome */\n      margin: 4px;\n      padding: 0;\n      width: 100%;\n    }\n    .fieldSlider:focus {\n      outline: none;\n    }\n    /* Webkit */\n    .fieldSlider::-webkit-slider-runnable-track {\n      background: #ddd;\n      border-radius: 5px;\n      height: 10px;\n    }\n    .fieldSlider::-webkit-slider-thumb {\n      -webkit-appearance: none;\n      background: #fff;\n      border-radius: 50%;\n      box-shadow: 0 0 0 4px rgba(255,255,255,.15);\n      cursor: pointer;\n      height: 24px;\n      margin-top: -7px;\n      width: 24px;\n    }\n    /* Firefox */\n    .fieldSlider::-moz-range-track {\n      background: #ddd;\n      border-radius: 5px;\n      height: 10px;\n    }\n    .fieldSlider::-moz-range-thumb {\n      background: #fff;\n      border: none;\n      border-radius: 50%;\n      box-shadow: 0 0 0 4px rgba(255,255,255,.15);\n      cursor: pointer;\n      height: 24px;\n      width: 24px;\n    }\n    .fieldSlider::-moz-focus-outer {\n      /* override the focus border style */\n      border: 0;\n    }\n    /* IE */\n    .fieldSlider::-ms-track {\n      /* IE wont let the thumb overflow the track, so fake it */\n      background: transparent;\n      border-color: transparent;\n      border-width: 15px 0;\n      /* remove default tick marks */\n      color: transparent;\n      height: 10px;\n      width: 100%;\n      margin: -4px 0;\n    }\n    .fieldSlider::-ms-fill-lower  {\n      background: #ddd;\n      border-radius: 5px;\n    }\n    .fieldSlider::-ms-fill-upper  {\n      background: #ddd;\n      border-radius: 5px;\n    }\n    .fieldSlider::-ms-thumb {\n      background: #fff;\n      border: none;\n      border-radius: 50%;\n      box-shadow: 0 0 0 4px rgba(255,255,255,.15);\n      cursor: pointer;\n      height: 24px;\n      width: 24px;\n    }"
/* eslint-enable indent */
]);
;// CONCATENATED MODULE: ./node_modules/@blockly/field-slider/src/index.js
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

;// CONCATENATED MODULE: ./node_modules/@blockly/block-dynamic-connection/src/insertion_marker_manager_monkey_patch.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Overrides methods on Blockly.InsertionMarkerManager to
 * allow blocks to hook in dynamic functionality when they have pending
 * connections.
 * @author anjali@code.org (Anjali Pal)
 */


core_browser.InsertionMarkerManager.prototype.update = function (dxy, deleteArea) {
  var candidate = this.getCandidate_(dxy);
  this.wouldDeleteBlock_ = this.shouldDelete_(candidate, deleteArea);
  var shouldUpdate = this.wouldDeleteBlock_ || this.shouldUpdatePreviews_(candidate, dxy);

  if (shouldUpdate) {
    // Begin monkey patch
    if (candidate.closest && candidate.closest.sourceBlock_.onPendingConnection) {
      candidate.closest.sourceBlock_.onPendingConnection(candidate.closest);

      if (!this.pendingBlocks) {
        this.pendingBlocks = new Set();
      }

      this.pendingBlocks.add(candidate.closest.sourceBlock_);
    } // End monkey patch
    // Don't fire events for insertion marker creation or movement.


    core_browser.Events.disable();
    this.maybeHidePreview_(candidate);
    this.maybeShowPreview_(candidate);
    core_browser.Events.enable();
  }
};

var oldDispose = core_browser.InsertionMarkerManager.prototype.dispose;

core_browser.InsertionMarkerManager.prototype.dispose = function () {
  if (this.pendingBlocks) {
    this.pendingBlocks.forEach(function (block) {
      if (block.finalizeConnections) {
        block.finalizeConnections();
      }
    });
  }

  oldDispose.call(this);
};
;// CONCATENATED MODULE: ./node_modules/@blockly/block-dynamic-connection/src/dynamic_if.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines a version of the if block with dyanmic
 *     inputs that appear when a block is dragged over inputs on the block.
 */

core_browser.Blocks.dynamic_if = {
  /**
   * Counter for the next input to add to this block.
   * @type {number}
   */
  inputCounter: 1,

  /**
   * Minimum number of inputs for this block.
   * @type {number}
   */
  minInputs: 1,

  /**
   * Block for if/elseif/else statements. Must have one if input.
   * Can have any number of elseif inputs and optionally one else input.
   * @this {Blockly.Block}
   */
  init: function init() {
    this.setHelpUrl(core_browser.Msg.CONTROLS_IF_HELPURL);
    this.setStyle('logic_blocks');
    this.appendValueInput('IF0').setCheck('Boolean').appendField(core_browser.Msg.CONTROLS_IF_MSG_IF, 'if');
    this.appendStatementInput('DO0').appendField(core_browser.Msg.CONTROLS_IF_MSG_THEN);
    this.setNextStatement(true);
    this.setPreviousStatement(true);
    this.setTooltip(core_browser.Msg.LISTS_CREATE_WITH_TOOLTIP);
  },

  /**
   * Create XML to represent if/elseif/else inputs.
   * @return {!Element} XML storage element.
   * @this {Blockly.Block}
   */
  mutationToDom: function mutationToDom() {
    var container = core_browser.utils.xml.createElement('mutation');
    var inputNames = this.inputList.filter(function (input) {
      return input.name.includes('IF');
    }).map(function (input) {
      return input.name.replace('IF', '');
    }).join(',');
    container.setAttribute('inputs', inputNames);
    var hasElse = !!this.getInput('ELSE');
    container.setAttribute('else', hasElse);
    container.setAttribute('next', this.inputCounter);
    return container;
  },

  /**
   * Parse XML to restore the inputs.
   * @param {!Element} xmlElement XML storage element.
   * @this {Blockly.Block}
   */
  domToMutation: function domToMutation(xmlElement) {
    var inputs = xmlElement.getAttribute('inputs');

    if (inputs) {
      var inputNumbers = inputs.split(',');

      if (this.getInput('IF0')) {
        this.removeInput('IF0');
      }

      if (this.getInput('DO0')) {
        this.removeInput('DO0');
      }

      var first = inputNumbers[0];
      this.appendValueInput('IF' + first).setCheck('Boolean').appendField(core_browser.Msg.CONTROLS_IF_MSG_IF, 'if');
      this.appendStatementInput('DO' + first).appendField(core_browser.Msg.CONTROLS_IF_MSG_THEN);

      for (var i = 1; i < inputNumbers.length; i++) {
        this.appendValueInput('IF' + inputNumbers[i]).setCheck('Boolean').appendField(core_browser.Msg.CONTROLS_IF_MSG_ELSEIF, 'elseif');
        this.appendStatementInput('DO' + inputNumbers[i]).appendField(core_browser.Msg.CONTROLS_IF_MSG_THEN);
      }
    }

    var hasElse = xmlElement.getAttribute('else');

    if (hasElse == 'true') {
      this.appendStatementInput('ELSE').appendField(core_browser.Msg.CONTROLS_IF_MSG_ELSE, 'else');
    }

    var next = parseInt(xmlElement.getAttribute('next'));
    this.inputCounter = next;
  },

  /**
   * Finds the index of a connection. Used to determine where in the block to
   * insert new inputs.
   * @param {!Blockly.Connection} connection A connection on this block.
   * @return {?number} The index of the connection in the this.inputList.
   */
  findInputIndexForConnection: function findInputIndexForConnection(connection) {
    for (var i = 0; i < this.inputList.length; i++) {
      var input = this.inputList[i];

      if (input.connection == connection) {
        return i;
      }
    }

    return null;
  },

  /**
   * Inserts a boolean value input and statement input at the specified index.
   * @param {number} index Index of the input before which to add new inputs.
   */
  insertElseIf: function insertElseIf(index) {
    var caseNumber = this.inputCounter;
    this.appendValueInput('IF' + caseNumber).setCheck('Boolean').appendField(core_browser.Msg.CONTROLS_IF_MSG_ELSEIF, 'elseif');
    this.appendStatementInput('DO' + caseNumber).appendField(core_browser.Msg.CONTROLS_IF_MSG_THEN);
    this.moveInputBefore('IF' + caseNumber, this.inputList[index].name);
    this.moveInputBefore('DO' + caseNumber, this.inputList[index + 1].name);
    this.inputCounter++;
  },

  /**
   * Called when a block is dragged over one of the connections on this block.
   * @param {!Blockly.Connection} connection The connection on this block that
   * has a pending connection.
   */
  onPendingConnection: function onPendingConnection(connection) {
    if (connection.type === core_browser.NEXT_STATEMENT && !this.getInput('ELSE')) {
      this.appendStatementInput('ELSE').appendField(core_browser.Msg.CONTROLS_IF_MSG_ELSE, 'else');
    }

    var inputIndex = this.findInputIndexForConnection(connection);

    if (inputIndex === null) {
      return;
    }

    var input = this.inputList[inputIndex];

    if (connection.targetConnection && input.name.includes('IF')) {
      var nextIfInput = this.inputList[inputIndex + 2];

      if (!nextIfInput || nextIfInput.name == 'ELSE') {
        this.insertElseIf(inputIndex + 2);
      } else {
        var nextIfConnection = nextIfInput && nextIfInput.connection.targetConnection;

        if (nextIfConnection && !nextIfConnection.sourceBlock_.isInsertionMarker()) {
          this.insertElseIf(inputIndex + 2);
        }
      }
    }
  },

  /**
   * Called when a block drag ends if the dragged block had a pending connection
   * with this block.
   */
  finalizeConnections: function finalizeConnections() {
    var _this = this;

    var toRemove = []; // Remove Else If inputs if neither the if nor the do has a connected block.

    for (var i = 2; i < this.inputList.length - 1; i += 2) {
      var ifConnection = this.inputList[i];
      var doConnection = this.inputList[i + 1];

      if (!ifConnection.connection.targetConnection && !doConnection.connection.targetConnection) {
        toRemove.push(ifConnection.name);
        toRemove.push(doConnection.name);
      }
    }

    toRemove.forEach(function (input) {
      return _this.removeInput(input);
    }); // Remove Else input if it doesn't have a connected block.

    var elseInput = this.getInput('ELSE');

    if (elseInput && !elseInput.connection.targetConnection) {
      this.removeInput(elseInput.name);
    } // Remove the If input if it is empty and there is at least one Else If


    if (this.inputList.length > 2) {
      var ifInput = this.inputList[0];
      var doInput = this.inputList[1];
      var nextInput = this.inputList[2];

      if (nextInput.name.includes('IF') && !ifInput.connection.targetConnection && !doInput.connection.targetConnection) {
        this.removeInput(ifInput.name);
        this.removeInput(doInput.name);
        nextInput.removeField('elseif');
        nextInput.appendField(core_browser.Msg.CONTROLS_IF_MSG_IF, 'if');
      }
    }
  }
};
;// CONCATENATED MODULE: ./node_modules/@blockly/block-dynamic-connection/src/dynamic_text_join.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines a version of the text_join block with dyanmic
 *    inputs that appear when a block is dragged over inputs on the block.
 */

core_browser.Blocks.dynamic_text_join = {
  /**
   * Counter for the next input to add to this block.
   * @type {number}
   */
  inputCounter: 2,

  /**
   * Minimum number of inputs for this block.
   * @type {number}
   */
  minInputs: 2,

  /**
   * Block for concatenating any number of strings.
   * @this {Blockly.Block}
   */
  init: function init() {
    this.setHelpUrl(core_browser.Msg.TEXT_JOIN_HELPURL);
    this.setStyle('text_blocks');
    this.appendValueInput('ADD0').appendField(core_browser.Msg.TEXT_JOIN_TITLE_CREATEWITH);
    this.appendValueInput('ADD1');
    this.setOutput(true, 'String');
    this.setTooltip(core_browser.Msg.TEXT_JOIN_TOOLTIP);
  },

  /**
   * Create XML to represent number of text inputs.
   * @return {!Element} XML storage element.
   * @this {Blockly.Block}
   */
  mutationToDom: function mutationToDom() {
    var container = core_browser.utils.xml.createElement('mutation');
    var inputNames = this.inputList.map(function (input) {
      return input.name;
    }).join(',');
    container.setAttribute('inputs', inputNames);
    container.setAttribute('next', this.inputCounter);
    return container;
  },

  /**
   * Parse XML to restore the text inputs.
   * @param {!Element} xmlElement XML storage element.
   * @this {Blockly.Block}
   */
  domToMutation: function domToMutation(xmlElement) {
    var _this = this;

    var items = xmlElement.getAttribute('inputs');

    if (items) {
      var inputNames = items.split(',');
      this.inputList = [];
      inputNames.forEach(function (name) {
        return _this.appendValueInput(name);
      });
      this.inputList[0].appendField(core_browser.Msg.TEXT_JOIN_TITLE_CREATEWITH);
    }

    var next = parseInt(xmlElement.getAttribute('next'));
    this.inputCounter = next;
  },

  /**
   * Check whether a new input should be added and determine where it should go.
   * @param {!Blockly.Connection} connection The connection that has a
   *     pending connection.
   * @return {number} The index before which to insert a new input,
   *     or null if no input should be added.
   */
  getIndexForNewInput: function getIndexForNewInput(connection) {
    if (!connection.targetConnection) {
      // this connection is available
      return null;
    }

    var connectionIndex;

    for (var i = 0; i < this.inputList.length; i++) {
      if (this.inputList[i].connection == connection) {
        connectionIndex = i;
      }
    }

    if (connectionIndex == this.inputList.length - 1) {
      // this connection is the last one and already has a block in it, so
      // we should add a new connection at the end.
      return this.inputList.length + 1;
    }

    var nextInput = this.inputList[connectionIndex + 1];
    var nextConnection = nextInput && nextInput.connection.targetConnection;

    if (nextConnection && !nextConnection.sourceBlock_.isInsertionMarker()) {
      return connectionIndex + 1;
    } // Don't add new connection


    return null;
  },

  /**
   * Called when a block is dragged over one of the connections on this block.
   * @param {!Blockly.Connection} connection The connection on this block that
   *     has a pending connection.
   */
  onPendingConnection: function onPendingConnection(connection) {
    var insertIndex = this.getIndexForNewInput(connection);

    if (insertIndex == null) {
      return;
    }

    this.appendValueInput('ADD' + this.inputCounter++);
    this.moveNumberedInputBefore(this.inputList.length - 1, insertIndex);
  },

  /**
   * Called when a block drag ends if the dragged block had a pending connection
   * with this block.
   */
  finalizeConnections: function finalizeConnections() {
    var _this2 = this;

    if (this.inputList.length > this.minInputs) {
      var toRemove = [];
      this.inputList.forEach(function (input) {
        var targetConnection = input.connection.targetConnection;

        if (!targetConnection) {
          toRemove.push(input.name);
        }
      });

      if (this.inputList.length - toRemove.length < this.minInputs) {
        // Always show at least two inputs
        toRemove = toRemove.slice(this.minInputs);
      }

      toRemove.forEach(function (inputName) {
        return _this2.removeInput(inputName);
      }); // The first input should have the block text. If we removed the
      // first input, add the block text to the new first input.

      if (this.inputList[0].fieldRow.length == 0) {
        this.inputList[0].appendField(core_browser.Msg.TEXT_JOIN_TITLE_CREATEWITH);
      }
    }
  }
};
;// CONCATENATED MODULE: ./node_modules/@blockly/block-dynamic-connection/src/dynamic_list_create.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Defines a version of the list_create block with dyanmic
 *     inputs that appear when a block is dragged over inputs on the block.
 */

core_browser.Blocks.dynamic_list_create = {
  /**
   * Counter for the next input to add to this block.
   * @type {number}
   */
  inputCounter: 2,

  /**
   * Minimum number of inputs for this block.
   * @type {number}
   */
  minInputs: 2,

  /**
   * Block for concatenating any number of strings.
   * @this {Blockly.Block}
   */
  init: function init() {
    this.setHelpUrl(core_browser.Msg.LISTS_CREATE_WITH_HELPURL);
    this.setStyle('list_blocks');
    this.appendValueInput('ADD0').appendField(core_browser.Msg.LISTS_CREATE_WITH_INPUT_WITH);
    this.appendValueInput('ADD1');
    this.setOutput(true, 'Array');
    this.setTooltip(core_browser.Msg.LISTS_CREATE_WITH_TOOLTIP);
  },

  /**
   * Create XML to represent number of text inputs.
   * @return {!Element} XML storage element.
   * @this {Blockly.Block}
   */
  mutationToDom: function mutationToDom() {
    var container = core_browser.utils.xml.createElement('mutation');
    var inputNames = this.inputList.map(function (input) {
      return input.name;
    }).join(',');
    container.setAttribute('inputs', inputNames);
    container.setAttribute('next', this.inputCounter);
    return container;
  },

  /**
   * Parse XML to restore the text inputs.
   * @param {!Element} xmlElement XML storage element.
   * @this {Blockly.Block}
   */
  domToMutation: function domToMutation(xmlElement) {
    var _this = this;

    var items = xmlElement.getAttribute('inputs');

    if (items) {
      var inputNames = items.split(',');
      this.inputList = [];
      inputNames.forEach(function (name) {
        return _this.appendValueInput(name);
      });
      this.inputList[0].appendField(core_browser.Msg.LISTS_CREATE_WITH_INPUT_WITH);
    }

    var next = parseInt(xmlElement.getAttribute('next'));
    this.inputCounter = next;
  },

  /**
   * Check whether a new input should be added and determine where it should go.
   * @param {!Blockly.Connection} connection The connection that has a
   *     pending connection.
   * @return {number} The index before which to insert a new input,
   *     or null if no input should be added.
   */
  getIndexForNewInput: function getIndexForNewInput(connection) {
    if (!connection.targetConnection) {
      // this connection is available
      return null;
    }

    var connectionIndex;

    for (var i = 0; i < this.inputList.length; i++) {
      if (this.inputList[i].connection == connection) {
        connectionIndex = i;
      }
    }

    if (connectionIndex == this.inputList.length - 1) {
      // this connection is the last one and already has a block in it, so
      // we should add a new connection at the end.
      return this.inputList.length + 1;
    }

    var nextInput = this.inputList[connectionIndex + 1];
    var nextConnection = nextInput && nextInput.connection.targetConnection;

    if (nextConnection && !nextConnection.sourceBlock_.isInsertionMarker()) {
      return connectionIndex + 1;
    } // Don't add new connection


    return null;
  },

  /**
   * Called when a block is dragged over one of the connections on this block.
   * @param {!Blockly.Connection} connection The connection on this block that
   * has a pending connection.
   */
  onPendingConnection: function onPendingConnection(connection) {
    var insertIndex = this.getIndexForNewInput(connection);

    if (insertIndex == null) {
      return;
    }

    this.appendValueInput('ADD' + this.inputCounter++);
    this.moveNumberedInputBefore(this.inputList.length - 1, insertIndex);
  },

  /**
   * Called when a block drag ends if the dragged block had a pending connection
   * with this block.
   */
  finalizeConnections: function finalizeConnections() {
    var _this2 = this;

    if (this.inputList.length > this.minInputs) {
      var toRemove = [];
      this.inputList.forEach(function (input) {
        var targetConnection = input.connection.targetConnection;

        if (!targetConnection) {
          toRemove.push(input.name);
        }
      });

      if (this.inputList.length - toRemove.length < this.minInputs) {
        // Always show at least two inputs
        toRemove = toRemove.slice(this.minInputs);
      }

      toRemove.forEach(function (inputName) {
        return _this2.removeInput(inputName);
      }); // The first input should have the block text. If we removed the
      // first input, add the block text to the new first input.

      if (this.inputList[0].fieldRow.length == 0) {
        this.inputList[0].appendField(core_browser.Msg.LISTS_CREATE_WITH_INPUT_WITH);
      }
    }
  }
};
;// CONCATENATED MODULE: ./node_modules/@blockly/block-dynamic-connection/src/index.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Adds blocks that replace the built-in mutator UI with dynamic
 *     connections that appear when a block is dragged over inputs on the block.
 */




var overrideOldBlockDefinitions = function overrideOldBlockDefinitions() {
  Blockly.Blocks['list_create'] = Blockly.Blocks['dynamic_list_create'];
  Blockly.Blocks['text_join'] = Blockly.Blocks['dynamic_text_join'];
  Blockly.Blocks['controls_if'] = Blockly.Blocks['dynamic_if'];
};
;// CONCATENATED MODULE: ./node_modules/@blockly/theme-modern/src/index.js
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Modern theme.
 */

/* harmony default export */ var src = (core_browser_default().Theme.defineTheme('modern', {
  'base': (core_browser_default()).Themes.Classic,
  'blockStyles': {
    'colour_blocks': {
      'colourPrimary': '#a5745b',
      'colourSecondary': '#dbc7bd',
      'colourTertiary': '#845d49'
    },
    'list_blocks': {
      'colourPrimary': '#745ba5',
      'colourSecondary': '#c7bddb',
      'colourTertiary': '#5d4984'
    },
    'logic_blocks': {
      'colourPrimary': '#5b80a5',
      'colourSecondary': '#bdccdb',
      'colourTertiary': '#496684'
    },
    'loop_blocks': {
      'colourPrimary': '#5ba55b',
      'colourSecondary': '#bddbbd',
      'colourTertiary': '#498449'
    },
    'math_blocks': {
      'colourPrimary': '#5b67a5',
      'colourSecondary': '#bdc2db',
      'colourTertiary': '#495284'
    },
    'procedure_blocks': {
      'colourPrimary': '#995ba5',
      'colourSecondary': '#d6bddb',
      'colourTertiary': '#7a4984'
    },
    'text_blocks': {
      'colourPrimary': '#5ba58c',
      'colourSecondary': '#bddbd1',
      'colourTertiary': '#498470'
    },
    'variable_blocks': {
      'colourPrimary': '#a55b99',
      'colourSecondary': '#dbbdd6',
      'colourTertiary': '#84497a'
    },
    'variable_dynamic_blocks': {
      'colourPrimary': '#a55b99',
      'colourSecondary': '#dbbdd6',
      'colourTertiary': '#84497a'
    },
    'hat_blocks': {
      'colourPrimary': '#a55b99',
      'colourSecondary': '#dbbdd6',
      'colourTertiary': '#84497a',
      'hat': 'cap'
    }
  },
  'categoryStyles': {
    'colour_category': {
      'colour': '#a5745b'
    },
    'list_category': {
      'colour': '#745ba5'
    },
    'logic_category': {
      'colour': '#5b80a5'
    },
    'loop_category': {
      'colour': '#5ba55b'
    },
    'math_category': {
      'colour': '#5b67a5'
    },
    'procedure_category': {
      'colour': '#995ba5'
    },
    'text_category': {
      'colour': '#5ba58c'
    },
    'variable_category': {
      'colour': '#a55b99'
    },
    'variable_dynamic_category': {
      'colour': '#a55b99'
    }
  },
  'componentStyles': {},
  'fontStyle': {},
  'startHats': null
}));
;// CONCATENATED MODULE: ./node_modules/@blockly/theme-dark/src/index.js
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Dark theme.
 */

/**
 * Dark theme.
 */

/* harmony default export */ var theme_dark_src = (core_browser_default().Theme.defineTheme('theme_dark', {
  'base': (core_browser_default()).Themes.Classic,
  'componentStyles': {
    'workspaceBackgroundColour': '#1e1e1e',
    'toolboxBackgroundColour': 'blackBackground',
    'toolboxForegroundColour': '#fff',
    'flyoutBackgroundColour': '#252526',
    'flyoutForegroundColour': '#ccc',
    'flyoutOpacity': 1,
    'scrollbarColour': '#797979',
    'insertionMarkerColour': '#fff',
    'insertionMarkerOpacity': 0.3,
    'scrollbarOpacity': 0.4,
    'cursorColour': '#d0d0d0',
    'blackBackground': '#333'
  }
}));
;// CONCATENATED MODULE: ./node_modules/@blockly/disable-top-blocks/src/index.js



/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Plugin for changing the context menu to match the
 * `disableOrphans` event handler.
 */

/**
 * This plugin changes the logic of the enable/disable context menu item. It is
 * enabled for all blocks except top-level blocks that have output or
 * previous connections. In other words, the option is disabled for orphan
 * blocks. Using this plugin allows users to disable valid non-orphan blocks,
 * but not re-enable blocks that have been automatically disabled by
 * `disableOrphans`.
 */

var DisableTopBlocks = /*#__PURE__*/function () {
  function DisableTopBlocks() {
    (0,classCallCheck/* default */.Z)(this, DisableTopBlocks);
  }

  (0,createClass/* default */.Z)(DisableTopBlocks, [{
    key: "init",
    value:
    /**
     * Modifies the context menu 'disable' option as described above.
     */
    function init() {
      var disableMenuItem = core_browser.ContextMenuRegistry.registry.getItem('blockDisable');
      this.oldPreconditionFn = disableMenuItem.preconditionFn;

      disableMenuItem.preconditionFn = function (
      /** @type {!Blockly.ContextMenuRegistry.Scope} */
      scope) {
        var block = scope.block;

        if (!block.isInFlyout && block.workspace.options.disable && block.isEditable()) {
          if (block.getInheritedDisabled() || isOrphan(block)) {
            return 'disabled';
          }

          return 'enabled';
        }

        return 'hidden';
      };
    }
    /**
     * Turn off the effects of this plugin and restore the initial behavior.
     * This is never required to be called. It is optional in case you need to
     * disable the plugin.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var disableMenuItem = core_browser.ContextMenuRegistry.registry.getItem('blockDisable');
      disableMenuItem.preconditionFn = this.oldPreconditionFn;
    }
  }]);

  return DisableTopBlocks;
}();
/**
 * A block is an orphan if its parent is an orphan, or if it doesn't have a
 * parent but it does have a previous or output connection (so it expects to be
 * attached to something). This means all children of orphan blocks are also
 * orphans and cannot be manually re-enabled.
 * @param {!Blockly.BlockSvg} block Block to check.
 * @return {boolean} Whether the block is an orphan.
 */

function isOrphan(block) {
  // If the parent is an orphan block, this block should also be considered
  // an orphan so it cannot be manually re-enabled.
  var parent =
  /** @type {Blockly.BlockSvg} */
  block.getParent();

  if (parent && isOrphan(parent)) {
    return true;
  }

  return !parent && !!(block.outputConnection || block.previousConnection);
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(85061);
// EXTERNAL MODULE: ./jacdac-ts/src/jdom/constants.ts
var constants = __webpack_require__(71815);
// EXTERNAL MODULE: ./jacdac-ts/jacdac-spec/spectool/jdspec.ts
var jdspec = __webpack_require__(13996);
// EXTERNAL MODULE: ./jacdac-ts/src/jdom/spec.ts + 2 modules
var spec = __webpack_require__(13173);
// EXTERNAL MODULE: ./jacdac-ts/src/jdom/utils.ts
var utils = __webpack_require__(81794);
// EXTERNAL MODULE: ./src/components/hooks/useServices.ts
var useServices = __webpack_require__(2928);
// EXTERNAL MODULE: ./jacdac-ts/src/jdom/flags.ts
var flags = __webpack_require__(21258);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/styles/useTheme.js
var useTheme = __webpack_require__(59355);
// EXTERNAL MODULE: ./node_modules/gatsby-link/index.js
var gatsby_link = __webpack_require__(38037);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(92137);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
var inheritsLoose = __webpack_require__(41788);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(87757);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
// EXTERNAL MODULE: ./src/components/hooks/toneContext.ts
var toneContext = __webpack_require__(66775);
// EXTERNAL MODULE: ./src/components/ui/Suspense.tsx
var Suspense = __webpack_require__(69672);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(73935);
// EXTERNAL MODULE: ./src/jacdac/Provider.tsx
var Provider = __webpack_require__(727);
// EXTERNAL MODULE: ./node_modules/react-use-id-hook/dist/react-use-id-hook.esm.js
var react_use_id_hook_esm = __webpack_require__(19640);
// EXTERNAL MODULE: ./src/components/ui/DarkModeProvider.tsx
var DarkModeProvider = __webpack_require__(7796);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/styles/createMuiTheme.js + 14 modules
var createMuiTheme = __webpack_require__(81864);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/styles/responsiveFontSizes.js + 1 modules
var responsiveFontSizes = __webpack_require__(23581);
// EXTERNAL MODULE: ./node_modules/@material-ui/styles/esm/ThemeProvider/ThemeProvider.js
var ThemeProvider = __webpack_require__(87761);
// EXTERNAL MODULE: ./src/components/ui/DarkModeContext.tsx
var DarkModeContext = __webpack_require__(91350);
;// CONCATENATED MODULE: ./src/components/ui/AppTheme.tsx



function AppTheme(props) {
  var _useContext = (0,react.useContext)(DarkModeContext/* default */.Z),
      darkMode = _useContext.darkMode;

  var isDark = darkMode === "dark";
  var themeDef = {
    palette: {
      primary: {
        main: isDark ? "#56d364" : "#2e7d32"
      },
      secondary: {
        main: "#ffc400"
      },
      contrastThreshold: isDark ? 5.1 : 3.1,
      type: darkMode
    }
  };
  var rawTheme = (0,createMuiTheme/* default */.Z)(themeDef);
  var theme = (0,responsiveFontSizes/* default */.Z)(rawTheme);
  return /*#__PURE__*/react.createElement(ThemeProvider/* default */.Z, Object.assign({
    theme: theme
  }, props));
}
;// CONCATENATED MODULE: ./src/components/vm/fields/ReactField.tsx










/**
 * A base class for react-based field
 * TODO:
 
```
  static fromJson(options) {
    return new ReactDateField(new Date(options['date']));
  }
  
  onDateSelected_ = (date) => {
    this.setValue(new Date(date));
    Blockly.DropDownDiv.hideIfOwner(this, true);
  }

  getText_() {
    return this.value_.toLocaleDateString();
  };

  fromXml(fieldElement) {
    this.setValue(new Date(fieldElement.textContent));
  }
```
*/
var ReactField = /*#__PURE__*/function (_Blockly$Field) {
  (0,inheritsLoose/* default */.Z)(ReactField, _Blockly$Field);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function ReactField(value, validator, options) {
    var _this;

    _this = _Blockly$Field.call(this, value, validator, options) || this;
    _this.SERIALIZABLE = true;
    return _this;
  }

  var _proto = ReactField.prototype;

  _proto.getText_ = function getText_() {
    return JSON.stringify(this.value);
  };

  _proto.fromXml = function fromXml(fieldElement) {
    try {
      var v = JSON.parse(fieldElement.textContent);
      this.value = v;
    } catch (e) {
      console.warn(e);
      this.value = undefined;
    }
  };

  _proto.setSourceBlock = function setSourceBlock(block) {
    _Blockly$Field.prototype.setSourceBlock.call(this, block);

    this.onSourceBlockChanged();
  };

  _proto.onSourceBlockChanged = function onSourceBlockChanged() {};

  _proto.onMount = function onMount() {};

  _proto.onUnmount = function onUnmount() {};

  _proto.showEditor_ = function showEditor_() {
    var _this2 = this;

    this.div_ = blockly_default().DropDownDiv.getContentDiv();
    react_dom.render(this.render(), this.div_);
    var border = this.sourceBlock_.getColourTertiary();
    blockly_default().DropDownDiv.setColour(this.sourceBlock_.getColour(), border); // the div_ size has not been computed yet, so let the browse handle this

    setTimeout(function () {
      blockly_default().DropDownDiv.showPositionedByField(_this2, _this2.dropdownDispose_.bind(_this2));

      _this2.onMount();
    }, 200);
  };

  _proto.hide = function hide() {
    blockly_default().DropDownDiv.hideIfOwner(this, true);
  };

  _proto.dropdownDispose_ = function dropdownDispose_() {
    // this blows on hot reloads
    try {
      this.onUnmount();
      react_dom.unmountComponentAtNode(this.div_);
    } catch (e) {
      console.error(e);
    }
  };

  _proto.render = function render() {
    return /*#__PURE__*/react.createElement(DarkModeProvider/* default */.Z, null, /*#__PURE__*/react.createElement(react_use_id_hook_esm/* IdProvider */.vc, null, /*#__PURE__*/react.createElement(Provider/* default */.Z, null, /*#__PURE__*/react.createElement(AppTheme, null, this.renderField()))));
  };

  _proto.renderField = function renderField() {
    return /*#__PURE__*/react.createElement("span", null, "not implemented");
  };

  (0,createClass/* default */.Z)(ReactField, [{
    key: "defaultValue",
    get: function get() {
      return {};
    }
  }, {
    key: "value",
    get: function get() {
      try {
        var v = JSON.parse(this.getValue());
        return v || this.defaultValue;
      } catch (e) {
        console.warn(e);
        return this.defaultValue;
      }
    },
    set: function set(v) {
      this.setValue(JSON.stringify(v));
    }
  }]);

  return ReactField;
}((blockly_default()).Field);
;// CONCATENATED MODULE: ./src/components/vm/fields/NoteField.tsx








var PianoWidget = /*#__PURE__*/(0,react.lazy)(function () {
  return Promise.all(/* import() */[__webpack_require__.e(532), __webpack_require__.e(8937)]).then(__webpack_require__.bind(__webpack_require__, 28937));
});

var NoteField = /*#__PURE__*/function (_ReactField) {
  (0,inheritsLoose/* default */.Z)(NoteField, _ReactField);

  function NoteField() {
    return _ReactField.apply(this, arguments) || this;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  NoteField.fromJson = function fromJson(options) {
    return new NoteField(options === null || options === void 0 ? void 0 : options.value, undefined, options);
  };

  var _proto = NoteField.prototype;

  _proto.getText_ = function getText_() {
    var frequency = this.value.frequency;
    return (frequency | 0) + "";
  };

  _proto.onUnmount = function onUnmount() {
    var _this$toneContext;

    (_this$toneContext = this.toneContext) === null || _this$toneContext === void 0 ? void 0 : _this$toneContext.close();
    this.toneContext = undefined;
  };

  _proto.renderField = function renderField() {
    var _this = this;

    var handlePlayTone = /*#__PURE__*/function () {
      var _ref = (0,asyncToGenerator/* default */.Z)( /*#__PURE__*/regenerator_default().mark(function _callee(newFrequency) {
        var _this$toneContext2;

        return regenerator_default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this.value = {
                  frequency: newFrequency
                };
                if (!_this.toneContext) _this.toneContext = (0,toneContext/* createToneContext */.W)();
                (_this$toneContext2 = _this.toneContext) === null || _this$toneContext2 === void 0 ? void 0 : _this$toneContext2.playTone(newFrequency, 400);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function handlePlayTone(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    return /*#__PURE__*/react.createElement(Suspense/* default */.Z, null, /*#__PURE__*/react.createElement(PianoWidget, {
      playTone: handlePlayTone
    }));
  };

  (0,createClass/* default */.Z)(NoteField, [{
    key: "defaultValue",
    get: function get() {
      return {
        frequency: 440
      };
    }
  }]);

  return NoteField;
}(ReactField);

NoteField.KEY = "jacdac_field_note";

// EXTERNAL MODULE: ./jacdac-ts/src/servers/hidkeyboardserver.ts
var hidkeyboardserver = __webpack_require__(41577);
;// CONCATENATED MODULE: ./src/components/vm/fields/KeyboardKeyField.tsx






var KeyboardKeyInput = /*#__PURE__*/(0,react.lazy)(function () {
  return Promise.all(/* import() */[__webpack_require__.e(532), __webpack_require__.e(7919), __webpack_require__.e(2860)]).then(__webpack_require__.bind(__webpack_require__, 82860));
});

var KeyboardKeyField = /*#__PURE__*/function (_ReactField) {
  (0,inheritsLoose/* default */.Z)(KeyboardKeyField, _ReactField);

  function KeyboardKeyField() {
    return _ReactField.apply(this, arguments) || this;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  KeyboardKeyField.fromJson = function fromJson(options) {
    return new KeyboardKeyField(options === null || options === void 0 ? void 0 : options.value, undefined, options);
  };

  var _proto = KeyboardKeyField.prototype;

  _proto.getText_ = function getText_() {
    var _this$value = this.value,
        selector = _this$value.selector,
        modifiers = _this$value.modifiers;
    return (0,hidkeyboardserver/* renderKeyboardKey */.OJ)(selector, modifiers, true);
  };

  _proto.renderField = function renderField() {
    var _this = this;

    var _this$value2 = this.value,
        selector = _this$value2.selector,
        modifiers = _this$value2.modifiers;

    var handleChange = function handleChange(newSelector, newModifiers) {
      _this.value = {
        selector: newSelector,
        modifiers: newModifiers
      };
    };

    return /*#__PURE__*/react.createElement(Suspense/* default */.Z, null, /*#__PURE__*/react.createElement(KeyboardKeyInput, {
      initialSelector: selector,
      initialModifiers: modifiers,
      onChange: handleChange
    }));
  };

  (0,createClass/* default */.Z)(KeyboardKeyField, [{
    key: "defaultValue",
    get: function get() {
      return {
        selector: 4,
        modifiers: 0
      };
    }
  }]);

  return KeyboardKeyField;
}(ReactField);

KeyboardKeyField.KEY = "jacdac_field_keyboard_key";

;// CONCATENATED MODULE: ./src/components/widgets/svg.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
function mkTitle(txt) {
  var t = elt("title");
  t.textContent = txt;
  return t;
}

function title(el, txt) {
  var t = mkTitle(txt);
  el.appendChild(t);
  return t;
}
function hydrate(el, props) {
  for (var k in props) {
    if (k == "title") {
      title(el, props[k]);
    } else el.setAttributeNS(null, k, props[k]);
  }
}
function elt(name, props) {
  var el = document.createElementNS("http://www.w3.org/2000/svg", name);
  if (props) hydrate(el, props);
  return el;
}
function child(parent, name, props) {
  var el = elt(name, props);
  parent.appendChild(el);
  return el;
}
;// CONCATENATED MODULE: ./src/components/vm/fields/ReactImageField.tsx





var ReactImageField = /*#__PURE__*/function (_ReactField) {
  (0,inheritsLoose/* default */.Z)(ReactImageField, _ReactField);

  function ReactImageField(value, width, height) {
    var _this;

    if (width === void 0) {
      width = 32;
    }

    if (height === void 0) {
      height = 32;
    }

    _this = _ReactField.call(this, value) || this;
    _this.size_ = new (blockly_default()).utils.Size(width, height);
    return _this;
  }

  var _proto = ReactImageField.prototype;

  _proto.setSize = function setSize(width, height) {
    this.size_ = new (blockly_default()).utils.Size(width, height);

    if (this.img) {
      this.img.setAttribute("width", width + "");
      this.img.setAttribute("height", height + "");
    }
  };

  _proto.updateImage = function updateImage() {
    var imgUri = this.renderValue();

    if (imgUri) {
      var _this$img, _this$img2;

      (_this$img = this.img) === null || _this$img === void 0 ? void 0 : _this$img.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", imgUri);
      (_this$img2 = this.img) === null || _this$img2 === void 0 ? void 0 : _this$img2.setAttribute("alt", this.getText());
    }
  }
  /**
   * Renders the value to a data uri string
   */
  ;

  _proto.renderValue = function renderValue() {
    return undefined;
  };

  _proto.initView = function initView() {
    var _this$size_ = this.size_,
        width = _this$size_.width,
        height = _this$size_.height;
    this.img = child(this.fieldGroup_, "image", {
      height: height,
      width: width,
      alt: this.getText()
    });
    this.updateImage();
  };

  _proto.doValueUpdate_ = function doValueUpdate_(newValue) {
    this.value_ = newValue;
    this.updateImage();
  };

  _proto.updateSize_ = function updateSize_() {};

  return ReactImageField;
}(ReactField);


;// CONCATENATED MODULE: ./src/components/vm/fields/LEDMatrixField.tsx






var LEDMatrixWidget = /*#__PURE__*/(0,react.lazy)(function () {
  return __webpack_require__.e(/* import() */ 317).then(__webpack_require__.bind(__webpack_require__, 71598));
});

var LEDMatrixField = /*#__PURE__*/function (_ReactImageField) {
  (0,inheritsLoose/* default */.Z)(LEDMatrixField, _ReactImageField);

  function LEDMatrixField(value) {
    return _ReactImageField.call(this, value) || this;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  LEDMatrixField.fromJson = function fromJson(options) {
    return new LEDMatrixField(options === null || options === void 0 ? void 0 : options.value);
  };

  var _proto = LEDMatrixField.prototype;

  _proto.getText_ = function getText_() {
    var _this$value = this.value,
        leds = _this$value.leds,
        rows = _this$value.rows,
        columns = _this$value.columns;
    return leds + " (" + rows + "x" + columns + ")";
  };

  _proto.doValueUpdate_ = function doValueUpdate_(newValue) {
    _ReactImageField.prototype.doValueUpdate_.call(this, newValue);

    var _this$value2 = this.value,
        rows = _this$value2.rows,
        columns = _this$value2.columns;
    this.setSize(32, 32 / columns * rows);
  };

  _proto.renderValue = function renderValue() {
    var _this$value3 = this.value,
        leds = _this$value3.leds,
        rows = _this$value3.rows,
        columns = _this$value3.columns; // render current state to LEDmatrix field

    var columnspadded = columns + (8 - columns % 8);
    var ledsBytes = (0,utils/* fromHex */.H_)(leds);
    var cvs = document.createElement("canvas");
    var b = 3;
    var pw = 8;
    var ph = 8;
    var w = rows * pw + (rows - 1) * b;
    var h = columns * ph + (columns - 1) * b;
    cvs.width = w + 2 * b;
    cvs.height = h + 2 * b;
    var ctx = cvs.getContext("2d");
    ctx.fillStyle = "#444";
    ctx.fillRect(b, b, w, h);
    ctx.fillStyle = "blue";

    for (var x = 0; x < columns; ++x) {
      for (var y = 0; y < rows; ++y) {
        var bitindex = y * columnspadded + x;
        var byte = ledsBytes[bitindex >> 3];
        var bit = bitindex % 8;
        var on = 1 === (byte >> bit & 1);
        ctx.fillStyle = on ? "#ffc400" : "#000";
        ctx.fillRect(x * (pw + b) + b, y * (ph + b) + b, pw, ph);
      }
    }

    var dataUri = cvs.toDataURL("image/png");
    return dataUri;
  };

  _proto.renderField = function renderField() {
    var _this = this;

    var _this$value4 = this.value,
        leds = _this$value4.leds,
        rows = _this$value4.rows,
        columns = _this$value4.columns;
    var ledsBytes = (0,utils/* fromHex */.H_)(leds);

    var onChange = function onChange(newLeds) {
      return _this.value = {
        leds: (0,utils/* toHex */.NC)(newLeds),
        rows: rows,
        columns: columns
      };
    };

    return /*#__PURE__*/react.createElement(Suspense/* default */.Z, null, /*#__PURE__*/react.createElement(LEDMatrixWidget, {
      color: "secondary",
      brightness: 1,
      leds: ledsBytes,
      rows: rows,
      columns: columns,
      onChange: onChange
    }));
  };

  (0,createClass/* default */.Z)(LEDMatrixField, [{
    key: "defaultValue",
    get: function get() {
      return {
        leds: (0,utils/* toHex */.NC)(new Uint8Array(4)),
        rows: 5,
        columns: 5
      };
    }
  }]);

  return LEDMatrixField;
}(ReactImageField);

LEDMatrixField.KEY = "jacdac_field_led_matrix";

;// CONCATENATED MODULE: ./src/components/vm/fields/fields.ts




var registered = false;
function registerFields() {
  if (registered) return;
  registered = true;
  blockly_default().fieldRegistry.register(KeyboardKeyField.KEY, KeyboardKeyField);
  blockly_default().fieldRegistry.register(NoteField.KEY, NoteField);
  blockly_default().fieldRegistry.register(LEDMatrixField.KEY, LEDMatrixField);
}
;// CONCATENATED MODULE: ./src/components/vm/useToolbox.ts















var NEW_PROJET_XML = '<xml xmlns="http://www.w3.org/1999/xhtml"></xml>';
var WHILE_CONDITION_BLOCK = "jacdac_while_event";
var WHILE_CONDITION_BLOCK_CONDITION = "condition";
var WAIT_BLOCK = "jacdac_wait";
var SET_STATUS_LIGHT_BLOCK = "jacdac_set_status_light";

function isBooleanField(field) {
  return field.type === "bool";
}

function isStringField(field) {
  return field.type === "string";
}

function toBlocklyType(field) {
  return isBooleanField(field) ? "Boolean" : isStringField(field) ? "String" : (0,jdspec/* isNumericType */.FV)(field) ? "Number" : undefined;
}

function enumInfo(srv, field) {
  var _srv$enums;

  var e = (_srv$enums = srv.enums) === null || _srv$enums === void 0 ? void 0 : _srv$enums[field.type];
  return e;
}

var ignoredServices = [constants/* SRV_CONTROL */.gm9, constants/* SRV_LOGGER */.w9j, constants/* SRV_ROLE_MANAGER */.igi, constants/* SRV_PROTO_TEST */.$Bn, constants/* SRV_SETTINGS */.B9b, constants/* SRV_BOOTLOADER */.PWm];
var ignoredEvents = [constants/* SystemEvent.StatusCodeChanged */.nSK.StatusCodeChanged];
var includedRegisters = [constants/* SystemReg.Reading */.ZJq.Reading, constants/* SystemReg.Value */.ZJq.Value, constants/* SystemReg.Intensity */.ZJq.Intensity];
var customMessages = [{
  service: constants/* SRV_JOYSTICK */.vRO,
  register: constants/* JoystickReg.Direction */.ztd.Direction,
  field: "buttons",
  get: "is %1 %2 pressed"
}];

function createBlockTheme(theme) {
  var sensorColor = theme.palette.success.main;
  var otherColor = theme.palette.info.main;
  var commandColor = theme.palette.warning.main;

  var serviceColor = function serviceColor(srv) {
    return (0,spec/* isSensor */.rq)(srv) ? sensorColor : otherColor;
  };

  return {
    serviceColor: serviceColor,
    sensorColor: sensorColor,
    commandColor: commandColor,
    otherColor: otherColor
  };
}

function loadBlocks(serviceColor, commandColor) {
  var serviceHelp = function serviceHelp(service) {
    return (0,gatsby_link/* withPrefix */.dq)("/services/" + service.shortId);
  };

  var fieldsSupported = function fieldsSupported(pkt) {
    return pkt.fields.every(toBlocklyType);
  };

  var fieldName = function fieldName(reg, field) {
    return field.name === "_" ? reg.name : field.name;
  };

  var fieldToShadow = function fieldToShadow(field) {
    return isBooleanField(field) ? {
      kind: "block",
      type: "jacdac_on_off"
    } : isStringField(field) ? {
      kind: "block",
      type: "text"
    } : field.unit === "°" ? {
      kind: "block",
      type: "jacdac_angle"
    } : field.unit === "/" ? {
      kind: "block",
      type: "jacdac_ratio"
    } : /^%/.test(field.unit) ? {
      kind: "block",
      type: "jacdac_percent"
    } : field.type === "u8" ? {
      kind: "block",
      type: "jacdac_byte"
    } : {
      kind: "block",
      type: "math_number",
      value: field.defaultValue || 0,
      min: field.typicalMin || field.absoluteMin,
      max: field.typicalMax || field.absoluteMax
    };
  };

  var variableName = function variableName(srv) {
    return (0,jdspec/* humanify */.lW)(srv.camelName).toLowerCase() + " 1";
  };

  var fieldVariable = function fieldVariable(service) {
    return {
      type: "field_variable",
      name: "role",
      variable: variableName(service),
      variableTypes: [service.shortId],
      defaultType: service.shortId
    };
  };

  var fieldsToFieldInputs = function fieldsToFieldInputs(info) {
    return info.fields.map(function (field) {
      return {
        type: "input_value",
        name: fieldName(info, field),
        check: toBlocklyType(field)
      };
    });
  };

  var fieldsToValues = function fieldsToValues(info) {
    return (0,utils/* toMap */.qL)(info.fields, function (field) {
      return fieldName(info, field);
    }, function (field) {
      return fieldToShadow(field);
    });
  };

  var fieldsToMessage = function fieldsToMessage(info) {
    return info.fields.map(function (field, i) {
      return (0,jdspec/* humanify */.lW)(field.name) + " %" + (2 + i);
    }).join(" ");
  };

  var isEnabledRegister = function isEnabledRegister(info) {
    return info.fields.length === 1 && info.fields[0].type === "bool" && info.name === "enabled";
  };

  var customMessage = function customMessage(srv, reg, field) {
    return customMessages.find(function (m) {
      return m.service === srv.classIdentifier && m.register === reg.identifier && m.field === field.name;
    });
  };

  var allServices = (0,spec/* serviceSpecifications */.Le)().filter(function (service) {
    return !/^_/.test(service.shortId) && service.status !== "deprecated";
  }).filter(function (service) {
    return ignoredServices.indexOf(service.classIdentifier) < 0;
  });

  var resolveService = function resolveService(cls) {
    return allServices.filter(function (srv) {
      return srv.classIdentifier === cls;
    });
  };

  var registers = (0,utils/* arrayConcatMany */.ue)(allServices.map(function (service) {
    return service.packets.filter(function (pkt) {
      return (0,spec/* isRegister */.x5)(pkt) && includedRegisters.indexOf(pkt.identifier) > -1;
    }).map(function (register) {
      return {
        service: service,
        register: register
      };
    });
  }));
  var events = allServices.map(function (service) {
    return {
      service: service,
      events: service.packets.filter(function (pkt) {
        return (0,spec/* isEvent */.cO)(pkt) && ignoredEvents.indexOf(pkt.identifier) < 0;
      })
    };
  }).filter(function (kv) {
    return !!kv.events.length;
  });
  var commands = (0,utils/* arrayConcatMany */.ue)(allServices.map(function (service) {
    return service.packets.filter(function (pkt) {
      return (0,spec/* isCommand */.ao)(pkt) && fieldsSupported(pkt);
    }).map(function (pkt) {
      return {
        service: service,
        command: pkt
      };
    });
  }));
  var customBlockDefinitions = [].concat((0,toConsumableArray/* default */.Z)(resolveService(constants/* SRV_HID_KEYBOARD */.Hg9).map(function (service) {
    return {
      kind: "block",
      type: "key",
      message0: "send %1 key %2",
      args0: [fieldVariable(service), {
        type: KeyboardKeyField.KEY,
        name: "combo"
      }],
      colour: serviceColor(service),
      inputsInline: true,
      previousStatement: null,
      nextStatement: null,
      tooltip: "Send a keyboard key combo",
      helpUrl: serviceHelp(service),
      service: service,
      expression: "role.key(combo.selectors, combo.modifiers)",
      //expression: `play_tone(frequency, duration) => role.send_pulse(frequency / 10000, duration)`,
      template: "custom"
    };
  })), (0,toConsumableArray/* default */.Z)(resolveService(constants/* SRV_BUZZER */.J1$).map(function (service) {
    return {
      kind: "block",
      type: "play_note",
      message0: "play %1 note %2 for %3 s at volume %4",
      args0: [fieldVariable(service), {
        type: "input_value",
        name: "frequency",
        check: "Number"
      }, {
        type: "input_value",
        name: "duration",
        check: "Number"
      }, {
        type: "input_value",
        name: "volume",
        check: "Number"
      }],
      values: {
        frequency: {
          kind: "block",
          type: "jacdac_note",
          shadow: true
        },
        duration: {
          kind: "block",
          type: "jacdac_time_picker",
          shadow: true
        },
        volume: {
          kind: "block",
          type: "jacdac_ratio",
          value: 0.5,
          shadow: true
        }
      },
      colour: serviceColor(service),
      inputsInline: true,
      previousStatement: null,
      nextStatement: null,
      tooltip: "Send a keyboard key combo",
      helpUrl: serviceHelp(service),
      service: service,
      expression: "role.play_tone(frequency / 10000, duration) TODO",
      template: "custom"
    };
  })), (0,toConsumableArray/* default */.Z)(resolveService(constants/* SRV_SEVEN_SEGMENT_DISPLAY */.hvg).map(function (service) {
    return {
      kind: "block",
      type: "set_digits",
      message0: "set %1 digits to %2",
      args0: [fieldVariable(service), {
        type: "input_value",
        name: "digits",
        check: "Number"
      }],
      values: {
        digits: {
          kind: "block",
          type: "math_number"
        }
      },
      colour: serviceColor(service),
      inputsInline: true,
      previousStatement: null,
      nextStatement: null,
      tooltip: "Display a number of the screen",
      helpUrl: serviceHelp(service),
      service: service,
      // encode digits
      template: "custom"
    };
  })), (0,toConsumableArray/* default */.Z)(resolveService(constants/* SRV_LED_MATRIX */.ZmS).map(function (service) {
    return {
      kind: "block",
      type: "_show_leds",
      message0: "show %1 leds %2",
      args0: [fieldVariable(service), {
        type: LEDMatrixField.KEY,
        name: "leds"
      }],
      colour: serviceColor(service),
      inputsInline: true,
      previousStatement: null,
      nextStatement: null,
      tooltip: "Display LEDs on the LED matrix",
      helpUrl: serviceHelp(service),
      service: service,
      // encode digits
      template: "custom"
    };
  }))).map(function (def) {
    def.type = "jacdac_custom_" + def.service.shortId + "_" + def.type;
    return def;
  });
  var eventBlocks = events.map(function (_ref) {
    var service = _ref.service,
        events = _ref.events;
    return {
      kind: "block",
      type: "jacdac_events_" + service.shortId,
      message0: "when %1 %2",
      args0: [fieldVariable(service), {
        type: "field_dropdown",
        name: "event",
        options: events.map(function (event) {
          return [(0,jdspec/* humanify */.lW)(event.name), event.name];
        })
      }],
      colour: serviceColor(service),
      inputsInline: true,
      nextStatement: null,
      tooltip: "Events for the " + service.name + " service",
      helpUrl: serviceHelp(service),
      service: service,
      events: events,
      template: "event"
    };
  }); // generate accessor blocks for event data with numbers

  var eventFieldBlocks = (0,utils/* arrayConcatMany */.ue)(events.map(function (_ref2) {
    var service = _ref2.service,
        events = _ref2.events;
    return events.filter(function (event) {
      return event.fields.filter(jdspec/* isNumericType */.FV).length > 0;
    }).map(function (event) {
      return {
        service: service,
        event: event
      };
    }).map(function (_ref3) {
      var service = _ref3.service,
          event = _ref3.event;
      return {
        kind: "block",
        type: "jacdac_event_field_" + service.shortId + "_" + event.name,
        message0: event.name + " %1",
        args0: [{
          type: "field_dropdown",
          name: "field",
          options: event.fields.map(function (field) {
            return [(0,jdspec/* humanify */.lW)(field.name), field.name];
          })
        }],
        colour: serviceColor(service),
        inputsInline: true,
        tooltip: "Data fields of the " + event.name + " event",
        helpUrl: serviceHelp(service),
        service: service,
        event: event,
        output: "Number",
        template: "event_field"
      };
    });
  }));
  var registerChangeByEventBlocks = registers.filter(function (_ref4) {
    var service = _ref4.service;
    return !service.packets.some(function (pkt) {
      return (0,spec/* isEvent */.cO)(pkt) && ignoredEvents.indexOf(pkt.identifier) < 0;
    });
  }).filter(function (_ref5) {
    var register = _ref5.register;
    return register.fields.length === 1 && (0,jdspec/* isNumericType */.FV)(register.fields[0]) && register.identifier !== constants/* SystemReg.Intensity */.ZJq.Intensity;
  }).map(function (_ref6) {
    var service = _ref6.service,
        register = _ref6.register;
    return {
      kind: "block",
      type: "jacdac_change_by_events_" + service.shortId + "_" + register.name,
      message0: "when %1 " + (0,jdspec/* humanify */.lW)(register.name) + " change by %2",
      args0: [fieldVariable(service)].concat((0,toConsumableArray/* default */.Z)(fieldsToFieldInputs(register))).filter(function (v) {
        return !!v;
      }),
      values: fieldsToValues(register),
      inputsInline: true,
      nextStatement: null,
      colour: serviceColor(service),
      tooltip: "Event raised when " + register.name + " changes",
      helpUrl: serviceHelp(service),
      service: service,
      register: register,
      template: "register_change_event"
    };
  });

  var _splitFilter = (0,utils/* splitFilter */.ap)(registers, function (reg) {
    return reg.register.fields.length == 1;
  }),
      registerSimples = _splitFilter[0],
      registerComposites = _splitFilter[1];

  var _splitFilter2 = (0,utils/* splitFilter */.ap)(registerSimples, function (_ref7) {
    var register = _ref7.register;
    return !!toBlocklyType(register.fields[0]);
  }),
      registerSimpleTypes = _splitFilter2[0],
      registerSimpleOthers = _splitFilter2[1];

  var registerSimplesGetBlocks = registerSimpleTypes.map(function (_ref8) {
    var _customMessage;

    var service = _ref8.service,
        register = _ref8.register;
    return {
      kind: "block",
      type: "jacdac_get_simple_" + service.shortId + "_" + register.name,
      message0: ((_customMessage = customMessage(service, register, register.fields[0])) === null || _customMessage === void 0 ? void 0 : _customMessage.get) || "%1 " + (0,jdspec/* humanify */.lW)(register.name),
      args0: [fieldVariable(service)],
      inputsInline: true,
      output: toBlocklyType(register.fields[0]),
      colour: serviceColor(service),
      tooltip: register.description,
      helpUrl: serviceHelp(service),
      service: service,
      register: register,
      field: register.fields[0],
      template: "register_get"
    };
  });
  var registerSimpleEnumTypes = registerSimpleOthers.filter(function (_ref9) {
    var service = _ref9.service,
        register = _ref9.register;
    return !!enumInfo(service, register.fields[0]);
  }).map(function (_ref10) {
    var service = _ref10.service,
        register = _ref10.register;
    return {
      service: service,
      register: register,
      field: register.fields[0],
      einfo: enumInfo(service, register.fields[0])
    };
  });
  var registerCompositeEnumTypes = (0,utils/* arrayConcatMany */.ue)(registerComposites.map(function (_ref11) {
    var service = _ref11.service,
        register = _ref11.register;
    return register.fields.map(function (field) {
      return {
        service: service,
        register: register,
        field: field,
        einfo: enumInfo(service, field)
      };
    }).filter(function (_ref12) {
      var einfo = _ref12.einfo;
      return !!einfo;
    });
  }));
  var registerEnumGetBlocks = [].concat((0,toConsumableArray/* default */.Z)(registerSimpleEnumTypes), (0,toConsumableArray/* default */.Z)(registerCompositeEnumTypes)).map(function (_ref13) {
    var _customMessage2;

    var service = _ref13.service,
        register = _ref13.register,
        field = _ref13.field,
        einfo = _ref13.einfo;
    return {
      kind: "block",
      type: "jacdac_get_enum_" + service.shortId + "_" + register.name + "_" + field.name,
      message0: ((_customMessage2 = customMessage(service, register, field)) === null || _customMessage2 === void 0 ? void 0 : _customMessage2.get) || "%1 " + (0,jdspec/* humanify */.lW)(register.name) + (field.name === "_" ? "" : " " + field.name) + " %2",
      args0: [fieldVariable(service), {
        type: "field_dropdown",
        name: field.name,
        options: Object.keys(einfo.members).map(function (member) {
          return [(0,jdspec/* humanify */.lW)(member), member];
        })
      }],
      inputsInline: true,
      output: "Boolean",
      colour: serviceColor(service),
      tooltip: register.description,
      helpUrl: serviceHelp(service),
      service: service,
      register: register,
      field: field,
      template: "register_get"
    };
  });
  var registerNumericsGetBlocks = registerComposites.filter(function (re) {
    return re.register.fields.some(jdspec/* isNumericType */.FV);
  }).map(function (_ref14) {
    var service = _ref14.service,
        register = _ref14.register;
    return {
      kind: "block",
      type: "jacdac_get_numerics_" + service.shortId + "_" + register.name,
      message0: "%1 " + (0,jdspec/* humanify */.lW)(register.name) + (register.fields.length > 1 ? " %2" : ""),
      args0: [fieldVariable(service), register.fields.length > 1 ? {
        type: "field_dropdown",
        name: "field",
        options: register.fields.filter(function (f) {
          return (0,jdspec/* isNumericType */.FV)(f);
        }).map(function (field) {
          return [(0,jdspec/* humanify */.lW)(field.name), fieldName(register, field)];
        })
      } : undefined].filter(function (v) {
        return !!v;
      }),
      inputsInline: true,
      output: "Number",
      colour: serviceColor(service),
      tooltip: register.description,
      helpUrl: serviceHelp(service),
      service: service,
      register: register,
      template: "register_get"
    };
  });
  var registerSetBlocks = registers.filter(function (_ref15) {
    var register = _ref15.register;
    return register.kind === "rw";
  }).filter(function (_ref16) {
    var register = _ref16.register;
    return fieldsSupported(register);
  }).map(function (_ref17) {
    var service = _ref17.service,
        register = _ref17.register;
    return {
      kind: "block",
      type: "jacdac_set_" + service.shortId + "_" + register.name,
      message0: isEnabledRegister(register) ? "set %1 %2" : "set %1 " + register.name + " to " + (register.fields.length === 1 ? "%2" : fieldsToMessage(register)),
      args0: [fieldVariable(service)].concat((0,toConsumableArray/* default */.Z)(fieldsToFieldInputs(register))),
      values: fieldsToValues(register),
      inputsInline: true,
      colour: serviceColor(service),
      tooltip: register.description,
      helpUrl: serviceHelp(service),
      service: service,
      register: register,
      previousStatement: null,
      nextStatement: null,
      template: "register_set"
    };
  });
  var commandBlocks = commands.map(function (_ref18) {
    var service = _ref18.service,
        command = _ref18.command;
    return {
      kind: "block",
      type: "jacdac_command_" + service.shortId + "_" + command.name,
      message0: !command.fields.length ? (0,jdspec/* humanify */.lW)(command.name) + " %1" : (0,jdspec/* humanify */.lW)(command.name) + " %1 with " + fieldsToMessage(command),
      args0: [fieldVariable(service)].concat((0,toConsumableArray/* default */.Z)(fieldsToFieldInputs(command))),
      values: fieldsToValues(command),
      inputsInline: true,
      colour: serviceColor(service),
      tooltip: command.description,
      helpUrl: serviceHelp(service),
      service: service,
      command: command,
      previousStatement: null,
      nextStatement: null,
      template: "command"
    };
  });
  var serviceBlocks = [].concat((0,toConsumableArray/* default */.Z)(eventBlocks), (0,toConsumableArray/* default */.Z)(eventFieldBlocks), (0,toConsumableArray/* default */.Z)(registerChangeByEventBlocks), (0,toConsumableArray/* default */.Z)(registerSimplesGetBlocks), (0,toConsumableArray/* default */.Z)(registerEnumGetBlocks), (0,toConsumableArray/* default */.Z)(registerNumericsGetBlocks), (0,toConsumableArray/* default */.Z)(registerSetBlocks), (0,toConsumableArray/* default */.Z)(customBlockDefinitions), (0,toConsumableArray/* default */.Z)(commandBlocks));
  var shadowBlocks = [{
    kind: "block",
    type: "jacdac_note",
    message0: "%1",
    args0: [{
      type: NoteField.KEY,
      name: "note"
    }],
    style: "math_blocks",
    output: "Number"
  }, {
    kind: "block",
    type: "jacdac_on_off",
    message0: "%1",
    args0: [{
      type: "field_dropdown",
      name: "value",
      options: [["enabled", "on"], ["disabled", "off"]]
    }],
    style: "logic_blocks",
    output: "Boolean"
  }, {
    kind: "block",
    type: "jacdac_time_picker",
    message0: "%1",
    args0: [{
      type: "field_dropdown",
      name: "value",
      options: [["0.1", "0.1"], ["1", "1"], ["5", "5"], ["30", "30"], ["60", "60"]]
    }],
    style: "math_blocks",
    output: "Number"
  }, {
    kind: "block",
    type: "jacdac_angle",
    message0: "%1",
    args0: [{
      type: "field_angle",
      name: "value",
      min: 0,
      max: 360,
      precision: 10
    }],
    style: "math_blocks",
    output: "Number"
  }, {
    kind: "block",
    type: "jacdac_percent",
    message0: "%1",
    args0: [{
      type: "field_slider",
      name: "value",
      min: 0,
      max: 100,
      precision: 1
    }],
    style: "math_blocks",
    output: "Number"
  }, {
    kind: "block",
    type: "jacdac_byte",
    message0: "%1",
    args0: [{
      type: "field_slider",
      name: "value",
      min: 0,
      max: 255,
      precision: 1
    }],
    style: "math_blocks",
    output: "Number"
  }, {
    kind: "block",
    type: "jacdac_ratio",
    message0: "%1",
    args0: [{
      type: "field_slider",
      name: "value",
      min: 0,
      max: 1,
      precision: 0.1
    }],
    style: "math_blocks",
    output: "Number"
  }, {
    kind: "block",
    type: "jacdac_color",
    message0: "%1",
    args0: [{
      type: "field_colour",
      name: "col",
      colour: "#ff0000",
      colourOptions: ["#ff0000", "#ff8000", "#ffff00", "#ff9da5", "#00ff00", "#b09eff", "#00ffff", "#007fff", "#65471f", "#0000ff", "#7f00ff", "#ff0080", "#ff00ff", "#ffffff", "#999999", "#000000"],
      columns: 4
    }],
    style: "math_blocks",
    output: "Color"
  }];
  var runtimeBlocks = [{
    kind: "block",
    type: WHILE_CONDITION_BLOCK,
    message0: "while %1",
    args0: [{
      type: "input_value",
      name: WHILE_CONDITION_BLOCK_CONDITION,
      check: "Boolean"
    }],
    colour: commandColor,
    inputsInline: true,
    nextStatement: "Statement",
    tooltip: "",
    helpUrl: ""
  }, {
    kind: "block",
    type: WAIT_BLOCK,
    message0: "wait %1 s",
    args0: [{
      type: "input_value",
      name: "time",
      check: "Number"
    }],
    inputsInline: true,
    previousStatement: "Statement",
    nextStatement: "Statement",
    colour: commandColor,
    tooltip: "Wait the desired time",
    helpUrl: ""
  }, {
    kind: "block",
    type: SET_STATUS_LIGHT_BLOCK,
    message0: "set %1 status to %2",
    args0: [{
      type: "field_variable",
      name: "role",
      variable: "all",
      variableTypes: ["client"].concat((0,toConsumableArray/* default */.Z)(allServices.map(function (service) {
        return service.shortId;
      }))),
      defaultType: "client"
    }, {
      type: "input_value",
      name: "color",
      check: "Color"
    }],
    inputsInline: true,
    previousStatement: "Statement",
    nextStatement: "Statement",
    colour: commandColor,
    tooltip: "Sets the color on the status light",
    helpUrl: ""
  }];
  var mathBlocks = [{
    kind: "block",
    type: "jacdac_math_arithmetic",
    message0: "%1 %2 %3",
    args0: [{
      type: "input_value",
      name: "A",
      check: "Number"
    }, {
      type: "field_dropdown",
      name: "OP",
      options: [["%{BKY_MATH_ADDITION_SYMBOL}", "ADD"], ["%{BKY_MATH_SUBTRACTION_SYMBOL}", "MINUS"], ["%{BKY_MATH_MULTIPLICATION_SYMBOL}", "MULTIPLY"], ["%{BKY_MATH_DIVISION_SYMBOL}", "DIVIDE"]]
    }, {
      type: "input_value",
      name: "B",
      check: "Number"
    }],
    inputsInline: true,
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_ARITHMETIC_HELPURL}",
    extensions: ["math_op_tooltip"]
  }, {
    kind: "block",
    type: "jacdac_math_single",
    message0: "%1 %2",
    args0: [{
      type: "field_dropdown",
      name: "OP",
      options: [["-", "NEG"], ["%{BKY_MATH_SINGLE_OP_ABSOLUTE}", "ABS"]]
    }, {
      type: "input_value",
      name: "NUM",
      check: "Number"
    }],
    output: "Number",
    style: "math_blocks",
    helpUrl: "%{BKY_MATH_SINGLE_HELPURL}",
    extensions: ["math_op_tooltip"]
  }];
  var blocks = [].concat((0,toConsumableArray/* default */.Z)(serviceBlocks), runtimeBlocks, shadowBlocks, mathBlocks); // register field editors

  registerFields(); // re-register blocks with blocklys

  blocks.map(function (block) {
    return (blockly_default()).Blocks[block.type] = {
      init: function init() {
        this.jsonInit(block);
      }
    };
  }); // final mapping

  var jdBlocks = serviceBlocks.filter(function (block) {
    return !!block.service;
  });
  var services = (0,utils/* uniqueMap */.EM)(jdBlocks, function (block) {
    return block.service.shortId;
  }, function (block) {
    return block.service;
  });
  console.debug("vmblocks", {
    blocks: blocks,
    serviceBlocks: serviceBlocks,
    services: services
  });
  return {
    blocks: blocks,
    serviceBlocks: serviceBlocks,
    services: services
  };
}

var BUILTIN_TYPES = ["", "Boolean", "Number", "String"];
function scanServices(workspace) {
  var variables = blockly_default().Variables.allUsedVarModels(workspace).filter(function (v) {
    return BUILTIN_TYPES.indexOf(v.type) < 0;
  }); // remove buildins

  var services = variables.map(function (v) {
    return v.type;
  });
  return services;
}

function patchCategoryJSONtoXML(cat) {
  var _cat$contents;

  if (cat.button) {
    if (!cat.contents) cat.contents = [];
    cat.contents.unshift(cat.button);
  }

  (_cat$contents = cat.contents) === null || _cat$contents === void 0 ? void 0 : _cat$contents.filter(function (node) {
    return node.kind === "block";
  }).map(function (node) {
    return node;
  }).filter(function (block) {
    return !!block.values && (blockly_default()).Blocks[block.type];
  }) // avoid broken blocks
  .forEach(function (block) {
    // yup, this suck but we have to go through it
    block.blockxml = "<block type=\"" + block.type + "\">" + Object.keys(block.values).map(function (name) {
      var type = block.values[name].type;
      return "<value name=\"" + name + "\"><shadow type=\"" + type + "\" /></value>";
    }).join("\n") + "</block>";
    delete block.type;
  });
  return cat;
}

function useToolbox(props) {
  var blockServices = props.blockServices,
      serviceClass = props.serviceClass;
  var theme = (0,useTheme/* default */.Z)();

  var _createBlockTheme = createBlockTheme(theme),
      serviceColor = _createBlockTheme.serviceColor,
      commandColor = _createBlockTheme.commandColor;

  var _useMemo = (0,react.useMemo)(function () {
    return loadBlocks(serviceColor, commandColor);
  }, [theme]),
      serviceBlocks = _useMemo.serviceBlocks,
      services = _useMemo.services;

  var liveServices = (0,useServices/* default */.Z)({
    specification: true
  });
  var toolboxServices = (0,utils/* uniqueMap */.EM)(flags/* default.diagnostics */.Z.diagnostics ? services : [].concat((0,toConsumableArray/* default */.Z)(blockServices.map(function (srvid) {
    return services.find(function (service) {
      return service.shortId === srvid;
    });
  }).filter(function (srv) {
    return !!srv;
  })), (0,toConsumableArray/* default */.Z)(liveServices.map(function (srv) {
    return srv.specification;
  }))).filter(function (srv) {
    return !serviceClass || srv.classIdentifier === serviceClass;
  }), function (srv) {
    return srv.shortId;
  }, function (srv) {
    return srv;
  }).filter(function (srv) {
    return srv && ignoredServices.indexOf(srv.classIdentifier) < 0;
  }).sort(function (l, r) {
    return l.name.localeCompare(r.name);
  });
  var servicesCategories = toolboxServices.map(function (service) {
    return {
      service: service,
      serviceBlocks: serviceBlocks.filter(function (block) {
        return block.service === service;
      })
    };
  }).map(function (_ref19) {
    var service = _ref19.service,
        serviceBlocks = _ref19.serviceBlocks;
    return {
      kind: "category",
      name: service.name,
      colour: serviceColor(service),
      contents: serviceBlocks.map(function (block) {
        return {
          kind: "block",
          type: block.type,
          values: block.values
        };
      }),
      button: {
        kind: "button",
        text: "Add " + service.name,
        callbackKey: "jacdac_add_role_callback_" + service.shortId,
        service: service
      }
    };
  }).filter(function (cat) {
    var _cat$contents2;

    return !!((_cat$contents2 = cat.contents) !== null && _cat$contents2 !== void 0 && _cat$contents2.length);
  });
  var commandsCategory = {
    kind: "category",
    name: "Commands",
    colour: commandColor,
    contents: [{
      kind: "block",
      type: WHILE_CONDITION_BLOCK
    }, {
      kind: "block",
      type: WAIT_BLOCK,
      values: {
        time: {
          kind: "block",
          type: "jacdac_time_picker"
        }
      }
    }, !!toolboxServices.length && {
      kind: "block",
      type: SET_STATUS_LIGHT_BLOCK,
      values: {
        color: {
          kind: "block",
          type: "jacdac_color"
        }
      }
    }].filter(function (b) {
      return !!b;
    })
  };
  var logicCategory = {
    kind: "category",
    name: "Logic",
    colour: "%{BKY_LOGIC_HUE}",
    contents: [{
      kind: "block",
      type: "dynamic_if"
    }, {
      kind: "block",
      type: "logic_compare",
      values: {
        A: {
          kind: "block",
          type: "math_number"
        },
        B: {
          kind: "block",
          type: "math_number"
        }
      }
    }, {
      kind: "block",
      type: "logic_operation",
      values: {
        A: {
          kind: "block",
          type: "logic_boolean"
        },
        B: {
          kind: "block",
          type: "logic_boolean"
        }
      }
    }, {
      kind: "block",
      type: "logic_negate",
      values: {
        BOOL: {
          kind: "block",
          type: "logic_boolean"
        }
      }
    }, {
      kind: "block",
      type: "logic_boolean"
    }]
  };
  var mathCategory = {
    kind: "category",
    name: "Math",
    colour: "%{BKY_MATH_HUE}",
    contents: [{
      kind: "block",
      type: "jacdac_math_arithmetic",
      values: {
        A: {
          kind: "block",
          type: "math_number"
        },
        B: {
          kind: "block",
          type: "math_number"
        }
      }
    }, {
      kind: "block",
      type: "jacdac_math_single",
      values: {
        NUM: {
          kind: "block",
          type: "math_number"
        }
      }
    }, {
      kind: "block",
      type: "math_number"
    }]
  };
  var variablesCategory = {
    kind: "category",
    name: "Variables",
    colour: "%{BKY_VARIABLES_HUE}",
    custom: "VARIABLE"
  };
  var toolboxConfiguration = {
    kind: "categoryToolbox",
    contents: [commandsCategory, (servicesCategories === null || servicesCategories === void 0 ? void 0 : servicesCategories.length) && {
      kind: "sep"
    }].concat((0,toConsumableArray/* default */.Z)(servicesCategories), [{
      kind: "sep"
    }, logicCategory, mathCategory, variablesCategory]).filter(function (cat) {
      return !!cat;
    }).map(function (node) {
      return node.kind === "category" ? patchCategoryJSONtoXML(node) : node;
    })
  };
  return {
    serviceBlocks: serviceBlocks,
    toolboxConfiguration: toolboxConfiguration,
    newProjectXml: NEW_PROJET_XML
  };
}
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/Dialog/Dialog.js
var Dialog = __webpack_require__(52468);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/DialogContent/DialogContent.js
var DialogContent = __webpack_require__(65733);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/DialogContentText/DialogContentText.js
var DialogContentText = __webpack_require__(32253);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/TextField/TextField.js
var TextField = __webpack_require__(1059);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/DialogActions/DialogActions.js
var DialogActions = __webpack_require__(89952);
// EXTERNAL MODULE: ./node_modules/gatsby-theme-material-ui/index.js
var gatsby_theme_material_ui = __webpack_require__(36176);
;// CONCATENATED MODULE: ./src/components/vm/BlocklyModalDialogs.tsx





function BlocklyModalDialogs() {
  var _useState = (0,react.useState)(),
      dialogType = _useState[0],
      setDialogType = _useState[1];

  var _useState2 = (0,react.useState)(""),
      message = _useState2[0],
      setMessage = _useState2[1];

  var _useState3 = (0,react.useState)(""),
      value = _useState3[0],
      setValue = _useState3[1];

  var valueId = (0,react_use_id_hook_esm/* useId */.Me)(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

  var callback = (0,react.useRef)();
  var showDialog = !!dialogType;
  (0,react.useEffect)(function () {
    // store older
    var previous = {
      alert: (blockly_default()).alert,
      confirm: (blockly_default()).confirm,
      prompt: (blockly_default()).prompt
    }; // replace

    (blockly_default()).alert = function (message, cb) {
      setMessage(message);
      callback.current = cb;
      setDialogType("alert");
    };

    (blockly_default()).confirm = function (message, cb) {
      setMessage(message);
      callback.current = cb;
      setDialogType("confirm");
    };

    (blockly_default()).prompt = function (message, defaultValue, cb) {
      setMessage(message);
      setValue(defaultValue);
      callback.current = cb;
      setDialogType("prompt");
    }; // cleanup


    return function () {
      console.log("cleanup");
      (blockly_default()).alert = previous.alert;
      (blockly_default()).confirm = previous.confirm;
      (blockly_default()).prompt = previous.prompt;
    };
  }, []);

  var handleCloseConfirm = function handleCloseConfirm() {
    return setDialogType(undefined);
  };

  var handleCancel = function handleCancel() {
    var _callback$current;

    (_callback$current = callback.current) === null || _callback$current === void 0 ? void 0 : _callback$current.call(callback, undefined);
    setDialogType(undefined);
  };

  var handleOk = function handleOk() {
    var _callback$current2;

    switch (dialogType) {
      case "alert":
        (_callback$current2 = callback.current) === null || _callback$current2 === void 0 ? void 0 : _callback$current2.call(callback);
        break;

      case "confirm":
        callback.current(true);
        break;

      case "prompt":
        callback.current(value);
        break;
    }

    setDialogType(undefined);
  };

  var handleValueChange = function handleValueChange(event) {
    setValue(event.target.value);
  };

  return /*#__PURE__*/react.createElement(Dialog/* default */.Z, {
    open: showDialog,
    onClose: handleCloseConfirm
  }, /*#__PURE__*/react.createElement(DialogContent/* default */.Z, null, /*#__PURE__*/react.createElement(DialogContentText/* default */.Z, null, message), dialogType === "prompt" && /*#__PURE__*/react.createElement(TextField/* default */.Z, {
    id: valueId,
    value: value,
    label: "Value",
    onChange: handleValueChange
  })), /*#__PURE__*/react.createElement(DialogActions/* default */.Z, null, dialogType !== "alert" && /*#__PURE__*/react.createElement(gatsby_theme_material_ui.Button, {
    variant: "contained",
    onClick: handleCancel
  }, "Cancel"), /*#__PURE__*/react.createElement(gatsby_theme_material_ui.Button, {
    variant: "contained",
    color: "primary",
    onClick: handleOk
  }, "Ok")));
}
;// CONCATENATED MODULE: ./src/components/vm/jsongenerator.ts
function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = jsongenerator_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function jsongenerator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return jsongenerator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jsongenerator_arrayLikeToArray(o, minLen); }

function jsongenerator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





function domToJSON(workspace) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var clean = function clean(o) {
    return Object.keys(o).filter(function (k) {
      return o[k] === undefined || o[k] === null;
    }).forEach(function (k) {
      return delete o[k];
    });
  };

  var builtins = {
    logic_null: function logic_null() {
      return null;
    },
    text: function text(block) {
      return block.getFieldValue("TEXT");
    },
    math_number: function math_number(block) {
      return Number(block.getFieldValue("NUM") || "0");
    },
    logic_boolean: function logic_boolean(block) {
      return block.getFieldValue("BOOL") === "TRUE";
    },
    jacdac_on_off: function jacdac_on_off(block) {
      return block.getFieldValue("value") === "on";
    },
    jacdac_time_picker: function jacdac_time_picker(block) {
      return Number(block.getFieldValue("value") || "0");
    },
    jacdac_angle: function jacdac_angle(block) {
      return Number(block.getFieldValue("value") || "0");
    },
    jacdac_percent: function jacdac_percent(block) {
      return Number(block.getFieldValue("value") || "0");
    },
    jacdac_ratio: function jacdac_ratio(block) {
      return Number(block.getFieldValue("value") || "0");
    }
  };

  var variableToJSON = function variableToJSON(variable) {
    return {
      name: variable.name,
      type: variable.type,
      id: variable.getId()
    };
  };

  var fieldsToJSON = function fieldsToJSON(fields) {
    return !fields.length ? undefined : (0,utils/* toMap */.qL)(fields, function (field) {
      var _field$name;

      return (_field$name = field.name) === null || _field$name === void 0 ? void 0 : _field$name.toLowerCase();
    }, fieldToJSON);
  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any


  var xmlToJSON = function xmlToJSON(xml) {
    var j = {};
    if (flags/* default.diagnostics */.Z.diagnostics) j["xml"] = xml.outerHTML; // dump attributes

    for (var _iterator = _createForOfIteratorHelperLoose(xml.getAttributeNames()), _step; !(_step = _iterator()).done;) {
      var _name = _step.value;
      var v = xml.getAttribute(_name);
      j[_name.toLowerCase()] = v;
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(xml.childNodes), _step2; !(_step2 = _iterator2()).done;) {
      var child = _step2.value;
      if (child.nodeType === Node.TEXT_NODE) j["value"] = xml.textContent;else if (child.nodeType === Node.ELEMENT_NODE) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var children = j["children"] || (j["children"] = []);
        children.push(xmlToJSON(child));
      }
    }

    return j;
  };

  var fieldToJSON = function fieldToJSON(field) {
    if (field.isSerializable()) {
      // custom field can just return the value
      if (field instanceof ReactField) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var value = field.value;
        return {
          value: value
        };
      } else {
        var container = blockly_default().utils.xml.createElement("field");
        var fieldXml = field.toXml(container);
        return xmlToJSON(fieldXml);
      }
    }

    return undefined;
  };

  var flattenNext = function flattenNext(block) {
    // flatten the linked list of next into an array
    var children = [];
    var current = block.next;

    while (current) {
      children.push(current);
      current = current.next;
    }

    if (children.length) {
      block.children = children;
      block.next = undefined;
    }
  };

  var blockToJSON = function blockToJSON(block) {
    var _builtins$block$type;

    if (!(block !== null && block !== void 0 && block.isEnabled())) return undefined; // Skip over insertion markers.

    if (block.isInsertionMarker()) {
      var child = block.getChildren(false)[0];
      if (child) return blockToJSON(child);else return undefined;
    } // dump object


    var value = (_builtins$block$type = builtins[block.type]) === null || _builtins$block$type === void 0 ? void 0 : _builtins$block$type.call(builtins, block);
    var element = {
      type: block.type,
      id: block.id,
      value: value,
      inputs: value === undefined ? block.inputList.map(function (input) {
        var _input$connection;

        var container = {
          type: input.type,
          name: input.name,
          fields: fieldsToJSON(input.fieldRow),
          child: blockToJSON((_input$connection = input.connection) === null || _input$connection === void 0 ? void 0 : _input$connection.targetBlock())
        };
        return container;
      }) : undefined,
      next: blockToJSON(block.getNextBlock())
    };
    flattenNext(element);
    clean(element);
    return element;
  };

  try {
    var variables = blockly_default().Variables.allUsedVarModels(workspace);
    var blocks = workspace.getTopBlocks(true).filter(function (b) {
      return b.isEnabled();
    });
    var json = {
      variables: variables.map(variableToJSON),
      blocks: blocks.map(blockToJSON).filter(function (b) {
        return !!b;
      })
    };
    return json;
  } catch (e) {
    console.error(e);
    return undefined;
  }
}
function visitBlock(block, visitor) {
  var _visitor$visitBlock;

  if (!block) return;
  (_visitor$visitBlock = visitor.visitBlock) === null || _visitor$visitBlock === void 0 ? void 0 : _visitor$visitBlock.call(visitor, block);
  var inputs = block.inputs,
      children = block.children;
  inputs === null || inputs === void 0 ? void 0 : inputs.forEach(function (input) {
    return visitInput(input, visitor);
  });
  children === null || children === void 0 ? void 0 : children.forEach(function (child) {
    return visitBlock(child, visitor);
  });
}
function visitInput(input, visitor) {
  var _visitor$visitInput;

  if (!input) return;
  (_visitor$visitInput = visitor.visitInput) === null || _visitor$visitInput === void 0 ? void 0 : _visitor$visitInput.call(visitor, input);
  var fields = input.fields,
      child = input.child;
  if (fields) Object.keys(fields).map(function (k) {
    return visitField(k, fields[k], visitor);
  });
  visitBlock(child, visitor);
}
function visitField(name, field, visitor) {
  var _visitor$visitField;

  if (!field) return;
  (_visitor$visitField = visitor.visitField) === null || _visitor$visitField === void 0 ? void 0 : _visitor$visitField.call(visitor, name, field);
}
function visitWorkspace(workspace, visitor) {
  workspace.blocks.forEach(function (block) {
    return visitBlock(block, visitor);
  });
}
;// CONCATENATED MODULE: ./src/components/vm/it4generator.ts


var ops = {
  AND: "&&",
  OR: "||",
  EQ: "===",
  NEQ: "!==",
  LT: "<",
  GT: ">",
  LTE: "<=",
  GTE: ">=",
  NEG: "-",
  ADD: "+",
  MUL: "*",
  DIV: "/",
  MINUS: "-"
};

function toIdentifier(id) {
  return {
    type: "Identifier",
    name: id
  };
}

function toMemberExpression(root, field) {
  return {
    type: "MemberExpression",
    object: toIdentifier(root),
    property: typeof field === "string" ? toIdentifier(field) : field,
    computed: false
  };
}

function workspaceJSONToIT4Program(serviceBlocks, workspace) {
  console.debug("compile it4", {
    workspace: workspace
  });
  var roles = workspace.variables.filter(function (v) {
    return BUILTIN_TYPES.indexOf(v.type) < 0;
  }).map(function (v) {
    return {
      role: v.name,
      serviceShortId: v.type
    };
  });

  var blockToExpression = function blockToExpression(block) {
    if (!block) return undefined;
    var type = block.type,
        value = block.value,
        inputs = block.inputs;
    console.debug("block", type, value, inputs);
    if (value !== undefined) // literal
      return {
        type: "Literal",
        value: value,
        raw: value + ""
      };

    switch (type) {
      case "jacdac_math_single":
        {
          var argument = blockToExpression(inputs[0].child);
          var op = inputs[0].fields["op"].value;
          return {
            type: "UnaryExpression",
            operator: ops[op] || op,
            argument: argument,
            prefix: false // TODO:?

          };
        }

      case "jacdac_math_arithmetic":
        {
          var left = blockToExpression(inputs[0].child);
          var right = blockToExpression(inputs[1].child);
          var _op = inputs[1].fields["op"].value;
          return {
            type: "BinaryExpression",
            operator: ops[_op] || _op,
            left: left,
            right: right
          };
        }

      case "logic_operation":
        {
          var _left = blockToExpression(inputs[0].child);

          var _right = blockToExpression(inputs[1].child);

          var _op2 = inputs[1].fields["op"].value;
          return {
            type: "LogicalExpression",
            operator: ops[_op2] || _op2,
            left: _left,
            right: _right
          };
        }

      case "logic_negate":
        {
          var _argument = blockToExpression(inputs[0].child);

          return {
            type: "UnaryExpression",
            operator: "!",
            argument: _argument,
            prefix: false // TODO:?

          };
        }

      case "logic_compare":
        {
          var _left2 = blockToExpression(inputs[0].child);

          var _right2 = blockToExpression(inputs[1].child);

          var _op3 = inputs[1].fields["op"].value;
          return {
            type: "BinaryExpression",
            operator: ops[_op3] || _op3,
            left: _left2,
            right: _right2
          };
        }

      default:
        {
          var def = serviceBlocks.find(function (def) {
            return def.type === type;
          });

          if (def) {
            var template = def.template;

            switch (template) {
              case "register_get":
                {
                  var _ref = def,
                      register = _ref.register;
                  var role = inputs[0].fields["role"].value;
                  var field = inputs[0].fields["field"];
                  return toMemberExpression(role, field ? toMemberExpression(register.name, field.value) : register.name);
                }
            }

            break;
          }
        }
    }

    return undefined;
  };

  var blockToCommand = function blockToCommand(block) {
    var command;
    var type = block.type,
        inputs = block.inputs;

    switch (type) {
      case WAIT_BLOCK:
        {
          var time = blockToExpression(inputs[0].child);
          command = {
            type: "CallExpression",
            arguments: [time],
            callee: toIdentifier("wait")
          };
          break;
        }
      // more builts

      default:
        {
          var def = serviceBlocks.find(function (def) {
            return def.type === type;
          });

          if (def) {
            var template = def.template;

            switch (template) {
              case "register_set":
                {
                  var _ref2 = def,
                      register = _ref2.register;
                  var val = blockToExpression(inputs[0].child);
                  var role = inputs[0].fields.role.value;
                  command = {
                    type: "CallExpression",
                    arguments: [toMemberExpression(role, register.name), val],
                    callee: toIdentifier("writeRegister")
                  };
                  break;
                }

              case "command":
                {
                  var _ref3 = def,
                      serviceCommand = _ref3.command;
                  var _role = inputs[0].fields.role.value;
                  command = {
                    type: "CallExpression",
                    arguments: inputs.map(function (a) {
                      return blockToExpression(a.child);
                    }),
                    callee: toMemberExpression(_role, serviceCommand.name)
                  };
                  break;
                }
            }
          }
        }
    } // for linking back


    return {
      sourceId: block.id,
      command: command
    };
  };

  var handlers = workspace.blocks.map(function (top) {
    var _top$children;

    var type = top.type,
        inputs = top.inputs;
    var commands = [];
    var command = undefined;

    if (type === WHILE_CONDITION_BLOCK) {
      // this is while (...)
      var condition = inputs[0].child;
      command = {
        type: "CallExpression",
        arguments: [blockToExpression(condition)],
        callee: toIdentifier("awaitCondition")
      };
    } else {
      var def = serviceBlocks.find(function (def) {
        return def.type === type;
      });
      (0,utils/* assert */.hu)(!!def);
      var template = def.template;
      var role = inputs[0].fields["role"].value;

      switch (template) {
        case "event":
          {
            var eventName = inputs[0].fields["event"].value;
            command = {
              type: "CallExpression",
              arguments: [toMemberExpression(role.toString(), eventName.toString())],
              callee: toIdentifier("awaitEvent")
            };
            break;
          }

        case "register_change_event":
          {
            var _ref4 = def,
                register = _ref4.register;
            var argument = blockToExpression(inputs[0].child);
            command = {
              type: "CallExpression",
              arguments: [toMemberExpression(role.toString(), register.name), argument],
              callee: toIdentifier("awaitChange")
            };
            break;
          }
      }
    }

    commands.push({
      sourceId: top.id,
      command: command
    }); // process children

    (_top$children = top.children) === null || _top$children === void 0 ? void 0 : _top$children.forEach(function (child) {
      return commands.push(blockToCommand(child));
    });
    return {
      commands: commands
    };
  });
  return {
    roles: roles,
    handlers: handlers
  };
}
// EXTERNAL MODULE: ./src/components/AppContext.tsx
var AppContext = __webpack_require__(84377);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/styles/makeStyles.js
var makeStyles = __webpack_require__(10920);
// EXTERNAL MODULE: ./node_modules/@material-ui/core/esm/styles/createStyles.js
var createStyles = __webpack_require__(70274);
// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.m.js
var clsx_m = __webpack_require__(85505);
;// CONCATENATED MODULE: ./src/components/vm/VMBlockEditor.tsx
















var useStyles = (0,makeStyles/* default */.Z)(function (theme) {
  return (0,createStyles/* default */.Z)({
    editor: {
      height: "40vh",
      "& .blocklyTreeLabel": {
        fontFamily: theme.typography.fontFamily
      },
      "& .blocklyText": {
        fontWeight: "normal !important",
        fontFamily: theme.typography.fontFamily + " !important"
      }
    }
  });
});
function VMBlockEditor(props) {
  var className = props.className,
      onXmlChange = props.onXmlChange,
      onJSONChange = props.onJSONChange,
      onIT4ProgramChange = props.onIT4ProgramChange,
      initialXml = props.initialXml,
      serviceClass = props.serviceClass,
      runner = props.runner;
  var classes = useStyles();

  var _useContext = (0,react.useContext)(DarkModeContext/* default */.Z),
      darkMode = _useContext.darkMode;

  var _useContext2 = (0,react.useContext)(AppContext/* default */.ZP),
      setError = _useContext2.setError;

  var _useState = (0,react.useState)([]),
      services = _useState[0],
      setServices = _useState[1];

  var _useToolbox = useToolbox({
    blockServices: services,
    serviceClass: serviceClass
  }),
      toolboxConfiguration = _useToolbox.toolboxConfiguration,
      newProjectXml = _useToolbox.newProjectXml,
      serviceBlocks = _useToolbox.serviceBlocks;

  var theme = darkMode === "dark" ? theme_dark_src : src;
  var gridColor = darkMode === "dark" ? "#555" : "#ccc"; // ReactBlockly
  // eslint-disable-next-line @typescript-eslint/no-explicit-any

  var blocklyRef = (0,react.useRef)(null);

  var _ref = (0,dist/* useBlocklyWorkspace */.JP)({
    ref: blocklyRef,
    toolboxConfiguration: toolboxConfiguration,
    workspaceConfiguration: {
      comments: false,
      css: true,
      trashcan: false,
      sounds: false,
      grid: {
        spacing: 25,
        length: 1,
        colour: gridColor,
        snap: true
      },
      renderer: "zelos",
      theme: theme,
      oneBasedIndex: false,
      move: {
        scrollbars: {
          vertical: false,
          horizontal: true
        }
      },
      zoom: {
        controls: true,
        wheel: true,
        startScale: 1.0,
        maxScale: 3,
        minScale: 0.3,
        scaleSpeed: 1.2,
        pinch: true
      }
    },
    initialXml: initialXml || newProjectXml,
    onImportXmlError: function onImportXmlError() {
      return setError("Error loading blocks...");
    }
  }),
      workspace = _ref.workspace,
      xml = _ref.xml;

  (0,react.useEffect)(function () {
    if (!workspace) return; // Add the disableOrphans event handler. This is not done automatically by
    // the plugin and should be handled by your application.

    workspace.addChangeListener((blockly_default()).Events.disableOrphans); // The plugin must be initialized before it has any effect.

    var disableTopBlocksPlugin = new DisableTopBlocks();
    disableTopBlocksPlugin.init();
  }, [workspace]); // blockly did a change

  (0,react.useEffect)(function () {
    if (!workspace) return;
    onXmlChange === null || onXmlChange === void 0 ? void 0 : onXmlChange(xml); // save json

    if (onJSONChange || onIT4ProgramChange) {
      // emit json
      var _json = domToJSON(workspace);

      onJSONChange === null || onJSONChange === void 0 ? void 0 : onJSONChange(_json);

      if (onIT4ProgramChange) {
        try {
          var _program = workspaceJSONToIT4Program(serviceBlocks, _json);

          onIT4ProgramChange(_program);
        } catch (e) {
          console.error(e);
          onIT4ProgramChange(undefined);
        }
      }
    } // update toolbox with declared roles


    var newServices = scanServices(workspace);
    if (JSON.stringify(services) !== JSON.stringify(newServices)) setServices(newServices);
  }, [workspace, xml]); // track workspace changes and update callbacks

  (0,react.useEffect)(function () {
    if (!workspace) return; // collect buttons

    var buttons = toolboxConfiguration === null || toolboxConfiguration === void 0 ? void 0 : toolboxConfiguration.contents // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .map(function (cat) {
      return cat.button;
    }).filter(function (btn) {
      return !!btn;
    });
    buttons === null || buttons === void 0 ? void 0 : buttons.forEach(function (button) {
      return workspace.registerButtonCallback(button.callbackKey, function () {
        return blockly_default().Variables.createVariableButtonHandler(workspace, null, button.service.shortId);
      });
    });
  }, [workspace, JSON.stringify(toolboxConfiguration)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(BlocklyModalDialogs, null), /*#__PURE__*/react.createElement("div", {
    className: (0,clsx_m/* default */.Z)(classes.editor, className),
    ref: blocklyRef
  }));
}

/***/ })

}]);
//# sourceMappingURL=f46badf6a1e485aca95f38418db0645a3911806b-93fae5463bd475b6353f.js.map