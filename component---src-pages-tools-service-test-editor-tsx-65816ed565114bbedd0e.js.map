{"version":3,"sources":["webpack:///./src/components/ServiceSpecificationSelect.tsx","webpack:///./jacdac-ts/jacdac-spec/spectool/jdtest.ts","webpack:///./src/components/tools/ServiceTestEditor.tsx","webpack:///./src/pages/tools/service-test-editor.tsx","webpack:///./src/components/ui/HighlightTextField.tsx","webpack:///./jacdac-ts/node_modules/jsep/build/jsep.js"],"names":["useStyles","makeStyles","createStyles","root","minWidth","ServiceSpecificationSelect","props","label","serviceClass","setServiceClass","variant","fullWidth","error","useState","Math","random","labelId","classes","specs","serviceSpecifications","filter","spec","test","shortId","handleChange","event","parseInt","target","value","map","classIdentifier","name","supportedExpressions","parseSpecificationTestMarkdownToJSON","filecontent","filename","replace","info","description","serviceClassIdentifier","tests","backticksType","errors","lineNo","currentTest","testHeading","testPrompt","split","line","processLine","e","message","finishTest","length","trim","m","exec","interpret","slice","hd","cont","expanded","processCommand","registers","commands","call","callee","index","testCommandFunctions","findIndex","r","id","jsep","type","arguments","indexOf","expected","args","forEach","arg","a","callers","JSONPath","path","json","callExpr","indexFun","testExpressionFunctions","callsUnder","ce","exprs","visited","parent","push","lookupReplace","prompt","child","lookup","Object","keys","key","property","val","parseIntFloat","lit","raw","toString","getRegister","msg","some","file","SERVICE_TEST_STORAGE_KEY","ServiceTestEditor","useContext","AppContext","setError","SRV_BUTTON","useLocalStorage","source","setSource","serviceSpec","useMemo","serviceSpecificationFromClassIdentifier","servicePath","camelName","toLowerCase","handleLoadFromGithub","fetchText","ghSource","Page","GithubPullRequestButton","lazy","AnnotationTooltip","withStyles","theme","arrow","color","palette","main","tooltip","backgroundColor","common","white","boxShadow","shadows","fontSize","typography","body2","Tooltip","HighlightTextField","code","onChange","language","annotations","pullRequestTitle","pullRequestPath","pullRequestDescription","DarkModeContext","darkMode","DARK_THEME","LIGHT_THEME","editorRef","useRef","useEditable","disabled","indentation","defaultProps","className","style","tokens","getTokenProps","minHeight","whiteSpace","i","annotation","find","title","el","borderBottom","token","empty"],"mappings":"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AEI,QAAI,EAAEC,eAFV;AAGI,eAAW,EAAEC,sBAHjB;AAII,SAAK,qBACAD,eAAe,GAAG,KADlB,IAC0BL,IAD1B;AAJT,IADJ,CADJ,CA9ER,CADJ;AA8FH,C;;;;;;;ACvJD;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gCAAgC;AAChC,GAAG;AACH;AACA;AACA;AACA;AACA,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,6EAA6E;AAC7E;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAI;;;AAGJ,MAAM,KAA8B,EAAE,iBAYnC;AACH;AACA,QAAQ,KAA6B;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,Q","file":"component---src-pages-tools-service-test-editor-tsx-65816ed565114bbedd0e.js","sourcesContent":["import { createStyles, makeStyles, MenuItem, TextField, Theme } from \"@material-ui/core\";\nimport React, { ChangeEvent, useState } from \"react\";\nimport { serviceSpecifications } from \"../../jacdac-ts/src/jdom/spec\"\n\nconst useStyles = makeStyles(() =>\n    createStyles({\n        root: {\n            minWidth: \"18rem\",\n        }\n    }),\n);\n\nexport default function ServiceSpecificationSelect(props: {\n    label: string,\n    serviceClass: number;\n    setServiceClass: (serviceClass: number) => void;\n    variant?: \"outlined\" | \"filled\" | \"standard\";\n    fullWidth?: boolean;\n    error?: string;\n}) {\n    const { label, serviceClass, setServiceClass, variant, fullWidth, error } = props;\n    const [labelId] = useState('select-' + Math.random());\n    const classes = useStyles();\n    const specs = serviceSpecifications().filter(spec => !/^_/.test(spec.shortId))\n\n    const handleChange = (event: ChangeEvent<HTMLInputElement>) =>\n        setServiceClass(parseInt(event.target.value));\n\n    return <TextField\n        id={labelId}\n        className={classes.root}\n        label={label}\n        error={!!error}\n        helperText={error}\n        value={serviceClass}\n        select\n        variant={variant}\n        fullWidth={fullWidth}\n        onChange={handleChange}>\n        <MenuItem key=\"none\" value=\"NaN\">No service selected</MenuItem>\n        {specs.map(spec => <MenuItem\n            key={spec.classIdentifier}\n            value={spec.classIdentifier}>{spec.name}</MenuItem>)}\n    </TextField>\n}","/* eslint-disable @typescript-eslint/triple-slash-reference */\n/// <reference path=\"jdspec.d.ts\" />\n/// <reference path=\"jdtest.d.ts\" />\n\nimport { parseIntFloat, getRegister } from \"./jdutils\"\nimport { JSONPath } from \"jsonpath-plus\"\nimport { testCommandFunctions, testExpressionFunctions } from \"./jdtestfuns\"\nimport jsep, { ExpressionType } from \"jsep\"\n\nconst supportedExpressions: ExpressionType[] = [\n    \"BinaryExpression\",\n    \"CallExpression\",\n    \"Identifier\",\n    \"Literal\",\n    \"UnaryExpression\",\n    \"LogicalExpression\",\n]\n\n// we parse a test with respect to an existing ServiceSpec\nexport function parseSpecificationTestMarkdownToJSON(\n    filecontent: string,\n    spec: jdspec.ServiceSpec,\n    filename = \"\"\n): jdtest.ServiceTestSpec {\n    filecontent = (filecontent || \"\").replace(/\\r/g, \"\")\n    const info: jdtest.ServiceTestSpec = {\n        description: \"\",\n        serviceClassIdentifier: spec.classIdentifier,\n        tests: [],\n    }\n\n    let backticksType = \"\"\n    const errors: jdspec.Diagnostic[] = []\n    let lineNo = 0\n    let currentTest: jdtest.TestSpec = null\n    let testHeading = \"\"\n    let testPrompt = \"\"\n\n    try {\n        for (const line of filecontent.split(/\\n/)) {\n            lineNo++\n            processLine(line)\n        }\n    } catch (e) {\n        error(\"exception: \" + e.message)\n    }\n\n    if (currentTest) finishTest()\n\n    if (errors.length) info.errors = errors\n\n    return info\n\n    function processLine(line: string) {\n        if (backticksType) {\n            if (line.trim() == \"```\") {\n                backticksType = null\n                if (backticksType == \"default\") return\n            }\n        } else {\n            const m = /^```(.*)/.exec(line)\n            if (m) {\n                backticksType = m[1] || \"default\"\n                if (backticksType == \"default\") return\n            }\n        }\n\n        const interpret =\n            backticksType == \"default\" || line.slice(0, 4) == \"    \"\n\n        if (!interpret) {\n            const m = /^(#+)\\s*(.*)/.exec(line)\n            if (m) {\n                testHeading = \"\"\n                testPrompt = \"\"\n                const [, hd, cont] = m\n                if (hd == \"#\" && !info.description) {\n                    info.description = cont.trim()\n                } else if (hd == \"##\") {\n                    if (currentTest) finishTest()\n                    testHeading = cont.trim()\n                }\n            } else {\n                testPrompt += line\n            }\n        } else {\n            const expanded = line.replace(/\\/\\/.*/, \"\").trim()\n            if (!expanded) return\n            processCommand(expanded)\n        }\n    }\n\n    function processCommand(expanded: string) {\n        if (!currentTest) {\n            if (!testHeading)\n                error(`every test must have a description (via ##)`)\n            currentTest = {\n                description: testHeading,\n                registers: [],\n                commands: [],\n            }\n            testHeading = \"\"\n        }\n        const call = /^([a-zA-Z]\\w*)\\(.*\\)$/.exec(expanded)\n        if (!call) {\n            error(\n                `a command must be a call to a registered test function (JavaScript syntax)`\n            )\n            return\n        }\n        const [, callee] = call\n        const index = testCommandFunctions.findIndex(r => callee == r.id)\n        if (index < 0) {\n            error(`${callee} is not a registered test command function.`)\n            return\n        }\n        const root: jsep.CallExpression = <jsep.CallExpression>jsep(expanded)\n        if (\n            !root ||\n            !root.type ||\n            root.type != \"CallExpression\" ||\n            !root.callee ||\n            !root.arguments\n        ) {\n            error(`a command must be a call expression in JavaScript syntax`)\n        } else {\n            // check for unsupported expression types\n            if (supportedExpressions.indexOf(root.type) < 0)\n                error(`Expression of type ${root.type} not currently supported`)\n            // check arguments\n            const expected = testCommandFunctions[index].args.length\n            if (expected !== root.arguments.length)\n                error(\n                    `${callee} expects ${expected} arguments; got ${root.arguments.length}`\n                )\n            else {\n                root.arguments.forEach((arg,a) => {\n                    if (testCommandFunctions[index].args[a] === \"register\" && arg.type !== \"Identifier\") {\n                        error (\n                            `${callee} expects a register in argument position ${a+1}`\n                        )\n                    }\n                })\n                const callers = <jsep.CallExpression[]>(\n                    JSONPath({\n                        path: \"$..*[?(@.type=='CallExpression')]\",\n                        json: root,\n                    })\n                )\n                callers.forEach(callExpr => {\n                    if (callExpr.callee.type !== \"Identifier\")\n                        error(`all calls must be direct calls`)\n                    const id = (<jsep.Identifier>callExpr.callee).name\n                    const indexFun = testExpressionFunctions.findIndex(\n                        r => id == r.id\n                    )\n                    if (indexFun < 0)\n                        error(\n                            `${id} is not a registered test expression function.`\n                        )\n                    if (id === 'start') {\n                        if (callee !== 'check')\n                            error(\"start expression function can only be used inside check test function\")\n                        const callsUnder = <jsep.CallExpression[]>(\n                            JSONPath({\n                                path: \"$..*[?(@.type=='CallExpression')]\",\n                                json: callExpr,\n                            })\n                        )\n                        callsUnder.forEach(ce => {\n                            if (ce.callee.type === \"Identifier\" && (<jsep.Identifier>ce.callee).name === \"start\")\n                                error(\"cannot nest start underneath start\")\n                        })\n                    }\n                    const expected =\n                        testExpressionFunctions[indexFun].args.length\n                    if (expected !== callExpr.arguments.length)\n                        error(\n                            `${callee} expects ${expected} arguments; got ${callExpr.arguments.length}`\n                        )\n                })\n            }\n            // now visit all (p,c), c an Identifier that is not a callee child of CallExpression\n            // or a property child of a MemberExpression\n            const exprs = <any[]>(\n                JSONPath({ path: \"$..*[?(@.type=='Identifier')]^\", json: root })\n            )\n            let visited: any[] = []\n            exprs.forEach(parent => {\n                if (visited.indexOf(parent) < 0) {\n                    visited.push(parent)\n                    lookupReplace(parent)\n                }\n            })\n            currentTest.commands.push({ prompt: testPrompt, call: root })\n            testPrompt = \"\"\n        }\n    }\n\n    function lookupReplace(parent: any) {\n        if (parent.length) {\n            const exprs: jsep.Expression[] = parent\n            exprs.forEach((child: jsep.Expression) => {\n                if (child.type === \"Identifier\")\n                    lookup(parent, <jsep.Identifier>child)\n            })\n        } else {\n            Object.keys(parent).forEach((key: string) => {\n                const child = parent[key]\n                if (child?.type !== \"Identifier\") return\n                if (\n                    (parent.type !== \"MemberExpression\" &&\n                        parent.type !== \"CallExpression\") ||\n                    (parent.type === \"MemberExpression\" &&\n                        child !== (<jsep.MemberExpression>parent).property) ||\n                    (parent.type === \"CallExpression\" &&\n                        child !== (<jsep.CallExpression>parent).callee)\n                ) {\n                    lookup(parent, <jsep.Identifier>child)\n                }\n            })\n        }\n\n        function lookup(parent: any, child: jsep.Identifier) {\n            try {\n                try {\n                    const val = parseIntFloat(spec, child.name)\n                    const lit: jsep.Literal = {\n                        type: \"Literal\",\n                        value: val,\n                        raw: val.toString(),\n                    }\n                    /*TODO: replace the Identifier by the (resolved) Literal\n                    if (parent.type) {\n                        Object.keys(parent).forEach((key:string) => {\n                            if (Object.getOwnPropertyDescriptor(parent,key) == child)\n                                Object.defineProperty(parent, key, lit);\n                        })\n                    } else {\n    \n                    }*/\n                } catch (e) {\n                    getRegister(spec, child.name)\n                    if (currentTest.registers.indexOf(child.name) < 0)\n                        currentTest.registers.push(child.name)\n                    // TODO: if parent is MemberExpression, continue to do lookup\n                }\n            } catch (e) {\n                error(`${child.name} not found in specification`)\n            }\n        }\n    }\n\n    function finishTest() {\n        info.tests.push(currentTest)\n        currentTest = null\n    }\n\n    function error(msg: string) {\n        if (!msg) msg = \"syntax error\"\n        if (errors.some(e => e.line == lineNo && e.message == msg)) return\n        errors.push({ file: filename, line: lineNo, message: msg })\n    }\n}\n","import React, { useContext, useMemo, useState } from \"react\"\nimport { Button, Grid } from \"@material-ui/core\"\nimport { parseSpecificationTestMarkdownToJSON } from \"../../../jacdac-ts/jacdac-spec/spectool/jdtest\"\nimport { serviceSpecificationFromClassIdentifier } from \"../../../jacdac-ts/src/jdom/spec\"\nimport useLocalStorage from \"../useLocalStorage\"\nimport HighlightTextField from \"../ui/HighlightTextField\"\nimport ServiceSpecificationSelect from \"../ServiceSpecificationSelect\"\nimport { SRV_BUTTON } from \"../../../jacdac-ts/src/jdom/constants\"\nimport ServiceTest from \"../ServiceTest\"\nimport { fetchText } from \"../github\"\nimport AppContext from \"../AppContext\"\n\nconst SERVICE_TEST_STORAGE_KEY = \"jacdac:servicetesteditorsource\"\n\nexport default function ServiceTestEditor() {\n    const { setError } = useContext(AppContext)\n    const [serviceClass, setServiceClass] = useState(SRV_BUTTON)\n    const [source, setSource] = useLocalStorage(SERVICE_TEST_STORAGE_KEY, \"\")\n    const serviceSpec = useMemo(\n        () => serviceSpecificationFromClassIdentifier(serviceClass),\n        [serviceClass]\n    )\n    const json = useMemo(\n        () => parseSpecificationTestMarkdownToJSON(source, serviceSpec),\n        [source, serviceSpec]\n    )\n    const servicePath =\n        json &&\n        `services/tests/${(\n            serviceSpec.camelName ||\n            serviceSpec.shortId ||\n            `0x${serviceSpec.classIdentifier.toString(16)}`\n        ).toLowerCase()}`\n    const handleLoadFromGithub = async () => {\n        try {\n            const ghSource = await fetchText(\n                \"microsoft/jacdac\",\n                \"main\",\n                `services/tests/${serviceSpec.shortId}.md`,\n                \"text/plain\"\n            )\n            if (ghSource)\n                setSource(ghSource)\n            else\n                setError(\"Test source not found\")\n        } catch (e) {\n            setError(e)\n        }\n    }\n    return (\n        <Grid spacing={2} container>\n            <Grid item xs={12}>\n                <Grid container spacing={2} direction=\"row\">\n                    <Grid item>\n                        <ServiceSpecificationSelect\n                            label={\"Select a service to test\"}\n                            serviceClass={serviceClass}\n                            setServiceClass={setServiceClass}\n                        />\n                    </Grid>\n                    <Grid item>\n                        <Button\n                            variant=\"outlined\"\n                            disabled={!serviceSpec}\n                            onClick={handleLoadFromGithub}\n                        >\n                            Load tests from GitHub\n                        </Button>\n                    </Grid>\n                </Grid>\n            </Grid>\n            <Grid item xs={12}>\n                <HighlightTextField\n                    code={source}\n                    language={\"markdown\"}\n                    onChange={setSource}\n                    annotations={json?.errors}\n                    pullRequestTitle={\n                        json && `Service test: ${serviceSpec.name}`\n                    }\n                    pullRequestPath={servicePath}\n                />\n            </Grid>\n            {json && (\n                <Grid item xs={12}>\n                    <ServiceTest showStartSimulator={true} serviceSpec={serviceSpec} serviceTest={json} />\n                </Grid>\n            )}\n        </Grid>\n    )\n}\n","import React from \"react\"\nimport ServiceTestEditor from '../../components/tools/ServiceTestEditor'\n\nexport default function Page() {\n    return <ServiceTestEditor />\n}","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable react/jsx-key */\nimport React, { useContext, useRef, lazy } from \"react\"\nimport Highlight, {\n    defaultProps,\n    Language,\n    PrismTheme,\n} from \"prism-react-renderer\"\n// tslint:disable-next-line: no-submodule-imports match-default-export-name\nimport LIGHT_THEME from \"prism-react-renderer/themes/github\"\n// tslint:disable-next-line: no-submodule-imports match-default-export-name\nimport DARK_THEME from \"prism-react-renderer/themes/vsDark\"\nimport DarkModeContext from \"./DarkModeContext\"\nimport { useEditable } from \"use-editable\"\nimport { Alert } from \"@material-ui/lab\"\nimport { Grid, Tooltip, withStyles } from \"@material-ui/core\"\nimport Suspense from \"../ui/Suspense\";\nconst GithubPullRequestButton = lazy(() => import('../GithubPullRequestButton'));\n\nconst AnnotationTooltip = withStyles(theme => ({\n    arrow: {\n        color: theme.palette.error.main,\n    },\n    tooltip: {\n        backgroundColor: theme.palette.error.main,\n        color: theme.palette.common.white,\n        boxShadow: theme.shadows[1],\n        fontSize: theme.typography.body2.fontSize,\n    },\n}))(Tooltip)\n\nexport default function HighlightTextField(props: {\n    language: string\n    code: string\n    onChange: (newValue: string) => void\n    annotations?: jdspec.Diagnostic[]\n    pullRequestTitle?: string\n    pullRequestPath?: string\n    pullRequestDescription?: string\n}) {\n    const {\n        code,\n        onChange,\n        language,\n        annotations,\n        pullRequestTitle,\n        pullRequestPath,\n        pullRequestDescription,\n    } = props\n    const { darkMode } = useContext(DarkModeContext)\n    const theme = (darkMode === \"dark\" ? DARK_THEME : LIGHT_THEME) as PrismTheme\n    const editorRef = useRef(null)\n\n    useEditable(editorRef, onChange, {\n        disabled: false,\n        indentation: 4,\n    })\n    return (\n        <Grid container spacing={1} direction=\"row\">\n            <Grid item xs={12}>\n                <Highlight\n                    {...defaultProps}\n                    code={code}\n                    language={language as Language}\n                    theme={theme}\n                >\n                    {({ className, style, tokens, getTokenProps }) => (\n                        <pre\n                            ref={editorRef}\n                            className={className}\n                            spellCheck={false}\n                            style={{\n                                ...style,\n                                ...{\n                                    minHeight: \"12rem\",\n                                    whiteSpace: \"pre-wrap\",\n                                },\n                            }}\n                        >\n                            {tokens.map((line, i) => {\n                                const annotation = annotations?.find(\n                                    a => a.line === i + 1\n                                )\n                                const title = annotation?.message\n                                const el = (\n                                    <span\n                                        key={i}\n                                        style={\n                                            annotation && {\n                                                borderBottom: \"dashed 1px red\",\n                                            }\n                                        }\n                                    >\n                                        {line\n                                            .filter(token => !token.empty)\n                                            .map((token, key) => (\n                                                <span\n                                                    {...getTokenProps({\n                                                        token,\n                                                        key,\n                                                    })}\n                                                />\n                                            ))}\n                                        {i < tokens.length - 1 ? \"\\n\" : null}\n                                    </span>\n                                )\n                                return title ? (\n                                    <AnnotationTooltip\n                                        title={title}\n                                        arrow\n                                        key={i}\n                                    >\n                                        {el}\n                                    </AnnotationTooltip>\n                                ) : (\n                                    el\n                                )\n                            })}\n                        </pre>\n                    )}\n                </Highlight>\n            </Grid>\n            {!!annotations?.length && (\n                <Grid item xs={12}>\n                    <Alert severity=\"error\">\n                        <ul>\n                            {annotations.map((a, i) => (\n                                <li key={i}>\n                                    line {a.line}: {a.message}\n                                </li>\n                            ))}\n                        </ul>\n                    </Alert>\n                </Grid>\n            )}\n            {pullRequestTitle && pullRequestPath && (\n                <Grid item>\n                    <Suspense>\n                        <GithubPullRequestButton\n                            title={pullRequestTitle}\n                            head={pullRequestPath}\n                            description={pullRequestDescription}\n                            files={{\n                                [pullRequestPath + \".md\"]: code,\n                            }}\n                        />\n                    </Suspense>\n                </Grid>\n            )}\n        </Grid>\n    )\n}\n","//     JavaScript Expression Parser (JSEP) 0.3.5\n//     JSEP may be freely distributed under the MIT License\n//     https://ericsmekens.github.io/jsep/\n\n/*global module: true, exports: true, console: true */\n(function (root) {\n  'use strict'; // Node Types\n  // ----------\n  // This is the full set of types that any JSEP node can be.\n  // Store them here to save space when minified\n\n  var COMPOUND = 'Compound',\n      IDENTIFIER = 'Identifier',\n      MEMBER_EXP = 'MemberExpression',\n      LITERAL = 'Literal',\n      THIS_EXP = 'ThisExpression',\n      CALL_EXP = 'CallExpression',\n      UNARY_EXP = 'UnaryExpression',\n      BINARY_EXP = 'BinaryExpression',\n      LOGICAL_EXP = 'LogicalExpression',\n      CONDITIONAL_EXP = 'ConditionalExpression',\n      ARRAY_EXP = 'ArrayExpression',\n      PERIOD_CODE = 46,\n      // '.'\n  COMMA_CODE = 44,\n      // ','\n  SQUOTE_CODE = 39,\n      // single quote\n  DQUOTE_CODE = 34,\n      // double quotes\n  OPAREN_CODE = 40,\n      // (\n  CPAREN_CODE = 41,\n      // )\n  OBRACK_CODE = 91,\n      // [\n  CBRACK_CODE = 93,\n      // ]\n  QUMARK_CODE = 63,\n      // ?\n  SEMCOL_CODE = 59,\n      // ;\n  COLON_CODE = 58,\n      // :\n  throwError = function throwError(message, index) {\n    var error = new Error(message + ' at character ' + index);\n    error.index = index;\n    error.description = message;\n    throw error;\n  },\n      // Operations\n  // ----------\n  // Set `t` to `true` to save space (when minified, not gzipped)\n  t = true,\n      // Use a quickly-accessible map to store all of the unary operators\n  // Values are set to `true` (it really doesn't matter)\n  unary_ops = {\n    '-': t,\n    '!': t,\n    '~': t,\n    '+': t\n  },\n      // Also use a map for the binary operations but set their values to their\n  // binary precedence for quick reference:\n  // see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n  binary_ops = {\n    '||': 1,\n    '&&': 2,\n    '|': 3,\n    '^': 4,\n    '&': 5,\n    '==': 6,\n    '!=': 6,\n    '===': 6,\n    '!==': 6,\n    '<': 7,\n    '>': 7,\n    '<=': 7,\n    '>=': 7,\n    '<<': 8,\n    '>>': 8,\n    '>>>': 8,\n    '+': 9,\n    '-': 9,\n    '*': 10,\n    '/': 10,\n    '%': 10\n  },\n      // Get return the longest key length of any object\n  getMaxKeyLen = function getMaxKeyLen(obj) {\n    var max_len = 0,\n        len;\n\n    for (var key in obj) {\n      if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n        max_len = len;\n      }\n    }\n\n    return max_len;\n  },\n      max_unop_len = getMaxKeyLen(unary_ops),\n      max_binop_len = getMaxKeyLen(binary_ops),\n      // Literals\n  // ----------\n  // Store the values to return for the various literals we may encounter\n  literals = {\n    'true': true,\n    'false': false,\n    'null': null\n  },\n      // Except for `this`, which is special. This could be changed to something like `'self'` as well\n  this_str = 'this',\n      // Returns the precedence of a binary operator or `0` if it isn't a binary operator\n  binaryPrecedence = function binaryPrecedence(op_val) {\n    return binary_ops[op_val] || 0;\n  },\n      // Utility function (gets called from multiple places)\n  // Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n  createBinaryExpression = function createBinaryExpression(operator, left, right) {\n    var type = operator === '||' || operator === '&&' ? LOGICAL_EXP : BINARY_EXP;\n    return {\n      type: type,\n      operator: operator,\n      left: left,\n      right: right\n    };\n  },\n      // `ch` is a character code in the next three functions\n  isDecimalDigit = function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0...9\n  },\n      isIdentifierStart = function isIdentifierStart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // a...z\n    ch >= 128 && !binary_ops[String.fromCharCode(ch)]; // any non-ASCII that is not an operator\n  },\n      isIdentifierPart = function isIdentifierPart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // a...z\n    ch >= 48 && ch <= 57 || // 0...9\n    ch >= 128 && !binary_ops[String.fromCharCode(ch)]; // any non-ASCII that is not an operator\n  },\n      // Parsing\n  // -------\n  // `expr` is a string with the passed in expression\n  jsep = function jsep(expr) {\n    // `index` stores the character number we are currently at while `length` is a constant\n    // All of the gobbles below will modify `index` as we move along\n    var index = 0,\n        charAtFunc = expr.charAt,\n        charCodeAtFunc = expr.charCodeAt,\n        exprI = function exprI(i) {\n      return charAtFunc.call(expr, i);\n    },\n        exprICode = function exprICode(i) {\n      return charCodeAtFunc.call(expr, i);\n    },\n        length = expr.length,\n        // Push `index` up to the next non-space character\n    gobbleSpaces = function gobbleSpaces() {\n      var ch = exprICode(index); // space or tab\n\n      while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {\n        ch = exprICode(++index);\n      }\n    },\n        // The main parsing function. Much of this code is dedicated to ternary expressions\n    gobbleExpression = function gobbleExpression() {\n      var test = gobbleBinaryExpression(),\n          consequent,\n          alternate;\n      gobbleSpaces();\n\n      if (exprICode(index) === QUMARK_CODE) {\n        // Ternary expression: test ? consequent : alternate\n        index++;\n        consequent = gobbleExpression();\n\n        if (!consequent) {\n          throwError('Expected expression', index);\n        }\n\n        gobbleSpaces();\n\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          alternate = gobbleExpression();\n\n          if (!alternate) {\n            throwError('Expected expression', index);\n          }\n\n          return {\n            type: CONDITIONAL_EXP,\n            test: test,\n            consequent: consequent,\n            alternate: alternate\n          };\n        } else {\n          throwError('Expected :', index);\n        }\n      } else {\n        return test;\n      }\n    },\n        // Search for the operation portion of the string (e.g. `+`, `===`)\n    // Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n    // and move down from 3 to 2 to 1 character until a matching binary operation is found\n    // then, return that binary operation\n    gobbleBinaryOp = function gobbleBinaryOp() {\n      gobbleSpaces();\n      var biop,\n          to_check = expr.substr(index, max_binop_len),\n          tc_len = to_check.length;\n\n      while (tc_len > 0) {\n        // Don't accept a binary op when it is an identifier.\n        // Binary ops that start with a identifier-valid character must be followed\n        // by a non identifier-part valid character\n        if (binary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {\n          index += tc_len;\n          return to_check;\n        }\n\n        to_check = to_check.substr(0, --tc_len);\n      }\n\n      return false;\n    },\n        // This function is responsible for gobbling an individual expression,\n    // e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n    gobbleBinaryExpression = function gobbleBinaryExpression() {\n      var ch_i, node, biop, prec, stack, biop_info, left, right, i, cur_biop; // First, try to get the leftmost thing\n      // Then, check to see if there's a binary operator operating on that leftmost thing\n\n      left = gobbleToken();\n      biop = gobbleBinaryOp(); // If there wasn't a binary operator, just return the leftmost node\n\n      if (!biop) {\n        return left;\n      } // Otherwise, we need to start a stack to properly place the binary operations in their\n      // precedence structure\n\n\n      biop_info = {\n        value: biop,\n        prec: binaryPrecedence(biop)\n      };\n      right = gobbleToken();\n\n      if (!right) {\n        throwError(\"Expected expression after \" + biop, index);\n      }\n\n      stack = [left, biop_info, right]; // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\n      while (biop = gobbleBinaryOp()) {\n        prec = binaryPrecedence(biop);\n\n        if (prec === 0) {\n          break;\n        }\n\n        biop_info = {\n          value: biop,\n          prec: prec\n        };\n        cur_biop = biop; // Reduce: make a binary expression from the three topmost entries.\n\n        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n          right = stack.pop();\n          biop = stack.pop().value;\n          left = stack.pop();\n          node = createBinaryExpression(biop, left, right);\n          stack.push(node);\n        }\n\n        node = gobbleToken();\n\n        if (!node) {\n          throwError(\"Expected expression after \" + cur_biop, index);\n        }\n\n        stack.push(biop_info, node);\n      }\n\n      i = stack.length - 1;\n      node = stack[i];\n\n      while (i > 1) {\n        node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\n        i -= 2;\n      }\n\n      return node;\n    },\n        // An individual part of a binary expression:\n    // e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n    gobbleToken = function gobbleToken() {\n      var ch, to_check, tc_len;\n      gobbleSpaces();\n      ch = exprICode(index);\n\n      if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n        // Char code 46 is a dot `.` which can start off a numeric literal\n        return gobbleNumericLiteral();\n      } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n        // Single or double quotes\n        return gobbleStringLiteral();\n      } else if (ch === OBRACK_CODE) {\n        return gobbleArray();\n      } else {\n        to_check = expr.substr(index, max_unop_len);\n        tc_len = to_check.length;\n\n        while (tc_len > 0) {\n          // Don't accept an unary op when it is an identifier.\n          // Unary ops that start with a identifier-valid character must be followed\n          // by a non identifier-part valid character\n          if (unary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {\n            index += tc_len;\n            return {\n              type: UNARY_EXP,\n              operator: to_check,\n              argument: gobbleToken(),\n              prefix: true\n            };\n          }\n\n          to_check = to_check.substr(0, --tc_len);\n        }\n\n        if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n          // open parenthesis\n          // `foo`, `bar.baz`\n          return gobbleVariable();\n        }\n      }\n\n      return false;\n    },\n        // Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n    // keep track of everything in the numeric literal and then calling `parseFloat` on that string\n    gobbleNumericLiteral = function gobbleNumericLiteral() {\n      var number = '',\n          ch,\n          chCode;\n\n      while (isDecimalDigit(exprICode(index))) {\n        number += exprI(index++);\n      }\n\n      if (exprICode(index) === PERIOD_CODE) {\n        // can start with a decimal marker\n        number += exprI(index++);\n\n        while (isDecimalDigit(exprICode(index))) {\n          number += exprI(index++);\n        }\n      }\n\n      ch = exprI(index);\n\n      if (ch === 'e' || ch === 'E') {\n        // exponent marker\n        number += exprI(index++);\n        ch = exprI(index);\n\n        if (ch === '+' || ch === '-') {\n          // exponent sign\n          number += exprI(index++);\n        }\n\n        while (isDecimalDigit(exprICode(index))) {\n          //exponent itself\n          number += exprI(index++);\n        }\n\n        if (!isDecimalDigit(exprICode(index - 1))) {\n          throwError('Expected exponent (' + number + exprI(index) + ')', index);\n        }\n      }\n\n      chCode = exprICode(index); // Check to make sure this isn't a variable name that start with a number (123abc)\n\n      if (isIdentifierStart(chCode)) {\n        throwError('Variable names cannot start with a number (' + number + exprI(index) + ')', index);\n      } else if (chCode === PERIOD_CODE) {\n        throwError('Unexpected period', index);\n      }\n\n      return {\n        type: LITERAL,\n        value: parseFloat(number),\n        raw: number\n      };\n    },\n        // Parses a string literal, staring with single or double quotes with basic support for escape codes\n    // e.g. `\"hello world\"`, `'this is\\nJSEP'`\n    gobbleStringLiteral = function gobbleStringLiteral() {\n      var str = '',\n          quote = exprI(index++),\n          closed = false,\n          ch;\n\n      while (index < length) {\n        ch = exprI(index++);\n\n        if (ch === quote) {\n          closed = true;\n          break;\n        } else if (ch === '\\\\') {\n          // Check for all of the common escape codes\n          ch = exprI(index++);\n\n          switch (ch) {\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            default:\n              str += ch;\n          }\n        } else {\n          str += ch;\n        }\n      }\n\n      if (!closed) {\n        throwError('Unclosed quote after \"' + str + '\"', index);\n      }\n\n      return {\n        type: LITERAL,\n        value: str,\n        raw: quote + str + quote\n      };\n    },\n        // Gobbles only identifiers\n    // e.g.: `foo`, `_value`, `$x1`\n    // Also, this function checks if that identifier is a literal:\n    // (e.g. `true`, `false`, `null`) or `this`\n    gobbleIdentifier = function gobbleIdentifier() {\n      var ch = exprICode(index),\n          start = index,\n          identifier;\n\n      if (isIdentifierStart(ch)) {\n        index++;\n      } else {\n        throwError('Unexpected ' + exprI(index), index);\n      }\n\n      while (index < length) {\n        ch = exprICode(index);\n\n        if (isIdentifierPart(ch)) {\n          index++;\n        } else {\n          break;\n        }\n      }\n\n      identifier = expr.slice(start, index);\n\n      if (literals.hasOwnProperty(identifier)) {\n        return {\n          type: LITERAL,\n          value: literals[identifier],\n          raw: identifier\n        };\n      } else if (identifier === this_str) {\n        return {\n          type: THIS_EXP\n        };\n      } else {\n        return {\n          type: IDENTIFIER,\n          name: identifier\n        };\n      }\n    },\n        // Gobbles a list of arguments within the context of a function call\n    // or array literal. This function also assumes that the opening character\n    // `(` or `[` has already been gobbled, and gobbles expressions and commas\n    // until the terminator character `)` or `]` is encountered.\n    // e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n    gobbleArguments = function gobbleArguments(termination) {\n      var ch_i,\n          args = [],\n          node,\n          closed = false;\n      var separator_count = 0;\n\n      while (index < length) {\n        gobbleSpaces();\n        ch_i = exprICode(index);\n\n        if (ch_i === termination) {\n          // done parsing\n          closed = true;\n          index++;\n\n          if (termination === CPAREN_CODE && separator_count && separator_count >= args.length) {\n            throwError('Unexpected token ' + String.fromCharCode(termination), index);\n          }\n\n          break;\n        } else if (ch_i === COMMA_CODE) {\n          // between expressions\n          index++;\n          separator_count++;\n\n          if (separator_count !== args.length) {\n            // missing argument\n            if (termination === CPAREN_CODE) {\n              throwError('Unexpected token ,', index);\n            } else if (termination === CBRACK_CODE) {\n              for (var arg = args.length; arg < separator_count; arg++) {\n                args.push(null);\n              }\n            }\n          }\n        } else {\n          node = gobbleExpression();\n\n          if (!node || node.type === COMPOUND) {\n            throwError('Expected comma', index);\n          }\n\n          args.push(node);\n        }\n      }\n\n      if (!closed) {\n        throwError('Expected ' + String.fromCharCode(termination), index);\n      }\n\n      return args;\n    },\n        // Gobble a non-literal variable name. This variable name may include properties\n    // e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n    // It also gobbles function calls:\n    // e.g. `Math.acos(obj.angle)`\n    gobbleVariable = function gobbleVariable() {\n      var ch_i, node;\n      ch_i = exprICode(index);\n\n      if (ch_i === OPAREN_CODE) {\n        node = gobbleGroup();\n      } else {\n        node = gobbleIdentifier();\n      }\n\n      gobbleSpaces();\n      ch_i = exprICode(index);\n\n      while (ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n        index++;\n\n        if (ch_i === PERIOD_CODE) {\n          gobbleSpaces();\n          node = {\n            type: MEMBER_EXP,\n            computed: false,\n            object: node,\n            property: gobbleIdentifier()\n          };\n        } else if (ch_i === OBRACK_CODE) {\n          node = {\n            type: MEMBER_EXP,\n            computed: true,\n            object: node,\n            property: gobbleExpression()\n          };\n          gobbleSpaces();\n          ch_i = exprICode(index);\n\n          if (ch_i !== CBRACK_CODE) {\n            throwError('Unclosed [', index);\n          }\n\n          index++;\n        } else if (ch_i === OPAREN_CODE) {\n          // A function call is being made; gobble all the arguments\n          node = {\n            type: CALL_EXP,\n            'arguments': gobbleArguments(CPAREN_CODE),\n            callee: node\n          };\n        }\n\n        gobbleSpaces();\n        ch_i = exprICode(index);\n      }\n\n      return node;\n    },\n        // Responsible for parsing a group of things within parentheses `()`\n    // This function assumes that it needs to gobble the opening parenthesis\n    // and then tries to gobble everything within that parenthesis, assuming\n    // that the next thing it should see is the close parenthesis. If not,\n    // then the expression probably doesn't have a `)`\n    gobbleGroup = function gobbleGroup() {\n      index++;\n      var node = gobbleExpression();\n      gobbleSpaces();\n\n      if (exprICode(index) === CPAREN_CODE) {\n        index++;\n        return node;\n      } else {\n        throwError('Unclosed (', index);\n      }\n    },\n        // Responsible for parsing Array literals `[1, 2, 3]`\n    // This function assumes that it needs to gobble the opening bracket\n    // and then tries to gobble the expressions as arguments.\n    gobbleArray = function gobbleArray() {\n      index++;\n      return {\n        type: ARRAY_EXP,\n        elements: gobbleArguments(CBRACK_CODE)\n      };\n    },\n        nodes = [],\n        ch_i,\n        node;\n\n    while (index < length) {\n      ch_i = exprICode(index); // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n\n      if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n        index++; // ignore separators\n      } else {\n        // Try to gobble each expression individually\n        if (node = gobbleExpression()) {\n          nodes.push(node); // If we weren't able to find a binary expression and are out of room, then\n          // the expression passed in probably has too much\n        } else if (index < length) {\n          throwError('Unexpected \"' + exprI(index) + '\"', index);\n        }\n      }\n    } // If there's only one expression just try returning the expression\n\n\n    if (nodes.length === 1) {\n      return nodes[0];\n    } else {\n      return {\n        type: COMPOUND,\n        body: nodes\n      };\n    }\n  }; // To be filled in by the template\n\n\n  jsep.version = '0.3.5';\n\n  jsep.toString = function () {\n    return 'JavaScript Expression Parser (JSEP) v' + jsep.version;\n  };\n  /**\n   * @method jsep.addUnaryOp\n   * @param {string} op_name The name of the unary op to add\n   * @return jsep\n   */\n\n\n  jsep.addUnaryOp = function (op_name) {\n    max_unop_len = Math.max(op_name.length, max_unop_len);\n    unary_ops[op_name] = t;\n    return this;\n  };\n  /**\n   * @method jsep.addBinaryOp\n   * @param {string} op_name The name of the binary op to add\n   * @param {number} precedence The precedence of the binary op (can be a float)\n   * @return jsep\n   */\n\n\n  jsep.addBinaryOp = function (op_name, precedence) {\n    max_binop_len = Math.max(op_name.length, max_binop_len);\n    binary_ops[op_name] = precedence;\n    return this;\n  };\n  /**\n   * @method jsep.addLiteral\n   * @param {string} literal_name The name of the literal to add\n   * @param {*} literal_value The value of the literal\n   * @return jsep\n   */\n\n\n  jsep.addLiteral = function (literal_name, literal_value) {\n    literals[literal_name] = literal_value;\n    return this;\n  };\n  /**\n   * @method jsep.removeUnaryOp\n   * @param {string} op_name The name of the unary op to remove\n   * @return jsep\n   */\n\n\n  jsep.removeUnaryOp = function (op_name) {\n    delete unary_ops[op_name];\n\n    if (op_name.length === max_unop_len) {\n      max_unop_len = getMaxKeyLen(unary_ops);\n    }\n\n    return this;\n  };\n  /**\n   * @method jsep.removeAllUnaryOps\n   * @return jsep\n   */\n\n\n  jsep.removeAllUnaryOps = function () {\n    unary_ops = {};\n    max_unop_len = 0;\n    return this;\n  };\n  /**\n   * @method jsep.removeBinaryOp\n   * @param {string} op_name The name of the binary op to remove\n   * @return jsep\n   */\n\n\n  jsep.removeBinaryOp = function (op_name) {\n    delete binary_ops[op_name];\n\n    if (op_name.length === max_binop_len) {\n      max_binop_len = getMaxKeyLen(binary_ops);\n    }\n\n    return this;\n  };\n  /**\n   * @method jsep.removeAllBinaryOps\n   * @return jsep\n   */\n\n\n  jsep.removeAllBinaryOps = function () {\n    binary_ops = {};\n    max_binop_len = 0;\n    return this;\n  };\n  /**\n   * @method jsep.removeLiteral\n   * @param {string} literal_name The name of the literal to remove\n   * @return jsep\n   */\n\n\n  jsep.removeLiteral = function (literal_name) {\n    delete literals[literal_name];\n    return this;\n  };\n  /**\n   * @method jsep.removeAllLiterals\n   * @return jsep\n   */\n\n\n  jsep.removeAllLiterals = function () {\n    literals = {};\n    return this;\n  }; // In desktop environments, have a way to restore the old value for `jsep`\n\n\n  if (typeof exports === 'undefined') {\n    var old_jsep = root.jsep; // The star of the show! It's a function!\n\n    root.jsep = jsep; // And a courteous function willing to move out of the way for other similarly-named objects!\n\n    jsep.noConflict = function () {\n      if (root.jsep === jsep) {\n        root.jsep = old_jsep;\n      }\n\n      return jsep;\n    };\n  } else {\n    // In Node.JS environments\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = jsep;\n    } else {\n      exports.parse = jsep;\n    }\n  }\n})(this);"],"sourceRoot":""}