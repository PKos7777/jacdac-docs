{"version":3,"sources":["webpack://jacdac-docs/webpack/bootstrap","webpack://jacdac-docs/webpack/runtime/make namespace object","webpack://jacdac-docs/./src/workers/data/dist/node_modules/data-worker.js"],"names":[],"mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;ACNA;AACA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,wDAAwD,OAAO;AAC7F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA","file":"src_workers_data_dist_node_modules_data-worker_js.render-page.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction tidy(items, ...fns) {\n  if (typeof items === \"function\") {\n    throw new Error(\"You must supply the data as the first argument to tidy()\");\n  }\n\n  let result = items;\n\n  for (const fn of fns) {\n    if (fn) {\n      result = fn(result);\n    }\n  }\n\n  return result;\n}\n\nfunction filter(filterFn) {\n  const _filter = items => items.filter(filterFn);\n\n  return _filter;\n}\n\nfunction singleOrArray(d) {\n  return d == null ? [] : Array.isArray(d) ? d : [d];\n}\n\nfunction ascending (a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction arrange(comparators) {\n  const _arrange = items => {\n    const comparatorFns = singleOrArray(comparators).map(comp => typeof comp === \"function\" ? comp : asc(comp));\n    return items.slice().sort((a, b) => {\n      for (const comparator of comparatorFns) {\n        const result = comparator(a, b);\n        if (result) return result;\n      }\n\n      return 0;\n    });\n  };\n\n  return _arrange;\n}\n\nfunction asc(key) {\n  const keyFn = typeof key === \"function\" ? key : d => d[key];\n  return function _asc(a, b) {\n    return emptyAwareComparator(keyFn(a), keyFn(b), false);\n  };\n}\n\nfunction desc(key) {\n  const keyFn = typeof key === \"function\" ? key : d => d[key];\n  return function _desc(a, b) {\n    return emptyAwareComparator(keyFn(a), keyFn(b), true);\n  };\n}\n\nfunction emptyAwareComparator(aInput, bInput, desc2) {\n  let a = desc2 ? bInput : aInput;\n  let b = desc2 ? aInput : bInput;\n\n  if (isEmpty(a) && isEmpty(b)) {\n    const rankA = a !== a ? 0 : a === null ? 1 : 2;\n    const rankB = b !== b ? 0 : b === null ? 1 : 2;\n    const order = rankA - rankB;\n    return desc2 ? -order : order;\n  }\n\n  if (isEmpty(a)) {\n    return desc2 ? -1 : 1;\n  }\n\n  if (isEmpty(b)) {\n    return desc2 ? 1 : -1;\n  }\n\n  return ascending(a, b);\n}\n\nfunction isEmpty(value) {\n  return value == null || value !== value;\n}\n\nfunction keysFromItems(items) {\n  if (items.length < 1) return [];\n  const keys = Object.keys(items[0]);\n  return keys;\n}\n\nfunction everything() {\n  return items => {\n    const keys = keysFromItems(items);\n    return keys;\n  };\n}\n\nfunction processSelectors(items, selectKeys) {\n  let processedSelectKeys = [];\n\n  for (const keyInput of singleOrArray(selectKeys)) {\n    if (typeof keyInput === \"function\") {\n      processedSelectKeys.push(...keyInput(items));\n    } else {\n      processedSelectKeys.push(keyInput);\n    }\n  }\n\n  if (processedSelectKeys.length && processedSelectKeys[0][0] === \"-\") {\n    processedSelectKeys = [...everything()(items), ...processedSelectKeys];\n  }\n\n  const negationMap = {};\n  const keysWithoutNegations = [];\n\n  for (let k = processedSelectKeys.length - 1; k >= 0; k--) {\n    const key = processedSelectKeys[k];\n\n    if (key[0] === \"-\") {\n      negationMap[key.substring(1)] = true;\n      continue;\n    }\n\n    if (negationMap[key]) {\n      negationMap[key] = false;\n      continue;\n    }\n\n    keysWithoutNegations.unshift(key);\n  }\n\n  processedSelectKeys = Array.from(new Set(keysWithoutNegations));\n  return processedSelectKeys;\n}\n\nfunction select(selectKeys) {\n  const _select = items => {\n    let processedSelectKeys = processSelectors(items, selectKeys);\n    if (!processedSelectKeys.length) return items;\n    return items.map(d => {\n      const mapped = {};\n\n      for (const key of processedSelectKeys) {\n        mapped[key] = d[key];\n      }\n\n      return mapped;\n    });\n  };\n\n  return _select;\n}\n\nconst _excluded = [\"worker\", \"data\", \"previousData\"];\n\nconst handlers = {\n  arrange: props => {\n    const {\n      column,\n      descending,\n      data\n    } = props;\n    return tidy(data, arrange(descending ? desc(column) : column));\n  },\n  drop: props => {\n    const {\n      columns,\n      data\n    } = props;\n    if (!columns) return data;else return tidy(data, select(columns.map(column => `-${column}`)));\n  },\n  filter_columns: props => {\n    const {\n      columns,\n      logic,\n      data\n    } = props;\n    const [left, right] = columns;\n    if (!left || !right) return data;\n\n    switch (logic) {\n      case \"gt\":\n        return tidy(data, filter(d => d[columns[0]] > d[columns[1]]));\n\n      case \"lt\":\n        return tidy(data, filter(d => d[columns[0]] < d[columns[1]]));\n\n      case \"ge\":\n        return tidy(data, filter(d => d[columns[0]] >= d[columns[1]]));\n\n      case \"le\":\n        return tidy(data, filter(d => d[columns[0]] <= d[columns[1]]));\n\n      case \"eq\":\n        return tidy(data, filter(d => d[columns[0]] === d[columns[1]]));\n\n      case \"ne\":\n        return tidy(data, filter(d => d[columns[0]] !== d[columns[1]]));\n\n      default:\n        return data;\n    }\n  },\n  recordwindow: props => {\n    var _previousData;\n\n    const {\n      data,\n      previousData,\n      horizon\n    } = props;\n    if (!(data != null && data.length)) return data;\n    const now = data[data.length - 1].time;\n    const previousNow = previousData == null ? void 0 : (_previousData = previousData[(previousData == null ? void 0 : previousData.length) - 1]) == null ? void 0 : _previousData.time;\n    if (now === undefined || previousNow === undefined) return data.filter(r => now - r.time < horizon);\n    return [...previousData.filter(r => now - r.time < horizon), ...data.filter(r => now - r.time < horizon && r.time > previousNow)];\n  }\n};\n\nfunction transformData(message) {\n  try {\n    const handler = handlers[message.type];\n    return handler == null ? void 0 : handler(message);\n  } catch (e) {\n    console.debug(e);\n    return undefined;\n  }\n}\n\nasync function handleMessage(event) {\n  const message = event.data; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  const {\n    worker\n  } = message,\n        rest = _objectWithoutPropertiesLoose(message, _excluded);\n\n  if (worker !== \"data\") return;\n  console.debug(\"Jacdac data in:\", {\n    message\n  });\n  const newData = await transformData(message);\n  console.debug(\"Jacdac data out:\", {\n    message\n  });\n\n  const resp = _extends({\n    worker\n  }, rest, {\n    data: newData\n  });\n\n  self.postMessage(resp);\n}\n\nself.addEventListener(\"message\", handleMessage);\nconsole.debug(`jacdac data: worker registered`);\n//# sourceMappingURL=data-worker.js.map\n"],"sourceRoot":""}